const mmio = @import("./mmio.zig");

pub const devices = struct {
    pub const @"ESP32-C6" = struct {
        pub const peripherals = struct {
            
            /// AES (Advanced Encryption Standard) Accelerator
            pub const AES = struct {
                
                /// Key material key_0 configure register
                pub const KEY_0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] This bits stores key_0 that is a part of key material.
                    KEY_0:  u32, 
                    
                }), @ptrFromInt(0x60088000));
                
                /// Key material key_1 configure register
                pub const KEY_1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] This bits stores key_1 that is a part of key material.
                    KEY_1:  u32, 
                    
                }), @ptrFromInt(0x60088004));
                
                /// Key material key_2 configure register
                pub const KEY_2 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] This bits stores key_2 that is a part of key material.
                    KEY_2:  u32, 
                    
                }), @ptrFromInt(0x60088008));
                
                /// Key material key_3 configure register
                pub const KEY_3 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] This bits stores key_3 that is a part of key material.
                    KEY_3:  u32, 
                    
                }), @ptrFromInt(0x6008800c));
                
                /// Key material key_4 configure register
                pub const KEY_4 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] This bits stores key_4 that is a part of key material.
                    KEY_4:  u32, 
                    
                }), @ptrFromInt(0x60088010));
                
                /// Key material key_5 configure register
                pub const KEY_5 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] This bits stores key_5 that is a part of key material.
                    KEY_5:  u32, 
                    
                }), @ptrFromInt(0x60088014));
                
                /// Key material key_6 configure register
                pub const KEY_6 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] This bits stores key_6 that is a part of key material.
                    KEY_6:  u32, 
                    
                }), @ptrFromInt(0x60088018));
                
                /// Key material key_7 configure register
                pub const KEY_7 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] This bits stores key_7 that is a part of key material.
                    KEY_7:  u32, 
                    
                }), @ptrFromInt(0x6008801c));
                
                /// source text material text_in_0 configure register
                pub const TEXT_IN_0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] This bits stores text_in_0 that is a part of source text material.
                    TEXT_IN_0:  u32, 
                    
                }), @ptrFromInt(0x60088020));
                
                /// source text material text_in_1 configure register
                pub const TEXT_IN_1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] This bits stores text_in_1 that is a part of source text material.
                    TEXT_IN_1:  u32, 
                    
                }), @ptrFromInt(0x60088024));
                
                /// source text material text_in_2 configure register
                pub const TEXT_IN_2 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] This bits stores text_in_2 that is a part of source text material.
                    TEXT_IN_2:  u32, 
                    
                }), @ptrFromInt(0x60088028));
                
                /// source text material text_in_3 configure register
                pub const TEXT_IN_3 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] This bits stores text_in_3 that is a part of source text material.
                    TEXT_IN_3:  u32, 
                    
                }), @ptrFromInt(0x6008802c));
                
                /// result text material text_out_0 configure register
                pub const TEXT_OUT_0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] This bits stores text_out_0 that is a part of result text material.
                    TEXT_OUT_0:  u32, 
                    
                }), @ptrFromInt(0x60088030));
                
                /// result text material text_out_1 configure register
                pub const TEXT_OUT_1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] This bits stores text_out_1 that is a part of result text material.
                    TEXT_OUT_1:  u32, 
                    
                }), @ptrFromInt(0x60088034));
                
                /// result text material text_out_2 configure register
                pub const TEXT_OUT_2 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] This bits stores text_out_2 that is a part of result text material.
                    TEXT_OUT_2:  u32, 
                    
                }), @ptrFromInt(0x60088038));
                
                /// result text material text_out_3 configure register
                pub const TEXT_OUT_3 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] This bits stores text_out_3 that is a part of result text material.
                    TEXT_OUT_3:  u32, 
                    
                }), @ptrFromInt(0x6008803c));
                
                /// AES Mode register
                pub const MODE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:2] This bits decides which one operation mode will be used. 3'd0: AES-EN-128, 3'd1: AES-EN-192, 3'd2: AES-EN-256, 3'd4: AES-DE-128, 3'd5: AES-DE-192, 3'd6: AES-DE-256.
                    MODE:  u3, 
                    
                    /// [3:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60088040));
                
                /// AES Endian configure register
                pub const ENDIAN = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] endian. [1:0] key endian, [3:2] text_in endian or in_stream endian,[5:4] text_out endian or out_stream endian
                    ENDIAN:  u6, 
                    
                    /// [6:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60088044));
                
                /// AES trigger register
                pub const TRIGGER = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Set this bit to start AES calculation.
                    TRIGGER:  u1, 
                    
                    /// [1:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60088048));
                
                /// AES state register
                pub const STATE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:1] Those bits shows AES status. For typical AES, 0: idle, 1: busy. For DMA-AES, 0: idle, 1: busy, 2: calculation_done.
                    STATE:  u2, 
                    
                    /// [2:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6008804c));
                
                /// The memory that stores initialization vector
                pub const IV_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x60088050));
                
                /// The memory that stores initialization vector
                pub const IV_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x60088051));
                
                /// The memory that stores initialization vector
                pub const IV_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x60088052));
                
                /// The memory that stores initialization vector
                pub const IV_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x60088053));
                
                /// The memory that stores initialization vector
                pub const IV_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x60088054));
                
                /// The memory that stores initialization vector
                pub const IV_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x60088055));
                
                /// The memory that stores initialization vector
                pub const IV_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x60088056));
                
                /// The memory that stores initialization vector
                pub const IV_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x60088057));
                
                /// The memory that stores initialization vector
                pub const IV_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x60088058));
                
                /// The memory that stores initialization vector
                pub const IV_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x60088059));
                
                /// The memory that stores initialization vector
                pub const IV_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008805a));
                
                /// The memory that stores initialization vector
                pub const IV_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008805b));
                
                /// The memory that stores initialization vector
                pub const IV_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008805c));
                
                /// The memory that stores initialization vector
                pub const IV_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008805d));
                
                /// The memory that stores initialization vector
                pub const IV_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008805e));
                
                /// The memory that stores initialization vector
                pub const IV_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008805f));
                
                /// The memory that stores GCM hash subkey
                pub const H_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x60088060));
                
                /// The memory that stores GCM hash subkey
                pub const H_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x60088061));
                
                /// The memory that stores GCM hash subkey
                pub const H_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x60088062));
                
                /// The memory that stores GCM hash subkey
                pub const H_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x60088063));
                
                /// The memory that stores GCM hash subkey
                pub const H_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x60088064));
                
                /// The memory that stores GCM hash subkey
                pub const H_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x60088065));
                
                /// The memory that stores GCM hash subkey
                pub const H_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x60088066));
                
                /// The memory that stores GCM hash subkey
                pub const H_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x60088067));
                
                /// The memory that stores GCM hash subkey
                pub const H_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x60088068));
                
                /// The memory that stores GCM hash subkey
                pub const H_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x60088069));
                
                /// The memory that stores GCM hash subkey
                pub const H_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008806a));
                
                /// The memory that stores GCM hash subkey
                pub const H_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008806b));
                
                /// The memory that stores GCM hash subkey
                pub const H_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008806c));
                
                /// The memory that stores GCM hash subkey
                pub const H_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008806d));
                
                /// The memory that stores GCM hash subkey
                pub const H_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008806e));
                
                /// The memory that stores GCM hash subkey
                pub const H_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008806f));
                
                /// The memory that stores J0
                pub const J0_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x60088070));
                
                /// The memory that stores J0
                pub const J0_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x60088071));
                
                /// The memory that stores J0
                pub const J0_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x60088072));
                
                /// The memory that stores J0
                pub const J0_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x60088073));
                
                /// The memory that stores J0
                pub const J0_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x60088074));
                
                /// The memory that stores J0
                pub const J0_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x60088075));
                
                /// The memory that stores J0
                pub const J0_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x60088076));
                
                /// The memory that stores J0
                pub const J0_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x60088077));
                
                /// The memory that stores J0
                pub const J0_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x60088078));
                
                /// The memory that stores J0
                pub const J0_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x60088079));
                
                /// The memory that stores J0
                pub const J0_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008807a));
                
                /// The memory that stores J0
                pub const J0_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008807b));
                
                /// The memory that stores J0
                pub const J0_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008807c));
                
                /// The memory that stores J0
                pub const J0_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008807d));
                
                /// The memory that stores J0
                pub const J0_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008807e));
                
                /// The memory that stores J0
                pub const J0_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008807f));
                
                /// The memory that stores T0
                pub const T0_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x60088080));
                
                /// The memory that stores T0
                pub const T0_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x60088081));
                
                /// The memory that stores T0
                pub const T0_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x60088082));
                
                /// The memory that stores T0
                pub const T0_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x60088083));
                
                /// The memory that stores T0
                pub const T0_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x60088084));
                
                /// The memory that stores T0
                pub const T0_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x60088085));
                
                /// The memory that stores T0
                pub const T0_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x60088086));
                
                /// The memory that stores T0
                pub const T0_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x60088087));
                
                /// The memory that stores T0
                pub const T0_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x60088088));
                
                /// The memory that stores T0
                pub const T0_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x60088089));
                
                /// The memory that stores T0
                pub const T0_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008808a));
                
                /// The memory that stores T0
                pub const T0_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008808b));
                
                /// The memory that stores T0
                pub const T0_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008808c));
                
                /// The memory that stores T0
                pub const T0_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008808d));
                
                /// The memory that stores T0
                pub const T0_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008808e));
                
                /// The memory that stores T0
                pub const T0_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008808f));
                
                /// DMA-AES working mode register
                pub const DMA_ENABLE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] 1'b0: typical AES working mode, 1'b1: DMA-AES working mode.
                    DMA_ENABLE:  u1, 
                    
                    /// [1:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60088090));
                
                /// AES cipher block mode register
                pub const BLOCK_MODE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:2] Those bits decides which block mode will be used. 0x0: ECB, 0x1: CBC, 0x2: OFB, 0x3: CTR, 0x4: CFB-8, 0x5: CFB-128, 0x6: GCM, 0x7: reserved.
                    BLOCK_MODE:  u3, 
                    
                    /// [3:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60088094));
                
                /// AES block number register
                pub const BLOCK_NUM = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Those bits stores the number of Plaintext/ciphertext block.
                    BLOCK_NUM:  u32, 
                    
                }), @ptrFromInt(0x60088098));
                
                /// Standard incrementing function configure register
                pub const INC_SEL = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] This bit decides the standard incrementing function. 0: INC32. 1: INC128.
                    INC_SEL:  u1, 
                    
                    /// [1:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6008809c));
                
                /// Additional Authential Data block number register
                pub const AAD_BLOCK_NUM = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Those bits stores the number of AAD block.
                    AAD_BLOCK_NUM:  u32, 
                    
                }), @ptrFromInt(0x600880a0));
                
                /// AES remainder bit number register
                pub const REMAINDER_BIT_NUM = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:6] Those bits stores the number of remainder bit.
                    REMAINDER_BIT_NUM:  u7, 
                    
                    /// [7:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600880a4));
                
                /// AES continue register
                pub const CONTINUE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Set this bit to continue GCM operation.
                    CONTINUE:  u1, 
                    
                    /// [1:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600880a8));
                
                /// AES Interrupt clear register
                pub const INT_CLEAR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Set this bit to clear the AES interrupt.
                    INT_CLEAR:  u1, 
                    
                    /// [1:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600880ac));
                
                /// AES Interrupt enable register
                pub const INT_ENA = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Set this bit to enable interrupt that occurs when DMA-AES calculation is done.
                    INT_ENA:  u1, 
                    
                    /// [1:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600880b0));
                
                /// AES version control register
                pub const DATE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:29] This bits stores the version information of AES.
                    DATE:  u30, 
                    
                    /// [30:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600880b4));
                
                /// AES-DMA exit config
                pub const DMA_EXIT = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Set this register to leave calculation done stage. Recommend to use it after software finishes reading DMA's output buffer.
                    DMA_EXIT:  u1, 
                    
                    /// [1:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600880b8));
                
            };
            
            /// SAR (Successive Approximation Register) Analog-to-Digital Converter
            pub const APB_SARADC = struct {
                
                /// digital saradc configure register
                pub const CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] select software enable saradc sample
                    SARADC_START_FORCE:  u1, 
                    
                    /// [1:1] software enable saradc sample
                    SARADC_START:  u1, 
                    
                    /// [2:5] 
                    res0:  u0, 
                    
                    /// [6:6] SAR clock gated
                    SARADC_SAR_CLK_GATED:  u1, 
                    
                    /// [7:14] SAR clock divider
                    SARADC_SAR_CLK_DIV:  u8, 
                    
                    /// [15:17] 0 ~ 15 means length 1 ~ 16
                    SARADC_SAR_PATT_LEN:  u3, 
                    
                    /// [18:22] 
                    res1:  u0, 
                    
                    /// [23:23] clear the pointer of pattern table for DIG ADC1 CTRL
                    SARADC_SAR_PATT_P_CLEAR:  u1, 
                    
                    /// [24:26] 
                    res2:  u0, 
                    
                    /// [27:28] force option to xpd sar blocks
                    SARADC_XPD_SAR_FORCE:  u2, 
                    
                    /// [29:29] enable saradc2 power detect driven func.
                    SARADC2_PWDET_DRV:  u1, 
                    
                    /// [30:31] wait arbit signal stable after sar_done
                    SARADC_WAIT_ARB_CYCLE:  u2, 
                    
                }), @ptrFromInt(0x6000e000));
                
                /// digital saradc configure register
                pub const CTRL2 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] enable max meas num
                    SARADC_MEAS_NUM_LIMIT:  u1, 
                    
                    /// [1:8] max conversion number
                    SARADC_MAX_MEAS_NUM:  u8, 
                    
                    /// [9:9] 1: data to DIG ADC1 CTRL is inverted, otherwise not
                    SARADC_SAR1_INV:  u1, 
                    
                    /// [10:10] 1: data to DIG ADC2 CTRL is inverted, otherwise not
                    SARADC_SAR2_INV:  u1, 
                    
                    /// [11:11] 
                    res0:  u0, 
                    
                    /// [12:23] to set saradc timer target
                    SARADC_TIMER_TARGET:  u12, 
                    
                    /// [24:24] to enable saradc timer trigger
                    SARADC_TIMER_EN:  u1, 
                    
                    /// [25:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x6000e004));
                
                /// digital saradc configure register
                pub const FILTER_CTRL1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:25] 
                    res0:  u0, 
                    
                    /// [26:28] Factor of saradc filter1
                    APB_SARADC_FILTER_FACTOR1:  u3, 
                    
                    /// [29:31] Factor of saradc filter0
                    APB_SARADC_FILTER_FACTOR0:  u3, 
                    
                }), @ptrFromInt(0x6000e008));
                
                /// digital saradc configure register
                pub const FSM_WAIT = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] saradc_xpd_wait
                    SARADC_XPD_WAIT:  u8, 
                    
                    /// [8:15] saradc_rstb_wait
                    SARADC_RSTB_WAIT:  u8, 
                    
                    /// [16:23] saradc_standby_wait
                    SARADC_STANDBY_WAIT:  u8, 
                    
                    /// [24:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000e00c));
                
                /// digital saradc configure register
                pub const SAR1_STATUS = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] saradc1 status about data and channel
                    SARADC_SAR1_STATUS:  u32, 
                    
                }), @ptrFromInt(0x6000e010));
                
                /// digital saradc configure register
                pub const SAR2_STATUS = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] saradc2 status about data and channel
                    SARADC_SAR2_STATUS:  u32, 
                    
                }), @ptrFromInt(0x6000e014));
                
                /// digital saradc configure register
                pub const SAR_PATT_TAB1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:23] item 0 ~ 3 for pattern table 1 (each item one byte)
                    SARADC_SAR_PATT_TAB1:  u24, 
                    
                    /// [24:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000e018));
                
                /// digital saradc configure register
                pub const SAR_PATT_TAB2 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:23] Item 4 ~ 7 for pattern table 1 (each item one byte)
                    SARADC_SAR_PATT_TAB2:  u24, 
                    
                    /// [24:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000e01c));
                
                /// digital saradc configure register
                pub const ONETIME_SAMPLE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:22] 
                    res0:  u0, 
                    
                    /// [23:24] configure onetime atten
                    SARADC_ONETIME_ATTEN:  u2, 
                    
                    /// [25:28] configure onetime channel
                    SARADC_ONETIME_CHANNEL:  u4, 
                    
                    /// [29:29] trigger adc onetime sample
                    SARADC_ONETIME_START:  u1, 
                    
                    /// [30:30] enable adc2 onetime sample
                    SARADC2_ONETIME_SAMPLE:  u1, 
                    
                    /// [31:31] enable adc1 onetime sample
                    SARADC1_ONETIME_SAMPLE:  u1, 
                    
                }), @ptrFromInt(0x6000e020));
                
                /// digital saradc configure register
                pub const ARB_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:1] 
                    res0:  u0, 
                    
                    /// [2:2] adc2 arbiter force to enableapb controller
                    ADC_ARB_APB_FORCE:  u1, 
                    
                    /// [3:3] adc2 arbiter force to enable rtc controller
                    ADC_ARB_RTC_FORCE:  u1, 
                    
                    /// [4:4] adc2 arbiter force to enable wifi controller
                    ADC_ARB_WIFI_FORCE:  u1, 
                    
                    /// [5:5] adc2 arbiter force grant
                    ADC_ARB_GRANT_FORCE:  u1, 
                    
                    /// [6:7] Set adc2 arbiterapb priority
                    ADC_ARB_APB_PRIORITY:  u2, 
                    
                    /// [8:9] Set adc2 arbiter rtc priority
                    ADC_ARB_RTC_PRIORITY:  u2, 
                    
                    /// [10:11] Set adc2 arbiter wifi priority
                    ADC_ARB_WIFI_PRIORITY:  u2, 
                    
                    /// [12:12] adc2 arbiter uses fixed priority
                    ADC_ARB_FIX_PRIORITY:  u1, 
                    
                    /// [13:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x6000e024));
                
                /// digital saradc configure register
                pub const FILTER_CTRL0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:17] 
                    res0:  u0, 
                    
                    /// [18:21] configure filter1 to adc channel
                    APB_SARADC_FILTER_CHANNEL1:  u4, 
                    
                    /// [22:25] configure filter0 to adc channel
                    APB_SARADC_FILTER_CHANNEL0:  u4, 
                    
                    /// [26:30] 
                    res1:  u0, 
                    
                    /// [31:31] enable apb_adc1_filter
                    APB_SARADC_FILTER_RESET:  u1, 
                    
                }), @ptrFromInt(0x6000e028));
                
                /// digital saradc configure register
                pub const SAR1DATA_STATUS = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:16] saradc1 data
                    APB_SARADC1_DATA:  u17, 
                    
                    /// [17:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000e02c));
                
                /// digital saradc configure register
                pub const SAR2DATA_STATUS = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:16] saradc2 data
                    APB_SARADC2_DATA:  u17, 
                    
                    /// [17:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000e030));
                
                /// digital saradc configure register
                pub const THRES0_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:3] configure thres0 to adc channel
                    APB_SARADC_THRES0_CHANNEL:  u4, 
                    
                    /// [4:4] 
                    res0:  u0, 
                    
                    /// [5:17] saradc thres0 monitor thres
                    APB_SARADC_THRES0_HIGH:  u13, 
                    
                    /// [18:30] saradc thres0 monitor thres
                    APB_SARADC_THRES0_LOW:  u13, 
                    
                    /// [31:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x6000e034));
                
                /// digital saradc configure register
                pub const THRES1_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:3] configure thres1 to adc channel
                    APB_SARADC_THRES1_CHANNEL:  u4, 
                    
                    /// [4:4] 
                    res0:  u0, 
                    
                    /// [5:17] saradc thres1 monitor thres
                    APB_SARADC_THRES1_HIGH:  u13, 
                    
                    /// [18:30] saradc thres1 monitor thres
                    APB_SARADC_THRES1_LOW:  u13, 
                    
                    /// [31:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x6000e038));
                
                /// digital saradc configure register
                pub const THRES_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:26] 
                    res0:  u0, 
                    
                    /// [27:27] enable thres to all channel
                    APB_SARADC_THRES_ALL_EN:  u1, 
                    
                    /// [28:29] 
                    res1:  u0, 
                    
                    /// [30:30] enable thres1
                    APB_SARADC_THRES1_EN:  u1, 
                    
                    /// [31:31] enable thres0
                    APB_SARADC_THRES0_EN:  u1, 
                    
                }), @ptrFromInt(0x6000e03c));
                
                /// digital saradc int register
                pub const INT_ENA = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:24] 
                    res0:  u0, 
                    
                    /// [25:25] tsens lowinterrupt enable
                    APB_SARADC_TSENS_INT_ENA:  u1, 
                    
                    /// [26:26] saradc thres1 lowinterrupt enable
                    APB_SARADC_THRES1_LOW_INT_ENA:  u1, 
                    
                    /// [27:27] saradc thres0 low interrupt enable
                    APB_SARADC_THRES0_LOW_INT_ENA:  u1, 
                    
                    /// [28:28] saradc thres1 high interrupt enable
                    APB_SARADC_THRES1_HIGH_INT_ENA:  u1, 
                    
                    /// [29:29] saradc thres0 high interrupt enable
                    APB_SARADC_THRES0_HIGH_INT_ENA:  u1, 
                    
                    /// [30:30] saradc2 done interrupt enable
                    APB_SARADC2_DONE_INT_ENA:  u1, 
                    
                    /// [31:31] saradc1 done interrupt enable
                    APB_SARADC1_DONE_INT_ENA:  u1, 
                    
                }), @ptrFromInt(0x6000e040));
                
                /// digital saradc int register
                pub const INT_RAW = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:24] 
                    res0:  u0, 
                    
                    /// [25:25] saradc tsensinterrupt raw
                    APB_SARADC_TSENS_INT_RAW:  u1, 
                    
                    /// [26:26] saradc thres1 lowinterrupt raw
                    APB_SARADC_THRES1_LOW_INT_RAW:  u1, 
                    
                    /// [27:27] saradc thres0 low interrupt raw
                    APB_SARADC_THRES0_LOW_INT_RAW:  u1, 
                    
                    /// [28:28] saradc thres1 high interrupt raw
                    APB_SARADC_THRES1_HIGH_INT_RAW:  u1, 
                    
                    /// [29:29] saradc thres0 high interrupt raw
                    APB_SARADC_THRES0_HIGH_INT_RAW:  u1, 
                    
                    /// [30:30] saradc2 done interrupt raw
                    APB_SARADC2_DONE_INT_RAW:  u1, 
                    
                    /// [31:31] saradc1 done interrupt raw
                    APB_SARADC1_DONE_INT_RAW:  u1, 
                    
                }), @ptrFromInt(0x6000e044));
                
                /// digital saradc int register
                pub const INT_ST = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:24] 
                    res0:  u0, 
                    
                    /// [25:25] saradc tsensinterrupt state
                    APB_SARADC_TSENS_INT_ST:  u1, 
                    
                    /// [26:26] saradc thres1 lowinterrupt state
                    APB_SARADC_THRES1_LOW_INT_ST:  u1, 
                    
                    /// [27:27] saradc thres0 low interrupt state
                    APB_SARADC_THRES0_LOW_INT_ST:  u1, 
                    
                    /// [28:28] saradc thres1 high interrupt state
                    APB_SARADC_THRES1_HIGH_INT_ST:  u1, 
                    
                    /// [29:29] saradc thres0 high interrupt state
                    APB_SARADC_THRES0_HIGH_INT_ST:  u1, 
                    
                    /// [30:30] saradc2 done interrupt state
                    APB_SARADC2_DONE_INT_ST:  u1, 
                    
                    /// [31:31] saradc1 done interrupt state
                    APB_SARADC1_DONE_INT_ST:  u1, 
                    
                }), @ptrFromInt(0x6000e048));
                
                /// digital saradc int register
                pub const INT_CLR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:24] 
                    res0:  u0, 
                    
                    /// [25:25] saradc tsensinterrupt clear
                    APB_SARADC_TSENS_INT_CLR:  u1, 
                    
                    /// [26:26] saradc thres1 lowinterrupt clear
                    APB_SARADC_THRES1_LOW_INT_CLR:  u1, 
                    
                    /// [27:27] saradc thres0 low interrupt clear
                    APB_SARADC_THRES0_LOW_INT_CLR:  u1, 
                    
                    /// [28:28] saradc thres1 high interrupt clear
                    APB_SARADC_THRES1_HIGH_INT_CLR:  u1, 
                    
                    /// [29:29] saradc thres0 high interrupt clear
                    APB_SARADC_THRES0_HIGH_INT_CLR:  u1, 
                    
                    /// [30:30] saradc2 done interrupt clear
                    APB_SARADC2_DONE_INT_CLR:  u1, 
                    
                    /// [31:31] saradc1 done interrupt clear
                    APB_SARADC1_DONE_INT_CLR:  u1, 
                    
                }), @ptrFromInt(0x6000e04c));
                
                /// digital saradc configure register
                pub const DMA_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:15] the dma_in_suc_eof gen when sample cnt = spi_eof_num
                    APB_ADC_EOF_NUM:  u16, 
                    
                    /// [16:29] 
                    res0:  u0, 
                    
                    /// [30:30] reset_apb_adc_state
                    APB_ADC_RESET_FSM:  u1, 
                    
                    /// [31:31] enable apb_adc use spi_dma
                    APB_ADC_TRANS:  u1, 
                    
                }), @ptrFromInt(0x6000e050));
                
                /// digital saradc configure register
                pub const CLKM_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] Integral I2S clock divider value
                    CLKM_DIV_NUM:  u8, 
                    
                    /// [8:13] Fractional clock divider numerator value
                    CLKM_DIV_B:  u6, 
                    
                    /// [14:19] Fractional clock divider denominator value
                    CLKM_DIV_A:  u6, 
                    
                    /// [20:20] reg clk en
                    CLK_EN:  u1, 
                    
                    /// [21:22] Set this bit to enable clk_apll
                    CLK_SEL:  u2, 
                    
                    /// [23:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000e054));
                
                /// digital tsens configure register
                pub const APB_TSENS_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] temperature sensor data out
                    TSENS_OUT:  u8, 
                    
                    /// [8:12] 
                    res0:  u0, 
                    
                    /// [13:13] invert temperature sensor data
                    TSENS_IN_INV:  u1, 
                    
                    /// [14:21] temperature sensor clock divider
                    TSENS_CLK_DIV:  u8, 
                    
                    /// [22:22] temperature sensor power up
                    TSENS_PU:  u1, 
                    
                    /// [23:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x6000e058));
                
                /// digital tsens configure register
                pub const TSENS_CTRL2 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:11] the time that power up tsens need wait
                    TSENS_XPD_WAIT:  u12, 
                    
                    /// [12:13] force power up tsens
                    TSENS_XPD_FORCE:  u2, 
                    
                    /// [14:14] inv tsens clk
                    TSENS_CLK_INV:  u1, 
                    
                    /// [15:15] tsens clk select
                    TSENS_CLK_SEL:  u1, 
                    
                    /// [16:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000e05c));
                
                /// digital saradc configure register
                pub const CALI = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:16] saradc cali factor
                    APB_SARADC_CALI_CFG:  u17, 
                    
                    /// [17:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000e060));
                
                /// digital tsens configure register
                pub const APB_TSENS_WAKE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] reg_wakeup_th_low
                    WAKEUP_TH_LOW:  u8, 
                    
                    /// [8:15] reg_wakeup_th_high
                    WAKEUP_TH_HIGH:  u8, 
                    
                    /// [16:16] reg_wakeup_over_upper_th
                    WAKEUP_OVER_UPPER_TH:  u1, 
                    
                    /// [17:17] reg_wakeup_mode
                    WAKEUP_MODE:  u1, 
                    
                    /// [18:18] reg_wakeup_en
                    WAKEUP_EN:  u1, 
                    
                    /// [19:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000e064));
                
                /// digital tsens configure register
                pub const APB_TSENS_SAMPLE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:15] HW sample rate
                    TSENS_SAMPLE_RATE:  u16, 
                    
                    /// [16:16] HW sample en
                    TSENS_SAMPLE_EN:  u1, 
                    
                    /// [17:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000e068));
                
                /// version
                pub const CTRL_DATE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] version
                    DATE:  u32, 
                    
                }), @ptrFromInt(0x6000e3fc));
                
            };
            
            /// Debug Assist
            pub const ASSIST_DEBUG = struct {
                
                /// core0 monitor enable configuration register
                pub const CORE_0_MONTR_ENA = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Core0 dram0 area0 read monitor enable
                    CORE_0_AREA_DRAM0_0_RD_ENA:  u1, 
                    
                    /// [1:1] Core0 dram0 area0 write monitor enable
                    CORE_0_AREA_DRAM0_0_WR_ENA:  u1, 
                    
                    /// [2:2] Core0 dram0 area1 read monitor enable
                    CORE_0_AREA_DRAM0_1_RD_ENA:  u1, 
                    
                    /// [3:3] Core0 dram0 area1 write monitor enable
                    CORE_0_AREA_DRAM0_1_WR_ENA:  u1, 
                    
                    /// [4:4] Core0 PIF area0 read monitor enable
                    CORE_0_AREA_PIF_0_RD_ENA:  u1, 
                    
                    /// [5:5] Core0 PIF area0 write monitor enable
                    CORE_0_AREA_PIF_0_WR_ENA:  u1, 
                    
                    /// [6:6] Core0 PIF area1 read monitor enable
                    CORE_0_AREA_PIF_1_RD_ENA:  u1, 
                    
                    /// [7:7] Core0 PIF area1 write monitor enable
                    CORE_0_AREA_PIF_1_WR_ENA:  u1, 
                    
                    /// [8:8] Core0 stackpoint underflow monitor enable
                    CORE_0_SP_SPILL_MIN_ENA:  u1, 
                    
                    /// [9:9] Core0 stackpoint overflow monitor enable
                    CORE_0_SP_SPILL_MAX_ENA:  u1, 
                    
                    /// [10:10] IBUS busy monitor enable
                    CORE_0_IRAM0_EXCEPTION_MONITOR_ENA:  u1, 
                    
                    /// [11:11] DBUS busy monitor enbale
                    CORE_0_DRAM0_EXCEPTION_MONITOR_ENA:  u1, 
                    
                    /// [12:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600c2000));
                
                /// core0 monitor interrupt status register
                pub const CORE_0_INTR_RAW = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Core0 dram0 area0 read monitor interrupt status
                    CORE_0_AREA_DRAM0_0_RD_RAW:  u1, 
                    
                    /// [1:1] Core0 dram0 area0 write monitor interrupt status
                    CORE_0_AREA_DRAM0_0_WR_RAW:  u1, 
                    
                    /// [2:2] Core0 dram0 area1 read monitor interrupt status
                    CORE_0_AREA_DRAM0_1_RD_RAW:  u1, 
                    
                    /// [3:3] Core0 dram0 area1 write monitor interrupt status
                    CORE_0_AREA_DRAM0_1_WR_RAW:  u1, 
                    
                    /// [4:4] Core0 PIF area0 read monitor interrupt status
                    CORE_0_AREA_PIF_0_RD_RAW:  u1, 
                    
                    /// [5:5] Core0 PIF area0 write monitor interrupt status
                    CORE_0_AREA_PIF_0_WR_RAW:  u1, 
                    
                    /// [6:6] Core0 PIF area1 read monitor interrupt status
                    CORE_0_AREA_PIF_1_RD_RAW:  u1, 
                    
                    /// [7:7] Core0 PIF area1 write monitor interrupt status
                    CORE_0_AREA_PIF_1_WR_RAW:  u1, 
                    
                    /// [8:8] Core0 stackpoint underflow monitor interrupt status
                    CORE_0_SP_SPILL_MIN_RAW:  u1, 
                    
                    /// [9:9] Core0 stackpoint overflow monitor interrupt status
                    CORE_0_SP_SPILL_MAX_RAW:  u1, 
                    
                    /// [10:10] IBUS busy monitor interrupt status
                    CORE_0_IRAM0_EXCEPTION_MONITOR_RAW:  u1, 
                    
                    /// [11:11] DBUS busy monitor initerrupt status
                    CORE_0_DRAM0_EXCEPTION_MONITOR_RAW:  u1, 
                    
                    /// [12:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600c2004));
                
                /// core0 monitor interrupt enable register
                pub const CORE_0_INTR_ENA = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Core0 dram0 area0 read monitor interrupt enable
                    CORE_0_AREA_DRAM0_0_RD_INTR_ENA:  u1, 
                    
                    /// [1:1] Core0 dram0 area0 write monitor interrupt enable
                    CORE_0_AREA_DRAM0_0_WR_INTR_ENA:  u1, 
                    
                    /// [2:2] Core0 dram0 area1 read monitor interrupt enable
                    CORE_0_AREA_DRAM0_1_RD_INTR_ENA:  u1, 
                    
                    /// [3:3] Core0 dram0 area1 write monitor interrupt enable
                    CORE_0_AREA_DRAM0_1_WR_INTR_ENA:  u1, 
                    
                    /// [4:4] Core0 PIF area0 read monitor interrupt enable
                    CORE_0_AREA_PIF_0_RD_INTR_ENA:  u1, 
                    
                    /// [5:5] Core0 PIF area0 write monitor interrupt enable
                    CORE_0_AREA_PIF_0_WR_INTR_ENA:  u1, 
                    
                    /// [6:6] Core0 PIF area1 read monitor interrupt enable
                    CORE_0_AREA_PIF_1_RD_INTR_ENA:  u1, 
                    
                    /// [7:7] Core0 PIF area1 write monitor interrupt enable
                    CORE_0_AREA_PIF_1_WR_INTR_ENA:  u1, 
                    
                    /// [8:8] Core0 stackpoint underflow monitor interrupt enable
                    CORE_0_SP_SPILL_MIN_INTR_ENA:  u1, 
                    
                    /// [9:9] Core0 stackpoint overflow monitor interrupt enable
                    CORE_0_SP_SPILL_MAX_INTR_ENA:  u1, 
                    
                    /// [10:10] IBUS busy monitor interrupt enable
                    CORE_0_IRAM0_EXCEPTION_MONITOR_INTR_ENA:  u1, 
                    
                    /// [11:11] DBUS busy monitor interrupt enbale
                    CORE_0_DRAM0_EXCEPTION_MONITOR_INTR_ENA:  u1, 
                    
                    /// [12:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600c2008));
                
                /// core0 monitor interrupt clr register
                pub const CORE_0_INTR_CLR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Core0 dram0 area0 read monitor interrupt clr
                    CORE_0_AREA_DRAM0_0_RD_CLR:  u1, 
                    
                    /// [1:1] Core0 dram0 area0 write monitor interrupt clr
                    CORE_0_AREA_DRAM0_0_WR_CLR:  u1, 
                    
                    /// [2:2] Core0 dram0 area1 read monitor interrupt clr
                    CORE_0_AREA_DRAM0_1_RD_CLR:  u1, 
                    
                    /// [3:3] Core0 dram0 area1 write monitor interrupt clr
                    CORE_0_AREA_DRAM0_1_WR_CLR:  u1, 
                    
                    /// [4:4] Core0 PIF area0 read monitor interrupt clr
                    CORE_0_AREA_PIF_0_RD_CLR:  u1, 
                    
                    /// [5:5] Core0 PIF area0 write monitor interrupt clr
                    CORE_0_AREA_PIF_0_WR_CLR:  u1, 
                    
                    /// [6:6] Core0 PIF area1 read monitor interrupt clr
                    CORE_0_AREA_PIF_1_RD_CLR:  u1, 
                    
                    /// [7:7] Core0 PIF area1 write monitor interrupt clr
                    CORE_0_AREA_PIF_1_WR_CLR:  u1, 
                    
                    /// [8:8] Core0 stackpoint underflow monitor interrupt clr
                    CORE_0_SP_SPILL_MIN_CLR:  u1, 
                    
                    /// [9:9] Core0 stackpoint overflow monitor interrupt clr
                    CORE_0_SP_SPILL_MAX_CLR:  u1, 
                    
                    /// [10:10] IBUS busy monitor interrupt clr
                    CORE_0_IRAM0_EXCEPTION_MONITOR_CLR:  u1, 
                    
                    /// [11:11] DBUS busy monitor interrupt clr
                    CORE_0_DRAM0_EXCEPTION_MONITOR_CLR:  u1, 
                    
                    /// [12:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600c200c));
                
                /// core0 dram0 region0 addr configuration register
                pub const CORE_0_AREA_DRAM0_0_MIN = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Core0 dram0 region0 start addr
                    CORE_0_AREA_DRAM0_0_MIN:  u32, 
                    
                }), @ptrFromInt(0x600c2010));
                
                /// core0 dram0 region0 addr configuration register
                pub const CORE_0_AREA_DRAM0_0_MAX = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Core0 dram0 region0 end addr
                    CORE_0_AREA_DRAM0_0_MAX:  u32, 
                    
                }), @ptrFromInt(0x600c2014));
                
                /// core0 dram0 region1 addr configuration register
                pub const CORE_0_AREA_DRAM0_1_MIN = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Core0 dram0 region1 start addr
                    CORE_0_AREA_DRAM0_1_MIN:  u32, 
                    
                }), @ptrFromInt(0x600c2018));
                
                /// core0 dram0 region1 addr configuration register
                pub const CORE_0_AREA_DRAM0_1_MAX = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Core0 dram0 region1 end addr
                    CORE_0_AREA_DRAM0_1_MAX:  u32, 
                    
                }), @ptrFromInt(0x600c201c));
                
                /// core0 PIF region0 addr configuration register
                pub const CORE_0_AREA_PIF_0_MIN = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Core0 PIF region0 start addr
                    CORE_0_AREA_PIF_0_MIN:  u32, 
                    
                }), @ptrFromInt(0x600c2020));
                
                /// core0 PIF region0 addr configuration register
                pub const CORE_0_AREA_PIF_0_MAX = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Core0 PIF region0 end addr
                    CORE_0_AREA_PIF_0_MAX:  u32, 
                    
                }), @ptrFromInt(0x600c2024));
                
                /// core0 PIF region1 addr configuration register
                pub const CORE_0_AREA_PIF_1_MIN = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Core0 PIF region1 start addr
                    CORE_0_AREA_PIF_1_MIN:  u32, 
                    
                }), @ptrFromInt(0x600c2028));
                
                /// core0 PIF region1 addr configuration register
                pub const CORE_0_AREA_PIF_1_MAX = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Core0 PIF region1 end addr
                    CORE_0_AREA_PIF_1_MAX:  u32, 
                    
                }), @ptrFromInt(0x600c202c));
                
                /// core0 area pc status register
                pub const CORE_0_AREA_PC = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] the stackpointer when first touch region monitor interrupt
                    CORE_0_AREA_PC:  u32, 
                    
                }), @ptrFromInt(0x600c2030));
                
                /// core0 area sp status register
                pub const CORE_0_AREA_SP = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] the PC when first touch region monitor interrupt
                    CORE_0_AREA_SP:  u32, 
                    
                }), @ptrFromInt(0x600c2034));
                
                /// stack min value
                pub const CORE_0_SP_MIN = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] core0 sp region configuration regsiter
                    CORE_0_SP_MIN:  u32, 
                    
                }), @ptrFromInt(0x600c2038));
                
                /// stack max value
                pub const CORE_0_SP_MAX = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] core0 sp pc status register
                    CORE_0_SP_MAX:  u32, 
                    
                }), @ptrFromInt(0x600c203c));
                
                /// stack monitor pc status register
                pub const CORE_0_SP_PC = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] This regsiter stores the PC when trigger stack monitor.
                    CORE_0_SP_PC:  u32, 
                    
                }), @ptrFromInt(0x600c2040));
                
                /// record enable configuration register
                pub const CORE_0_RCD_EN = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Set 1 to enable record PC
                    CORE_0_RCD_RECORDEN:  u1, 
                    
                    /// [1:1] Set 1 to enable cpu pdebug function, must set this bit can get cpu PC
                    CORE_0_RCD_PDEBUGEN:  u1, 
                    
                    /// [2:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600c2044));
                
                /// record status regsiter
                pub const CORE_0_RCD_PDEBUGPC = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] recorded PC
                    CORE_0_RCD_PDEBUGPC:  u32, 
                    
                }), @ptrFromInt(0x600c2048));
                
                /// record status regsiter
                pub const CORE_0_RCD_PDEBUGSP = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] recorded sp
                    CORE_0_RCD_PDEBUGSP:  u32, 
                    
                }), @ptrFromInt(0x600c204c));
                
                /// exception monitor status register0
                pub const CORE_0_IRAM0_EXCEPTION_MONITOR_0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:23] reg_core_0_iram0_recording_addr_0
                    CORE_0_IRAM0_RECORDING_ADDR_0:  u24, 
                    
                    /// [24:24] reg_core_0_iram0_recording_wr_0
                    CORE_0_IRAM0_RECORDING_WR_0:  u1, 
                    
                    /// [25:25] reg_core_0_iram0_recording_loadstore_0
                    CORE_0_IRAM0_RECORDING_LOADSTORE_0:  u1, 
                    
                    /// [26:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600c2050));
                
                /// exception monitor status register1
                pub const CORE_0_IRAM0_EXCEPTION_MONITOR_1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:23] reg_core_0_iram0_recording_addr_1
                    CORE_0_IRAM0_RECORDING_ADDR_1:  u24, 
                    
                    /// [24:24] reg_core_0_iram0_recording_wr_1
                    CORE_0_IRAM0_RECORDING_WR_1:  u1, 
                    
                    /// [25:25] reg_core_0_iram0_recording_loadstore_1
                    CORE_0_IRAM0_RECORDING_LOADSTORE_1:  u1, 
                    
                    /// [26:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600c2054));
                
                /// exception monitor status register2
                pub const CORE_0_DRAM0_EXCEPTION_MONITOR_0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:23] reg_core_0_dram0_recording_addr_0
                    CORE_0_DRAM0_RECORDING_ADDR_0:  u24, 
                    
                    /// [24:24] reg_core_0_dram0_recording_wr_0
                    CORE_0_DRAM0_RECORDING_WR_0:  u1, 
                    
                    /// [25:28] reg_core_0_dram0_recording_byteen_0
                    CORE_0_DRAM0_RECORDING_BYTEEN_0:  u4, 
                    
                    /// [29:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600c2058));
                
                /// exception monitor status register3
                pub const CORE_0_DRAM0_EXCEPTION_MONITOR_1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] reg_core_0_dram0_recording_pc_0
                    CORE_0_DRAM0_RECORDING_PC_0:  u32, 
                    
                }), @ptrFromInt(0x600c205c));
                
                /// exception monitor status register4
                pub const CORE_0_DRAM0_EXCEPTION_MONITOR_2 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:23] reg_core_0_dram0_recording_addr_1
                    CORE_0_DRAM0_RECORDING_ADDR_1:  u24, 
                    
                    /// [24:24] reg_core_0_dram0_recording_wr_1
                    CORE_0_DRAM0_RECORDING_WR_1:  u1, 
                    
                    /// [25:28] reg_core_0_dram0_recording_byteen_1
                    CORE_0_DRAM0_RECORDING_BYTEEN_1:  u4, 
                    
                    /// [29:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600c2060));
                
                /// exception monitor status register5
                pub const CORE_0_DRAM0_EXCEPTION_MONITOR_3 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] reg_core_0_dram0_recording_pc_1
                    CORE_0_DRAM0_RECORDING_PC_1:  u32, 
                    
                }), @ptrFromInt(0x600c2064));
                
                /// exception monitor status register6
                pub const CORE_X_IRAM0_DRAM0_EXCEPTION_MONITOR_0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:19] reg_core_x_iram0_dram0_limit_cycle_0
                    CORE_X_IRAM0_DRAM0_LIMIT_CYCLE_0:  u20, 
                    
                    /// [20:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600c2068));
                
                /// exception monitor status register7
                pub const CORE_X_IRAM0_DRAM0_EXCEPTION_MONITOR_1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:19] reg_core_x_iram0_dram0_limit_cycle_1
                    CORE_X_IRAM0_DRAM0_LIMIT_CYCLE_1:  u20, 
                    
                    /// [20:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600c206c));
                
                /// cpu status register
                pub const C0RE_0_LASTPC_BEFORE_EXCEPTION = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] cpu's lastpc before exception
                    CORE_0_LASTPC_BEFORE_EXC:  u32, 
                    
                }), @ptrFromInt(0x600c2070));
                
                /// cpu status register
                pub const C0RE_0_DEBUG_MODE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] cpu debug mode status, 1 means cpu enter debug mode.
                    CORE_0_DEBUG_MODE:  u1, 
                    
                    /// [1:1] cpu debug_module active status
                    CORE_0_DEBUG_MODULE_ACTIVE:  u1, 
                    
                    /// [2:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600c2074));
                
                /// clock register
                pub const CLOCK_GATE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Set 1 force on the clock gate
                    CLK_EN:  u1, 
                    
                    /// [1:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600c2078));
                
                /// version register
                pub const DATE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:27] version register
                    ASSIST_DEBUG_DATE:  u28, 
                    
                    /// [28:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600c23fc));
                
            };
            
            /// Atomic Locker
            pub const ATOMIC = struct {
                
                /// hardware lock regsiter
                pub const ADDR_LOCK = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:1] read to acquire hardware lock, write to release hardware lock
                    LOCK:  u2, 
                    
                    /// [2:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60011000));
                
                /// gloable lr address regsiter
                pub const LR_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] backup gloable address
                    GLOABLE_LR_ADDR:  u32, 
                    
                }), @ptrFromInt(0x60011004));
                
                /// gloable lr value regsiter
                pub const LR_VALUE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] backup gloable value
                    GLOABLE_LR_VALUE:  u32, 
                    
                }), @ptrFromInt(0x60011008));
                
                /// lock status regsiter
                pub const LOCK_STATUS = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:1] read hareware lock status for debug
                    LOCK_STATUS:  u2, 
                    
                    /// [2:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6001100c));
                
                /// wait counter register
                pub const COUNTER = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:15] delay counter
                    WAIT_COUNTER:  u16, 
                    
                    /// [16:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60011010));
                
            };
            
            /// DMA (Direct Memory Access) Controller
            pub const DMA = struct {
                
                /// Raw status interrupt of channel 0
                pub const IN_INT_RAW_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] The raw interrupt bit turns to high level when the last data pointed by one inlink descriptor has been received for Rx channel 0.
                    IN_DONE:  u1, 
                    
                    /// [1:1] The raw interrupt bit turns to high level when the last data pointed by one inlink descriptor has been received for Rx channel 0. For UHCI0 the raw interrupt bit turns to high level when the last data pointed by one inlink descriptor has been received and no data error is detected for Rx channel 0.
                    IN_SUC_EOF:  u1, 
                    
                    /// [2:2] The raw interrupt bit turns to high level when data error is detected only in the case that the peripheral is UHCI0 for Rx channel 0. For other peripherals this raw interrupt is reserved.
                    IN_ERR_EOF:  u1, 
                    
                    /// [3:3] The raw interrupt bit turns to high level when detecting inlink descriptor error including owner error and the second and third word error of inlink descriptor for Rx channel 0.
                    IN_DSCR_ERR:  u1, 
                    
                    /// [4:4] The raw interrupt bit turns to high level when Rx buffer pointed by inlink is full and receiving data is not completed but there is no more inlink for Rx channel 0.
                    IN_DSCR_EMPTY:  u1, 
                    
                    /// [5:5] This raw interrupt bit turns to high level when level 1 fifo of Rx channel 0 is overflow.
                    INFIFO_OVF:  u1, 
                    
                    /// [6:6] This raw interrupt bit turns to high level when level 1 fifo of Rx channel 0 is underflow.
                    INFIFO_UDF:  u1, 
                    
                    /// [7:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60080000));
                
                /// Raw status interrupt of channel 0
                pub const IN_INT_RAW_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] The raw interrupt bit turns to high level when the last data pointed by one inlink descriptor has been received for Rx channel 0.
                    IN_DONE:  u1, 
                    
                    /// [1:1] The raw interrupt bit turns to high level when the last data pointed by one inlink descriptor has been received for Rx channel 0. For UHCI0 the raw interrupt bit turns to high level when the last data pointed by one inlink descriptor has been received and no data error is detected for Rx channel 0.
                    IN_SUC_EOF:  u1, 
                    
                    /// [2:2] The raw interrupt bit turns to high level when data error is detected only in the case that the peripheral is UHCI0 for Rx channel 0. For other peripherals this raw interrupt is reserved.
                    IN_ERR_EOF:  u1, 
                    
                    /// [3:3] The raw interrupt bit turns to high level when detecting inlink descriptor error including owner error and the second and third word error of inlink descriptor for Rx channel 0.
                    IN_DSCR_ERR:  u1, 
                    
                    /// [4:4] The raw interrupt bit turns to high level when Rx buffer pointed by inlink is full and receiving data is not completed but there is no more inlink for Rx channel 0.
                    IN_DSCR_EMPTY:  u1, 
                    
                    /// [5:5] This raw interrupt bit turns to high level when level 1 fifo of Rx channel 0 is overflow.
                    INFIFO_OVF:  u1, 
                    
                    /// [6:6] This raw interrupt bit turns to high level when level 1 fifo of Rx channel 0 is underflow.
                    INFIFO_UDF:  u1, 
                    
                    /// [7:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60080004));
                
                /// Raw status interrupt of channel 0
                pub const IN_INT_RAW_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] The raw interrupt bit turns to high level when the last data pointed by one inlink descriptor has been received for Rx channel 0.
                    IN_DONE:  u1, 
                    
                    /// [1:1] The raw interrupt bit turns to high level when the last data pointed by one inlink descriptor has been received for Rx channel 0. For UHCI0 the raw interrupt bit turns to high level when the last data pointed by one inlink descriptor has been received and no data error is detected for Rx channel 0.
                    IN_SUC_EOF:  u1, 
                    
                    /// [2:2] The raw interrupt bit turns to high level when data error is detected only in the case that the peripheral is UHCI0 for Rx channel 0. For other peripherals this raw interrupt is reserved.
                    IN_ERR_EOF:  u1, 
                    
                    /// [3:3] The raw interrupt bit turns to high level when detecting inlink descriptor error including owner error and the second and third word error of inlink descriptor for Rx channel 0.
                    IN_DSCR_ERR:  u1, 
                    
                    /// [4:4] The raw interrupt bit turns to high level when Rx buffer pointed by inlink is full and receiving data is not completed but there is no more inlink for Rx channel 0.
                    IN_DSCR_EMPTY:  u1, 
                    
                    /// [5:5] This raw interrupt bit turns to high level when level 1 fifo of Rx channel 0 is overflow.
                    INFIFO_OVF:  u1, 
                    
                    /// [6:6] This raw interrupt bit turns to high level when level 1 fifo of Rx channel 0 is underflow.
                    INFIFO_UDF:  u1, 
                    
                    /// [7:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60080008));
                
                /// Masked interrupt of channel 0
                pub const IN_INT_ST_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] The raw interrupt status bit for the IN_DONE_CH_INT interrupt.
                    IN_DONE:  u1, 
                    
                    /// [1:1] The raw interrupt status bit for the IN_SUC_EOF_CH_INT interrupt.
                    IN_SUC_EOF:  u1, 
                    
                    /// [2:2] The raw interrupt status bit for the IN_ERR_EOF_CH_INT interrupt.
                    IN_ERR_EOF:  u1, 
                    
                    /// [3:3] The raw interrupt status bit for the IN_DSCR_ERR_CH_INT interrupt.
                    IN_DSCR_ERR:  u1, 
                    
                    /// [4:4] The raw interrupt status bit for the IN_DSCR_EMPTY_CH_INT interrupt.
                    IN_DSCR_EMPTY:  u1, 
                    
                    /// [5:5] The raw interrupt status bit for the INFIFO_OVF_L1_CH_INT interrupt.
                    INFIFO_OVF:  u1, 
                    
                    /// [6:6] The raw interrupt status bit for the INFIFO_UDF_L1_CH_INT interrupt.
                    INFIFO_UDF:  u1, 
                    
                    /// [7:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60080004));
                
                /// Masked interrupt of channel 0
                pub const IN_INT_ST_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] The raw interrupt status bit for the IN_DONE_CH_INT interrupt.
                    IN_DONE:  u1, 
                    
                    /// [1:1] The raw interrupt status bit for the IN_SUC_EOF_CH_INT interrupt.
                    IN_SUC_EOF:  u1, 
                    
                    /// [2:2] The raw interrupt status bit for the IN_ERR_EOF_CH_INT interrupt.
                    IN_ERR_EOF:  u1, 
                    
                    /// [3:3] The raw interrupt status bit for the IN_DSCR_ERR_CH_INT interrupt.
                    IN_DSCR_ERR:  u1, 
                    
                    /// [4:4] The raw interrupt status bit for the IN_DSCR_EMPTY_CH_INT interrupt.
                    IN_DSCR_EMPTY:  u1, 
                    
                    /// [5:5] The raw interrupt status bit for the INFIFO_OVF_L1_CH_INT interrupt.
                    INFIFO_OVF:  u1, 
                    
                    /// [6:6] The raw interrupt status bit for the INFIFO_UDF_L1_CH_INT interrupt.
                    INFIFO_UDF:  u1, 
                    
                    /// [7:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60080008));
                
                /// Masked interrupt of channel 0
                pub const IN_INT_ST_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] The raw interrupt status bit for the IN_DONE_CH_INT interrupt.
                    IN_DONE:  u1, 
                    
                    /// [1:1] The raw interrupt status bit for the IN_SUC_EOF_CH_INT interrupt.
                    IN_SUC_EOF:  u1, 
                    
                    /// [2:2] The raw interrupt status bit for the IN_ERR_EOF_CH_INT interrupt.
                    IN_ERR_EOF:  u1, 
                    
                    /// [3:3] The raw interrupt status bit for the IN_DSCR_ERR_CH_INT interrupt.
                    IN_DSCR_ERR:  u1, 
                    
                    /// [4:4] The raw interrupt status bit for the IN_DSCR_EMPTY_CH_INT interrupt.
                    IN_DSCR_EMPTY:  u1, 
                    
                    /// [5:5] The raw interrupt status bit for the INFIFO_OVF_L1_CH_INT interrupt.
                    INFIFO_OVF:  u1, 
                    
                    /// [6:6] The raw interrupt status bit for the INFIFO_UDF_L1_CH_INT interrupt.
                    INFIFO_UDF:  u1, 
                    
                    /// [7:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6008000c));
                
                /// Interrupt enable bits of channel 0
                pub const IN_INT_ENA_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] The interrupt enable bit for the IN_DONE_CH_INT interrupt.
                    IN_DONE:  u1, 
                    
                    /// [1:1] The interrupt enable bit for the IN_SUC_EOF_CH_INT interrupt.
                    IN_SUC_EOF:  u1, 
                    
                    /// [2:2] The interrupt enable bit for the IN_ERR_EOF_CH_INT interrupt.
                    IN_ERR_EOF:  u1, 
                    
                    /// [3:3] The interrupt enable bit for the IN_DSCR_ERR_CH_INT interrupt.
                    IN_DSCR_ERR:  u1, 
                    
                    /// [4:4] The interrupt enable bit for the IN_DSCR_EMPTY_CH_INT interrupt.
                    IN_DSCR_EMPTY:  u1, 
                    
                    /// [5:5] The interrupt enable bit for the INFIFO_OVF_L1_CH_INT interrupt.
                    INFIFO_OVF:  u1, 
                    
                    /// [6:6] The interrupt enable bit for the INFIFO_UDF_L1_CH_INT interrupt.
                    INFIFO_UDF:  u1, 
                    
                    /// [7:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60080008));
                
                /// Interrupt enable bits of channel 0
                pub const IN_INT_ENA_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] The interrupt enable bit for the IN_DONE_CH_INT interrupt.
                    IN_DONE:  u1, 
                    
                    /// [1:1] The interrupt enable bit for the IN_SUC_EOF_CH_INT interrupt.
                    IN_SUC_EOF:  u1, 
                    
                    /// [2:2] The interrupt enable bit for the IN_ERR_EOF_CH_INT interrupt.
                    IN_ERR_EOF:  u1, 
                    
                    /// [3:3] The interrupt enable bit for the IN_DSCR_ERR_CH_INT interrupt.
                    IN_DSCR_ERR:  u1, 
                    
                    /// [4:4] The interrupt enable bit for the IN_DSCR_EMPTY_CH_INT interrupt.
                    IN_DSCR_EMPTY:  u1, 
                    
                    /// [5:5] The interrupt enable bit for the INFIFO_OVF_L1_CH_INT interrupt.
                    INFIFO_OVF:  u1, 
                    
                    /// [6:6] The interrupt enable bit for the INFIFO_UDF_L1_CH_INT interrupt.
                    INFIFO_UDF:  u1, 
                    
                    /// [7:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6008000c));
                
                /// Interrupt enable bits of channel 0
                pub const IN_INT_ENA_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] The interrupt enable bit for the IN_DONE_CH_INT interrupt.
                    IN_DONE:  u1, 
                    
                    /// [1:1] The interrupt enable bit for the IN_SUC_EOF_CH_INT interrupt.
                    IN_SUC_EOF:  u1, 
                    
                    /// [2:2] The interrupt enable bit for the IN_ERR_EOF_CH_INT interrupt.
                    IN_ERR_EOF:  u1, 
                    
                    /// [3:3] The interrupt enable bit for the IN_DSCR_ERR_CH_INT interrupt.
                    IN_DSCR_ERR:  u1, 
                    
                    /// [4:4] The interrupt enable bit for the IN_DSCR_EMPTY_CH_INT interrupt.
                    IN_DSCR_EMPTY:  u1, 
                    
                    /// [5:5] The interrupt enable bit for the INFIFO_OVF_L1_CH_INT interrupt.
                    INFIFO_OVF:  u1, 
                    
                    /// [6:6] The interrupt enable bit for the INFIFO_UDF_L1_CH_INT interrupt.
                    INFIFO_UDF:  u1, 
                    
                    /// [7:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60080010));
                
                /// Interrupt clear bits of channel 0
                pub const IN_INT_CLR_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Set this bit to clear the IN_DONE_CH_INT interrupt.
                    IN_DONE:  u1, 
                    
                    /// [1:1] Set this bit to clear the IN_SUC_EOF_CH_INT interrupt.
                    IN_SUC_EOF:  u1, 
                    
                    /// [2:2] Set this bit to clear the IN_ERR_EOF_CH_INT interrupt.
                    IN_ERR_EOF:  u1, 
                    
                    /// [3:3] Set this bit to clear the IN_DSCR_ERR_CH_INT interrupt.
                    IN_DSCR_ERR:  u1, 
                    
                    /// [4:4] Set this bit to clear the IN_DSCR_EMPTY_CH_INT interrupt.
                    IN_DSCR_EMPTY:  u1, 
                    
                    /// [5:5] Set this bit to clear the INFIFO_OVF_L1_CH_INT interrupt.
                    INFIFO_OVF:  u1, 
                    
                    /// [6:6] Set this bit to clear the INFIFO_UDF_L1_CH_INT interrupt.
                    INFIFO_UDF:  u1, 
                    
                    /// [7:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6008000c));
                
                /// Interrupt clear bits of channel 0
                pub const IN_INT_CLR_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Set this bit to clear the IN_DONE_CH_INT interrupt.
                    IN_DONE:  u1, 
                    
                    /// [1:1] Set this bit to clear the IN_SUC_EOF_CH_INT interrupt.
                    IN_SUC_EOF:  u1, 
                    
                    /// [2:2] Set this bit to clear the IN_ERR_EOF_CH_INT interrupt.
                    IN_ERR_EOF:  u1, 
                    
                    /// [3:3] Set this bit to clear the IN_DSCR_ERR_CH_INT interrupt.
                    IN_DSCR_ERR:  u1, 
                    
                    /// [4:4] Set this bit to clear the IN_DSCR_EMPTY_CH_INT interrupt.
                    IN_DSCR_EMPTY:  u1, 
                    
                    /// [5:5] Set this bit to clear the INFIFO_OVF_L1_CH_INT interrupt.
                    INFIFO_OVF:  u1, 
                    
                    /// [6:6] Set this bit to clear the INFIFO_UDF_L1_CH_INT interrupt.
                    INFIFO_UDF:  u1, 
                    
                    /// [7:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60080010));
                
                /// Interrupt clear bits of channel 0
                pub const IN_INT_CLR_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Set this bit to clear the IN_DONE_CH_INT interrupt.
                    IN_DONE:  u1, 
                    
                    /// [1:1] Set this bit to clear the IN_SUC_EOF_CH_INT interrupt.
                    IN_SUC_EOF:  u1, 
                    
                    /// [2:2] Set this bit to clear the IN_ERR_EOF_CH_INT interrupt.
                    IN_ERR_EOF:  u1, 
                    
                    /// [3:3] Set this bit to clear the IN_DSCR_ERR_CH_INT interrupt.
                    IN_DSCR_ERR:  u1, 
                    
                    /// [4:4] Set this bit to clear the IN_DSCR_EMPTY_CH_INT interrupt.
                    IN_DSCR_EMPTY:  u1, 
                    
                    /// [5:5] Set this bit to clear the INFIFO_OVF_L1_CH_INT interrupt.
                    INFIFO_OVF:  u1, 
                    
                    /// [6:6] Set this bit to clear the INFIFO_UDF_L1_CH_INT interrupt.
                    INFIFO_UDF:  u1, 
                    
                    /// [7:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60080014));
                
                /// Raw status interrupt of channel 0
                pub const OUT_INT_RAW_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] The raw interrupt bit turns to high level when the last data pointed by one outlink descriptor has been transmitted to peripherals for Tx channel 0.
                    OUT_DONE:  u1, 
                    
                    /// [1:1] The raw interrupt bit turns to high level when the last data pointed by one outlink descriptor has been read from memory for Tx channel 0.
                    OUT_EOF:  u1, 
                    
                    /// [2:2] The raw interrupt bit turns to high level when detecting outlink descriptor error including owner error and the second and third word error of outlink descriptor for Tx channel 0.
                    OUT_DSCR_ERR:  u1, 
                    
                    /// [3:3] The raw interrupt bit turns to high level when data corresponding a outlink (includes one link descriptor or few link descriptors) is transmitted out for Tx channel 0.
                    OUT_TOTAL_EOF:  u1, 
                    
                    /// [4:4] This raw interrupt bit turns to high level when level 1 fifo of Tx channel 0 is overflow.
                    OUTFIFO_OVF:  u1, 
                    
                    /// [5:5] This raw interrupt bit turns to high level when level 1 fifo of Tx channel 0 is underflow.
                    OUTFIFO_UDF:  u1, 
                    
                    /// [6:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60080030));
                
                /// Raw status interrupt of channel 0
                pub const OUT_INT_RAW_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] The raw interrupt bit turns to high level when the last data pointed by one outlink descriptor has been transmitted to peripherals for Tx channel 0.
                    OUT_DONE:  u1, 
                    
                    /// [1:1] The raw interrupt bit turns to high level when the last data pointed by one outlink descriptor has been read from memory for Tx channel 0.
                    OUT_EOF:  u1, 
                    
                    /// [2:2] The raw interrupt bit turns to high level when detecting outlink descriptor error including owner error and the second and third word error of outlink descriptor for Tx channel 0.
                    OUT_DSCR_ERR:  u1, 
                    
                    /// [3:3] The raw interrupt bit turns to high level when data corresponding a outlink (includes one link descriptor or few link descriptors) is transmitted out for Tx channel 0.
                    OUT_TOTAL_EOF:  u1, 
                    
                    /// [4:4] This raw interrupt bit turns to high level when level 1 fifo of Tx channel 0 is overflow.
                    OUTFIFO_OVF:  u1, 
                    
                    /// [5:5] This raw interrupt bit turns to high level when level 1 fifo of Tx channel 0 is underflow.
                    OUTFIFO_UDF:  u1, 
                    
                    /// [6:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60080034));
                
                /// Raw status interrupt of channel 0
                pub const OUT_INT_RAW_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] The raw interrupt bit turns to high level when the last data pointed by one outlink descriptor has been transmitted to peripherals for Tx channel 0.
                    OUT_DONE:  u1, 
                    
                    /// [1:1] The raw interrupt bit turns to high level when the last data pointed by one outlink descriptor has been read from memory for Tx channel 0.
                    OUT_EOF:  u1, 
                    
                    /// [2:2] The raw interrupt bit turns to high level when detecting outlink descriptor error including owner error and the second and third word error of outlink descriptor for Tx channel 0.
                    OUT_DSCR_ERR:  u1, 
                    
                    /// [3:3] The raw interrupt bit turns to high level when data corresponding a outlink (includes one link descriptor or few link descriptors) is transmitted out for Tx channel 0.
                    OUT_TOTAL_EOF:  u1, 
                    
                    /// [4:4] This raw interrupt bit turns to high level when level 1 fifo of Tx channel 0 is overflow.
                    OUTFIFO_OVF:  u1, 
                    
                    /// [5:5] This raw interrupt bit turns to high level when level 1 fifo of Tx channel 0 is underflow.
                    OUTFIFO_UDF:  u1, 
                    
                    /// [6:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60080038));
                
                /// Masked interrupt of channel 0
                pub const OUT_INT_ST_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] The raw interrupt status bit for the OUT_DONE_CH_INT interrupt.
                    OUT_DONE:  u1, 
                    
                    /// [1:1] The raw interrupt status bit for the OUT_EOF_CH_INT interrupt.
                    OUT_EOF:  u1, 
                    
                    /// [2:2] The raw interrupt status bit for the OUT_DSCR_ERR_CH_INT interrupt.
                    OUT_DSCR_ERR:  u1, 
                    
                    /// [3:3] The raw interrupt status bit for the OUT_TOTAL_EOF_CH_INT interrupt.
                    OUT_TOTAL_EOF:  u1, 
                    
                    /// [4:4] The raw interrupt status bit for the OUTFIFO_OVF_L1_CH_INT interrupt.
                    OUTFIFO_OVF:  u1, 
                    
                    /// [5:5] The raw interrupt status bit for the OUTFIFO_UDF_L1_CH_INT interrupt.
                    OUTFIFO_UDF:  u1, 
                    
                    /// [6:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60080034));
                
                /// Masked interrupt of channel 0
                pub const OUT_INT_ST_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] The raw interrupt status bit for the OUT_DONE_CH_INT interrupt.
                    OUT_DONE:  u1, 
                    
                    /// [1:1] The raw interrupt status bit for the OUT_EOF_CH_INT interrupt.
                    OUT_EOF:  u1, 
                    
                    /// [2:2] The raw interrupt status bit for the OUT_DSCR_ERR_CH_INT interrupt.
                    OUT_DSCR_ERR:  u1, 
                    
                    /// [3:3] The raw interrupt status bit for the OUT_TOTAL_EOF_CH_INT interrupt.
                    OUT_TOTAL_EOF:  u1, 
                    
                    /// [4:4] The raw interrupt status bit for the OUTFIFO_OVF_L1_CH_INT interrupt.
                    OUTFIFO_OVF:  u1, 
                    
                    /// [5:5] The raw interrupt status bit for the OUTFIFO_UDF_L1_CH_INT interrupt.
                    OUTFIFO_UDF:  u1, 
                    
                    /// [6:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60080038));
                
                /// Masked interrupt of channel 0
                pub const OUT_INT_ST_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] The raw interrupt status bit for the OUT_DONE_CH_INT interrupt.
                    OUT_DONE:  u1, 
                    
                    /// [1:1] The raw interrupt status bit for the OUT_EOF_CH_INT interrupt.
                    OUT_EOF:  u1, 
                    
                    /// [2:2] The raw interrupt status bit for the OUT_DSCR_ERR_CH_INT interrupt.
                    OUT_DSCR_ERR:  u1, 
                    
                    /// [3:3] The raw interrupt status bit for the OUT_TOTAL_EOF_CH_INT interrupt.
                    OUT_TOTAL_EOF:  u1, 
                    
                    /// [4:4] The raw interrupt status bit for the OUTFIFO_OVF_L1_CH_INT interrupt.
                    OUTFIFO_OVF:  u1, 
                    
                    /// [5:5] The raw interrupt status bit for the OUTFIFO_UDF_L1_CH_INT interrupt.
                    OUTFIFO_UDF:  u1, 
                    
                    /// [6:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6008003c));
                
                /// Interrupt enable bits of channel 0
                pub const OUT_INT_ENA_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] The interrupt enable bit for the OUT_DONE_CH_INT interrupt.
                    OUT_DONE:  u1, 
                    
                    /// [1:1] The interrupt enable bit for the OUT_EOF_CH_INT interrupt.
                    OUT_EOF:  u1, 
                    
                    /// [2:2] The interrupt enable bit for the OUT_DSCR_ERR_CH_INT interrupt.
                    OUT_DSCR_ERR:  u1, 
                    
                    /// [3:3] The interrupt enable bit for the OUT_TOTAL_EOF_CH_INT interrupt.
                    OUT_TOTAL_EOF:  u1, 
                    
                    /// [4:4] The interrupt enable bit for the OUTFIFO_OVF_L1_CH_INT interrupt.
                    OUTFIFO_OVF:  u1, 
                    
                    /// [5:5] The interrupt enable bit for the OUTFIFO_UDF_L1_CH_INT interrupt.
                    OUTFIFO_UDF:  u1, 
                    
                    /// [6:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60080038));
                
                /// Interrupt enable bits of channel 0
                pub const OUT_INT_ENA_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] The interrupt enable bit for the OUT_DONE_CH_INT interrupt.
                    OUT_DONE:  u1, 
                    
                    /// [1:1] The interrupt enable bit for the OUT_EOF_CH_INT interrupt.
                    OUT_EOF:  u1, 
                    
                    /// [2:2] The interrupt enable bit for the OUT_DSCR_ERR_CH_INT interrupt.
                    OUT_DSCR_ERR:  u1, 
                    
                    /// [3:3] The interrupt enable bit for the OUT_TOTAL_EOF_CH_INT interrupt.
                    OUT_TOTAL_EOF:  u1, 
                    
                    /// [4:4] The interrupt enable bit for the OUTFIFO_OVF_L1_CH_INT interrupt.
                    OUTFIFO_OVF:  u1, 
                    
                    /// [5:5] The interrupt enable bit for the OUTFIFO_UDF_L1_CH_INT interrupt.
                    OUTFIFO_UDF:  u1, 
                    
                    /// [6:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6008003c));
                
                /// Interrupt enable bits of channel 0
                pub const OUT_INT_ENA_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] The interrupt enable bit for the OUT_DONE_CH_INT interrupt.
                    OUT_DONE:  u1, 
                    
                    /// [1:1] The interrupt enable bit for the OUT_EOF_CH_INT interrupt.
                    OUT_EOF:  u1, 
                    
                    /// [2:2] The interrupt enable bit for the OUT_DSCR_ERR_CH_INT interrupt.
                    OUT_DSCR_ERR:  u1, 
                    
                    /// [3:3] The interrupt enable bit for the OUT_TOTAL_EOF_CH_INT interrupt.
                    OUT_TOTAL_EOF:  u1, 
                    
                    /// [4:4] The interrupt enable bit for the OUTFIFO_OVF_L1_CH_INT interrupt.
                    OUTFIFO_OVF:  u1, 
                    
                    /// [5:5] The interrupt enable bit for the OUTFIFO_UDF_L1_CH_INT interrupt.
                    OUTFIFO_UDF:  u1, 
                    
                    /// [6:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60080040));
                
                /// Interrupt clear bits of channel 0
                pub const OUT_INT_CLR_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Set this bit to clear the OUT_DONE_CH_INT interrupt.
                    OUT_DONE:  u1, 
                    
                    /// [1:1] Set this bit to clear the OUT_EOF_CH_INT interrupt.
                    OUT_EOF:  u1, 
                    
                    /// [2:2] Set this bit to clear the OUT_DSCR_ERR_CH_INT interrupt.
                    OUT_DSCR_ERR:  u1, 
                    
                    /// [3:3] Set this bit to clear the OUT_TOTAL_EOF_CH_INT interrupt.
                    OUT_TOTAL_EOF:  u1, 
                    
                    /// [4:4] Set this bit to clear the OUTFIFO_OVF_L1_CH_INT interrupt.
                    OUTFIFO_OVF:  u1, 
                    
                    /// [5:5] Set this bit to clear the OUTFIFO_UDF_L1_CH_INT interrupt.
                    OUTFIFO_UDF:  u1, 
                    
                    /// [6:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6008003c));
                
                /// Interrupt clear bits of channel 0
                pub const OUT_INT_CLR_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Set this bit to clear the OUT_DONE_CH_INT interrupt.
                    OUT_DONE:  u1, 
                    
                    /// [1:1] Set this bit to clear the OUT_EOF_CH_INT interrupt.
                    OUT_EOF:  u1, 
                    
                    /// [2:2] Set this bit to clear the OUT_DSCR_ERR_CH_INT interrupt.
                    OUT_DSCR_ERR:  u1, 
                    
                    /// [3:3] Set this bit to clear the OUT_TOTAL_EOF_CH_INT interrupt.
                    OUT_TOTAL_EOF:  u1, 
                    
                    /// [4:4] Set this bit to clear the OUTFIFO_OVF_L1_CH_INT interrupt.
                    OUTFIFO_OVF:  u1, 
                    
                    /// [5:5] Set this bit to clear the OUTFIFO_UDF_L1_CH_INT interrupt.
                    OUTFIFO_UDF:  u1, 
                    
                    /// [6:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60080040));
                
                /// Interrupt clear bits of channel 0
                pub const OUT_INT_CLR_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Set this bit to clear the OUT_DONE_CH_INT interrupt.
                    OUT_DONE:  u1, 
                    
                    /// [1:1] Set this bit to clear the OUT_EOF_CH_INT interrupt.
                    OUT_EOF:  u1, 
                    
                    /// [2:2] Set this bit to clear the OUT_DSCR_ERR_CH_INT interrupt.
                    OUT_DSCR_ERR:  u1, 
                    
                    /// [3:3] Set this bit to clear the OUT_TOTAL_EOF_CH_INT interrupt.
                    OUT_TOTAL_EOF:  u1, 
                    
                    /// [4:4] Set this bit to clear the OUTFIFO_OVF_L1_CH_INT interrupt.
                    OUTFIFO_OVF:  u1, 
                    
                    /// [5:5] Set this bit to clear the OUTFIFO_UDF_L1_CH_INT interrupt.
                    OUTFIFO_UDF:  u1, 
                    
                    /// [6:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60080044));
                
                /// reserved
                pub const AHB_TEST = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:2] reserved
                    AHB_TESTMODE:  u3, 
                    
                    /// [3:3] 
                    res0:  u0, 
                    
                    /// [4:5] reserved
                    AHB_TESTADDR:  u2, 
                    
                    /// [6:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x60080060));
                
                /// MISC register
                pub const MISC_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Set this bit then clear this bit to reset the internal ahb FSM.
                    AHBM_RST_INTER:  u1, 
                    
                    /// [1:1] 
                    res0:  u0, 
                    
                    /// [2:2] Set this bit to disable priority arbitration function.
                    ARB_PRI_DIS:  u1, 
                    
                    /// [3:3] 1'h1: Force clock on for register. 1'h0: Support clock only when application writes registers.
                    CLK_EN:  u1, 
                    
                    /// [4:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x60080064));
                
                /// Version control register
                pub const DATE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] register version.
                    DATE:  u32, 
                    
                }), @ptrFromInt(0x60080068));
                
                /// Configure 0 register of Rx channel 0
                pub const IN_CONF0_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] This bit is used to reset DMA channel 0 Rx FSM and Rx FIFO pointer.
                    IN_RST:  u1, 
                    
                    /// [1:1] reserved
                    IN_LOOP_TEST:  u1, 
                    
                    /// [2:2] Set this bit to 1 to enable INCR burst transfer for Rx channel 0 reading link descriptor when accessing internal SRAM.
                    INDSCR_BURST_EN:  u1, 
                    
                    /// [3:3] Set this bit to 1 to enable INCR burst transfer for Rx channel 0 receiving data when accessing internal SRAM.
                    IN_DATA_BURST_EN:  u1, 
                    
                    /// [4:4] Set this bit 1 to enable automatic transmitting data from memory to memory via DMA.
                    MEM_TRANS_EN:  u1, 
                    
                    /// [5:5] Set this bit to 1 to enable etm control mode, dma Rx channel 0 is triggered by etm task.
                    IN_ETM_EN:  u1, 
                    
                    /// [6:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60080070));
                
                /// Configure 0 register of Rx channel 0
                pub const IN_CONF0_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] This bit is used to reset DMA channel 0 Rx FSM and Rx FIFO pointer.
                    IN_RST:  u1, 
                    
                    /// [1:1] reserved
                    IN_LOOP_TEST:  u1, 
                    
                    /// [2:2] Set this bit to 1 to enable INCR burst transfer for Rx channel 0 reading link descriptor when accessing internal SRAM.
                    INDSCR_BURST_EN:  u1, 
                    
                    /// [3:3] Set this bit to 1 to enable INCR burst transfer for Rx channel 0 receiving data when accessing internal SRAM.
                    IN_DATA_BURST_EN:  u1, 
                    
                    /// [4:4] Set this bit 1 to enable automatic transmitting data from memory to memory via DMA.
                    MEM_TRANS_EN:  u1, 
                    
                    /// [5:5] Set this bit to 1 to enable etm control mode, dma Rx channel 0 is triggered by etm task.
                    IN_ETM_EN:  u1, 
                    
                    /// [6:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60080074));
                
                /// Configure 0 register of Rx channel 0
                pub const IN_CONF0_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] This bit is used to reset DMA channel 0 Rx FSM and Rx FIFO pointer.
                    IN_RST:  u1, 
                    
                    /// [1:1] reserved
                    IN_LOOP_TEST:  u1, 
                    
                    /// [2:2] Set this bit to 1 to enable INCR burst transfer for Rx channel 0 reading link descriptor when accessing internal SRAM.
                    INDSCR_BURST_EN:  u1, 
                    
                    /// [3:3] Set this bit to 1 to enable INCR burst transfer for Rx channel 0 receiving data when accessing internal SRAM.
                    IN_DATA_BURST_EN:  u1, 
                    
                    /// [4:4] Set this bit 1 to enable automatic transmitting data from memory to memory via DMA.
                    MEM_TRANS_EN:  u1, 
                    
                    /// [5:5] Set this bit to 1 to enable etm control mode, dma Rx channel 0 is triggered by etm task.
                    IN_ETM_EN:  u1, 
                    
                    /// [6:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60080078));
                
                /// Configure 1 register of Rx channel 0
                pub const IN_CONF1_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:11] 
                    res0:  u0, 
                    
                    /// [12:12] Set this bit to enable checking the owner attribute of the link descriptor.
                    IN_CHECK_OWNER:  u1, 
                    
                    /// [13:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x60080074));
                
                /// Configure 1 register of Rx channel 0
                pub const IN_CONF1_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:11] 
                    res0:  u0, 
                    
                    /// [12:12] Set this bit to enable checking the owner attribute of the link descriptor.
                    IN_CHECK_OWNER:  u1, 
                    
                    /// [13:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x60080078));
                
                /// Configure 1 register of Rx channel 0
                pub const IN_CONF1_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:11] 
                    res0:  u0, 
                    
                    /// [12:12] Set this bit to enable checking the owner attribute of the link descriptor.
                    IN_CHECK_OWNER:  u1, 
                    
                    /// [13:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x6008007c));
                
                /// Receive FIFO status of Rx channel 0
                pub const INFIFO_STATUS_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] L1 Rx FIFO full signal for Rx channel 0.
                    INFIFO_FULL:  u1, 
                    
                    /// [1:1] L1 Rx FIFO empty signal for Rx channel 0.
                    INFIFO_EMPTY:  u1, 
                    
                    /// [2:7] The register stores the byte number of the data in L1 Rx FIFO for Rx channel 0.
                    INFIFO_CNT:  u6, 
                    
                    /// [8:22] 
                    res0:  u0, 
                    
                    /// [23:23] reserved
                    IN_REMAIN_UNDER_1B:  u1, 
                    
                    /// [24:24] reserved
                    IN_REMAIN_UNDER_2B:  u1, 
                    
                    /// [25:25] reserved
                    IN_REMAIN_UNDER_3B:  u1, 
                    
                    /// [26:26] reserved
                    IN_REMAIN_UNDER_4B:  u1, 
                    
                    /// [27:27] reserved
                    IN_BUF_HUNGRY:  u1, 
                    
                    /// [28:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x60080078));
                
                /// Receive FIFO status of Rx channel 0
                pub const INFIFO_STATUS_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] L1 Rx FIFO full signal for Rx channel 0.
                    INFIFO_FULL:  u1, 
                    
                    /// [1:1] L1 Rx FIFO empty signal for Rx channel 0.
                    INFIFO_EMPTY:  u1, 
                    
                    /// [2:7] The register stores the byte number of the data in L1 Rx FIFO for Rx channel 0.
                    INFIFO_CNT:  u6, 
                    
                    /// [8:22] 
                    res0:  u0, 
                    
                    /// [23:23] reserved
                    IN_REMAIN_UNDER_1B:  u1, 
                    
                    /// [24:24] reserved
                    IN_REMAIN_UNDER_2B:  u1, 
                    
                    /// [25:25] reserved
                    IN_REMAIN_UNDER_3B:  u1, 
                    
                    /// [26:26] reserved
                    IN_REMAIN_UNDER_4B:  u1, 
                    
                    /// [27:27] reserved
                    IN_BUF_HUNGRY:  u1, 
                    
                    /// [28:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x6008007c));
                
                /// Receive FIFO status of Rx channel 0
                pub const INFIFO_STATUS_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] L1 Rx FIFO full signal for Rx channel 0.
                    INFIFO_FULL:  u1, 
                    
                    /// [1:1] L1 Rx FIFO empty signal for Rx channel 0.
                    INFIFO_EMPTY:  u1, 
                    
                    /// [2:7] The register stores the byte number of the data in L1 Rx FIFO for Rx channel 0.
                    INFIFO_CNT:  u6, 
                    
                    /// [8:22] 
                    res0:  u0, 
                    
                    /// [23:23] reserved
                    IN_REMAIN_UNDER_1B:  u1, 
                    
                    /// [24:24] reserved
                    IN_REMAIN_UNDER_2B:  u1, 
                    
                    /// [25:25] reserved
                    IN_REMAIN_UNDER_3B:  u1, 
                    
                    /// [26:26] reserved
                    IN_REMAIN_UNDER_4B:  u1, 
                    
                    /// [27:27] reserved
                    IN_BUF_HUNGRY:  u1, 
                    
                    /// [28:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x60080080));
                
                /// Pop control register of Rx channel 0
                pub const IN_POP_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:11] This register stores the data popping from DMA FIFO.
                    INFIFO_RDATA:  u12, 
                    
                    /// [12:12] Set this bit to pop data from DMA FIFO.
                    INFIFO_POP:  u1, 
                    
                    /// [13:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6008007c));
                
                /// Pop control register of Rx channel 0
                pub const IN_POP_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:11] This register stores the data popping from DMA FIFO.
                    INFIFO_RDATA:  u12, 
                    
                    /// [12:12] Set this bit to pop data from DMA FIFO.
                    INFIFO_POP:  u1, 
                    
                    /// [13:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60080080));
                
                /// Pop control register of Rx channel 0
                pub const IN_POP_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:11] This register stores the data popping from DMA FIFO.
                    INFIFO_RDATA:  u12, 
                    
                    /// [12:12] Set this bit to pop data from DMA FIFO.
                    INFIFO_POP:  u1, 
                    
                    /// [13:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60080084));
                
                /// Link descriptor configure and control register of Rx channel 0
                pub const IN_LINK_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:19] This register stores the 20 least significant bits of the first inlink descriptor's address.
                    INLINK_ADDR:  u20, 
                    
                    /// [20:20] Set this bit to return to current inlink descriptor's address when there are some errors in current receiving data.
                    INLINK_AUTO_RET:  u1, 
                    
                    /// [21:21] Set this bit to stop dealing with the inlink descriptors.
                    INLINK_STOP:  u1, 
                    
                    /// [22:22] Set this bit to start dealing with the inlink descriptors.
                    INLINK_START:  u1, 
                    
                    /// [23:23] Set this bit to mount a new inlink descriptor.
                    INLINK_RESTART:  u1, 
                    
                    /// [24:24] 1: the inlink descriptor's FSM is in idle state.0: the inlink descriptor's FSM is working.
                    INLINK_PARK:  u1, 
                    
                    /// [25:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60080080));
                
                /// Link descriptor configure and control register of Rx channel 0
                pub const IN_LINK_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:19] This register stores the 20 least significant bits of the first inlink descriptor's address.
                    INLINK_ADDR:  u20, 
                    
                    /// [20:20] Set this bit to return to current inlink descriptor's address when there are some errors in current receiving data.
                    INLINK_AUTO_RET:  u1, 
                    
                    /// [21:21] Set this bit to stop dealing with the inlink descriptors.
                    INLINK_STOP:  u1, 
                    
                    /// [22:22] Set this bit to start dealing with the inlink descriptors.
                    INLINK_START:  u1, 
                    
                    /// [23:23] Set this bit to mount a new inlink descriptor.
                    INLINK_RESTART:  u1, 
                    
                    /// [24:24] 1: the inlink descriptor's FSM is in idle state.0: the inlink descriptor's FSM is working.
                    INLINK_PARK:  u1, 
                    
                    /// [25:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60080084));
                
                /// Link descriptor configure and control register of Rx channel 0
                pub const IN_LINK_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:19] This register stores the 20 least significant bits of the first inlink descriptor's address.
                    INLINK_ADDR:  u20, 
                    
                    /// [20:20] Set this bit to return to current inlink descriptor's address when there are some errors in current receiving data.
                    INLINK_AUTO_RET:  u1, 
                    
                    /// [21:21] Set this bit to stop dealing with the inlink descriptors.
                    INLINK_STOP:  u1, 
                    
                    /// [22:22] Set this bit to start dealing with the inlink descriptors.
                    INLINK_START:  u1, 
                    
                    /// [23:23] Set this bit to mount a new inlink descriptor.
                    INLINK_RESTART:  u1, 
                    
                    /// [24:24] 1: the inlink descriptor's FSM is in idle state.0: the inlink descriptor's FSM is working.
                    INLINK_PARK:  u1, 
                    
                    /// [25:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60080088));
                
                /// Receive status of Rx channel 0
                pub const IN_STATE_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:17] This register stores the current inlink descriptor's address.
                    INLINK_DSCR_ADDR:  u18, 
                    
                    /// [18:19] reserved
                    IN_DSCR_STATE:  u2, 
                    
                    /// [20:22] reserved
                    IN_STATE:  u3, 
                    
                    /// [23:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60080084));
                
                /// Receive status of Rx channel 0
                pub const IN_STATE_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:17] This register stores the current inlink descriptor's address.
                    INLINK_DSCR_ADDR:  u18, 
                    
                    /// [18:19] reserved
                    IN_DSCR_STATE:  u2, 
                    
                    /// [20:22] reserved
                    IN_STATE:  u3, 
                    
                    /// [23:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60080088));
                
                /// Receive status of Rx channel 0
                pub const IN_STATE_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:17] This register stores the current inlink descriptor's address.
                    INLINK_DSCR_ADDR:  u18, 
                    
                    /// [18:19] reserved
                    IN_DSCR_STATE:  u2, 
                    
                    /// [20:22] reserved
                    IN_STATE:  u3, 
                    
                    /// [23:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6008008c));
                
                /// Inlink descriptor address when EOF occurs of Rx channel 0
                pub const IN_SUC_EOF_DES_ADDR_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] This register stores the address of the inlink descriptor when the EOF bit in this descriptor is 1.
                    IN_SUC_EOF_DES_ADDR:  u32, 
                    
                }), @ptrFromInt(0x60080088));
                
                /// Inlink descriptor address when EOF occurs of Rx channel 0
                pub const IN_SUC_EOF_DES_ADDR_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] This register stores the address of the inlink descriptor when the EOF bit in this descriptor is 1.
                    IN_SUC_EOF_DES_ADDR:  u32, 
                    
                }), @ptrFromInt(0x6008008c));
                
                /// Inlink descriptor address when EOF occurs of Rx channel 0
                pub const IN_SUC_EOF_DES_ADDR_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] This register stores the address of the inlink descriptor when the EOF bit in this descriptor is 1.
                    IN_SUC_EOF_DES_ADDR:  u32, 
                    
                }), @ptrFromInt(0x60080090));
                
                /// Inlink descriptor address when errors occur of Rx channel 0
                pub const IN_ERR_EOF_DES_ADDR_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] This register stores the address of the inlink descriptor when there are some errors in current receiving data. Only used when peripheral is UHCI0.
                    IN_ERR_EOF_DES_ADDR:  u32, 
                    
                }), @ptrFromInt(0x6008008c));
                
                /// Inlink descriptor address when errors occur of Rx channel 0
                pub const IN_ERR_EOF_DES_ADDR_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] This register stores the address of the inlink descriptor when there are some errors in current receiving data. Only used when peripheral is UHCI0.
                    IN_ERR_EOF_DES_ADDR:  u32, 
                    
                }), @ptrFromInt(0x60080090));
                
                /// Inlink descriptor address when errors occur of Rx channel 0
                pub const IN_ERR_EOF_DES_ADDR_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] This register stores the address of the inlink descriptor when there are some errors in current receiving data. Only used when peripheral is UHCI0.
                    IN_ERR_EOF_DES_ADDR:  u32, 
                    
                }), @ptrFromInt(0x60080094));
                
                /// Current inlink descriptor address of Rx channel 0
                pub const IN_DSCR_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] The address of the current inlink descriptor x.
                    INLINK_DSCR:  u32, 
                    
                }), @ptrFromInt(0x60080090));
                
                /// Current inlink descriptor address of Rx channel 0
                pub const IN_DSCR_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] The address of the current inlink descriptor x.
                    INLINK_DSCR:  u32, 
                    
                }), @ptrFromInt(0x60080094));
                
                /// Current inlink descriptor address of Rx channel 0
                pub const IN_DSCR_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] The address of the current inlink descriptor x.
                    INLINK_DSCR:  u32, 
                    
                }), @ptrFromInt(0x60080098));
                
                /// The last inlink descriptor address of Rx channel 0
                pub const IN_DSCR_BF0_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] The address of the last inlink descriptor x-1.
                    INLINK_DSCR_BF0:  u32, 
                    
                }), @ptrFromInt(0x60080094));
                
                /// The last inlink descriptor address of Rx channel 0
                pub const IN_DSCR_BF0_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] The address of the last inlink descriptor x-1.
                    INLINK_DSCR_BF0:  u32, 
                    
                }), @ptrFromInt(0x60080098));
                
                /// The last inlink descriptor address of Rx channel 0
                pub const IN_DSCR_BF0_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] The address of the last inlink descriptor x-1.
                    INLINK_DSCR_BF0:  u32, 
                    
                }), @ptrFromInt(0x6008009c));
                
                /// The second-to-last inlink descriptor address of Rx channel 0
                pub const IN_DSCR_BF1_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] The address of the second-to-last inlink descriptor x-2.
                    INLINK_DSCR_BF1:  u32, 
                    
                }), @ptrFromInt(0x60080098));
                
                /// The second-to-last inlink descriptor address of Rx channel 0
                pub const IN_DSCR_BF1_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] The address of the second-to-last inlink descriptor x-2.
                    INLINK_DSCR_BF1:  u32, 
                    
                }), @ptrFromInt(0x6008009c));
                
                /// The second-to-last inlink descriptor address of Rx channel 0
                pub const IN_DSCR_BF1_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] The address of the second-to-last inlink descriptor x-2.
                    INLINK_DSCR_BF1:  u32, 
                    
                }), @ptrFromInt(0x600800a0));
                
                /// Priority register of Rx channel 0
                pub const IN_PRI_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:3] The priority of Rx channel 0. The larger of the value the higher of the priority.
                    RX_PRI:  u4, 
                    
                    /// [4:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6008009c));
                
                /// Priority register of Rx channel 0
                pub const IN_PRI_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:3] The priority of Rx channel 0. The larger of the value the higher of the priority.
                    RX_PRI:  u4, 
                    
                    /// [4:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600800a0));
                
                /// Priority register of Rx channel 0
                pub const IN_PRI_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:3] The priority of Rx channel 0. The larger of the value the higher of the priority.
                    RX_PRI:  u4, 
                    
                    /// [4:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600800a4));
                
                /// Peripheral selection of Rx channel 0
                pub const IN_PERI_SEL_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] This register is used to select peripheral for Rx channel 0. 0:SPI2. 1: Dummy. 2: UHCI0. 3: I2S0. 4: Dummy. 5: Dummy. 6: AES. 7: SHA. 8: ADC_DAC. 9: Parallel_IO. 10~15: Dummy
                    PERI_IN_SEL:  u6, 
                    
                    /// [6:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600800a0));
                
                /// Peripheral selection of Rx channel 0
                pub const IN_PERI_SEL_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] This register is used to select peripheral for Rx channel 0. 0:SPI2. 1: Dummy. 2: UHCI0. 3: I2S0. 4: Dummy. 5: Dummy. 6: AES. 7: SHA. 8: ADC_DAC. 9: Parallel_IO. 10~15: Dummy
                    PERI_IN_SEL:  u6, 
                    
                    /// [6:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600800a4));
                
                /// Peripheral selection of Rx channel 0
                pub const IN_PERI_SEL_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] This register is used to select peripheral for Rx channel 0. 0:SPI2. 1: Dummy. 2: UHCI0. 3: I2S0. 4: Dummy. 5: Dummy. 6: AES. 7: SHA. 8: ADC_DAC. 9: Parallel_IO. 10~15: Dummy
                    PERI_IN_SEL:  u6, 
                    
                    /// [6:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600800a8));
                
                /// Configure 1 register of Tx channel 0
                pub const OUT_CONF1_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:11] 
                    res0:  u0, 
                    
                    /// [12:12] Set this bit to enable checking the owner attribute of the link descriptor.
                    OUT_CHECK_OWNER:  u1, 
                    
                    /// [13:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x600800d4));
                
                /// Configure 1 register of Tx channel 0
                pub const OUT_CONF1_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:11] 
                    res0:  u0, 
                    
                    /// [12:12] Set this bit to enable checking the owner attribute of the link descriptor.
                    OUT_CHECK_OWNER:  u1, 
                    
                    /// [13:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x600800d8));
                
                /// Configure 1 register of Tx channel 0
                pub const OUT_CONF1_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:11] 
                    res0:  u0, 
                    
                    /// [12:12] Set this bit to enable checking the owner attribute of the link descriptor.
                    OUT_CHECK_OWNER:  u1, 
                    
                    /// [13:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x600800dc));
                
                /// Transmit FIFO status of Tx channel 0
                pub const OUTFIFO_STATUS_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] L1 Tx FIFO full signal for Tx channel 0.
                    OUTFIFO_FULL:  u1, 
                    
                    /// [1:1] L1 Tx FIFO empty signal for Tx channel 0.
                    OUTFIFO_EMPTY:  u1, 
                    
                    /// [2:7] The register stores the byte number of the data in L1 Tx FIFO for Tx channel 0.
                    OUTFIFO_CNT:  u6, 
                    
                    /// [8:22] 
                    res0:  u0, 
                    
                    /// [23:23] reserved
                    OUT_REMAIN_UNDER_1B:  u1, 
                    
                    /// [24:24] reserved
                    OUT_REMAIN_UNDER_2B:  u1, 
                    
                    /// [25:25] reserved
                    OUT_REMAIN_UNDER_3B:  u1, 
                    
                    /// [26:26] reserved
                    OUT_REMAIN_UNDER_4B:  u1, 
                    
                    /// [27:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x600800d8));
                
                /// Transmit FIFO status of Tx channel 0
                pub const OUTFIFO_STATUS_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] L1 Tx FIFO full signal for Tx channel 0.
                    OUTFIFO_FULL:  u1, 
                    
                    /// [1:1] L1 Tx FIFO empty signal for Tx channel 0.
                    OUTFIFO_EMPTY:  u1, 
                    
                    /// [2:7] The register stores the byte number of the data in L1 Tx FIFO for Tx channel 0.
                    OUTFIFO_CNT:  u6, 
                    
                    /// [8:22] 
                    res0:  u0, 
                    
                    /// [23:23] reserved
                    OUT_REMAIN_UNDER_1B:  u1, 
                    
                    /// [24:24] reserved
                    OUT_REMAIN_UNDER_2B:  u1, 
                    
                    /// [25:25] reserved
                    OUT_REMAIN_UNDER_3B:  u1, 
                    
                    /// [26:26] reserved
                    OUT_REMAIN_UNDER_4B:  u1, 
                    
                    /// [27:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x600800dc));
                
                /// Transmit FIFO status of Tx channel 0
                pub const OUTFIFO_STATUS_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] L1 Tx FIFO full signal for Tx channel 0.
                    OUTFIFO_FULL:  u1, 
                    
                    /// [1:1] L1 Tx FIFO empty signal for Tx channel 0.
                    OUTFIFO_EMPTY:  u1, 
                    
                    /// [2:7] The register stores the byte number of the data in L1 Tx FIFO for Tx channel 0.
                    OUTFIFO_CNT:  u6, 
                    
                    /// [8:22] 
                    res0:  u0, 
                    
                    /// [23:23] reserved
                    OUT_REMAIN_UNDER_1B:  u1, 
                    
                    /// [24:24] reserved
                    OUT_REMAIN_UNDER_2B:  u1, 
                    
                    /// [25:25] reserved
                    OUT_REMAIN_UNDER_3B:  u1, 
                    
                    /// [26:26] reserved
                    OUT_REMAIN_UNDER_4B:  u1, 
                    
                    /// [27:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x600800e0));
                
                /// Push control register of Rx channel 0
                pub const OUT_PUSH_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:8] This register stores the data that need to be pushed into DMA FIFO.
                    OUTFIFO_WDATA:  u9, 
                    
                    /// [9:9] Set this bit to push data into DMA FIFO.
                    OUTFIFO_PUSH:  u1, 
                    
                    /// [10:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600800dc));
                
                /// Push control register of Rx channel 0
                pub const OUT_PUSH_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:8] This register stores the data that need to be pushed into DMA FIFO.
                    OUTFIFO_WDATA:  u9, 
                    
                    /// [9:9] Set this bit to push data into DMA FIFO.
                    OUTFIFO_PUSH:  u1, 
                    
                    /// [10:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600800e0));
                
                /// Push control register of Rx channel 0
                pub const OUT_PUSH_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:8] This register stores the data that need to be pushed into DMA FIFO.
                    OUTFIFO_WDATA:  u9, 
                    
                    /// [9:9] Set this bit to push data into DMA FIFO.
                    OUTFIFO_PUSH:  u1, 
                    
                    /// [10:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600800e4));
                
                /// Link descriptor configure and control register of Tx channel 0
                pub const OUT_LINK_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:19] This register stores the 20 least significant bits of the first outlink descriptor's address.
                    OUTLINK_ADDR:  u20, 
                    
                    /// [20:20] Set this bit to stop dealing with the outlink descriptors.
                    OUTLINK_STOP:  u1, 
                    
                    /// [21:21] Set this bit to start dealing with the outlink descriptors.
                    OUTLINK_START:  u1, 
                    
                    /// [22:22] Set this bit to restart a new outlink from the last address.
                    OUTLINK_RESTART:  u1, 
                    
                    /// [23:23] 1: the outlink descriptor's FSM is in idle state.0: the outlink descriptor's FSM is working.
                    OUTLINK_PARK:  u1, 
                    
                    /// [24:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600800e0));
                
                /// Link descriptor configure and control register of Tx channel 0
                pub const OUT_LINK_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:19] This register stores the 20 least significant bits of the first outlink descriptor's address.
                    OUTLINK_ADDR:  u20, 
                    
                    /// [20:20] Set this bit to stop dealing with the outlink descriptors.
                    OUTLINK_STOP:  u1, 
                    
                    /// [21:21] Set this bit to start dealing with the outlink descriptors.
                    OUTLINK_START:  u1, 
                    
                    /// [22:22] Set this bit to restart a new outlink from the last address.
                    OUTLINK_RESTART:  u1, 
                    
                    /// [23:23] 1: the outlink descriptor's FSM is in idle state.0: the outlink descriptor's FSM is working.
                    OUTLINK_PARK:  u1, 
                    
                    /// [24:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600800e4));
                
                /// Link descriptor configure and control register of Tx channel 0
                pub const OUT_LINK_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:19] This register stores the 20 least significant bits of the first outlink descriptor's address.
                    OUTLINK_ADDR:  u20, 
                    
                    /// [20:20] Set this bit to stop dealing with the outlink descriptors.
                    OUTLINK_STOP:  u1, 
                    
                    /// [21:21] Set this bit to start dealing with the outlink descriptors.
                    OUTLINK_START:  u1, 
                    
                    /// [22:22] Set this bit to restart a new outlink from the last address.
                    OUTLINK_RESTART:  u1, 
                    
                    /// [23:23] 1: the outlink descriptor's FSM is in idle state.0: the outlink descriptor's FSM is working.
                    OUTLINK_PARK:  u1, 
                    
                    /// [24:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600800e8));
                
                /// Transmit status of Tx channel 0
                pub const OUT_STATE_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:17] This register stores the current outlink descriptor's address.
                    OUTLINK_DSCR_ADDR:  u18, 
                    
                    /// [18:19] reserved
                    OUT_DSCR_STATE:  u2, 
                    
                    /// [20:22] reserved
                    OUT_STATE:  u3, 
                    
                    /// [23:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600800e4));
                
                /// Transmit status of Tx channel 0
                pub const OUT_STATE_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:17] This register stores the current outlink descriptor's address.
                    OUTLINK_DSCR_ADDR:  u18, 
                    
                    /// [18:19] reserved
                    OUT_DSCR_STATE:  u2, 
                    
                    /// [20:22] reserved
                    OUT_STATE:  u3, 
                    
                    /// [23:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600800e8));
                
                /// Transmit status of Tx channel 0
                pub const OUT_STATE_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:17] This register stores the current outlink descriptor's address.
                    OUTLINK_DSCR_ADDR:  u18, 
                    
                    /// [18:19] reserved
                    OUT_DSCR_STATE:  u2, 
                    
                    /// [20:22] reserved
                    OUT_STATE:  u3, 
                    
                    /// [23:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600800ec));
                
                /// Outlink descriptor address when EOF occurs of Tx channel 0
                pub const OUT_EOF_DES_ADDR_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] This register stores the address of the outlink descriptor when the EOF bit in this descriptor is 1.
                    OUT_EOF_DES_ADDR:  u32, 
                    
                }), @ptrFromInt(0x600800e8));
                
                /// Outlink descriptor address when EOF occurs of Tx channel 0
                pub const OUT_EOF_DES_ADDR_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] This register stores the address of the outlink descriptor when the EOF bit in this descriptor is 1.
                    OUT_EOF_DES_ADDR:  u32, 
                    
                }), @ptrFromInt(0x600800ec));
                
                /// Outlink descriptor address when EOF occurs of Tx channel 0
                pub const OUT_EOF_DES_ADDR_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] This register stores the address of the outlink descriptor when the EOF bit in this descriptor is 1.
                    OUT_EOF_DES_ADDR:  u32, 
                    
                }), @ptrFromInt(0x600800f0));
                
                /// The last outlink descriptor address when EOF occurs of Tx channel 0
                pub const OUT_EOF_BFR_DES_ADDR_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] This register stores the address of the outlink descriptor before the last outlink descriptor.
                    OUT_EOF_BFR_DES_ADDR:  u32, 
                    
                }), @ptrFromInt(0x600800ec));
                
                /// The last outlink descriptor address when EOF occurs of Tx channel 0
                pub const OUT_EOF_BFR_DES_ADDR_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] This register stores the address of the outlink descriptor before the last outlink descriptor.
                    OUT_EOF_BFR_DES_ADDR:  u32, 
                    
                }), @ptrFromInt(0x600800f0));
                
                /// The last outlink descriptor address when EOF occurs of Tx channel 0
                pub const OUT_EOF_BFR_DES_ADDR_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] This register stores the address of the outlink descriptor before the last outlink descriptor.
                    OUT_EOF_BFR_DES_ADDR:  u32, 
                    
                }), @ptrFromInt(0x600800f4));
                
                /// Current inlink descriptor address of Tx channel 0
                pub const OUT_DSCR_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] The address of the current outlink descriptor y.
                    OUTLINK_DSCR:  u32, 
                    
                }), @ptrFromInt(0x600800f0));
                
                /// Current inlink descriptor address of Tx channel 0
                pub const OUT_DSCR_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] The address of the current outlink descriptor y.
                    OUTLINK_DSCR:  u32, 
                    
                }), @ptrFromInt(0x600800f4));
                
                /// Current inlink descriptor address of Tx channel 0
                pub const OUT_DSCR_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] The address of the current outlink descriptor y.
                    OUTLINK_DSCR:  u32, 
                    
                }), @ptrFromInt(0x600800f8));
                
                /// The last inlink descriptor address of Tx channel 0
                pub const OUT_DSCR_BF0_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] The address of the last outlink descriptor y-1.
                    OUTLINK_DSCR_BF0:  u32, 
                    
                }), @ptrFromInt(0x600800f4));
                
                /// The last inlink descriptor address of Tx channel 0
                pub const OUT_DSCR_BF0_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] The address of the last outlink descriptor y-1.
                    OUTLINK_DSCR_BF0:  u32, 
                    
                }), @ptrFromInt(0x600800f8));
                
                /// The last inlink descriptor address of Tx channel 0
                pub const OUT_DSCR_BF0_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] The address of the last outlink descriptor y-1.
                    OUTLINK_DSCR_BF0:  u32, 
                    
                }), @ptrFromInt(0x600800fc));
                
                /// The second-to-last inlink descriptor address of Tx channel 0
                pub const OUT_DSCR_BF1_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] The address of the second-to-last inlink descriptor x-2.
                    OUTLINK_DSCR_BF1:  u32, 
                    
                }), @ptrFromInt(0x600800f8));
                
                /// The second-to-last inlink descriptor address of Tx channel 0
                pub const OUT_DSCR_BF1_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] The address of the second-to-last inlink descriptor x-2.
                    OUTLINK_DSCR_BF1:  u32, 
                    
                }), @ptrFromInt(0x600800fc));
                
                /// The second-to-last inlink descriptor address of Tx channel 0
                pub const OUT_DSCR_BF1_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] The address of the second-to-last inlink descriptor x-2.
                    OUTLINK_DSCR_BF1:  u32, 
                    
                }), @ptrFromInt(0x60080100));
                
                /// Priority register of Tx channel 0.
                pub const OUT_PRI_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:3] The priority of Tx channel 0. The larger of the value the higher of the priority.
                    TX_PRI:  u4, 
                    
                    /// [4:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600800fc));
                
                /// Priority register of Tx channel 0.
                pub const OUT_PRI_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:3] The priority of Tx channel 0. The larger of the value the higher of the priority.
                    TX_PRI:  u4, 
                    
                    /// [4:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60080100));
                
                /// Priority register of Tx channel 0.
                pub const OUT_PRI_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:3] The priority of Tx channel 0. The larger of the value the higher of the priority.
                    TX_PRI:  u4, 
                    
                    /// [4:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60080104));
                
                /// Peripheral selection of Tx channel 0
                pub const OUT_PERI_SEL_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] This register is used to select peripheral for Tx channel 0. 0:SPI2. 1: Dummy. 2: UHCI0. 3: I2S0. 4: Dummy. 5: Dummy. 6: AES. 7: SHA. 8: ADC_DAC. 9: Parallel_IO. 10~15: Dummy
                    PERI_OUT_SEL:  u6, 
                    
                    /// [6:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60080100));
                
                /// Peripheral selection of Tx channel 0
                pub const OUT_PERI_SEL_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] This register is used to select peripheral for Tx channel 0. 0:SPI2. 1: Dummy. 2: UHCI0. 3: I2S0. 4: Dummy. 5: Dummy. 6: AES. 7: SHA. 8: ADC_DAC. 9: Parallel_IO. 10~15: Dummy
                    PERI_OUT_SEL:  u6, 
                    
                    /// [6:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60080104));
                
                /// Peripheral selection of Tx channel 0
                pub const OUT_PERI_SEL_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] This register is used to select peripheral for Tx channel 0. 0:SPI2. 1: Dummy. 2: UHCI0. 3: I2S0. 4: Dummy. 5: Dummy. 6: AES. 7: SHA. 8: ADC_DAC. 9: Parallel_IO. 10~15: Dummy
                    PERI_OUT_SEL:  u6, 
                    
                    /// [6:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60080108));
                
                /// Configure 0 register of Tx channel 1
                pub const OUT_CONF0_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] This bit is used to reset DMA channel 1 Tx FSM and Tx FIFO pointer.
                    OUT_RST:  u1, 
                    
                    /// [1:1] reserved
                    OUT_LOOP_TEST:  u1, 
                    
                    /// [2:2] Set this bit to enable automatic outlink-writeback when all the data in tx buffer has been transmitted.
                    OUT_AUTO_WRBACK:  u1, 
                    
                    /// [3:3] EOF flag generation mode when transmitting data. 1: EOF flag for Tx channel 1 is generated when data need to transmit has been popped from FIFO in DMA
                    OUT_EOF_MODE:  u1, 
                    
                    /// [4:4] Set this bit to 1 to enable INCR burst transfer for Tx channel 1 reading link descriptor when accessing internal SRAM.
                    OUTDSCR_BURST_EN:  u1, 
                    
                    /// [5:5] Set this bit to 1 to enable INCR burst transfer for Tx channel 1 transmitting data when accessing internal SRAM.
                    OUT_DATA_BURST_EN:  u1, 
                    
                    /// [6:6] Set this bit to 1 to enable etm control mode, dma Tx channel 1 is triggered by etm task.
                    OUT_ETM_EN:  u1, 
                    
                    /// [7:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60080190));
                
                /// Configure 0 register of Tx channel 1
                pub const OUT_CONF0_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] This bit is used to reset DMA channel 1 Tx FSM and Tx FIFO pointer.
                    OUT_RST:  u1, 
                    
                    /// [1:1] reserved
                    OUT_LOOP_TEST:  u1, 
                    
                    /// [2:2] Set this bit to enable automatic outlink-writeback when all the data in tx buffer has been transmitted.
                    OUT_AUTO_WRBACK:  u1, 
                    
                    /// [3:3] EOF flag generation mode when transmitting data. 1: EOF flag for Tx channel 1 is generated when data need to transmit has been popped from FIFO in DMA
                    OUT_EOF_MODE:  u1, 
                    
                    /// [4:4] Set this bit to 1 to enable INCR burst transfer for Tx channel 1 reading link descriptor when accessing internal SRAM.
                    OUTDSCR_BURST_EN:  u1, 
                    
                    /// [5:5] Set this bit to 1 to enable INCR burst transfer for Tx channel 1 transmitting data when accessing internal SRAM.
                    OUT_DATA_BURST_EN:  u1, 
                    
                    /// [6:6] Set this bit to 1 to enable etm control mode, dma Tx channel 1 is triggered by etm task.
                    OUT_ETM_EN:  u1, 
                    
                    /// [7:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60080194));
                
                /// Configure 0 register of Tx channel 1
                pub const OUT_CONF0_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] This bit is used to reset DMA channel 1 Tx FSM and Tx FIFO pointer.
                    OUT_RST:  u1, 
                    
                    /// [1:1] reserved
                    OUT_LOOP_TEST:  u1, 
                    
                    /// [2:2] Set this bit to enable automatic outlink-writeback when all the data in tx buffer has been transmitted.
                    OUT_AUTO_WRBACK:  u1, 
                    
                    /// [3:3] EOF flag generation mode when transmitting data. 1: EOF flag for Tx channel 1 is generated when data need to transmit has been popped from FIFO in DMA
                    OUT_EOF_MODE:  u1, 
                    
                    /// [4:4] Set this bit to 1 to enable INCR burst transfer for Tx channel 1 reading link descriptor when accessing internal SRAM.
                    OUTDSCR_BURST_EN:  u1, 
                    
                    /// [5:5] Set this bit to 1 to enable INCR burst transfer for Tx channel 1 transmitting data when accessing internal SRAM.
                    OUT_DATA_BURST_EN:  u1, 
                    
                    /// [6:6] Set this bit to 1 to enable etm control mode, dma Tx channel 1 is triggered by etm task.
                    OUT_ETM_EN:  u1, 
                    
                    /// [7:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60080198));
                
            };
            
            /// Digital Signature
            pub const DS = struct {
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c000));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c001));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c002));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c003));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c004));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c005));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c006));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c007));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c008));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c009));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c00a));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c00b));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c00c));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c00d));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c00e));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c00f));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c010));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c011));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c012));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c013));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c014));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c015));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c016));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c017));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c018));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c019));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c01a));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c01b));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c01c));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c01d));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c01e));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c01f));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c020));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c021));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c022));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c023));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c024));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c025));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c026));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c027));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c028));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c029));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c02a));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c02b));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c02c));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c02d));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c02e));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c02f));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c030));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c031));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c032));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c033));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c034));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c035));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c036));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c037));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c038));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c039));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c03a));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c03b));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c03c));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c03d));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c03e));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c03f));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c040));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c041));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c042));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c043));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c044));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c045));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c046));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c047));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c048));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c049));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c04a));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c04b));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c04c));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c04d));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c04e));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c04f));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c050));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c051));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c052));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c053));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c054));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c055));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c056));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c057));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c058));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c059));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c05a));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c05b));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c05c));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c05d));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c05e));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c05f));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c060));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c061));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c062));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c063));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c064));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c065));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c066));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c067));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c068));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c069));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c06a));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c06b));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c06c));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c06d));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c06e));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c06f));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c070));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c071));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c072));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c073));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c074));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c075));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c076));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c077));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c078));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c079));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c07a));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c07b));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c07c));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c07d));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c07e));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c07f));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c080));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c081));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c082));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c083));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c084));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c085));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c086));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c087));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c088));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c089));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c08a));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c08b));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c08c));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c08d));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c08e));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c08f));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c090));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c091));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c092));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c093));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c094));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c095));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c096));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c097));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c098));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c099));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c09a));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c09b));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c09c));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c09d));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c09e));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c09f));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c0a0));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c0a1));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c0a2));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c0a3));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c0a4));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c0a5));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c0a6));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c0a7));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c0a8));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c0a9));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c0aa));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c0ab));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c0ac));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c0ad));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c0ae));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c0af));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c0b0));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c0b1));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c0b2));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c0b3));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c0b4));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c0b5));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c0b6));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c0b7));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c0b8));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c0b9));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c0ba));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c0bb));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c0bc));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c0bd));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c0be));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c0bf));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c0c0));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c0c1));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c0c2));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c0c3));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c0c4));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c0c5));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c0c6));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c0c7));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c0c8));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c0c9));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c0ca));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c0cb));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c0cc));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c0cd));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c0ce));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c0cf));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c0d0));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c0d1));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c0d2));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c0d3));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c0d4));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c0d5));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c0d6));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c0d7));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c0d8));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c0d9));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c0da));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c0db));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c0dc));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c0dd));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c0de));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c0df));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c0e0));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c0e1));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c0e2));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c0e3));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c0e4));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c0e5));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c0e6));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c0e7));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c0e8));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c0e9));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c0ea));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c0eb));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c0ec));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c0ed));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c0ee));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c0ef));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c0f0));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c0f1));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c0f2));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c0f3));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c0f4));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c0f5));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c0f6));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c0f7));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c0f8));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c0f9));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c0fa));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c0fb));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c0fc));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c0fd));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c0fe));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c0ff));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c100));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c101));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c102));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c103));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c104));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c105));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c106));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c107));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c108));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c109));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c10a));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c10b));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c10c));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c10d));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c10e));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c10f));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c110));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c111));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c112));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c113));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c114));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c115));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c116));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c117));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c118));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c119));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c11a));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c11b));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c11c));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c11d));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c11e));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c11f));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c120));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c121));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c122));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c123));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c124));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c125));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c126));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c127));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c128));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c129));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c12a));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c12b));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c12c));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c12d));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c12e));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c12f));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c130));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c131));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c132));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c133));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c134));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c135));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c136));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c137));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c138));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c139));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c13a));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c13b));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c13c));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c13d));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c13e));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c13f));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c140));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c141));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c142));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c143));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c144));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c145));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c146));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c147));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c148));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c149));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c14a));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c14b));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c14c));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c14d));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c14e));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c14f));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c150));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c151));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c152));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c153));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c154));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c155));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c156));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c157));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c158));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c159));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c15a));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c15b));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c15c));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c15d));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c15e));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c15f));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c160));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c161));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c162));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c163));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c164));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c165));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c166));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c167));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c168));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c169));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c16a));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c16b));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c16c));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c16d));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c16e));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c16f));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c170));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c171));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c172));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c173));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c174));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c175));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c176));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c177));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c178));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c179));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c17a));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c17b));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c17c));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c17d));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c17e));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c17f));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c180));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c181));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c182));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c183));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c184));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c185));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c186));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c187));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c188));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c189));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c18a));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c18b));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c18c));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c18d));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c18e));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c18f));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c190));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c191));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c192));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c193));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c194));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c195));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c196));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c197));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c198));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c199));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c19a));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c19b));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c19c));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c19d));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c19e));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c19f));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c1a0));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c1a1));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c1a2));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c1a3));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c1a4));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c1a5));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c1a6));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c1a7));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c1a8));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c1a9));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c1aa));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c1ab));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c1ac));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c1ad));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c1ae));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c1af));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c1b0));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c1b1));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c1b2));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c1b3));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c1b4));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c1b5));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c1b6));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c1b7));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c1b8));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c1b9));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c1ba));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c1bb));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c1bc));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c1bd));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c1be));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c1bf));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c1c0));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c1c1));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c1c2));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c1c3));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c1c4));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c1c5));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c1c6));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c1c7));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c1c8));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c1c9));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c1ca));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c1cb));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c1cc));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c1cd));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c1ce));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c1cf));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c1d0));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c1d1));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c1d2));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c1d3));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c1d4));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c1d5));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c1d6));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c1d7));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c1d8));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c1d9));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c1da));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c1db));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c1dc));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c1dd));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c1de));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c1df));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c1e0));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c1e1));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c1e2));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c1e3));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c1e4));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c1e5));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c1e6));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c1e7));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c1e8));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c1e9));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c1ea));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c1eb));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c1ec));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c1ed));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c1ee));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c1ef));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c1f0));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c1f1));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c1f2));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c1f3));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c1f4));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c1f5));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c1f6));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c1f7));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c1f8));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c1f9));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c1fa));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c1fb));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c1fc));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c1fd));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c1fe));
                
                /// memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c1ff));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c200));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c201));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c202));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c203));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c204));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c205));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c206));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c207));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c208));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c209));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c20a));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c20b));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c20c));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c20d));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c20e));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c20f));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c210));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c211));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c212));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c213));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c214));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c215));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c216));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c217));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c218));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c219));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c21a));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c21b));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c21c));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c21d));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c21e));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c21f));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c220));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c221));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c222));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c223));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c224));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c225));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c226));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c227));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c228));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c229));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c22a));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c22b));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c22c));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c22d));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c22e));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c22f));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c230));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c231));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c232));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c233));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c234));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c235));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c236));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c237));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c238));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c239));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c23a));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c23b));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c23c));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c23d));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c23e));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c23f));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c240));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c241));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c242));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c243));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c244));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c245));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c246));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c247));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c248));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c249));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c24a));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c24b));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c24c));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c24d));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c24e));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c24f));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c250));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c251));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c252));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c253));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c254));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c255));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c256));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c257));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c258));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c259));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c25a));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c25b));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c25c));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c25d));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c25e));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c25f));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c260));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c261));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c262));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c263));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c264));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c265));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c266));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c267));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c268));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c269));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c26a));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c26b));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c26c));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c26d));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c26e));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c26f));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c270));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c271));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c272));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c273));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c274));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c275));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c276));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c277));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c278));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c279));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c27a));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c27b));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c27c));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c27d));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c27e));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c27f));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c280));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c281));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c282));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c283));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c284));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c285));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c286));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c287));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c288));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c289));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c28a));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c28b));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c28c));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c28d));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c28e));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c28f));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c290));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c291));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c292));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c293));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c294));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c295));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c296));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c297));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c298));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c299));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c29a));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c29b));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c29c));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c29d));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c29e));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c29f));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c2a0));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c2a1));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c2a2));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c2a3));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c2a4));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c2a5));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c2a6));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c2a7));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c2a8));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c2a9));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c2aa));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c2ab));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c2ac));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c2ad));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c2ae));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c2af));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c2b0));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c2b1));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c2b2));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c2b3));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c2b4));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c2b5));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c2b6));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c2b7));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c2b8));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c2b9));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c2ba));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c2bb));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c2bc));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c2bd));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c2be));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c2bf));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c2c0));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c2c1));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c2c2));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c2c3));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c2c4));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c2c5));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c2c6));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c2c7));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c2c8));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c2c9));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c2ca));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c2cb));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c2cc));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c2cd));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c2ce));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c2cf));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c2d0));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c2d1));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c2d2));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c2d3));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c2d4));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c2d5));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c2d6));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c2d7));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c2d8));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c2d9));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c2da));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c2db));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c2dc));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c2dd));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c2de));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c2df));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c2e0));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c2e1));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c2e2));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c2e3));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c2e4));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c2e5));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c2e6));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c2e7));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c2e8));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c2e9));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c2ea));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c2eb));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c2ec));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c2ed));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c2ee));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c2ef));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c2f0));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c2f1));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c2f2));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c2f3));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c2f4));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c2f5));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c2f6));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c2f7));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c2f8));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c2f9));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c2fa));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c2fb));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c2fc));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c2fd));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c2fe));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c2ff));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c300));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c301));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c302));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c303));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c304));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c305));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c306));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c307));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c308));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c309));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c30a));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c30b));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c30c));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c30d));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c30e));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c30f));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c310));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c311));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c312));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c313));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c314));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c315));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c316));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c317));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c318));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c319));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c31a));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c31b));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c31c));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c31d));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c31e));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c31f));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c320));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c321));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c322));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c323));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c324));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c325));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c326));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c327));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c328));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c329));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c32a));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c32b));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c32c));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c32d));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c32e));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c32f));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c330));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c331));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c332));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c333));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c334));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c335));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c336));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c337));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c338));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c339));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c33a));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c33b));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c33c));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c33d));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c33e));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c33f));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c340));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c341));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c342));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c343));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c344));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c345));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c346));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c347));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c348));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c349));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c34a));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c34b));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c34c));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c34d));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c34e));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c34f));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c350));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c351));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c352));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c353));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c354));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c355));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c356));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c357));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c358));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c359));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c35a));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c35b));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c35c));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c35d));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c35e));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c35f));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c360));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c361));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c362));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c363));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c364));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c365));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c366));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c367));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c368));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c369));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c36a));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c36b));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c36c));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c36d));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c36e));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c36f));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c370));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c371));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c372));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c373));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c374));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c375));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c376));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c377));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c378));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c379));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c37a));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c37b));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c37c));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c37d));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c37e));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c37f));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c380));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c381));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c382));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c383));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c384));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c385));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c386));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c387));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c388));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c389));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c38a));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c38b));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c38c));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c38d));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c38e));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c38f));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c390));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c391));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c392));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c393));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c394));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c395));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c396));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c397));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c398));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c399));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c39a));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c39b));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c39c));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c39d));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c39e));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c39f));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c3a0));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c3a1));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c3a2));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c3a3));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c3a4));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c3a5));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c3a6));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c3a7));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c3a8));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c3a9));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c3aa));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c3ab));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c3ac));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c3ad));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c3ae));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c3af));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c3b0));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c3b1));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c3b2));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c3b3));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c3b4));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c3b5));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c3b6));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c3b7));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c3b8));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c3b9));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c3ba));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c3bb));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c3bc));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c3bd));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c3be));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c3bf));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c3c0));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c3c1));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c3c2));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c3c3));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c3c4));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c3c5));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c3c6));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c3c7));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c3c8));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c3c9));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c3ca));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c3cb));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c3cc));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c3cd));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c3ce));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c3cf));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c3d0));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c3d1));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c3d2));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c3d3));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c3d4));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c3d5));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c3d6));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c3d7));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c3d8));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c3d9));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c3da));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c3db));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c3dc));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c3dd));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c3de));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c3df));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c3e0));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c3e1));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c3e2));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c3e3));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c3e4));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c3e5));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c3e6));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c3e7));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c3e8));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c3e9));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c3ea));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c3eb));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c3ec));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c3ed));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c3ee));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c3ef));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c3f0));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c3f1));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c3f2));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c3f3));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c3f4));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c3f5));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c3f6));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c3f7));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c3f8));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c3f9));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c3fa));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c3fb));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c3fc));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c3fd));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c3fe));
                
                /// memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c3ff));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c400));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c401));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c402));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c403));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c404));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c405));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c406));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c407));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c408));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c409));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c40a));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c40b));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c40c));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c40d));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c40e));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c40f));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c410));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c411));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c412));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c413));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c414));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c415));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c416));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c417));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c418));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c419));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c41a));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c41b));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c41c));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c41d));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c41e));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c41f));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c420));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c421));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c422));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c423));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c424));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c425));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c426));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c427));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c428));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c429));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c42a));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c42b));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c42c));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c42d));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c42e));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c42f));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c430));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c431));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c432));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c433));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c434));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c435));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c436));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c437));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c438));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c439));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c43a));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c43b));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c43c));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c43d));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c43e));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c43f));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c440));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c441));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c442));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c443));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c444));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c445));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c446));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c447));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c448));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c449));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c44a));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c44b));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c44c));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c44d));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c44e));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c44f));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c450));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c451));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c452));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c453));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c454));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c455));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c456));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c457));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c458));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c459));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c45a));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c45b));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c45c));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c45d));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c45e));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c45f));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c460));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c461));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c462));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c463));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c464));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c465));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c466));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c467));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c468));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c469));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c46a));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c46b));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c46c));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c46d));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c46e));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c46f));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c470));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c471));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c472));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c473));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c474));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c475));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c476));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c477));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c478));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c479));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c47a));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c47b));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c47c));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c47d));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c47e));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c47f));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c480));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c481));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c482));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c483));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c484));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c485));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c486));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c487));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c488));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c489));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c48a));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c48b));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c48c));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c48d));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c48e));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c48f));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c490));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c491));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c492));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c493));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c494));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c495));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c496));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c497));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c498));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c499));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c49a));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c49b));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c49c));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c49d));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c49e));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c49f));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c4a0));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c4a1));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c4a2));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c4a3));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c4a4));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c4a5));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c4a6));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c4a7));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c4a8));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c4a9));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c4aa));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c4ab));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c4ac));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c4ad));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c4ae));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c4af));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c4b0));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c4b1));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c4b2));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c4b3));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c4b4));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c4b5));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c4b6));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c4b7));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c4b8));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c4b9));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c4ba));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c4bb));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c4bc));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c4bd));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c4be));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c4bf));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c4c0));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c4c1));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c4c2));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c4c3));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c4c4));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c4c5));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c4c6));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c4c7));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c4c8));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c4c9));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c4ca));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c4cb));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c4cc));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c4cd));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c4ce));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c4cf));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c4d0));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c4d1));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c4d2));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c4d3));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c4d4));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c4d5));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c4d6));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c4d7));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c4d8));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c4d9));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c4da));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c4db));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c4dc));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c4dd));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c4de));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c4df));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c4e0));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c4e1));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c4e2));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c4e3));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c4e4));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c4e5));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c4e6));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c4e7));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c4e8));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c4e9));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c4ea));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c4eb));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c4ec));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c4ed));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c4ee));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c4ef));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c4f0));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c4f1));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c4f2));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c4f3));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c4f4));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c4f5));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c4f6));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c4f7));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c4f8));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c4f9));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c4fa));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c4fb));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c4fc));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c4fd));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c4fe));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c4ff));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c500));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c501));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c502));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c503));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c504));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c505));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c506));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c507));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c508));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c509));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c50a));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c50b));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c50c));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c50d));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c50e));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c50f));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c510));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c511));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c512));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c513));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c514));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c515));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c516));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c517));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c518));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c519));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c51a));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c51b));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c51c));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c51d));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c51e));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c51f));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c520));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c521));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c522));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c523));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c524));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c525));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c526));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c527));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c528));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c529));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c52a));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c52b));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c52c));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c52d));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c52e));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c52f));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c530));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c531));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c532));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c533));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c534));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c535));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c536));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c537));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c538));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c539));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c53a));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c53b));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c53c));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c53d));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c53e));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c53f));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c540));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c541));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c542));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c543));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c544));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c545));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c546));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c547));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c548));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c549));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c54a));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c54b));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c54c));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c54d));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c54e));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c54f));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c550));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c551));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c552));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c553));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c554));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c555));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c556));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c557));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c558));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c559));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c55a));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c55b));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c55c));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c55d));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c55e));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c55f));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c560));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c561));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c562));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c563));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c564));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c565));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c566));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c567));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c568));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c569));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c56a));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c56b));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c56c));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c56d));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c56e));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c56f));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c570));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c571));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c572));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c573));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c574));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c575));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c576));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c577));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c578));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c579));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c57a));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c57b));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c57c));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c57d));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c57e));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c57f));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c580));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c581));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c582));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c583));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c584));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c585));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c586));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c587));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c588));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c589));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c58a));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c58b));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c58c));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c58d));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c58e));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c58f));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c590));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c591));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c592));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c593));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c594));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c595));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c596));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c597));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c598));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c599));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c59a));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c59b));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c59c));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c59d));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c59e));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c59f));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c5a0));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c5a1));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c5a2));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c5a3));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c5a4));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c5a5));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c5a6));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c5a7));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c5a8));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c5a9));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c5aa));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c5ab));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c5ac));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c5ad));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c5ae));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c5af));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c5b0));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c5b1));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c5b2));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c5b3));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c5b4));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c5b5));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c5b6));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c5b7));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c5b8));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c5b9));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c5ba));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c5bb));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c5bc));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c5bd));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c5be));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c5bf));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c5c0));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c5c1));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c5c2));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c5c3));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c5c4));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c5c5));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c5c6));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c5c7));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c5c8));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c5c9));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c5ca));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c5cb));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c5cc));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c5cd));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c5ce));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c5cf));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c5d0));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c5d1));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c5d2));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c5d3));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c5d4));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c5d5));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c5d6));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c5d7));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c5d8));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c5d9));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c5da));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c5db));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c5dc));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c5dd));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c5de));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c5df));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c5e0));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c5e1));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c5e2));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c5e3));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c5e4));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c5e5));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c5e6));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c5e7));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c5e8));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c5e9));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c5ea));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c5eb));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c5ec));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c5ed));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c5ee));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c5ef));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c5f0));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c5f1));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c5f2));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c5f3));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c5f4));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c5f5));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c5f6));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c5f7));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c5f8));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c5f9));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c5fa));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c5fb));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c5fc));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c5fd));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c5fe));
                
                /// memory that stores Rb
                pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c5ff));
                
                /// memory that stores BOX
                pub const BOX_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c600));
                
                /// memory that stores BOX
                pub const BOX_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c601));
                
                /// memory that stores BOX
                pub const BOX_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c602));
                
                /// memory that stores BOX
                pub const BOX_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c603));
                
                /// memory that stores BOX
                pub const BOX_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c604));
                
                /// memory that stores BOX
                pub const BOX_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c605));
                
                /// memory that stores BOX
                pub const BOX_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c606));
                
                /// memory that stores BOX
                pub const BOX_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c607));
                
                /// memory that stores BOX
                pub const BOX_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c608));
                
                /// memory that stores BOX
                pub const BOX_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c609));
                
                /// memory that stores BOX
                pub const BOX_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c60a));
                
                /// memory that stores BOX
                pub const BOX_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c60b));
                
                /// memory that stores BOX
                pub const BOX_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c60c));
                
                /// memory that stores BOX
                pub const BOX_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c60d));
                
                /// memory that stores BOX
                pub const BOX_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c60e));
                
                /// memory that stores BOX
                pub const BOX_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c60f));
                
                /// memory that stores BOX
                pub const BOX_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c610));
                
                /// memory that stores BOX
                pub const BOX_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c611));
                
                /// memory that stores BOX
                pub const BOX_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c612));
                
                /// memory that stores BOX
                pub const BOX_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c613));
                
                /// memory that stores BOX
                pub const BOX_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c614));
                
                /// memory that stores BOX
                pub const BOX_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c615));
                
                /// memory that stores BOX
                pub const BOX_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c616));
                
                /// memory that stores BOX
                pub const BOX_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c617));
                
                /// memory that stores BOX
                pub const BOX_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c618));
                
                /// memory that stores BOX
                pub const BOX_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c619));
                
                /// memory that stores BOX
                pub const BOX_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c61a));
                
                /// memory that stores BOX
                pub const BOX_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c61b));
                
                /// memory that stores BOX
                pub const BOX_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c61c));
                
                /// memory that stores BOX
                pub const BOX_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c61d));
                
                /// memory that stores BOX
                pub const BOX_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c61e));
                
                /// memory that stores BOX
                pub const BOX_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c61f));
                
                /// memory that stores BOX
                pub const BOX_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c620));
                
                /// memory that stores BOX
                pub const BOX_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c621));
                
                /// memory that stores BOX
                pub const BOX_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c622));
                
                /// memory that stores BOX
                pub const BOX_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c623));
                
                /// memory that stores BOX
                pub const BOX_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c624));
                
                /// memory that stores BOX
                pub const BOX_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c625));
                
                /// memory that stores BOX
                pub const BOX_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c626));
                
                /// memory that stores BOX
                pub const BOX_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c627));
                
                /// memory that stores BOX
                pub const BOX_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c628));
                
                /// memory that stores BOX
                pub const BOX_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c629));
                
                /// memory that stores BOX
                pub const BOX_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c62a));
                
                /// memory that stores BOX
                pub const BOX_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c62b));
                
                /// memory that stores BOX
                pub const BOX_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c62c));
                
                /// memory that stores BOX
                pub const BOX_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c62d));
                
                /// memory that stores BOX
                pub const BOX_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c62e));
                
                /// memory that stores BOX
                pub const BOX_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c62f));
                
                /// memory that stores IV
                pub const IV_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c630));
                
                /// memory that stores IV
                pub const IV_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c631));
                
                /// memory that stores IV
                pub const IV_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c632));
                
                /// memory that stores IV
                pub const IV_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c633));
                
                /// memory that stores IV
                pub const IV_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c634));
                
                /// memory that stores IV
                pub const IV_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c635));
                
                /// memory that stores IV
                pub const IV_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c636));
                
                /// memory that stores IV
                pub const IV_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c637));
                
                /// memory that stores IV
                pub const IV_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c638));
                
                /// memory that stores IV
                pub const IV_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c639));
                
                /// memory that stores IV
                pub const IV_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c63a));
                
                /// memory that stores IV
                pub const IV_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c63b));
                
                /// memory that stores IV
                pub const IV_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c63c));
                
                /// memory that stores IV
                pub const IV_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c63d));
                
                /// memory that stores IV
                pub const IV_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c63e));
                
                /// memory that stores IV
                pub const IV_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c63f));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c800));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c801));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c802));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c803));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c804));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c805));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c806));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c807));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c808));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c809));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c80a));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c80b));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c80c));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c80d));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c80e));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c80f));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c810));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c811));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c812));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c813));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c814));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c815));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c816));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c817));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c818));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c819));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c81a));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c81b));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c81c));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c81d));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c81e));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c81f));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c820));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c821));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c822));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c823));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c824));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c825));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c826));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c827));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c828));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c829));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c82a));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c82b));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c82c));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c82d));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c82e));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c82f));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c830));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c831));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c832));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c833));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c834));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c835));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c836));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c837));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c838));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c839));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c83a));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c83b));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c83c));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c83d));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c83e));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c83f));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c840));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c841));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c842));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c843));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c844));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c845));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c846));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c847));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c848));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c849));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c84a));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c84b));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c84c));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c84d));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c84e));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c84f));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c850));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c851));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c852));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c853));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c854));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c855));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c856));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c857));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c858));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c859));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c85a));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c85b));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c85c));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c85d));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c85e));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c85f));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c860));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c861));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c862));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c863));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c864));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c865));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c866));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c867));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c868));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c869));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c86a));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c86b));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c86c));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c86d));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c86e));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c86f));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c870));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c871));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c872));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c873));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c874));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c875));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c876));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c877));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c878));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c879));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c87a));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c87b));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c87c));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c87d));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c87e));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c87f));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c880));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c881));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c882));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c883));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c884));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c885));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c886));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c887));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c888));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c889));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c88a));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c88b));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c88c));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c88d));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c88e));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c88f));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c890));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c891));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c892));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c893));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c894));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c895));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c896));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c897));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c898));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c899));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c89a));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c89b));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c89c));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c89d));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c89e));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c89f));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c8a0));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c8a1));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c8a2));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c8a3));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c8a4));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c8a5));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c8a6));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c8a7));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c8a8));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c8a9));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c8aa));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c8ab));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c8ac));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c8ad));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c8ae));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c8af));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c8b0));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c8b1));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c8b2));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c8b3));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c8b4));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c8b5));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c8b6));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c8b7));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c8b8));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c8b9));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c8ba));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c8bb));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c8bc));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c8bd));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c8be));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c8bf));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c8c0));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c8c1));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c8c2));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c8c3));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c8c4));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c8c5));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c8c6));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c8c7));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c8c8));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c8c9));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c8ca));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c8cb));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c8cc));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c8cd));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c8ce));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c8cf));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c8d0));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c8d1));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c8d2));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c8d3));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c8d4));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c8d5));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c8d6));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c8d7));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c8d8));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c8d9));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c8da));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c8db));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c8dc));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c8dd));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c8de));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c8df));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c8e0));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c8e1));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c8e2));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c8e3));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c8e4));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c8e5));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c8e6));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c8e7));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c8e8));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c8e9));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c8ea));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c8eb));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c8ec));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c8ed));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c8ee));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c8ef));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c8f0));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c8f1));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c8f2));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c8f3));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c8f4));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c8f5));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c8f6));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c8f7));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c8f8));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c8f9));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c8fa));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c8fb));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c8fc));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c8fd));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c8fe));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c8ff));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c900));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c901));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c902));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c903));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c904));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c905));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c906));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c907));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c908));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c909));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c90a));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c90b));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c90c));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c90d));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c90e));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c90f));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c910));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c911));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c912));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c913));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c914));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c915));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c916));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c917));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c918));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c919));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c91a));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c91b));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c91c));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c91d));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c91e));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c91f));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c920));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c921));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c922));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c923));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c924));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c925));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c926));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c927));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c928));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c929));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c92a));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c92b));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c92c));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c92d));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c92e));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c92f));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c930));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c931));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c932));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c933));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c934));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c935));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c936));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c937));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c938));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c939));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c93a));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c93b));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c93c));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c93d));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c93e));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c93f));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c940));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c941));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c942));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c943));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c944));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c945));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c946));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c947));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c948));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c949));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c94a));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c94b));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c94c));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c94d));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c94e));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c94f));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c950));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c951));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c952));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c953));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c954));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c955));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c956));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c957));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c958));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c959));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c95a));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c95b));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c95c));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c95d));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c95e));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c95f));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c960));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c961));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c962));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c963));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c964));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c965));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c966));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c967));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c968));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c969));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c96a));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c96b));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c96c));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c96d));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c96e));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c96f));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c970));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c971));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c972));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c973));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c974));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c975));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c976));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c977));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c978));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c979));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c97a));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c97b));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c97c));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c97d));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c97e));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c97f));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c980));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c981));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c982));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c983));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c984));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c985));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c986));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c987));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c988));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c989));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c98a));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c98b));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c98c));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c98d));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c98e));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c98f));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c990));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c991));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c992));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c993));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c994));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c995));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c996));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c997));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c998));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c999));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c99a));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c99b));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c99c));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c99d));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c99e));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c99f));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c9a0));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c9a1));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c9a2));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c9a3));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c9a4));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c9a5));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c9a6));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c9a7));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c9a8));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c9a9));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c9aa));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c9ab));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c9ac));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c9ad));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c9ae));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c9af));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c9b0));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c9b1));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c9b2));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c9b3));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c9b4));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c9b5));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c9b6));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c9b7));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c9b8));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c9b9));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c9ba));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c9bb));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c9bc));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c9bd));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c9be));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c9bf));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c9c0));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c9c1));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c9c2));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c9c3));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c9c4));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c9c5));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c9c6));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c9c7));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c9c8));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c9c9));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c9ca));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c9cb));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c9cc));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c9cd));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c9ce));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c9cf));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c9d0));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c9d1));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c9d2));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c9d3));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c9d4));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c9d5));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c9d6));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c9d7));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c9d8));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c9d9));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c9da));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c9db));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c9dc));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c9dd));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c9de));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c9df));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c9e0));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c9e1));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c9e2));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c9e3));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c9e4));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c9e5));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c9e6));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c9e7));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c9e8));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c9e9));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c9ea));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c9eb));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c9ec));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c9ed));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c9ee));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c9ef));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c9f0));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c9f1));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c9f2));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c9f3));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c9f4));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c9f5));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c9f6));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c9f7));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c9f8));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c9f9));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c9fa));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c9fb));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c9fc));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c9fd));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c9fe));
                
                /// memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008c9ff));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca00));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca01));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca02));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca03));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca04));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca05));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca06));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca07));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca08));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca09));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca0a));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca0b));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca0c));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca0d));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca0e));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca0f));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca10));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca11));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca12));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca13));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca14));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca15));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca16));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca17));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca18));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca19));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca1a));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca1b));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca1c));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca1d));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca1e));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca1f));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca20));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca21));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca22));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca23));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca24));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca25));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca26));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca27));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca28));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca29));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca2a));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca2b));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca2c));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca2d));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca2e));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca2f));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca30));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca31));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca32));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca33));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca34));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca35));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca36));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca37));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca38));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca39));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca3a));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca3b));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca3c));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca3d));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca3e));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca3f));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca40));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca41));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca42));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca43));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca44));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca45));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca46));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca47));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca48));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca49));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca4a));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca4b));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca4c));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca4d));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca4e));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca4f));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca50));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca51));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca52));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca53));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca54));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca55));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca56));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca57));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca58));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca59));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca5a));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca5b));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca5c));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca5d));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca5e));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca5f));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca60));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca61));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca62));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca63));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca64));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca65));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca66));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca67));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca68));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca69));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca6a));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca6b));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca6c));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca6d));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca6e));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca6f));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca70));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca71));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca72));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca73));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca74));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca75));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca76));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca77));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca78));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca79));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca7a));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca7b));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca7c));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca7d));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca7e));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca7f));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca80));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca81));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca82));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca83));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca84));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca85));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca86));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca87));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca88));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca89));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca8a));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca8b));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca8c));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca8d));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca8e));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca8f));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca90));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca91));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca92));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca93));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca94));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca95));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca96));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca97));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca98));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca99));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca9a));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca9b));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca9c));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca9d));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca9e));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008ca9f));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008caa0));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008caa1));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008caa2));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008caa3));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008caa4));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008caa5));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008caa6));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008caa7));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008caa8));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008caa9));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008caaa));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008caab));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008caac));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008caad));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008caae));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008caaf));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cab0));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cab1));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cab2));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cab3));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cab4));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cab5));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cab6));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cab7));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cab8));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cab9));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008caba));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cabb));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cabc));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cabd));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cabe));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cabf));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cac0));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cac1));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cac2));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cac3));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cac4));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cac5));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cac6));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cac7));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cac8));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cac9));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008caca));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cacb));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cacc));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cacd));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cace));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cacf));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cad0));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cad1));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cad2));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cad3));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cad4));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cad5));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cad6));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cad7));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cad8));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cad9));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cada));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cadb));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cadc));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cadd));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cade));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cadf));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cae0));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cae1));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cae2));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cae3));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cae4));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cae5));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cae6));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cae7));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cae8));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cae9));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008caea));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008caeb));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008caec));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008caed));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008caee));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008caef));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008caf0));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008caf1));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008caf2));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008caf3));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008caf4));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008caf5));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008caf6));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008caf7));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008caf8));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008caf9));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cafa));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cafb));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cafc));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cafd));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cafe));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008caff));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb00));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb01));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb02));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb03));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb04));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb05));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb06));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb07));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb08));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb09));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb0a));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb0b));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb0c));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb0d));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb0e));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb0f));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb10));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb11));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb12));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb13));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb14));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb15));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb16));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb17));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb18));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb19));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb1a));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb1b));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb1c));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb1d));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb1e));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb1f));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb20));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb21));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb22));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb23));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb24));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb25));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb26));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb27));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb28));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb29));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb2a));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb2b));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb2c));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb2d));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb2e));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb2f));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb30));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb31));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb32));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb33));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb34));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb35));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb36));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb37));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb38));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb39));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb3a));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb3b));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb3c));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb3d));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb3e));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb3f));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb40));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb41));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb42));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb43));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb44));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb45));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb46));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb47));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb48));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb49));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb4a));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb4b));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb4c));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb4d));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb4e));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb4f));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb50));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb51));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb52));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb53));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb54));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb55));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb56));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb57));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb58));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb59));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb5a));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb5b));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb5c));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb5d));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb5e));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb5f));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb60));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb61));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb62));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb63));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb64));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb65));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb66));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb67));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb68));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb69));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb6a));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb6b));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb6c));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb6d));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb6e));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb6f));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb70));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb71));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb72));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb73));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb74));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb75));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb76));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb77));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb78));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb79));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb7a));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb7b));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb7c));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb7d));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb7e));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb7f));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb80));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb81));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb82));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb83));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb84));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb85));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb86));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb87));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb88));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb89));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb8a));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb8b));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb8c));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb8d));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb8e));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb8f));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb90));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb91));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb92));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb93));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb94));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb95));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb96));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb97));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb98));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb99));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb9a));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb9b));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb9c));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb9d));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb9e));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cb9f));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cba0));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cba1));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cba2));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cba3));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cba4));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cba5));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cba6));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cba7));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cba8));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cba9));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cbaa));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cbab));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cbac));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cbad));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cbae));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cbaf));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cbb0));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cbb1));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cbb2));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cbb3));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cbb4));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cbb5));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cbb6));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cbb7));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cbb8));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cbb9));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cbba));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cbbb));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cbbc));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cbbd));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cbbe));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cbbf));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cbc0));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cbc1));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cbc2));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cbc3));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cbc4));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cbc5));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cbc6));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cbc7));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cbc8));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cbc9));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cbca));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cbcb));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cbcc));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cbcd));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cbce));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cbcf));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cbd0));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cbd1));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cbd2));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cbd3));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cbd4));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cbd5));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cbd6));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cbd7));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cbd8));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cbd9));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cbda));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cbdb));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cbdc));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cbdd));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cbde));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cbdf));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cbe0));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cbe1));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cbe2));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cbe3));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cbe4));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cbe5));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cbe6));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cbe7));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cbe8));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cbe9));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cbea));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cbeb));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cbec));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cbed));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cbee));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cbef));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cbf0));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cbf1));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cbf2));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cbf3));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cbf4));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cbf5));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cbf6));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cbf7));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cbf8));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cbf9));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cbfa));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cbfb));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cbfc));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cbfd));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cbfe));
                
                /// memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008cbff));
                
                /// DS start control register
                pub const SET_START = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] set this bit to start DS operation.
                    SET_START:  u1, 
                    
                    /// [1:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6008ce00));
                
                /// DS continue control register
                pub const SET_CONTINUE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] set this bit to continue DS operation.
                    SET_CONTINUE:  u1, 
                    
                    /// [1:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6008ce04));
                
                /// DS finish control register
                pub const SET_FINISH = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Set this bit to finish DS process.
                    SET_FINISH:  u1, 
                    
                    /// [1:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6008ce08));
                
                /// DS query busy register
                pub const QUERY_BUSY = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] digital signature state. 1'b0: idle, 1'b1: busy
                    QUERY_BUSY:  u1, 
                    
                    /// [1:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6008ce0c));
                
                /// DS query key-wrong counter register
                pub const QUERY_KEY_WRONG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:3] digital signature key wrong counter
                    QUERY_KEY_WRONG:  u4, 
                    
                    /// [4:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6008ce10));
                
                /// DS query check result register
                pub const QUERY_CHECK = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] MD checkout result. 1'b0: MD check pass, 1'b1: MD check fail
                    MD_ERROR:  u1, 
                    
                    /// [1:1] padding checkout result. 1'b0: a good padding, 1'b1: a bad padding
                    PADDING_BAD:  u1, 
                    
                    /// [2:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6008ce14));
                
                /// DS version control register
                pub const DATE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:29] ds version information
                    DATE:  u30, 
                    
                    /// [30:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6008ce20));
                
            };
            
            /// ECC (ECC Hardware Accelerator)
            pub const ECC = struct {
                
                /// ECC interrupt raw register, valid in level.
                pub const MULT_INT_RAW = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] The raw interrupt status bitfor the ecc_calc_done_int interrupt
                    CALC_DONE_INT_RAW:  u1, 
                    
                    /// [1:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6008b00c));
                
                /// ECC interrupt status register.
                pub const MULT_INT_ST = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] The masked interrupt status bitfor the ecc_calc_done_int interrupt
                    CALC_DONE_INT_ST:  u1, 
                    
                    /// [1:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6008b010));
                
                /// ECC interrupt enable register.
                pub const MULT_INT_ENA = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] The interrupt enable bitfor the ecc_calc_done_int interrupt
                    CALC_DONE_INT_ENA:  u1, 
                    
                    /// [1:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6008b014));
                
                /// ECC interrupt clear register.
                pub const MULT_INT_CLR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Set this bit to clear the ecc_calc_done_int interrupt
                    CALC_DONE_INT_CLR:  u1, 
                    
                    /// [1:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6008b018));
                
                /// ECC configure register
                pub const MULT_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Write 1 to start caculation of ECC Accelerator. This bit will be self-cleared after the caculatrion is done.
                    START:  u1, 
                    
                    /// [1:1] Write 1 to reset ECC Accelerator.
                    RESET:  u1, 
                    
                    /// [2:2] The key length mode bit of ECC Accelerator.0: P-192.1: P-256.
                    KEY_LENGTH:  u1, 
                    
                    /// [3:3] Reserved
                    SECURITY_MODE:  u1, 
                    
                    /// [4:4] Write 1 to force on register clock gate.
                    CLK_EN:  u1, 
                    
                    /// [5:7] The work mode bits of ECC Accelerator. 0: Point Mult Mode. 1: Division mode. 2: Point verification mode. 3: Point Verif+mult mode. 4: Jacobian Point Mult Mode. 5: Reserved. 6: Jacobian Point Verification Mode. 7: Point Verif + Jacobian Mult Mode.
                    WORK_MODE:  u3, 
                    
                    /// [8:8] The verification result bit of ECC Accelerator, only valid when calculation is done.
                    VERIFICATION_RESULT:  u1, 
                    
                    /// [9:30] 
                    res0:  u0, 
                    
                    /// [31:31] ECC memory clock gate force on register
                    MEM_CLOCK_GATE_FORCE_ON:  u1, 
                    
                }), @ptrFromInt(0x6008b01c));
                
                /// Version control register
                pub const MULT_DATE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:27] ECC mult version control register
                    DATE:  u28, 
                    
                    /// [28:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6008b0fc));
                
                /// The memory that stores k.
                pub const K_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008b100));
                
                /// The memory that stores k.
                pub const K_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008b101));
                
                /// The memory that stores k.
                pub const K_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008b102));
                
                /// The memory that stores k.
                pub const K_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008b103));
                
                /// The memory that stores k.
                pub const K_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008b104));
                
                /// The memory that stores k.
                pub const K_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008b105));
                
                /// The memory that stores k.
                pub const K_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008b106));
                
                /// The memory that stores k.
                pub const K_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008b107));
                
                /// The memory that stores k.
                pub const K_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008b108));
                
                /// The memory that stores k.
                pub const K_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008b109));
                
                /// The memory that stores k.
                pub const K_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008b10a));
                
                /// The memory that stores k.
                pub const K_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008b10b));
                
                /// The memory that stores k.
                pub const K_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008b10c));
                
                /// The memory that stores k.
                pub const K_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008b10d));
                
                /// The memory that stores k.
                pub const K_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008b10e));
                
                /// The memory that stores k.
                pub const K_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008b10f));
                
                /// The memory that stores k.
                pub const K_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008b110));
                
                /// The memory that stores k.
                pub const K_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008b111));
                
                /// The memory that stores k.
                pub const K_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008b112));
                
                /// The memory that stores k.
                pub const K_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008b113));
                
                /// The memory that stores k.
                pub const K_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008b114));
                
                /// The memory that stores k.
                pub const K_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008b115));
                
                /// The memory that stores k.
                pub const K_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008b116));
                
                /// The memory that stores k.
                pub const K_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008b117));
                
                /// The memory that stores k.
                pub const K_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008b118));
                
                /// The memory that stores k.
                pub const K_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008b119));
                
                /// The memory that stores k.
                pub const K_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008b11a));
                
                /// The memory that stores k.
                pub const K_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008b11b));
                
                /// The memory that stores k.
                pub const K_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008b11c));
                
                /// The memory that stores k.
                pub const K_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008b11d));
                
                /// The memory that stores k.
                pub const K_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008b11e));
                
                /// The memory that stores k.
                pub const K_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008b11f));
                
                /// The memory that stores Px.
                pub const PX_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008b120));
                
                /// The memory that stores Px.
                pub const PX_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008b121));
                
                /// The memory that stores Px.
                pub const PX_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008b122));
                
                /// The memory that stores Px.
                pub const PX_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008b123));
                
                /// The memory that stores Px.
                pub const PX_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008b124));
                
                /// The memory that stores Px.
                pub const PX_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008b125));
                
                /// The memory that stores Px.
                pub const PX_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008b126));
                
                /// The memory that stores Px.
                pub const PX_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008b127));
                
                /// The memory that stores Px.
                pub const PX_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008b128));
                
                /// The memory that stores Px.
                pub const PX_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008b129));
                
                /// The memory that stores Px.
                pub const PX_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008b12a));
                
                /// The memory that stores Px.
                pub const PX_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008b12b));
                
                /// The memory that stores Px.
                pub const PX_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008b12c));
                
                /// The memory that stores Px.
                pub const PX_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008b12d));
                
                /// The memory that stores Px.
                pub const PX_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008b12e));
                
                /// The memory that stores Px.
                pub const PX_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008b12f));
                
                /// The memory that stores Px.
                pub const PX_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008b130));
                
                /// The memory that stores Px.
                pub const PX_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008b131));
                
                /// The memory that stores Px.
                pub const PX_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008b132));
                
                /// The memory that stores Px.
                pub const PX_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008b133));
                
                /// The memory that stores Px.
                pub const PX_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008b134));
                
                /// The memory that stores Px.
                pub const PX_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008b135));
                
                /// The memory that stores Px.
                pub const PX_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008b136));
                
                /// The memory that stores Px.
                pub const PX_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008b137));
                
                /// The memory that stores Px.
                pub const PX_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008b138));
                
                /// The memory that stores Px.
                pub const PX_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008b139));
                
                /// The memory that stores Px.
                pub const PX_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008b13a));
                
                /// The memory that stores Px.
                pub const PX_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008b13b));
                
                /// The memory that stores Px.
                pub const PX_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008b13c));
                
                /// The memory that stores Px.
                pub const PX_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008b13d));
                
                /// The memory that stores Px.
                pub const PX_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008b13e));
                
                /// The memory that stores Px.
                pub const PX_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008b13f));
                
                /// The memory that stores Py.
                pub const PY_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008b140));
                
                /// The memory that stores Py.
                pub const PY_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008b141));
                
                /// The memory that stores Py.
                pub const PY_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008b142));
                
                /// The memory that stores Py.
                pub const PY_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008b143));
                
                /// The memory that stores Py.
                pub const PY_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008b144));
                
                /// The memory that stores Py.
                pub const PY_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008b145));
                
                /// The memory that stores Py.
                pub const PY_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008b146));
                
                /// The memory that stores Py.
                pub const PY_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008b147));
                
                /// The memory that stores Py.
                pub const PY_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008b148));
                
                /// The memory that stores Py.
                pub const PY_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008b149));
                
                /// The memory that stores Py.
                pub const PY_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008b14a));
                
                /// The memory that stores Py.
                pub const PY_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008b14b));
                
                /// The memory that stores Py.
                pub const PY_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008b14c));
                
                /// The memory that stores Py.
                pub const PY_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008b14d));
                
                /// The memory that stores Py.
                pub const PY_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008b14e));
                
                /// The memory that stores Py.
                pub const PY_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008b14f));
                
                /// The memory that stores Py.
                pub const PY_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008b150));
                
                /// The memory that stores Py.
                pub const PY_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008b151));
                
                /// The memory that stores Py.
                pub const PY_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008b152));
                
                /// The memory that stores Py.
                pub const PY_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008b153));
                
                /// The memory that stores Py.
                pub const PY_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008b154));
                
                /// The memory that stores Py.
                pub const PY_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008b155));
                
                /// The memory that stores Py.
                pub const PY_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008b156));
                
                /// The memory that stores Py.
                pub const PY_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008b157));
                
                /// The memory that stores Py.
                pub const PY_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008b158));
                
                /// The memory that stores Py.
                pub const PY_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008b159));
                
                /// The memory that stores Py.
                pub const PY_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008b15a));
                
                /// The memory that stores Py.
                pub const PY_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008b15b));
                
                /// The memory that stores Py.
                pub const PY_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008b15c));
                
                /// The memory that stores Py.
                pub const PY_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008b15d));
                
                /// The memory that stores Py.
                pub const PY_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008b15e));
                
                /// The memory that stores Py.
                pub const PY_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008b15f));
                
            };
            
            /// eFuse Controller
            pub const EFUSE = struct {
                
                /// Register 0 that stores data to be programmed.
                pub const PGM_DATA0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Configures the 0th 32-bit data to be programmed.
                    PGM_DATA_0:  u32, 
                    
                }), @ptrFromInt(0x600b0800));
                
                /// Register 1 that stores data to be programmed.
                pub const PGM_DATA1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Configures the 1st 32-bit data to be programmed.
                    PGM_DATA_1:  u32, 
                    
                }), @ptrFromInt(0x600b0804));
                
                /// Register 2 that stores data to be programmed.
                pub const PGM_DATA2 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Configures the 2nd 32-bit data to be programmed.
                    PGM_DATA_2:  u32, 
                    
                }), @ptrFromInt(0x600b0808));
                
                /// Register 3 that stores data to be programmed.
                pub const PGM_DATA3 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Configures the 3rd 32-bit data to be programmed.
                    PGM_DATA_3:  u32, 
                    
                }), @ptrFromInt(0x600b080c));
                
                /// Register 4 that stores data to be programmed.
                pub const PGM_DATA4 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Configures the 4th 32-bit data to be programmed.
                    PGM_DATA_4:  u32, 
                    
                }), @ptrFromInt(0x600b0810));
                
                /// Register 5 that stores data to be programmed.
                pub const PGM_DATA5 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Configures the 5th 32-bit data to be programmed.
                    PGM_DATA_5:  u32, 
                    
                }), @ptrFromInt(0x600b0814));
                
                /// Register 6 that stores data to be programmed.
                pub const PGM_DATA6 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Configures the 6th 32-bit data to be programmed.
                    PGM_DATA_6:  u32, 
                    
                }), @ptrFromInt(0x600b0818));
                
                /// Register 7 that stores data to be programmed.
                pub const PGM_DATA7 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Configures the 7th 32-bit data to be programmed.
                    PGM_DATA_7:  u32, 
                    
                }), @ptrFromInt(0x600b081c));
                
                /// Register 0 that stores the RS code to be programmed.
                pub const PGM_CHECK_VALUE0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Configures the 0th 32-bit RS code to be programmed.
                    PGM_RS_DATA_0:  u32, 
                    
                }), @ptrFromInt(0x600b0820));
                
                /// Register 1 that stores the RS code to be programmed.
                pub const PGM_CHECK_VALUE1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Configures the 1st 32-bit RS code to be programmed.
                    PGM_RS_DATA_1:  u32, 
                    
                }), @ptrFromInt(0x600b0824));
                
                /// Register 2 that stores the RS code to be programmed.
                pub const PGM_CHECK_VALUE2 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Configures the 2nd 32-bit RS code to be programmed.
                    PGM_RS_DATA_2:  u32, 
                    
                }), @ptrFromInt(0x600b0828));
                
                /// BLOCK0 data register 0.
                pub const RD_WR_DIS = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Represents whether programming of individual eFuse memory bit is disabled or enabled. 1: Disabled. 0 Enabled.
                    WR_DIS:  u32, 
                    
                }), @ptrFromInt(0x600b082c));
                
                /// BLOCK0 data register 1.
                pub const RD_REPEAT_DATA0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:6] Represents whether reading of individual eFuse block(block4~block10) is disabled or enabled. 1: disabled. 0: enabled.
                    RD_DIS:  u7, 
                    
                    /// [7:7] Represents whether pad of uart and sdio is swapped or not. 1: swapped. 0: not swapped.
                    SWAP_UART_SDIO_EN:  u1, 
                    
                    /// [8:8] Represents whether icache is disabled or enabled. 1: disabled. 0: enabled.
                    DIS_ICACHE:  u1, 
                    
                    /// [9:9] Represents whether the function of usb switch to jtag is disabled or enabled. 1: disabled. 0: enabled.
                    DIS_USB_JTAG:  u1, 
                    
                    /// [10:10] Represents whether icache is disabled or enabled in Download mode. 1: disabled. 0: enabled.
                    DIS_DOWNLOAD_ICACHE:  u1, 
                    
                    /// [11:11] Represents whether USB-Serial-JTAG is disabled or enabled. 1: disabled. 0: enabled.
                    DIS_USB_SERIAL_JTAG:  u1, 
                    
                    /// [12:12] Represents whether the function that forces chip into download mode is disabled or enabled. 1: disabled. 0: enabled.
                    DIS_FORCE_DOWNLOAD:  u1, 
                    
                    /// [13:13] Represents whether SPI0 controller during boot_mode_download is disabled or enabled. 1: disabled. 0: enabled.
                    SPI_DOWNLOAD_MSPI_DIS:  u1, 
                    
                    /// [14:14] Represents whether TWAI function is disabled or enabled. 1: disabled. 0: enabled.
                    DIS_CAN:  u1, 
                    
                    /// [15:15] Represents whether the selection between usb_to_jtag and pad_to_jtag through strapping gpio15 when both EFUSE_DIS_PAD_JTAG and EFUSE_DIS_USB_JTAG are equal to 0 is enabled or disabled. 1: enabled. 0: disabled.
                    JTAG_SEL_ENABLE:  u1, 
                    
                    /// [16:18] Represents whether JTAG is disabled in soft way. Odd number: disabled. Even number: enabled.
                    SOFT_DIS_JTAG:  u3, 
                    
                    /// [19:19] Represents whether JTAG is disabled in the hard way(permanently). 1: disabled. 0: enabled.
                    DIS_PAD_JTAG:  u1, 
                    
                    /// [20:20] Represents whether flash encrypt function is disabled or enabled(except in SPI boot mode). 1: disabled. 0: enabled.
                    DIS_DOWNLOAD_MANUAL_ENCRYPT:  u1, 
                    
                    /// [21:22] Represents the single-end input threhold vrefh, 1.76 V to 2 V with step of 80 mV.
                    USB_DREFH:  u2, 
                    
                    /// [23:24] Represents the single-end input threhold vrefl, 1.76 V to 2 V with step of 80 mV.
                    USB_DREFL:  u2, 
                    
                    /// [25:25] Represents whether the D+ and D- pins is exchanged. 1: exchanged. 0: not exchanged.
                    USB_EXCHG_PINS:  u1, 
                    
                    /// [26:26] Represents whether vdd spi pin is functioned as gpio. 1: functioned. 0: not functioned.
                    VDD_SPI_AS_GPIO:  u1, 
                    
                    /// [27:28] Reserved.
                    RPT4_RESERVED0_2:  u2, 
                    
                    /// [29:29] Reserved.
                    RPT4_RESERVED0_1:  u1, 
                    
                    /// [30:31] Reserved.
                    RPT4_RESERVED0_0:  u2, 
                    
                }), @ptrFromInt(0x600b0830));
                
                /// BLOCK0 data register 2.
                pub const RD_REPEAT_DATA1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:15] Reserved.
                    RPT4_RESERVED1_0:  u16, 
                    
                    /// [16:17] Represents whether RTC watchdog timeout threshold is selected at startup. 1: selected. 0: not selected.
                    WDT_DELAY_SEL:  u2, 
                    
                    /// [18:20] Represents whether SPI boot encrypt/decrypt is disabled or enabled. Odd number of 1: enabled. Even number of 1: disabled.
                    SPI_BOOT_CRYPT_CNT:  u3, 
                    
                    /// [21:21] Represents whether revoking first secure boot key is enabled or disabled. 1: enabled. 0: disabled.
                    SECURE_BOOT_KEY_REVOKE0:  u1, 
                    
                    /// [22:22] Represents whether revoking second secure boot key is enabled or disabled. 1: enabled. 0: disabled.
                    SECURE_BOOT_KEY_REVOKE1:  u1, 
                    
                    /// [23:23] Represents whether revoking third secure boot key is enabled or disabled. 1: enabled. 0: disabled.
                    SECURE_BOOT_KEY_REVOKE2:  u1, 
                    
                    /// [24:27] Represents the purpose of Key0.
                    KEY_PURPOSE_0:  u4, 
                    
                    /// [28:31] Represents the purpose of Key1.
                    KEY_PURPOSE_1:  u4, 
                    
                }), @ptrFromInt(0x600b0834));
                
                /// BLOCK0 data register 3.
                pub const RD_REPEAT_DATA2 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:3] Represents the purpose of Key2.
                    KEY_PURPOSE_2:  u4, 
                    
                    /// [4:7] Represents the purpose of Key3.
                    KEY_PURPOSE_3:  u4, 
                    
                    /// [8:11] Represents the purpose of Key4.
                    KEY_PURPOSE_4:  u4, 
                    
                    /// [12:15] Represents the purpose of Key5.
                    KEY_PURPOSE_5:  u4, 
                    
                    /// [16:17] Represents the spa secure level by configuring the clock random divide mode.
                    DPA_SEC_LEVEL:  u2, 
                    
                    /// [18:18] Reserved.
                    RPT4_RESERVED2_1:  u1, 
                    
                    /// [19:19] Represents whether anti-dpa attack is enabled. 1:enabled. 0: disabled.
                    CRYPT_DPA_ENABLE:  u1, 
                    
                    /// [20:20] Represents whether secure boot is enabled or disabled. 1: enabled. 0: disabled.
                    SECURE_BOOT_EN:  u1, 
                    
                    /// [21:21] Represents whether revoking aggressive secure boot is enabled or disabled. 1: enabled. 0: disabled.
                    SECURE_BOOT_AGGRESSIVE_REVOKE:  u1, 
                    
                    /// [22:27] Reserved.
                    RPT4_RESERVED2_0:  u6, 
                    
                    /// [28:31] Represents the flash waiting time after power-up, in unit of ms. When the value less than 15, the waiting time is the programmed value. Otherwise, the waiting time is 2 times the programmed value.
                    FLASH_TPUW:  u4, 
                    
                }), @ptrFromInt(0x600b0838));
                
                /// BLOCK0 data register 4.
                pub const RD_REPEAT_DATA3 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Represents whether Download mode is disabled or enabled. 1: disabled. 0: enabled.
                    DIS_DOWNLOAD_MODE:  u1, 
                    
                    /// [1:1] Represents whether direct boot mode is disabled or enabled. 1: disabled. 0: enabled.
                    DIS_DIRECT_BOOT:  u1, 
                    
                    /// [2:2] Represents whether print from USB-Serial-JTAG is disabled or enabled. 1: disabled. 0: enabled.
                    DIS_USB_PRINT:  u1, 
                    
                    /// [3:3] Reserved.
                    RPT4_RESERVED3_5:  u1, 
                    
                    /// [4:4] Represents whether the USB-Serial-JTAG download function is disabled or enabled. 1: disabled. 0: enabled.
                    DIS_USB_SERIAL_JTAG_DOWNLOAD_MODE:  u1, 
                    
                    /// [5:5] Represents whether security download is enabled or disabled. 1: enabled. 0: disabled.
                    ENABLE_SECURITY_DOWNLOAD:  u1, 
                    
                    /// [6:7] Represents the type of UART printing. 00: force enable printing. 01: enable printing when GPIO8 is reset at low level. 10: enable printing when GPIO8 is reset at high level. 11: force disable printing.
                    UART_PRINT_CONTROL:  u2, 
                    
                    /// [8:8] Reserved.
                    RPT4_RESERVED3_4:  u1, 
                    
                    /// [9:9] Reserved.
                    RPT4_RESERVED3_3:  u1, 
                    
                    /// [10:11] Reserved.
                    RPT4_RESERVED3_2:  u2, 
                    
                    /// [12:12] Reserved.
                    RPT4_RESERVED3_1:  u1, 
                    
                    /// [13:13] Represents whether ROM code is forced to send a resume command during SPI boot. 1: forced. 0:not forced.
                    FORCE_SEND_RESUME:  u1, 
                    
                    /// [14:29] Represents the version used by ESP-IDF anti-rollback feature.
                    SECURE_VERSION:  u16, 
                    
                    /// [30:30] Represents whether FAST VERIFY ON WAKE is disabled or enabled when Secure Boot is enabled. 1: disabled. 0: enabled.
                    SECURE_BOOT_DISABLE_FAST_WAKE:  u1, 
                    
                    /// [31:31] Reserved.
                    RPT4_RESERVED3_0:  u1, 
                    
                }), @ptrFromInt(0x600b083c));
                
                /// BLOCK0 data register 5.
                pub const RD_REPEAT_DATA4 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:23] Reserved.
                    RPT4_RESERVED4_1:  u24, 
                    
                    /// [24:31] Reserved.
                    RPT4_RESERVED4_0:  u8, 
                    
                }), @ptrFromInt(0x600b0840));
                
                /// BLOCK1 data register $n.
                pub const RD_MAC_SPI_SYS_0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Stores the low 32 bits of MAC address.
                    MAC_0:  u32, 
                    
                }), @ptrFromInt(0x600b0844));
                
                /// BLOCK1 data register $n.
                pub const RD_MAC_SPI_SYS_1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:15] Stores the high 16 bits of MAC address.
                    MAC_1:  u16, 
                    
                    /// [16:31] Stores the extended bits of MAC address.
                    MAC_EXT:  u16, 
                    
                }), @ptrFromInt(0x600b0848));
                
                /// BLOCK1 data register $n.
                pub const RD_MAC_SPI_SYS_2 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:13] Reserved.
                    MAC_SPI_RESERVED:  u14, 
                    
                    /// [14:31] Stores the first part of SPI_PAD_CONF.
                    SPI_PAD_CONF_1:  u18, 
                    
                }), @ptrFromInt(0x600b084c));
                
                /// BLOCK1 data register $n.
                pub const RD_MAC_SPI_SYS_3 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:17] Stores the second part of SPI_PAD_CONF.
                    SPI_PAD_CONF_2:  u18, 
                    
                    /// [18:31] Stores the first 14 bits of the zeroth part of system data.
                    SYS_DATA_PART0_0:  u14, 
                    
                }), @ptrFromInt(0x600b0850));
                
                /// BLOCK1 data register $n.
                pub const RD_MAC_SPI_SYS_4 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Stores the first 32 bits of the zeroth part of system data.
                    SYS_DATA_PART0_1:  u32, 
                    
                }), @ptrFromInt(0x600b0854));
                
                /// BLOCK1 data register $n.
                pub const RD_MAC_SPI_SYS_5 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Stores the second 32 bits of the zeroth part of system data.
                    SYS_DATA_PART0_2:  u32, 
                    
                }), @ptrFromInt(0x600b0858));
                
                /// Register $n of BLOCK2 (system).
                pub const RD_SYS_PART1_DATA0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Stores the zeroth 32 bits of the first part of system data.
                    SYS_DATA_PART1_0:  u32, 
                    
                }), @ptrFromInt(0x600b085c));
                
                /// Register $n of BLOCK2 (system).
                pub const RD_SYS_PART1_DATA1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Stores the first 32 bits of the first part of system data.
                    SYS_DATA_PART1_1:  u32, 
                    
                }), @ptrFromInt(0x600b0860));
                
                /// Register $n of BLOCK2 (system).
                pub const RD_SYS_PART1_DATA2 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Stores the second 32 bits of the first part of system data.
                    SYS_DATA_PART1_2:  u32, 
                    
                }), @ptrFromInt(0x600b0864));
                
                /// Register $n of BLOCK2 (system).
                pub const RD_SYS_PART1_DATA3 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Stores the third 32 bits of the first part of system data.
                    SYS_DATA_PART1_3:  u32, 
                    
                }), @ptrFromInt(0x600b0868));
                
                /// Register $n of BLOCK2 (system).
                pub const RD_SYS_PART1_DATA4 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Stores the fourth 32 bits of the first part of system data.
                    SYS_DATA_PART1_4:  u32, 
                    
                }), @ptrFromInt(0x600b086c));
                
                /// Register $n of BLOCK2 (system).
                pub const RD_SYS_PART1_DATA5 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Stores the fifth 32 bits of the first part of system data.
                    SYS_DATA_PART1_5:  u32, 
                    
                }), @ptrFromInt(0x600b0870));
                
                /// Register $n of BLOCK2 (system).
                pub const RD_SYS_PART1_DATA6 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Stores the sixth 32 bits of the first part of system data.
                    SYS_DATA_PART1_6:  u32, 
                    
                }), @ptrFromInt(0x600b0874));
                
                /// Register $n of BLOCK2 (system).
                pub const RD_SYS_PART1_DATA7 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Stores the seventh 32 bits of the first part of system data.
                    SYS_DATA_PART1_7:  u32, 
                    
                }), @ptrFromInt(0x600b0878));
                
                /// Register $n of BLOCK3 (user).
                pub const RD_USR_DATA0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Stores the zeroth 32 bits of BLOCK3 (user).
                    USR_DATA0:  u32, 
                    
                }), @ptrFromInt(0x600b087c));
                
                /// Register $n of BLOCK3 (user).
                pub const RD_USR_DATA1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Stores the first 32 bits of BLOCK3 (user).
                    USR_DATA1:  u32, 
                    
                }), @ptrFromInt(0x600b0880));
                
                /// Register $n of BLOCK3 (user).
                pub const RD_USR_DATA2 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Stores the second 32 bits of BLOCK3 (user).
                    USR_DATA2:  u32, 
                    
                }), @ptrFromInt(0x600b0884));
                
                /// Register $n of BLOCK3 (user).
                pub const RD_USR_DATA3 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Stores the third 32 bits of BLOCK3 (user).
                    USR_DATA3:  u32, 
                    
                }), @ptrFromInt(0x600b0888));
                
                /// Register $n of BLOCK3 (user).
                pub const RD_USR_DATA4 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Stores the fourth 32 bits of BLOCK3 (user).
                    USR_DATA4:  u32, 
                    
                }), @ptrFromInt(0x600b088c));
                
                /// Register $n of BLOCK3 (user).
                pub const RD_USR_DATA5 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Stores the fifth 32 bits of BLOCK3 (user).
                    USR_DATA5:  u32, 
                    
                }), @ptrFromInt(0x600b0890));
                
                /// Register $n of BLOCK3 (user).
                pub const RD_USR_DATA6 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Stores the sixth 32 bits of BLOCK3 (user).
                    USR_DATA6:  u32, 
                    
                }), @ptrFromInt(0x600b0894));
                
                /// Register $n of BLOCK3 (user).
                pub const RD_USR_DATA7 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Stores the seventh 32 bits of BLOCK3 (user).
                    USR_DATA7:  u32, 
                    
                }), @ptrFromInt(0x600b0898));
                
                /// Register $n of BLOCK4 (KEY0).
                pub const RD_KEY0_DATA0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Stores the zeroth 32 bits of KEY0.
                    KEY0_DATA0:  u32, 
                    
                }), @ptrFromInt(0x600b089c));
                
                /// Register $n of BLOCK4 (KEY0).
                pub const RD_KEY0_DATA1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Stores the first 32 bits of KEY0.
                    KEY0_DATA1:  u32, 
                    
                }), @ptrFromInt(0x600b08a0));
                
                /// Register $n of BLOCK4 (KEY0).
                pub const RD_KEY0_DATA2 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Stores the second 32 bits of KEY0.
                    KEY0_DATA2:  u32, 
                    
                }), @ptrFromInt(0x600b08a4));
                
                /// Register $n of BLOCK4 (KEY0).
                pub const RD_KEY0_DATA3 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Stores the third 32 bits of KEY0.
                    KEY0_DATA3:  u32, 
                    
                }), @ptrFromInt(0x600b08a8));
                
                /// Register $n of BLOCK4 (KEY0).
                pub const RD_KEY0_DATA4 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Stores the fourth 32 bits of KEY0.
                    KEY0_DATA4:  u32, 
                    
                }), @ptrFromInt(0x600b08ac));
                
                /// Register $n of BLOCK4 (KEY0).
                pub const RD_KEY0_DATA5 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Stores the fifth 32 bits of KEY0.
                    KEY0_DATA5:  u32, 
                    
                }), @ptrFromInt(0x600b08b0));
                
                /// Register $n of BLOCK4 (KEY0).
                pub const RD_KEY0_DATA6 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Stores the sixth 32 bits of KEY0.
                    KEY0_DATA6:  u32, 
                    
                }), @ptrFromInt(0x600b08b4));
                
                /// Register $n of BLOCK4 (KEY0).
                pub const RD_KEY0_DATA7 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Stores the seventh 32 bits of KEY0.
                    KEY0_DATA7:  u32, 
                    
                }), @ptrFromInt(0x600b08b8));
                
                /// Register $n of BLOCK5 (KEY1).
                pub const RD_KEY1_DATA0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Stores the zeroth 32 bits of KEY1.
                    KEY1_DATA0:  u32, 
                    
                }), @ptrFromInt(0x600b08bc));
                
                /// Register $n of BLOCK5 (KEY1).
                pub const RD_KEY1_DATA1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Stores the first 32 bits of KEY1.
                    KEY1_DATA1:  u32, 
                    
                }), @ptrFromInt(0x600b08c0));
                
                /// Register $n of BLOCK5 (KEY1).
                pub const RD_KEY1_DATA2 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Stores the second 32 bits of KEY1.
                    KEY1_DATA2:  u32, 
                    
                }), @ptrFromInt(0x600b08c4));
                
                /// Register $n of BLOCK5 (KEY1).
                pub const RD_KEY1_DATA3 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Stores the third 32 bits of KEY1.
                    KEY1_DATA3:  u32, 
                    
                }), @ptrFromInt(0x600b08c8));
                
                /// Register $n of BLOCK5 (KEY1).
                pub const RD_KEY1_DATA4 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Stores the fourth 32 bits of KEY1.
                    KEY1_DATA4:  u32, 
                    
                }), @ptrFromInt(0x600b08cc));
                
                /// Register $n of BLOCK5 (KEY1).
                pub const RD_KEY1_DATA5 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Stores the fifth 32 bits of KEY1.
                    KEY1_DATA5:  u32, 
                    
                }), @ptrFromInt(0x600b08d0));
                
                /// Register $n of BLOCK5 (KEY1).
                pub const RD_KEY1_DATA6 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Stores the sixth 32 bits of KEY1.
                    KEY1_DATA6:  u32, 
                    
                }), @ptrFromInt(0x600b08d4));
                
                /// Register $n of BLOCK5 (KEY1).
                pub const RD_KEY1_DATA7 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Stores the seventh 32 bits of KEY1.
                    KEY1_DATA7:  u32, 
                    
                }), @ptrFromInt(0x600b08d8));
                
                /// Register $n of BLOCK6 (KEY2).
                pub const RD_KEY2_DATA0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Stores the zeroth 32 bits of KEY2.
                    KEY2_DATA0:  u32, 
                    
                }), @ptrFromInt(0x600b08dc));
                
                /// Register $n of BLOCK6 (KEY2).
                pub const RD_KEY2_DATA1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Stores the first 32 bits of KEY2.
                    KEY2_DATA1:  u32, 
                    
                }), @ptrFromInt(0x600b08e0));
                
                /// Register $n of BLOCK6 (KEY2).
                pub const RD_KEY2_DATA2 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Stores the second 32 bits of KEY2.
                    KEY2_DATA2:  u32, 
                    
                }), @ptrFromInt(0x600b08e4));
                
                /// Register $n of BLOCK6 (KEY2).
                pub const RD_KEY2_DATA3 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Stores the third 32 bits of KEY2.
                    KEY2_DATA3:  u32, 
                    
                }), @ptrFromInt(0x600b08e8));
                
                /// Register $n of BLOCK6 (KEY2).
                pub const RD_KEY2_DATA4 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Stores the fourth 32 bits of KEY2.
                    KEY2_DATA4:  u32, 
                    
                }), @ptrFromInt(0x600b08ec));
                
                /// Register $n of BLOCK6 (KEY2).
                pub const RD_KEY2_DATA5 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Stores the fifth 32 bits of KEY2.
                    KEY2_DATA5:  u32, 
                    
                }), @ptrFromInt(0x600b08f0));
                
                /// Register $n of BLOCK6 (KEY2).
                pub const RD_KEY2_DATA6 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Stores the sixth 32 bits of KEY2.
                    KEY2_DATA6:  u32, 
                    
                }), @ptrFromInt(0x600b08f4));
                
                /// Register $n of BLOCK6 (KEY2).
                pub const RD_KEY2_DATA7 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Stores the seventh 32 bits of KEY2.
                    KEY2_DATA7:  u32, 
                    
                }), @ptrFromInt(0x600b08f8));
                
                /// Register $n of BLOCK7 (KEY3).
                pub const RD_KEY3_DATA0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Stores the zeroth 32 bits of KEY3.
                    KEY3_DATA0:  u32, 
                    
                }), @ptrFromInt(0x600b08fc));
                
                /// Register $n of BLOCK7 (KEY3).
                pub const RD_KEY3_DATA1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Stores the first 32 bits of KEY3.
                    KEY3_DATA1:  u32, 
                    
                }), @ptrFromInt(0x600b0900));
                
                /// Register $n of BLOCK7 (KEY3).
                pub const RD_KEY3_DATA2 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Stores the second 32 bits of KEY3.
                    KEY3_DATA2:  u32, 
                    
                }), @ptrFromInt(0x600b0904));
                
                /// Register $n of BLOCK7 (KEY3).
                pub const RD_KEY3_DATA3 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Stores the third 32 bits of KEY3.
                    KEY3_DATA3:  u32, 
                    
                }), @ptrFromInt(0x600b0908));
                
                /// Register $n of BLOCK7 (KEY3).
                pub const RD_KEY3_DATA4 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Stores the fourth 32 bits of KEY3.
                    KEY3_DATA4:  u32, 
                    
                }), @ptrFromInt(0x600b090c));
                
                /// Register $n of BLOCK7 (KEY3).
                pub const RD_KEY3_DATA5 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Stores the fifth 32 bits of KEY3.
                    KEY3_DATA5:  u32, 
                    
                }), @ptrFromInt(0x600b0910));
                
                /// Register $n of BLOCK7 (KEY3).
                pub const RD_KEY3_DATA6 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Stores the sixth 32 bits of KEY3.
                    KEY3_DATA6:  u32, 
                    
                }), @ptrFromInt(0x600b0914));
                
                /// Register $n of BLOCK7 (KEY3).
                pub const RD_KEY3_DATA7 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Stores the seventh 32 bits of KEY3.
                    KEY3_DATA7:  u32, 
                    
                }), @ptrFromInt(0x600b0918));
                
                /// Register $n of BLOCK8 (KEY4).
                pub const RD_KEY4_DATA0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Stores the zeroth 32 bits of KEY4.
                    KEY4_DATA0:  u32, 
                    
                }), @ptrFromInt(0x600b091c));
                
                /// Register $n of BLOCK8 (KEY4).
                pub const RD_KEY4_DATA1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Stores the first 32 bits of KEY4.
                    KEY4_DATA1:  u32, 
                    
                }), @ptrFromInt(0x600b0920));
                
                /// Register $n of BLOCK8 (KEY4).
                pub const RD_KEY4_DATA2 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Stores the second 32 bits of KEY4.
                    KEY4_DATA2:  u32, 
                    
                }), @ptrFromInt(0x600b0924));
                
                /// Register $n of BLOCK8 (KEY4).
                pub const RD_KEY4_DATA3 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Stores the third 32 bits of KEY4.
                    KEY4_DATA3:  u32, 
                    
                }), @ptrFromInt(0x600b0928));
                
                /// Register $n of BLOCK8 (KEY4).
                pub const RD_KEY4_DATA4 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Stores the fourth 32 bits of KEY4.
                    KEY4_DATA4:  u32, 
                    
                }), @ptrFromInt(0x600b092c));
                
                /// Register $n of BLOCK8 (KEY4).
                pub const RD_KEY4_DATA5 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Stores the fifth 32 bits of KEY4.
                    KEY4_DATA5:  u32, 
                    
                }), @ptrFromInt(0x600b0930));
                
                /// Register $n of BLOCK8 (KEY4).
                pub const RD_KEY4_DATA6 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Stores the sixth 32 bits of KEY4.
                    KEY4_DATA6:  u32, 
                    
                }), @ptrFromInt(0x600b0934));
                
                /// Register $n of BLOCK8 (KEY4).
                pub const RD_KEY4_DATA7 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Stores the seventh 32 bits of KEY4.
                    KEY4_DATA7:  u32, 
                    
                }), @ptrFromInt(0x600b0938));
                
                /// Register $n of BLOCK9 (KEY5).
                pub const RD_KEY5_DATA0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Stores the zeroth 32 bits of KEY5.
                    KEY5_DATA0:  u32, 
                    
                }), @ptrFromInt(0x600b093c));
                
                /// Register $n of BLOCK9 (KEY5).
                pub const RD_KEY5_DATA1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Stores the first 32 bits of KEY5.
                    KEY5_DATA1:  u32, 
                    
                }), @ptrFromInt(0x600b0940));
                
                /// Register $n of BLOCK9 (KEY5).
                pub const RD_KEY5_DATA2 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Stores the second 32 bits of KEY5.
                    KEY5_DATA2:  u32, 
                    
                }), @ptrFromInt(0x600b0944));
                
                /// Register $n of BLOCK9 (KEY5).
                pub const RD_KEY5_DATA3 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Stores the third 32 bits of KEY5.
                    KEY5_DATA3:  u32, 
                    
                }), @ptrFromInt(0x600b0948));
                
                /// Register $n of BLOCK9 (KEY5).
                pub const RD_KEY5_DATA4 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Stores the fourth 32 bits of KEY5.
                    KEY5_DATA4:  u32, 
                    
                }), @ptrFromInt(0x600b094c));
                
                /// Register $n of BLOCK9 (KEY5).
                pub const RD_KEY5_DATA5 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Stores the fifth 32 bits of KEY5.
                    KEY5_DATA5:  u32, 
                    
                }), @ptrFromInt(0x600b0950));
                
                /// Register $n of BLOCK9 (KEY5).
                pub const RD_KEY5_DATA6 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Stores the sixth 32 bits of KEY5.
                    KEY5_DATA6:  u32, 
                    
                }), @ptrFromInt(0x600b0954));
                
                /// Register $n of BLOCK9 (KEY5).
                pub const RD_KEY5_DATA7 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Stores the seventh 32 bits of KEY5.
                    KEY5_DATA7:  u32, 
                    
                }), @ptrFromInt(0x600b0958));
                
                /// Register $n of BLOCK10 (system).
                pub const RD_SYS_PART2_DATA0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Stores the 0th 32 bits of the 2nd part of system data.
                    SYS_DATA_PART2_0:  u32, 
                    
                }), @ptrFromInt(0x600b095c));
                
                /// Register $n of BLOCK9 (KEY5).
                pub const RD_SYS_PART2_DATA1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Stores the 0th 32 bits of the 2nd part of system data.
                    SYS_DATA_PART2_1:  u32, 
                    
                }), @ptrFromInt(0x600b0960));
                
                /// Register $n of BLOCK10 (system).
                pub const RD_SYS_PART2_DATA2 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Stores the 0th 32 bits of the 2nd part of system data.
                    SYS_DATA_PART2_2:  u32, 
                    
                }), @ptrFromInt(0x600b0964));
                
                /// Register $n of BLOCK10 (system).
                pub const RD_SYS_PART2_DATA3 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Stores the 0th 32 bits of the 2nd part of system data.
                    SYS_DATA_PART2_3:  u32, 
                    
                }), @ptrFromInt(0x600b0968));
                
                /// Register $n of BLOCK10 (system).
                pub const RD_SYS_PART2_DATA4 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Stores the 0th 32 bits of the 2nd part of system data.
                    SYS_DATA_PART2_4:  u32, 
                    
                }), @ptrFromInt(0x600b096c));
                
                /// Register $n of BLOCK10 (system).
                pub const RD_SYS_PART2_DATA5 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Stores the 0th 32 bits of the 2nd part of system data.
                    SYS_DATA_PART2_5:  u32, 
                    
                }), @ptrFromInt(0x600b0970));
                
                /// Register $n of BLOCK10 (system).
                pub const RD_SYS_PART2_DATA6 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Stores the 0th 32 bits of the 2nd part of system data.
                    SYS_DATA_PART2_6:  u32, 
                    
                }), @ptrFromInt(0x600b0974));
                
                /// Register $n of BLOCK10 (system).
                pub const RD_SYS_PART2_DATA7 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Stores the 0th 32 bits of the 2nd part of system data.
                    SYS_DATA_PART2_7:  u32, 
                    
                }), @ptrFromInt(0x600b0978));
                
                /// Programming error record register 0 of BLOCK0.
                pub const RD_REPEAT_ERR0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:6] Indicates a programming error of RD_DIS.
                    RD_DIS_ERR:  u7, 
                    
                    /// [7:7] Indicates a programming error of SWAP_UART_SDIO_EN.
                    SWAP_UART_SDIO_EN_ERR:  u1, 
                    
                    /// [8:8] Indicates a programming error of DIS_ICACHE.
                    DIS_ICACHE_ERR:  u1, 
                    
                    /// [9:9] Indicates a programming error of DIS_USB_JTAG.
                    DIS_USB_JTAG_ERR:  u1, 
                    
                    /// [10:10] Indicates a programming error of DIS_DOWNLOAD_ICACHE.
                    DIS_DOWNLOAD_ICACHE_ERR:  u1, 
                    
                    /// [11:11] Indicates a programming error of DIS_USB_DEVICE.
                    DIS_USB_SERIAL_JTAG_ERR:  u1, 
                    
                    /// [12:12] Indicates a programming error of DIS_FORCE_DOWNLOAD.
                    DIS_FORCE_DOWNLOAD_ERR:  u1, 
                    
                    /// [13:13] Indicates a programming error of SPI_DOWNLOAD_MSPI_DIS.
                    SPI_DOWNLOAD_MSPI_DIS_ERR:  u1, 
                    
                    /// [14:14] Indicates a programming error of DIS_CAN.
                    DIS_TWAI_ERR:  u1, 
                    
                    /// [15:15] Indicates a programming error of JTAG_SEL_ENABLE.
                    JTAG_SEL_ENABLE_ERR:  u1, 
                    
                    /// [16:18] Indicates a programming error of SOFT_DIS_JTAG.
                    SOFT_DIS_JTAG_ERR:  u3, 
                    
                    /// [19:19] Indicates a programming error of DIS_PAD_JTAG.
                    DIS_PAD_JTAG_ERR:  u1, 
                    
                    /// [20:20] Indicates a programming error of DIS_DOWNLOAD_MANUAL_ENCRYPT.
                    DIS_DOWNLOAD_MANUAL_ENCRYPT_ERR:  u1, 
                    
                    /// [21:22] Indicates a programming error of USB_DREFH.
                    USB_DREFH_ERR:  u2, 
                    
                    /// [23:24] Indicates a programming error of USB_DREFL.
                    USB_DREFL_ERR:  u2, 
                    
                    /// [25:25] Indicates a programming error of USB_EXCHG_PINS.
                    USB_EXCHG_PINS_ERR:  u1, 
                    
                    /// [26:26] Indicates a programming error of VDD_SPI_AS_GPIO.
                    VDD_SPI_AS_GPIO_ERR:  u1, 
                    
                    /// [27:28] Reserved.
                    RPT4_RESERVED0_ERR_2:  u2, 
                    
                    /// [29:29] Reserved.
                    RPT4_RESERVED0_ERR_1:  u1, 
                    
                    /// [30:31] Reserved.
                    RPT4_RESERVED0_ERR_0:  u2, 
                    
                }), @ptrFromInt(0x600b097c));
                
                /// Programming error record register 1 of BLOCK0.
                pub const RD_REPEAT_ERR1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:15] Reserved.
                    RPT4_RESERVED1_ERR_0:  u16, 
                    
                    /// [16:17] Indicates a programming error of WDT_DELAY_SEL.
                    WDT_DELAY_SEL_ERR:  u2, 
                    
                    /// [18:20] Indicates a programming error of SPI_BOOT_CRYPT_CNT.
                    SPI_BOOT_CRYPT_CNT_ERR:  u3, 
                    
                    /// [21:21] Indicates a programming error of SECURE_BOOT_KEY_REVOKE0.
                    SECURE_BOOT_KEY_REVOKE0_ERR:  u1, 
                    
                    /// [22:22] Indicates a programming error of SECURE_BOOT_KEY_REVOKE1.
                    SECURE_BOOT_KEY_REVOKE1_ERR:  u1, 
                    
                    /// [23:23] Indicates a programming error of SECURE_BOOT_KEY_REVOKE2.
                    SECURE_BOOT_KEY_REVOKE2_ERR:  u1, 
                    
                    /// [24:27] Indicates a programming error of KEY_PURPOSE_0.
                    KEY_PURPOSE_0_ERR:  u4, 
                    
                    /// [28:31] Indicates a programming error of KEY_PURPOSE_1.
                    KEY_PURPOSE_1_ERR:  u4, 
                    
                }), @ptrFromInt(0x600b0980));
                
                /// Programming error record register 2 of BLOCK0.
                pub const RD_REPEAT_ERR2 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:3] Indicates a programming error of KEY_PURPOSE_2.
                    KEY_PURPOSE_2_ERR:  u4, 
                    
                    /// [4:7] Indicates a programming error of KEY_PURPOSE_3.
                    KEY_PURPOSE_3_ERR:  u4, 
                    
                    /// [8:11] Indicates a programming error of KEY_PURPOSE_4.
                    KEY_PURPOSE_4_ERR:  u4, 
                    
                    /// [12:15] Indicates a programming error of KEY_PURPOSE_5.
                    KEY_PURPOSE_5_ERR:  u4, 
                    
                    /// [16:17] Indicates a programming error of SEC_DPA_LEVEL.
                    SEC_DPA_LEVEL_ERR:  u2, 
                    
                    /// [18:18] Reserved.
                    RPT4_RESERVED2_ERR_1:  u1, 
                    
                    /// [19:19] Indicates a programming error of CRYPT_DPA_ENABLE.
                    CRYPT_DPA_ENABLE_ERR:  u1, 
                    
                    /// [20:20] Indicates a programming error of SECURE_BOOT_EN.
                    SECURE_BOOT_EN_ERR:  u1, 
                    
                    /// [21:21] Indicates a programming error of SECURE_BOOT_AGGRESSIVE_REVOKE.
                    SECURE_BOOT_AGGRESSIVE_REVOKE_ERR:  u1, 
                    
                    /// [22:27] Reserved.
                    RPT4_RESERVED2_ERR_0:  u6, 
                    
                    /// [28:31] Indicates a programming error of FLASH_TPUW.
                    FLASH_TPUW_ERR:  u4, 
                    
                }), @ptrFromInt(0x600b0984));
                
                /// Programming error record register 3 of BLOCK0.
                pub const RD_REPEAT_ERR3 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Indicates a programming error of DIS_DOWNLOAD_MODE.
                    DIS_DOWNLOAD_MODE_ERR:  u1, 
                    
                    /// [1:1] Indicates a programming error of DIS_DIRECT_BOOT.
                    DIS_DIRECT_BOOT_ERR:  u1, 
                    
                    /// [2:2] Indicates a programming error of UART_PRINT_CHANNEL.
                    USB_PRINT_ERR:  u1, 
                    
                    /// [3:3] Reserved.
                    RPT4_RESERVED3_ERR_5:  u1, 
                    
                    /// [4:4] Indicates a programming error of DIS_USB_SERIAL_JTAG_DOWNLOAD_MODE.
                    DIS_USB_SERIAL_JTAG_DOWNLOAD_MODE_ERR:  u1, 
                    
                    /// [5:5] Indicates a programming error of ENABLE_SECURITY_DOWNLOAD.
                    ENABLE_SECURITY_DOWNLOAD_ERR:  u1, 
                    
                    /// [6:7] Indicates a programming error of UART_PRINT_CONTROL.
                    UART_PRINT_CONTROL_ERR:  u2, 
                    
                    /// [8:8] Reserved.
                    RPT4_RESERVED3_ERR_4:  u1, 
                    
                    /// [9:9] Reserved.
                    RPT4_RESERVED3_ERR_3:  u1, 
                    
                    /// [10:11] Reserved.
                    RPT4_RESERVED3_ERR_2:  u2, 
                    
                    /// [12:12] Reserved.
                    RPT4_RESERVED3_ERR_1:  u1, 
                    
                    /// [13:13] Indicates a programming error of FORCE_SEND_RESUME.
                    FORCE_SEND_RESUME_ERR:  u1, 
                    
                    /// [14:29] Indicates a programming error of SECURE_VERSION.
                    SECURE_VERSION_ERR:  u16, 
                    
                    /// [30:31] Reserved.
                    RPT4_RESERVED3_ERR_0:  u2, 
                    
                }), @ptrFromInt(0x600b0988));
                
                /// Programming error record register 4 of BLOCK0.
                pub const RD_REPEAT_ERR4 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:23] Reserved.
                    RPT4_RESERVED4_ERR_1:  u24, 
                    
                    /// [24:31] Reserved.
                    RPT4_RESERVED4_ERR_0:  u8, 
                    
                }), @ptrFromInt(0x600b0990));
                
                /// Programming error record register 0 of BLOCK1-10.
                pub const RD_RS_ERR0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:2] The value of this signal means the number of error bytes.
                    MAC_SPI_8M_ERR_NUM:  u3, 
                    
                    /// [3:3] 0: Means no failure and that the data of MAC_SPI_8M is reliable 1: Means that programming user data failed and the number of error bytes is over 6.
                    MAC_SPI_8M_FAIL:  u1, 
                    
                    /// [4:6] The value of this signal means the number of error bytes.
                    SYS_PART1_NUM:  u3, 
                    
                    /// [7:7] 0: Means no failure and that the data of system part1 is reliable 1: Means that programming user data failed and the number of error bytes is over 6.
                    SYS_PART1_FAIL:  u1, 
                    
                    /// [8:10] The value of this signal means the number of error bytes.
                    USR_DATA_ERR_NUM:  u3, 
                    
                    /// [11:11] 0: Means no failure and that the user data is reliable 1: Means that programming user data failed and the number of error bytes is over 6.
                    USR_DATA_FAIL:  u1, 
                    
                    /// [12:14] The value of this signal means the number of error bytes.
                    KEY0_ERR_NUM:  u3, 
                    
                    /// [15:15] 0: Means no failure and that the data of key0 is reliable 1: Means that programming key0 failed and the number of error bytes is over 6.
                    KEY0_FAIL:  u1, 
                    
                    /// [16:18] The value of this signal means the number of error bytes.
                    KEY1_ERR_NUM:  u3, 
                    
                    /// [19:19] 0: Means no failure and that the data of key1 is reliable 1: Means that programming key1 failed and the number of error bytes is over 6.
                    KEY1_FAIL:  u1, 
                    
                    /// [20:22] The value of this signal means the number of error bytes.
                    KEY2_ERR_NUM:  u3, 
                    
                    /// [23:23] 0: Means no failure and that the data of key2 is reliable 1: Means that programming key2 failed and the number of error bytes is over 6.
                    KEY2_FAIL:  u1, 
                    
                    /// [24:26] The value of this signal means the number of error bytes.
                    KEY3_ERR_NUM:  u3, 
                    
                    /// [27:27] 0: Means no failure and that the data of key3 is reliable 1: Means that programming key3 failed and the number of error bytes is over 6.
                    KEY3_FAIL:  u1, 
                    
                    /// [28:30] The value of this signal means the number of error bytes.
                    KEY4_ERR_NUM:  u3, 
                    
                    /// [31:31] 0: Means no failure and that the data of key4 is reliable 1: Means that programming key4 failed and the number of error bytes is over 6.
                    KEY4_FAIL:  u1, 
                    
                }), @ptrFromInt(0x600b09c0));
                
                /// Programming error record register 1 of BLOCK1-10.
                pub const RD_RS_ERR1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:2] The value of this signal means the number of error bytes.
                    KEY5_ERR_NUM:  u3, 
                    
                    /// [3:3] 0: Means no failure and that the data of key5 is reliable 1: Means that programming key5 failed and the number of error bytes is over 6.
                    KEY5_FAIL:  u1, 
                    
                    /// [4:6] The value of this signal means the number of error bytes.
                    SYS_PART2_ERR_NUM:  u3, 
                    
                    /// [7:7] 0: Means no failure and that the data of system part2 is reliable 1: Means that programming user data failed and the number of error bytes is over 6.
                    SYS_PART2_FAIL:  u1, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600b09c4));
                
                /// eFuse clcok configuration register.
                pub const CLK = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Set this bit to force eFuse SRAM into power-saving mode.
                    MEM_FORCE_PD:  u1, 
                    
                    /// [1:1] Set this bit and force to activate clock signal of eFuse SRAM.
                    MEM_CLK_FORCE_ON:  u1, 
                    
                    /// [2:2] Set this bit to force eFuse SRAM into working mode.
                    MEM_FORCE_PU:  u1, 
                    
                    /// [3:15] 
                    res0:  u0, 
                    
                    /// [16:16] Set this bit to force enable eFuse register configuration clock signal.
                    EN:  u1, 
                    
                    /// [17:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x600b09c8));
                
                /// eFuse operation mode configuraiton register
                pub const CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:15] 0x5A5A:programming operation command 0x5AA5: read operation command.
                    OP_CODE:  u16, 
                    
                    /// [16:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600b09cc));
                
                /// eFuse status register.
                pub const STATUS = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:3] Indicates the state of the eFuse state machine.
                    STATE:  u4, 
                    
                    /// [4:4] The value of OTP_LOAD_SW.
                    OTP_LOAD_SW:  u1, 
                    
                    /// [5:5] The value of OTP_VDDQ_C_SYNC2.
                    OTP_VDDQ_C_SYNC2:  u1, 
                    
                    /// [6:6] The value of OTP_STROBE_SW.
                    OTP_STROBE_SW:  u1, 
                    
                    /// [7:7] The value of OTP_CSB_SW.
                    OTP_CSB_SW:  u1, 
                    
                    /// [8:8] The value of OTP_PGENB_SW.
                    OTP_PGENB_SW:  u1, 
                    
                    /// [9:9] The value of OTP_VDDQ_IS_SW.
                    OTP_VDDQ_IS_SW:  u1, 
                    
                    /// [10:19] Indicates the number of block valid bit.
                    BLK0_VALID_BIT_CNT:  u10, 
                    
                    /// [20:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600b09d0));
                
                /// eFuse command register.
                pub const CMD = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Set this bit to send read command.
                    READ_CMD:  u1, 
                    
                    /// [1:1] Set this bit to send programming command.
                    PGM_CMD:  u1, 
                    
                    /// [2:5] The serial number of the block to be programmed. Value 0-10 corresponds to block number 0-10, respectively.
                    BLK_NUM:  u4, 
                    
                    /// [6:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600b09d4));
                
                /// eFuse raw interrupt register.
                pub const INT_RAW = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] The raw bit signal for read_done interrupt.
                    READ_DONE_INT_RAW:  u1, 
                    
                    /// [1:1] The raw bit signal for pgm_done interrupt.
                    PGM_DONE_INT_RAW:  u1, 
                    
                    /// [2:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600b09d8));
                
                /// eFuse interrupt status register.
                pub const INT_ST = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] The status signal for read_done interrupt.
                    READ_DONE_INT_ST:  u1, 
                    
                    /// [1:1] The status signal for pgm_done interrupt.
                    PGM_DONE_INT_ST:  u1, 
                    
                    /// [2:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600b09dc));
                
                /// eFuse interrupt enable register.
                pub const INT_ENA = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] The enable signal for read_done interrupt.
                    READ_DONE_INT_ENA:  u1, 
                    
                    /// [1:1] The enable signal for pgm_done interrupt.
                    PGM_DONE_INT_ENA:  u1, 
                    
                    /// [2:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600b09e0));
                
                /// eFuse interrupt clear register.
                pub const INT_CLR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] The clear signal for read_done interrupt.
                    READ_DONE_INT_CLR:  u1, 
                    
                    /// [1:1] The clear signal for pgm_done interrupt.
                    PGM_DONE_INT_CLR:  u1, 
                    
                    /// [2:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600b09e4));
                
                /// Controls the eFuse programming voltage.
                pub const DAC_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] Controls the division factor of the rising clock of the programming voltage.
                    DAC_CLK_DIV:  u8, 
                    
                    /// [8:8] Don't care.
                    DAC_CLK_PAD_SEL:  u1, 
                    
                    /// [9:16] Controls the rising period of the programming voltage.
                    DAC_NUM:  u8, 
                    
                    /// [17:17] Reduces the power supply of the programming voltage.
                    OE_CLR:  u1, 
                    
                    /// [18:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600b09e8));
                
                /// Configures read timing parameters.
                pub const RD_TIM_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] Configures the read hold time.
                    THR_A:  u8, 
                    
                    /// [8:15] Configures the read time.
                    TRD:  u8, 
                    
                    /// [16:23] Configures the read setup time.
                    TSUR_A:  u8, 
                    
                    /// [24:31] Configures the waiting time of reading eFuse memory.
                    READ_INIT_NUM:  u8, 
                    
                }), @ptrFromInt(0x600b09ec));
                
                /// Configurarion register 1 of eFuse programming timing parameters.
                pub const WR_TIM_CONF1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] Configures the programming setup time.
                    TSUP_A:  u8, 
                    
                    /// [8:23] Configures the power up time for VDDQ.
                    PWR_ON_NUM:  u16, 
                    
                    /// [24:31] Configures the programming hold time.
                    THP_A:  u8, 
                    
                }), @ptrFromInt(0x600b09f0));
                
                /// Configurarion register 2 of eFuse programming timing parameters.
                pub const WR_TIM_CONF2 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:15] Configures the power outage time for VDDQ.
                    PWR_OFF_NUM:  u16, 
                    
                    /// [16:31] Configures the active programming time.
                    TPGM:  u16, 
                    
                }), @ptrFromInt(0x600b09f4));
                
                /// Configurarion register0 of eFuse programming time parameters and rs bypass operation.
                pub const WR_TIM_CONF0_RS_BYPASS = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Set this bit to bypass reed solomon correction step.
                    BYPASS_RS_CORRECTION:  u1, 
                    
                    /// [1:11] Configures block number of programming twice operation.
                    BYPASS_RS_BLK_NUM:  u11, 
                    
                    /// [12:12] Set this bit to update multi-bit register signals.
                    UPDATE:  u1, 
                    
                    /// [13:20] Configures the inactive programming time.
                    TPGM_INACTIVE:  u8, 
                    
                    /// [21:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600b09f8));
                
                /// eFuse version register.
                pub const DATE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:27] Stores eFuse version.
                    DATE:  u28, 
                    
                    /// [28:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600b09fc));
                
            };
            
            /// External Memory
            pub const EXTMEM = struct {
                
                /// L1 instruction Cache(L1-ICache) control register
                pub const L1_ICACHE_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] The bit is used to disable core0 ibus access L1-ICache, 0: enable, 1: disable
                    L1_ICACHE_SHUT_IBUS0:  u1, 
                    
                    /// [1:1] The bit is used to disable core1 ibus access L1-ICache, 0: enable, 1: disable
                    L1_ICACHE_SHUT_IBUS1:  u1, 
                    
                    /// [2:2] Reserved
                    L1_ICACHE_SHUT_IBUS2:  u1, 
                    
                    /// [3:3] Reserved
                    L1_ICACHE_SHUT_IBUS3:  u1, 
                    
                    /// [4:7] Reserved
                    L1_ICACHE_UNDEF_OP:  u4, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600c8000));
                
                /// L1 data Cache(L1-Cache) control register
                pub const L1_CACHE_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] The bit is used to disable core0 dbus access L1-Cache, 0: enable, 1: disable
                    L1_CACHE_SHUT_BUS0:  u1, 
                    
                    /// [1:1] The bit is used to disable core1 dbus access L1-Cache, 0: enable, 1: disable
                    L1_CACHE_SHUT_BUS1:  u1, 
                    
                    /// [2:2] Reserved
                    L1_CACHE_SHUT_DBUS2:  u1, 
                    
                    /// [3:3] Reserved
                    L1_CACHE_SHUT_DBUS3:  u1, 
                    
                    /// [4:4] The bit is used to disable DMA access L1-Cache, 0: enable, 1: disable
                    L1_CACHE_SHUT_DMA:  u1, 
                    
                    /// [5:7] 
                    res0:  u0, 
                    
                    /// [8:11] Reserved
                    L1_CACHE_UNDEF_OP:  u4, 
                    
                    /// [12:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x600c8004));
                
                /// Bypass Cache configure register
                pub const L1_BYPASS_CACHE_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] The bit is used to enable bypass L1-ICache0. 0: disable bypass, 1: enable bypass.
                    BYPASS_L1_ICACHE0_EN:  u1, 
                    
                    /// [1:1] The bit is used to enable bypass L1-ICache1. 0: disable bypass, 1: enable bypass.
                    BYPASS_L1_ICACHE1_EN:  u1, 
                    
                    /// [2:2] Reserved
                    BYPASS_L1_ICACHE2_EN:  u1, 
                    
                    /// [3:3] Reserved
                    BYPASS_L1_ICACHE3_EN:  u1, 
                    
                    /// [4:4] The bit is used to enable bypass L1-DCache. 0: disable bypass, 1: enable bypass.
                    BYPASS_L1_DCACHE_EN:  u1, 
                    
                    /// [5:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600c8008));
                
                /// L1 Cache atomic feature configure register
                pub const L1_CACHE_ATOMIC_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] The bit is used to enable atomic feature on L1-Cache when multiple cores access L1-Cache.1: disable, 1: enable.
                    L1_CACHE_ATOMIC_EN:  u1, 
                    
                    /// [1:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600c800c));
                
                /// L1 instruction Cache CacheSize mode configure register
                pub const L1_ICACHE_CACHESIZE_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] The field is used to configure cachesize of L1-ICache as 1k bytes. This field and all other fields within this register is onehot.
                    L1_ICACHE_CACHESIZE_1K:  u1, 
                    
                    /// [1:1] The field is used to configure cachesize of L1-ICache as 2k bytes. This field and all other fields within this register is onehot.
                    L1_ICACHE_CACHESIZE_2K:  u1, 
                    
                    /// [2:2] The field is used to configure cachesize of L1-ICache as 4k bytes. This field and all other fields within this register is onehot.
                    L1_ICACHE_CACHESIZE_4K:  u1, 
                    
                    /// [3:3] The field is used to configure cachesize of L1-ICache as 8k bytes. This field and all other fields within this register is onehot.
                    L1_ICACHE_CACHESIZE_8K:  u1, 
                    
                    /// [4:4] The field is used to configure cachesize of L1-ICache as 16k bytes. This field and all other fields within this register is onehot.
                    L1_ICACHE_CACHESIZE_16K:  u1, 
                    
                    /// [5:5] The field is used to configure cachesize of L1-ICache as 32k bytes. This field and all other fields within this register is onehot.
                    L1_ICACHE_CACHESIZE_32K:  u1, 
                    
                    /// [6:6] The field is used to configure cachesize of L1-ICache as 64k bytes. This field and all other fields within this register is onehot.
                    L1_ICACHE_CACHESIZE_64K:  u1, 
                    
                    /// [7:7] The field is used to configure cachesize of L1-ICache as 128k bytes. This field and all other fields within this register is onehot.
                    L1_ICACHE_CACHESIZE_128K:  u1, 
                    
                    /// [8:8] The field is used to configure cachesize of L1-ICache as 256k bytes. This field and all other fields within this register is onehot.
                    L1_ICACHE_CACHESIZE_256K:  u1, 
                    
                    /// [9:9] The field is used to configure cachesize of L1-ICache as 512k bytes. This field and all other fields within this register is onehot.
                    L1_ICACHE_CACHESIZE_512K:  u1, 
                    
                    /// [10:10] The field is used to configure cachesize of L1-ICache as 1024k bytes. This field and all other fields within this register is onehot.
                    L1_ICACHE_CACHESIZE_1024K:  u1, 
                    
                    /// [11:11] The field is used to configure cachesize of L1-ICache as 2048k bytes. This field and all other fields within this register is onehot.
                    L1_ICACHE_CACHESIZE_2048K:  u1, 
                    
                    /// [12:12] The field is used to configure cachesize of L1-ICache as 4096k bytes. This field and all other fields within this register is onehot.
                    L1_ICACHE_CACHESIZE_4096K:  u1, 
                    
                    /// [13:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600c8010));
                
                /// L1 instruction Cache BlockSize mode configure register
                pub const L1_ICACHE_BLOCKSIZE_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] The field is used to configureblocksize of L1-ICache as 8 bytes. This field and all other fields within this register is onehot.
                    L1_ICACHE_BLOCKSIZE_8:  u1, 
                    
                    /// [1:1] The field is used to configureblocksize of L1-ICache as 16 bytes. This field and all other fields within this register is onehot.
                    L1_ICACHE_BLOCKSIZE_16:  u1, 
                    
                    /// [2:2] The field is used to configureblocksize of L1-ICache as 32 bytes. This field and all other fields within this register is onehot.
                    L1_ICACHE_BLOCKSIZE_32:  u1, 
                    
                    /// [3:3] The field is used to configureblocksize of L1-ICache as 64 bytes. This field and all other fields within this register is onehot.
                    L1_ICACHE_BLOCKSIZE_64:  u1, 
                    
                    /// [4:4] The field is used to configureblocksize of L1-ICache as 128 bytes. This field and all other fields within this register is onehot.
                    L1_ICACHE_BLOCKSIZE_128:  u1, 
                    
                    /// [5:5] The field is used to configureblocksize of L1-ICache as 256 bytes. This field and all other fields within this register is onehot.
                    L1_ICACHE_BLOCKSIZE_256:  u1, 
                    
                    /// [6:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600c8014));
                
                /// L1 data Cache CacheSize mode configure register
                pub const L1_CACHE_CACHESIZE_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] The field is used to configure cachesize of L1-Cache as 1k bytes. This field and all other fields within this register is onehot.
                    L1_CACHE_CACHESIZE_1K:  u1, 
                    
                    /// [1:1] The field is used to configure cachesize of L1-Cache as 2k bytes. This field and all other fields within this register is onehot.
                    L1_CACHE_CACHESIZE_2K:  u1, 
                    
                    /// [2:2] The field is used to configure cachesize of L1-Cache as 4k bytes. This field and all other fields within this register is onehot.
                    L1_CACHE_CACHESIZE_4K:  u1, 
                    
                    /// [3:3] The field is used to configure cachesize of L1-Cache as 8k bytes. This field and all other fields within this register is onehot.
                    L1_CACHE_CACHESIZE_8K:  u1, 
                    
                    /// [4:4] The field is used to configure cachesize of L1-Cache as 16k bytes. This field and all other fields within this register is onehot.
                    L1_CACHE_CACHESIZE_16K:  u1, 
                    
                    /// [5:5] The field is used to configure cachesize of L1-Cache as 32k bytes. This field and all other fields within this register is onehot.
                    L1_CACHE_CACHESIZE_32K:  u1, 
                    
                    /// [6:6] The field is used to configure cachesize of L1-Cache as 64k bytes. This field and all other fields within this register is onehot.
                    L1_CACHE_CACHESIZE_64K:  u1, 
                    
                    /// [7:7] The field is used to configure cachesize of L1-Cache as 128k bytes. This field and all other fields within this register is onehot.
                    L1_CACHE_CACHESIZE_128K:  u1, 
                    
                    /// [8:8] The field is used to configure cachesize of L1-Cache as 256k bytes. This field and all other fields within this register is onehot.
                    L1_CACHE_CACHESIZE_256K:  u1, 
                    
                    /// [9:9] The field is used to configure cachesize of L1-Cache as 512k bytes. This field and all other fields within this register is onehot.
                    L1_CACHE_CACHESIZE_512K:  u1, 
                    
                    /// [10:10] The field is used to configure cachesize of L1-Cache as 1024k bytes. This field and all other fields within this register is onehot.
                    L1_CACHE_CACHESIZE_1024K:  u1, 
                    
                    /// [11:11] The field is used to configure cachesize of L1-Cache as 2048k bytes. This field and all other fields within this register is onehot.
                    L1_CACHE_CACHESIZE_2048K:  u1, 
                    
                    /// [12:12] The field is used to configure cachesize of L1-Cache as 4096k bytes. This field and all other fields within this register is onehot.
                    L1_CACHE_CACHESIZE_4096K:  u1, 
                    
                    /// [13:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600c8018));
                
                /// L1 data Cache BlockSize mode configure register
                pub const L1_CACHE_BLOCKSIZE_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] The field is used to configureblocksize of L1-DCache as 8 bytes. This field and all other fields within this register is onehot.
                    L1_CACHE_BLOCKSIZE_8:  u1, 
                    
                    /// [1:1] The field is used to configureblocksize of L1-DCache as 16 bytes. This field and all other fields within this register is onehot.
                    L1_CACHE_BLOCKSIZE_16:  u1, 
                    
                    /// [2:2] The field is used to configureblocksize of L1-DCache as 32 bytes. This field and all other fields within this register is onehot.
                    L1_CACHE_BLOCKSIZE_32:  u1, 
                    
                    /// [3:3] The field is used to configureblocksize of L1-DCache as 64 bytes. This field and all other fields within this register is onehot.
                    L1_CACHE_BLOCKSIZE_64:  u1, 
                    
                    /// [4:4] The field is used to configureblocksize of L1-DCache as 128 bytes. This field and all other fields within this register is onehot.
                    L1_CACHE_BLOCKSIZE_128:  u1, 
                    
                    /// [5:5] The field is used to configureblocksize of L1-DCache as 256 bytes. This field and all other fields within this register is onehot.
                    L1_CACHE_BLOCKSIZE_256:  u1, 
                    
                    /// [6:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600c801c));
                
                /// Cache wrap around control register
                pub const L1_CACHE_WRAP_AROUND_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Set this bit as 1 to enable L1-ICache0 wrap around mode.
                    L1_ICACHE0_WRAP:  u1, 
                    
                    /// [1:1] Set this bit as 1 to enable L1-ICache1 wrap around mode.
                    L1_ICACHE1_WRAP:  u1, 
                    
                    /// [2:2] Reserved
                    L1_ICACHE2_WRAP:  u1, 
                    
                    /// [3:3] Reserved
                    L1_ICACHE3_WRAP:  u1, 
                    
                    /// [4:4] Set this bit as 1 to enable L1-DCache wrap around mode.
                    L1_CACHE_WRAP:  u1, 
                    
                    /// [5:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600c8020));
                
                /// Cache tag memory power control register
                pub const L1_CACHE_TAG_MEM_POWER_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] The bit is used to close clock gating ofL1-ICache0 tag memory. 1: close gating, 0: open clock gating.
                    L1_ICACHE0_TAG_MEM_FORCE_ON:  u1, 
                    
                    /// [1:1] The bit is used to power L1-ICache0 tag memory down. 0: follow rtc_lslp, 1: power down
                    L1_ICACHE0_TAG_MEM_FORCE_PD:  u1, 
                    
                    /// [2:2] The bit is used to power L1-ICache0 tag memory up. 0: follow rtc_lslp, 1: power up
                    L1_ICACHE0_TAG_MEM_FORCE_PU:  u1, 
                    
                    /// [3:3] 
                    res0:  u0, 
                    
                    /// [4:4] The bit is used to close clock gating ofL1-ICache1 tag memory. 1: close gating, 0: open clock gating.
                    L1_ICACHE1_TAG_MEM_FORCE_ON:  u1, 
                    
                    /// [5:5] The bit is used to power L1-ICache1 tag memory down. 0: follow rtc_lslp, 1: power down
                    L1_ICACHE1_TAG_MEM_FORCE_PD:  u1, 
                    
                    /// [6:6] The bit is used to power L1-ICache1 tag memory up. 0: follow rtc_lslp, 1: power up
                    L1_ICACHE1_TAG_MEM_FORCE_PU:  u1, 
                    
                    /// [7:7] 
                    res1:  u0, 
                    
                    /// [8:8] Reserved
                    L1_ICACHE2_TAG_MEM_FORCE_ON:  u1, 
                    
                    /// [9:9] Reserved
                    L1_ICACHE2_TAG_MEM_FORCE_PD:  u1, 
                    
                    /// [10:10] Reserved
                    L1_ICACHE2_TAG_MEM_FORCE_PU:  u1, 
                    
                    /// [11:11] 
                    res2:  u0, 
                    
                    /// [12:12] Reserved
                    L1_ICACHE3_TAG_MEM_FORCE_ON:  u1, 
                    
                    /// [13:13] Reserved
                    L1_ICACHE3_TAG_MEM_FORCE_PD:  u1, 
                    
                    /// [14:14] Reserved
                    L1_ICACHE3_TAG_MEM_FORCE_PU:  u1, 
                    
                    /// [15:15] 
                    res3:  u0, 
                    
                    /// [16:16] The bit is used to close clock gating ofL1-Cache tag memory. 1: close gating, 0: open clock gating.
                    L1_CACHE_TAG_MEM_FORCE_ON:  u1, 
                    
                    /// [17:17] The bit is used to power L1-Cache tag memory down. 0: follow rtc_lslp, 1: power down
                    L1_CACHE_TAG_MEM_FORCE_PD:  u1, 
                    
                    /// [18:18] The bit is used to power L1-Cache tag memory up. 0: follow rtc_lslp, 1: power up
                    L1_CACHE_TAG_MEM_FORCE_PU:  u1, 
                    
                    /// [19:31] 
                    res4:  u0, 
                    
                }), @ptrFromInt(0x600c8024));
                
                /// Cache data memory power control register
                pub const L1_CACHE_DATA_MEM_POWER_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] The bit is used to close clock gating ofL1-ICache0 data memory. 1: close gating, 0: open clock gating.
                    L1_ICACHE0_DATA_MEM_FORCE_ON:  u1, 
                    
                    /// [1:1] The bit is used to power L1-ICache0 data memory down. 0: follow rtc_lslp, 1: power down
                    L1_ICACHE0_DATA_MEM_FORCE_PD:  u1, 
                    
                    /// [2:2] The bit is used to power L1-ICache0 data memory up. 0: follow rtc_lslp, 1: power up
                    L1_ICACHE0_DATA_MEM_FORCE_PU:  u1, 
                    
                    /// [3:3] 
                    res0:  u0, 
                    
                    /// [4:4] The bit is used to close clock gating ofL1-ICache1 data memory. 1: close gating, 0: open clock gating.
                    L1_ICACHE1_DATA_MEM_FORCE_ON:  u1, 
                    
                    /// [5:5] The bit is used to power L1-ICache1 data memory down. 0: follow rtc_lslp, 1: power down
                    L1_ICACHE1_DATA_MEM_FORCE_PD:  u1, 
                    
                    /// [6:6] The bit is used to power L1-ICache1 data memory up. 0: follow rtc_lslp, 1: power up
                    L1_ICACHE1_DATA_MEM_FORCE_PU:  u1, 
                    
                    /// [7:7] 
                    res1:  u0, 
                    
                    /// [8:8] Reserved
                    L1_ICACHE2_DATA_MEM_FORCE_ON:  u1, 
                    
                    /// [9:9] Reserved
                    L1_ICACHE2_DATA_MEM_FORCE_PD:  u1, 
                    
                    /// [10:10] Reserved
                    L1_ICACHE2_DATA_MEM_FORCE_PU:  u1, 
                    
                    /// [11:11] 
                    res2:  u0, 
                    
                    /// [12:12] Reserved
                    L1_ICACHE3_DATA_MEM_FORCE_ON:  u1, 
                    
                    /// [13:13] Reserved
                    L1_ICACHE3_DATA_MEM_FORCE_PD:  u1, 
                    
                    /// [14:14] Reserved
                    L1_ICACHE3_DATA_MEM_FORCE_PU:  u1, 
                    
                    /// [15:15] 
                    res3:  u0, 
                    
                    /// [16:16] The bit is used to close clock gating ofL1-Cache data memory. 1: close gating, 0: open clock gating.
                    L1_CACHE_DATA_MEM_FORCE_ON:  u1, 
                    
                    /// [17:17] The bit is used to power L1-Cache data memory down. 0: follow rtc_lslp, 1: power down
                    L1_CACHE_DATA_MEM_FORCE_PD:  u1, 
                    
                    /// [18:18] The bit is used to power L1-Cache data memory up. 0: follow rtc_lslp, 1: power up
                    L1_CACHE_DATA_MEM_FORCE_PU:  u1, 
                    
                    /// [19:31] 
                    res4:  u0, 
                    
                }), @ptrFromInt(0x600c8028));
                
                /// Cache Freeze control register
                pub const L1_CACHE_FREEZE_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] The bit is used to enable freeze operation on L1-ICache0. It can be cleared by software.
                    L1_ICACHE0_FREEZE_EN:  u1, 
                    
                    /// [1:1] The bit is used to configure mode of freeze operation L1-ICache0. 0: a miss-access will not stuck. 1: a miss-access will stuck.
                    L1_ICACHE0_FREEZE_MODE:  u1, 
                    
                    /// [2:2] The bit is used to indicate whether freeze operation on L1-ICache0 is finished or not. 0: not finished. 1: finished.
                    L1_ICACHE0_FREEZE_DONE:  u1, 
                    
                    /// [3:3] 
                    res0:  u0, 
                    
                    /// [4:4] The bit is used to enable freeze operation on L1-ICache1. It can be cleared by software.
                    L1_ICACHE1_FREEZE_EN:  u1, 
                    
                    /// [5:5] The bit is used to configure mode of freeze operation L1-ICache1. 0: a miss-access will not stuck. 1: a miss-access will stuck.
                    L1_ICACHE1_FREEZE_MODE:  u1, 
                    
                    /// [6:6] The bit is used to indicate whether freeze operation on L1-ICache1 is finished or not. 0: not finished. 1: finished.
                    L1_ICACHE1_FREEZE_DONE:  u1, 
                    
                    /// [7:7] 
                    res1:  u0, 
                    
                    /// [8:8] Reserved
                    L1_ICACHE2_FREEZE_EN:  u1, 
                    
                    /// [9:9] Reserved
                    L1_ICACHE2_FREEZE_MODE:  u1, 
                    
                    /// [10:10] Reserved
                    L1_ICACHE2_FREEZE_DONE:  u1, 
                    
                    /// [11:11] 
                    res2:  u0, 
                    
                    /// [12:12] Reserved
                    L1_ICACHE3_FREEZE_EN:  u1, 
                    
                    /// [13:13] Reserved
                    L1_ICACHE3_FREEZE_MODE:  u1, 
                    
                    /// [14:14] Reserved
                    L1_ICACHE3_FREEZE_DONE:  u1, 
                    
                    /// [15:15] 
                    res3:  u0, 
                    
                    /// [16:16] The bit is used to enable freeze operation on L1-Cache. It can be cleared by software.
                    L1_CACHE_FREEZE_EN:  u1, 
                    
                    /// [17:17] The bit is used to configure mode of freeze operation L1-Cache. 0: a miss-access will not stuck. 1: a miss-access will stuck.
                    L1_CACHE_FREEZE_MODE:  u1, 
                    
                    /// [18:18] The bit is used to indicate whether freeze operation on L1-Cache is finished or not. 0: not finished. 1: finished.
                    L1_CACHE_FREEZE_DONE:  u1, 
                    
                    /// [19:31] 
                    res4:  u0, 
                    
                }), @ptrFromInt(0x600c802c));
                
                /// Cache data memory access configure register
                pub const L1_CACHE_DATA_MEM_ACS_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] The bit is used to enable config-bus read L1-ICache0 data memoryory. 0: disable, 1: enable.
                    L1_ICACHE0_DATA_MEM_RD_EN:  u1, 
                    
                    /// [1:1] The bit is used to enable config-bus write L1-ICache0 data memoryory. 0: disable, 1: enable.
                    L1_ICACHE0_DATA_MEM_WR_EN:  u1, 
                    
                    /// [2:3] 
                    res0:  u0, 
                    
                    /// [4:4] The bit is used to enable config-bus read L1-ICache1 data memoryory. 0: disable, 1: enable.
                    L1_ICACHE1_DATA_MEM_RD_EN:  u1, 
                    
                    /// [5:5] The bit is used to enable config-bus write L1-ICache1 data memoryory. 0: disable, 1: enable.
                    L1_ICACHE1_DATA_MEM_WR_EN:  u1, 
                    
                    /// [6:7] 
                    res1:  u0, 
                    
                    /// [8:8] Reserved
                    L1_ICACHE2_DATA_MEM_RD_EN:  u1, 
                    
                    /// [9:9] Reserved
                    L1_ICACHE2_DATA_MEM_WR_EN:  u1, 
                    
                    /// [10:11] 
                    res2:  u0, 
                    
                    /// [12:12] Reserved
                    L1_ICACHE3_DATA_MEM_RD_EN:  u1, 
                    
                    /// [13:13] Reserved
                    L1_ICACHE3_DATA_MEM_WR_EN:  u1, 
                    
                    /// [14:15] 
                    res3:  u0, 
                    
                    /// [16:16] The bit is used to enable config-bus read L1-Cache data memoryory. 0: disable, 1: enable.
                    L1_CACHE_DATA_MEM_RD_EN:  u1, 
                    
                    /// [17:17] The bit is used to enable config-bus write L1-Cache data memoryory. 0: disable, 1: enable.
                    L1_CACHE_DATA_MEM_WR_EN:  u1, 
                    
                    /// [18:31] 
                    res4:  u0, 
                    
                }), @ptrFromInt(0x600c8030));
                
                /// Cache tag memory access configure register
                pub const L1_CACHE_TAG_MEM_ACS_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] The bit is used to enable config-bus read L1-ICache0 tag memoryory. 0: disable, 1: enable.
                    L1_ICACHE0_TAG_MEM_RD_EN:  u1, 
                    
                    /// [1:1] The bit is used to enable config-bus write L1-ICache0 tag memoryory. 0: disable, 1: enable.
                    L1_ICACHE0_TAG_MEM_WR_EN:  u1, 
                    
                    /// [2:3] 
                    res0:  u0, 
                    
                    /// [4:4] The bit is used to enable config-bus read L1-ICache1 tag memoryory. 0: disable, 1: enable.
                    L1_ICACHE1_TAG_MEM_RD_EN:  u1, 
                    
                    /// [5:5] The bit is used to enable config-bus write L1-ICache1 tag memoryory. 0: disable, 1: enable.
                    L1_ICACHE1_TAG_MEM_WR_EN:  u1, 
                    
                    /// [6:7] 
                    res1:  u0, 
                    
                    /// [8:8] Reserved
                    L1_ICACHE2_TAG_MEM_RD_EN:  u1, 
                    
                    /// [9:9] Reserved
                    L1_ICACHE2_TAG_MEM_WR_EN:  u1, 
                    
                    /// [10:11] 
                    res2:  u0, 
                    
                    /// [12:12] Reserved
                    L1_ICACHE3_TAG_MEM_RD_EN:  u1, 
                    
                    /// [13:13] Reserved
                    L1_ICACHE3_TAG_MEM_WR_EN:  u1, 
                    
                    /// [14:15] 
                    res3:  u0, 
                    
                    /// [16:16] The bit is used to enable config-bus read L1-Cache tag memoryory. 0: disable, 1: enable.
                    L1_CACHE_TAG_MEM_RD_EN:  u1, 
                    
                    /// [17:17] The bit is used to enable config-bus write L1-Cache tag memoryory. 0: disable, 1: enable.
                    L1_CACHE_TAG_MEM_WR_EN:  u1, 
                    
                    /// [18:31] 
                    res4:  u0, 
                    
                }), @ptrFromInt(0x600c8034));
                
                /// L1 instruction Cache 0 prelock configure register
                pub const L1_ICACHE0_PRELOCK_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] The bit is used to enable the first section of prelock function on L1-ICache0.
                    L1_ICACHE0_PRELOCK_SCT0_EN:  u1, 
                    
                    /// [1:1] The bit is used to enable the second section of prelock function on L1-ICache0.
                    L1_ICACHE0_PRELOCK_SCT1_EN:  u1, 
                    
                    /// [2:5] The bit is used to setthe gid of l1 icache0 prelock.
                    L1_ICACHE0_PRELOCK_RGID:  u4, 
                    
                    /// [6:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600c8038));
                
                /// L1 instruction Cache 0 prelock section0 address configure register
                pub const L1_ICACHE0_PRELOCK_SCT0_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Those bits are used to configure the start virtual address of the first section of prelock on L1-ICache0, which should be used together with L1_ICACHE0_PRELOCK_SCT0_SIZE_REG
                    L1_ICACHE0_PRELOCK_SCT0_ADDR:  u32, 
                    
                }), @ptrFromInt(0x600c803c));
                
                /// L1 instruction Cache 0 prelock section1 address configure register
                pub const L1_ICACHE0_PRELOCK_SCT1_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Those bits are used to configure the start virtual address of the second section of prelock on L1-ICache0, which should be used together with L1_ICACHE0_PRELOCK_SCT1_SIZE_REG
                    L1_ICACHE0_PRELOCK_SCT1_ADDR:  u32, 
                    
                }), @ptrFromInt(0x600c8040));
                
                /// L1 instruction Cache 0 prelock section size configure register
                pub const L1_ICACHE0_PRELOCK_SCT_SIZE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:13] Those bits are used to configure the size of the first section of prelock on L1-ICache0, which should be used together with L1_ICACHE0_PRELOCK_SCT0_ADDR_REG
                    L1_ICACHE0_PRELOCK_SCT0_SIZE:  u14, 
                    
                    /// [14:15] 
                    res0:  u0, 
                    
                    /// [16:29] Those bits are used to configure the size of the second section of prelock on L1-ICache0, which should be used together with L1_ICACHE0_PRELOCK_SCT1_ADDR_REG
                    L1_ICACHE0_PRELOCK_SCT1_SIZE:  u14, 
                    
                    /// [30:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x600c8044));
                
                /// L1 instruction Cache 1 prelock configure register
                pub const L1_ICACHE1_PRELOCK_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] The bit is used to enable the first section of prelock function on L1-ICache1.
                    L1_ICACHE1_PRELOCK_SCT0_EN:  u1, 
                    
                    /// [1:1] The bit is used to enable the second section of prelock function on L1-ICache1.
                    L1_ICACHE1_PRELOCK_SCT1_EN:  u1, 
                    
                    /// [2:5] The bit is used to setthe gid of l1 icache1 prelock.
                    L1_ICACHE1_PRELOCK_RGID:  u4, 
                    
                    /// [6:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600c8048));
                
                /// L1 instruction Cache 1 prelock section0 address configure register
                pub const L1_ICACHE1_PRELOCK_SCT0_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Those bits are used to configure the start virtual address of the first section of prelock on L1-ICache1, which should be used together with L1_ICACHE1_PRELOCK_SCT0_SIZE_REG
                    L1_ICACHE1_PRELOCK_SCT0_ADDR:  u32, 
                    
                }), @ptrFromInt(0x600c804c));
                
                /// L1 instruction Cache 1 prelock section1 address configure register
                pub const L1_ICACHE1_PRELOCK_SCT1_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Those bits are used to configure the start virtual address of the second section of prelock on L1-ICache1, which should be used together with L1_ICACHE1_PRELOCK_SCT1_SIZE_REG
                    L1_ICACHE1_PRELOCK_SCT1_ADDR:  u32, 
                    
                }), @ptrFromInt(0x600c8050));
                
                /// L1 instruction Cache 1 prelock section size configure register
                pub const L1_ICACHE1_PRELOCK_SCT_SIZE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:13] Those bits are used to configure the size of the first section of prelock on L1-ICache1, which should be used together with L1_ICACHE1_PRELOCK_SCT0_ADDR_REG
                    L1_ICACHE1_PRELOCK_SCT0_SIZE:  u14, 
                    
                    /// [14:15] 
                    res0:  u0, 
                    
                    /// [16:29] Those bits are used to configure the size of the second section of prelock on L1-ICache1, which should be used together with L1_ICACHE1_PRELOCK_SCT1_ADDR_REG
                    L1_ICACHE1_PRELOCK_SCT1_SIZE:  u14, 
                    
                    /// [30:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x600c8054));
                
                /// L1 instruction Cache 2 prelock configure register
                pub const L1_ICACHE2_PRELOCK_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] The bit is used to enable the first section of prelock function on L1-ICache2.
                    L1_ICACHE2_PRELOCK_SCT0_EN:  u1, 
                    
                    /// [1:1] The bit is used to enable the second section of prelock function on L1-ICache2.
                    L1_ICACHE2_PRELOCK_SCT1_EN:  u1, 
                    
                    /// [2:5] The bit is used to setthe gid of l1 icache2 prelock.
                    L1_ICACHE2_PRELOCK_RGID:  u4, 
                    
                    /// [6:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600c8058));
                
                /// L1 instruction Cache 2 prelock section0 address configure register
                pub const L1_ICACHE2_PRELOCK_SCT0_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Those bits are used to configure the start virtual address of the first section of prelock on L1-ICache2, which should be used together with L1_ICACHE2_PRELOCK_SCT0_SIZE_REG
                    L1_ICACHE2_PRELOCK_SCT0_ADDR:  u32, 
                    
                }), @ptrFromInt(0x600c805c));
                
                /// L1 instruction Cache 2 prelock section1 address configure register
                pub const L1_ICACHE2_PRELOCK_SCT1_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Those bits are used to configure the start virtual address of the second section of prelock on L1-ICache2, which should be used together with L1_ICACHE2_PRELOCK_SCT1_SIZE_REG
                    L1_ICACHE2_PRELOCK_SCT1_ADDR:  u32, 
                    
                }), @ptrFromInt(0x600c8060));
                
                /// L1 instruction Cache 2 prelock section size configure register
                pub const L1_ICACHE2_PRELOCK_SCT_SIZE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:13] Those bits are used to configure the size of the first section of prelock on L1-ICache2, which should be used together with L1_ICACHE2_PRELOCK_SCT0_ADDR_REG
                    L1_ICACHE2_PRELOCK_SCT0_SIZE:  u14, 
                    
                    /// [14:15] 
                    res0:  u0, 
                    
                    /// [16:29] Those bits are used to configure the size of the second section of prelock on L1-ICache2, which should be used together with L1_ICACHE2_PRELOCK_SCT1_ADDR_REG
                    L1_ICACHE2_PRELOCK_SCT1_SIZE:  u14, 
                    
                    /// [30:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x600c8064));
                
                /// L1 instruction Cache 3 prelock configure register
                pub const L1_ICACHE3_PRELOCK_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] The bit is used to enable the first section of prelock function on L1-ICache3.
                    L1_ICACHE3_PRELOCK_SCT0_EN:  u1, 
                    
                    /// [1:1] The bit is used to enable the second section of prelock function on L1-ICache3.
                    L1_ICACHE3_PRELOCK_SCT1_EN:  u1, 
                    
                    /// [2:5] The bit is used to setthe gid of l1 icache3 prelock.
                    L1_ICACHE3_PRELOCK_RGID:  u4, 
                    
                    /// [6:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600c8068));
                
                /// L1 instruction Cache 3 prelock section0 address configure register
                pub const L1_ICACHE3_PRELOCK_SCT0_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Those bits are used to configure the start virtual address of the first section of prelock on L1-ICache3, which should be used together with L1_ICACHE3_PRELOCK_SCT0_SIZE_REG
                    L1_ICACHE3_PRELOCK_SCT0_ADDR:  u32, 
                    
                }), @ptrFromInt(0x600c806c));
                
                /// L1 instruction Cache 3 prelock section1 address configure register
                pub const L1_ICACHE3_PRELOCK_SCT1_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Those bits are used to configure the start virtual address of the second section of prelock on L1-ICache3, which should be used together with L1_ICACHE3_PRELOCK_SCT1_SIZE_REG
                    L1_ICACHE3_PRELOCK_SCT1_ADDR:  u32, 
                    
                }), @ptrFromInt(0x600c8070));
                
                /// L1 instruction Cache 3 prelock section size configure register
                pub const L1_ICACHE3_PRELOCK_SCT_SIZE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:13] Those bits are used to configure the size of the first section of prelock on L1-ICache3, which should be used together with L1_ICACHE3_PRELOCK_SCT0_ADDR_REG
                    L1_ICACHE3_PRELOCK_SCT0_SIZE:  u14, 
                    
                    /// [14:15] 
                    res0:  u0, 
                    
                    /// [16:29] Those bits are used to configure the size of the second section of prelock on L1-ICache3, which should be used together with L1_ICACHE3_PRELOCK_SCT1_ADDR_REG
                    L1_ICACHE3_PRELOCK_SCT1_SIZE:  u14, 
                    
                    /// [30:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x600c8074));
                
                /// L1 Cache prelock configure register
                pub const L1_CACHE_PRELOCK_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] The bit is used to enable the first section of prelock function on L1-Cache.
                    L1_CACHE_PRELOCK_SCT0_EN:  u1, 
                    
                    /// [1:1] The bit is used to enable the second section of prelock function on L1-Cache.
                    L1_CACHE_PRELOCK_SCT1_EN:  u1, 
                    
                    /// [2:5] The bit is used to setthe gid of l1 cache prelock.
                    L1_CACHE_PRELOCK_RGID:  u4, 
                    
                    /// [6:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600c8078));
                
                /// L1 Cache prelock section0 address configure register
                pub const L1_CACHE_PRELOCK_SCT0_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Those bits are used to configure the start virtual address of the first section of prelock on L1-Cache, which should be used together with L1_CACHE_PRELOCK_SCT0_SIZE_REG
                    L1_CACHE_PRELOCK_SCT0_ADDR:  u32, 
                    
                }), @ptrFromInt(0x600c807c));
                
                /// L1 Cache prelock section1 address configure register
                pub const L1_DCACHE_PRELOCK_SCT1_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Those bits are used to configure the start virtual address of the second section of prelock on L1-Cache, which should be used together with L1_CACHE_PRELOCK_SCT1_SIZE_REG
                    L1_CACHE_PRELOCK_SCT1_ADDR:  u32, 
                    
                }), @ptrFromInt(0x600c8080));
                
                /// L1Cache prelock section size configure register
                pub const L1_DCACHE_PRELOCK_SCT_SIZE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:13] Those bits are used to configure the size of the first section of prelock on L1-Cache, which should be used together with L1_CACHE_PRELOCK_SCT0_ADDR_REG
                    L1_CACHE_PRELOCK_SCT0_SIZE:  u14, 
                    
                    /// [14:15] 
                    res0:  u0, 
                    
                    /// [16:29] Those bits are used to configure the size of the second section of prelock on L1-Cache, which should be used together with L1_CACHE_PRELOCK_SCT1_ADDR_REG
                    L1_CACHE_PRELOCK_SCT1_SIZE:  u14, 
                    
                    /// [30:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x600c8084));
                
                /// Lock-class (manual lock) operation control register
                pub const CACHE_LOCK_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] The bit is used to enable lock operation. It will be cleared by hardware after lock operation done
                    CACHE_LOCK_ENA:  u1, 
                    
                    /// [1:1] The bit is used to enable unlock operation. It will be cleared by hardware after unlock operation done
                    CACHE_UNLOCK_ENA:  u1, 
                    
                    /// [2:2] The bit is used to indicate whether unlock/lock operation is finished or not. 0: not finished. 1: finished.
                    CACHE_LOCK_DONE:  u1, 
                    
                    /// [3:6] The bit is used to setthe gid of cache lock/unlock.
                    CACHE_LOCK_RGID:  u4, 
                    
                    /// [7:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600c8088));
                
                /// Lock (manual lock) map configure register
                pub const CACHE_LOCK_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] Those bits are used to indicate which caches in the two-level cache structure will apply this lock/unlock operation. [4]: L1-Cache
                    CACHE_LOCK_MAP:  u6, 
                    
                    /// [6:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600c808c));
                
                /// Lock (manual lock) address configure register
                pub const CACHE_LOCK_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Those bits are used to configure the start virtual address of the lock/unlock operation, which should be used together with CACHE_LOCK_SIZE_REG
                    CACHE_LOCK_ADDR:  u32, 
                    
                }), @ptrFromInt(0x600c8090));
                
                /// Lock (manual lock) size configure register
                pub const CACHE_LOCK_SIZE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:15] Those bits are used to configure the size of the lock/unlock operation, which should be used together with CACHE_LOCK_ADDR_REG
                    CACHE_LOCK_SIZE:  u16, 
                    
                    /// [16:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600c8094));
                
                /// Sync-class operation control register
                pub const CACHE_SYNC_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] The bit is used to enable invalidate operation. It will be cleared by hardware after invalidate operation done. Note that this bit and the other sync-bits (clean_ena, writeback_ena, writeback_invalidate_ena) are mutually exclusive, that is, those bits can not be set to 1 at the same time.
                    CACHE_INVALIDATE_ENA:  u1, 
                    
                    /// [1:1] The bit is used to enable clean operation. It will be cleared by hardware after clean operation done. Note that this bit and the other sync-bits (invalidate_ena, writeback_ena, writeback_invalidate_ena) are mutually exclusive, that is, those bits can not be set to 1 at the same time.
                    CACHE_CLEAN_ENA:  u1, 
                    
                    /// [2:2] The bit is used to enable writeback operation. It will be cleared by hardware after writeback operation done. Note that this bit and the other sync-bits (invalidate_ena, clean_ena, writeback_invalidate_ena) are mutually exclusive, that is, those bits can not be set to 1 at the same time.
                    CACHE_WRITEBACK_ENA:  u1, 
                    
                    /// [3:3] The bit is used to enable writeback-invalidate operation. It will be cleared by hardware after writeback-invalidate operation done. Note that this bit and the other sync-bits (invalidate_ena, clean_ena, writeback_ena) are mutually exclusive, that is, those bits can not be set to 1 at the same time.
                    CACHE_WRITEBACK_INVALIDATE_ENA:  u1, 
                    
                    /// [4:4] The bit is used to indicate whether sync operation (invalidate, clean, writeback, writeback_invalidate) is finished or not. 0: not finished. 1: finished.
                    CACHE_SYNC_DONE:  u1, 
                    
                    /// [5:8] The bit is used to setthe gid of cache sync operation (invalidate, clean, writeback, writeback_invalidate)
                    CACHE_SYNC_RGID:  u4, 
                    
                    /// [9:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600c8098));
                
                /// Sync map configure register
                pub const CACHE_SYNC_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] Those bits are used to indicate which caches in the two-level cache structure will apply the sync operation.[4]: L1-Cache
                    CACHE_SYNC_MAP:  u6, 
                    
                    /// [6:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600c809c));
                
                /// Sync address configure register
                pub const CACHE_SYNC_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Those bits are used to configure the start virtual address of the sync operation, which should be used together with CACHE_SYNC_SIZE_REG
                    CACHE_SYNC_ADDR:  u32, 
                    
                }), @ptrFromInt(0x600c80a0));
                
                /// Sync size configure register
                pub const CACHE_SYNC_SIZE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:23] Those bits are used to configure the size of the sync operation, which should be used together with CACHE_SYNC_ADDR_REG
                    CACHE_SYNC_SIZE:  u24, 
                    
                    /// [24:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600c80a4));
                
                /// L1 instruction Cache 0 preload-operation control register
                pub const L1_ICACHE0_PRELOAD_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] The bit is used to enable preload operation on L1-ICache0. It will be cleared by hardware automatically after preload operation is done.
                    L1_ICACHE0_PRELOAD_ENA:  u1, 
                    
                    /// [1:1] The bit is used to indicate whether preload operation is finished or not. 0: not finished. 1: finished.
                    L1_ICACHE0_PRELOAD_DONE:  u1, 
                    
                    /// [2:2] The bit is used to configure the direction of preload operation. 0: ascending, 1: descending.
                    L1_ICACHE0_PRELOAD_ORDER:  u1, 
                    
                    /// [3:6] The bit is used to setthe gid of l1 icache0 preload.
                    L1_ICACHE0_PRELOAD_RGID:  u4, 
                    
                    /// [7:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600c80a8));
                
                /// L1 instruction Cache 0 preload address configure register
                pub const L1_ICACHE0_PRELOAD_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Those bits are used to configure the start virtual address of preload on L1-ICache0, which should be used together with L1_ICACHE0_PRELOAD_SIZE_REG
                    L1_ICACHE0_PRELOAD_ADDR:  u32, 
                    
                }), @ptrFromInt(0x600c80ac));
                
                /// L1 instruction Cache 0 preload size configure register
                pub const L1_ICACHE0_PRELOAD_SIZE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:13] Those bits are used to configure the size of the first section of prelock on L1-ICache0, which should be used together with L1_ICACHE0_PRELOAD_ADDR_REG
                    L1_ICACHE0_PRELOAD_SIZE:  u14, 
                    
                    /// [14:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600c80b0));
                
                /// L1 instruction Cache 1 preload-operation control register
                pub const L1_ICACHE1_PRELOAD_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] The bit is used to enable preload operation on L1-ICache1. It will be cleared by hardware automatically after preload operation is done.
                    L1_ICACHE1_PRELOAD_ENA:  u1, 
                    
                    /// [1:1] The bit is used to indicate whether preload operation is finished or not. 0: not finished. 1: finished.
                    L1_ICACHE1_PRELOAD_DONE:  u1, 
                    
                    /// [2:2] The bit is used to configure the direction of preload operation. 0: ascending, 1: descending.
                    L1_ICACHE1_PRELOAD_ORDER:  u1, 
                    
                    /// [3:6] The bit is used to setthe gid of l1 icache1 preload.
                    L1_ICACHE1_PRELOAD_RGID:  u4, 
                    
                    /// [7:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600c80b4));
                
                /// L1 instruction Cache 1 preload address configure register
                pub const L1_ICACHE1_PRELOAD_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Those bits are used to configure the start virtual address of preload on L1-ICache1, which should be used together with L1_ICACHE1_PRELOAD_SIZE_REG
                    L1_ICACHE1_PRELOAD_ADDR:  u32, 
                    
                }), @ptrFromInt(0x600c80b8));
                
                /// L1 instruction Cache 1 preload size configure register
                pub const L1_ICACHE1_PRELOAD_SIZE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:13] Those bits are used to configure the size of the first section of prelock on L1-ICache1, which should be used together with L1_ICACHE1_PRELOAD_ADDR_REG
                    L1_ICACHE1_PRELOAD_SIZE:  u14, 
                    
                    /// [14:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600c80bc));
                
                /// L1 instruction Cache 2 preload-operation control register
                pub const L1_ICACHE2_PRELOAD_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] The bit is used to enable preload operation on L1-ICache2. It will be cleared by hardware automatically after preload operation is done.
                    L1_ICACHE2_PRELOAD_ENA:  u1, 
                    
                    /// [1:1] The bit is used to indicate whether preload operation is finished or not. 0: not finished. 1: finished.
                    L1_ICACHE2_PRELOAD_DONE:  u1, 
                    
                    /// [2:2] The bit is used to configure the direction of preload operation. 0: ascending, 1: descending.
                    L1_ICACHE2_PRELOAD_ORDER:  u1, 
                    
                    /// [3:6] The bit is used to setthe gid of l1 icache2 preload.
                    L1_ICACHE2_PRELOAD_RGID:  u4, 
                    
                    /// [7:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600c80c0));
                
                /// L1 instruction Cache 2 preload address configure register
                pub const L1_ICACHE2_PRELOAD_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Those bits are used to configure the start virtual address of preload on L1-ICache2, which should be used together with L1_ICACHE2_PRELOAD_SIZE_REG
                    L1_ICACHE2_PRELOAD_ADDR:  u32, 
                    
                }), @ptrFromInt(0x600c80c4));
                
                /// L1 instruction Cache 2 preload size configure register
                pub const L1_ICACHE2_PRELOAD_SIZE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:13] Those bits are used to configure the size of the first section of prelock on L1-ICache2, which should be used together with L1_ICACHE2_PRELOAD_ADDR_REG
                    L1_ICACHE2_PRELOAD_SIZE:  u14, 
                    
                    /// [14:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600c80c8));
                
                /// L1 instruction Cache 3 preload-operation control register
                pub const L1_ICACHE3_PRELOAD_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] The bit is used to enable preload operation on L1-ICache3. It will be cleared by hardware automatically after preload operation is done.
                    L1_ICACHE3_PRELOAD_ENA:  u1, 
                    
                    /// [1:1] The bit is used to indicate whether preload operation is finished or not. 0: not finished. 1: finished.
                    L1_ICACHE3_PRELOAD_DONE:  u1, 
                    
                    /// [2:2] The bit is used to configure the direction of preload operation. 0: ascending, 1: descending.
                    L1_ICACHE3_PRELOAD_ORDER:  u1, 
                    
                    /// [3:6] The bit is used to setthe gid of l1 icache3 preload.
                    L1_ICACHE3_PRELOAD_RGID:  u4, 
                    
                    /// [7:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600c80cc));
                
                /// L1 instruction Cache 3 preload address configure register
                pub const L1_ICACHE3_PRELOAD_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Those bits are used to configure the start virtual address of preload on L1-ICache3, which should be used together with L1_ICACHE3_PRELOAD_SIZE_REG
                    L1_ICACHE3_PRELOAD_ADDR:  u32, 
                    
                }), @ptrFromInt(0x600c80d0));
                
                /// L1 instruction Cache 3 preload size configure register
                pub const L1_ICACHE3_PRELOAD_SIZE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:13] Those bits are used to configure the size of the first section of prelock on L1-ICache3, which should be used together with L1_ICACHE3_PRELOAD_ADDR_REG
                    L1_ICACHE3_PRELOAD_SIZE:  u14, 
                    
                    /// [14:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600c80d4));
                
                /// L1 Cachepreload-operation control register
                pub const L1_CACHE_PRELOAD_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] The bit is used to enable preload operation on L1-Cache. It will be cleared by hardware automatically after preload operation is done.
                    L1_CACHE_PRELOAD_ENA:  u1, 
                    
                    /// [1:1] The bit is used to indicate whether preload operation is finished or not. 0: not finished. 1: finished.
                    L1_CACHE_PRELOAD_DONE:  u1, 
                    
                    /// [2:2] The bit is used to configure the direction of preload operation. 0: ascending, 1: descending.
                    L1_CACHE_PRELOAD_ORDER:  u1, 
                    
                    /// [3:6] The bit is used to setthe gid of l1 cache preload.
                    L1_CACHE_PRELOAD_RGID:  u4, 
                    
                    /// [7:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600c80d8));
                
                /// L1 Cachepreload address configure register
                pub const L1_DCACHE_PRELOAD_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Those bits are used to configure the start virtual address of preload on L1-Cache, which should be used together with L1_CACHE_PRELOAD_SIZE_REG
                    L1_CACHE_PRELOAD_ADDR:  u32, 
                    
                }), @ptrFromInt(0x600c80dc));
                
                /// L1 Cachepreload size configure register
                pub const L1_DCACHE_PRELOAD_SIZE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:13] Those bits are used to configure the size of the first section of prelock on L1-Cache, which should be used together with L1_CACHE_PRELOAD_ADDR_REG
                    L1_CACHE_PRELOAD_SIZE:  u14, 
                    
                    /// [14:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600c80e0));
                
                /// L1 instruction Cache 0 autoload-operation control register
                pub const L1_ICACHE0_AUTOLOAD_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] The bit is used to enable and disable autoload operation on L1-ICache0.1: enable, 0: disable.
                    L1_ICACHE0_AUTOLOAD_ENA:  u1, 
                    
                    /// [1:1] The bit is used to indicate whether autoload operation on L1-ICache0 is finished or not. 0: not finished. 1: finished.
                    L1_ICACHE0_AUTOLOAD_DONE:  u1, 
                    
                    /// [2:2] The bit is used to configure the direction of autoload operation on L1-ICache0. 0: ascending. 1: descending.
                    L1_ICACHE0_AUTOLOAD_ORDER:  u1, 
                    
                    /// [3:4] The field is used to configure trigger mode of autoload operation on L1-ICache0. 0/3: miss-trigger, 1: hit-trigger, 2: miss-hit-trigger.
                    L1_ICACHE0_AUTOLOAD_TRIGGER_MODE:  u2, 
                    
                    /// [5:7] 
                    res0:  u0, 
                    
                    /// [8:8] The bit is used to enable the first section for autoload operation on L1-ICache0.
                    L1_ICACHE0_AUTOLOAD_SCT0_ENA:  u1, 
                    
                    /// [9:9] The bit is used to enable the second section for autoload operation on L1-ICache0.
                    L1_ICACHE0_AUTOLOAD_SCT1_ENA:  u1, 
                    
                    /// [10:13] The bit is used to setthe gid of l1 icache0 autoload.
                    L1_ICACHE0_AUTOLOAD_RGID:  u4, 
                    
                    /// [14:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x600c80e4));
                
                /// L1 instruction Cache 0 autoload section 0 address configure register
                pub const L1_ICACHE0_AUTOLOAD_SCT0_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Those bits are used to configure the start virtual address of the first section for autoload operation on L1-ICache0. Note that it should be used together with L1_ICACHE0_AUTOLOAD_SCT0_SIZE and L1_ICACHE_AUTOLOAD_SCT0_ENA.
                    L1_ICACHE0_AUTOLOAD_SCT0_ADDR:  u32, 
                    
                }), @ptrFromInt(0x600c80e8));
                
                /// L1 instruction Cache 0 autoload section 0 size configure register
                pub const L1_ICACHE0_AUTOLOAD_SCT0_SIZE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:27] Those bits are used to configure the size of the first section for autoload operation on L1-ICache0. Note that it should be used together with L1_ICACHE0_AUTOLOAD_SCT0_ADDR and L1_ICACHE_AUTOLOAD_SCT0_ENA.
                    L1_ICACHE0_AUTOLOAD_SCT0_SIZE:  u28, 
                    
                    /// [28:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600c80ec));
                
                /// L1 instruction Cache 0 autoload section 1 address configure register
                pub const L1_ICACHE0_AUTOLOAD_SCT1_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Those bits are used to configure the start virtual address of the second section for autoload operation on L1-ICache0. Note that it should be used together with L1_ICACHE0_AUTOLOAD_SCT1_SIZE and L1_ICACHE_AUTOLOAD_SCT1_ENA.
                    L1_ICACHE0_AUTOLOAD_SCT1_ADDR:  u32, 
                    
                }), @ptrFromInt(0x600c80f0));
                
                /// L1 instruction Cache 0 autoload section 1 size configure register
                pub const L1_ICACHE0_AUTOLOAD_SCT1_SIZE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:27] Those bits are used to configure the size of the second section for autoload operation on L1-ICache0. Note that it should be used together with L1_ICACHE0_AUTOLOAD_SCT1_ADDR and L1_ICACHE_AUTOLOAD_SCT1_ENA.
                    L1_ICACHE0_AUTOLOAD_SCT1_SIZE:  u28, 
                    
                    /// [28:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600c80f4));
                
                /// L1 instruction Cache 1 autoload-operation control register
                pub const L1_ICACHE1_AUTOLOAD_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] The bit is used to enable and disable autoload operation on L1-ICache1.1: enable, 0: disable.
                    L1_ICACHE1_AUTOLOAD_ENA:  u1, 
                    
                    /// [1:1] The bit is used to indicate whether autoload operation on L1-ICache1 is finished or not. 0: not finished. 1: finished.
                    L1_ICACHE1_AUTOLOAD_DONE:  u1, 
                    
                    /// [2:2] The bit is used to configure the direction of autoload operation on L1-ICache1. 0: ascending. 1: descending.
                    L1_ICACHE1_AUTOLOAD_ORDER:  u1, 
                    
                    /// [3:4] The field is used to configure trigger mode of autoload operation on L1-ICache1. 0/3: miss-trigger, 1: hit-trigger, 2: miss-hit-trigger.
                    L1_ICACHE1_AUTOLOAD_TRIGGER_MODE:  u2, 
                    
                    /// [5:7] 
                    res0:  u0, 
                    
                    /// [8:8] The bit is used to enable the first section for autoload operation on L1-ICache1.
                    L1_ICACHE1_AUTOLOAD_SCT0_ENA:  u1, 
                    
                    /// [9:9] The bit is used to enable the second section for autoload operation on L1-ICache1.
                    L1_ICACHE1_AUTOLOAD_SCT1_ENA:  u1, 
                    
                    /// [10:13] The bit is used to setthe gid of l1 icache1 autoload.
                    L1_ICACHE1_AUTOLOAD_RGID:  u4, 
                    
                    /// [14:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x600c80f8));
                
                /// L1 instruction Cache 1 autoload section 0 address configure register
                pub const L1_ICACHE1_AUTOLOAD_SCT0_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Those bits are used to configure the start virtual address of the first section for autoload operation on L1-ICache1. Note that it should be used together with L1_ICACHE1_AUTOLOAD_SCT0_SIZE and L1_ICACHE_AUTOLOAD_SCT0_ENA.
                    L1_ICACHE1_AUTOLOAD_SCT0_ADDR:  u32, 
                    
                }), @ptrFromInt(0x600c80fc));
                
                /// L1 instruction Cache 1 autoload section 0 size configure register
                pub const L1_ICACHE1_AUTOLOAD_SCT0_SIZE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:27] Those bits are used to configure the size of the first section for autoload operation on L1-ICache1. Note that it should be used together with L1_ICACHE1_AUTOLOAD_SCT0_ADDR and L1_ICACHE_AUTOLOAD_SCT0_ENA.
                    L1_ICACHE1_AUTOLOAD_SCT0_SIZE:  u28, 
                    
                    /// [28:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600c8100));
                
                /// L1 instruction Cache 1 autoload section 1 address configure register
                pub const L1_ICACHE1_AUTOLOAD_SCT1_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Those bits are used to configure the start virtual address of the second section for autoload operation on L1-ICache1. Note that it should be used together with L1_ICACHE1_AUTOLOAD_SCT1_SIZE and L1_ICACHE_AUTOLOAD_SCT1_ENA.
                    L1_ICACHE1_AUTOLOAD_SCT1_ADDR:  u32, 
                    
                }), @ptrFromInt(0x600c8104));
                
                /// L1 instruction Cache 1 autoload section 1 size configure register
                pub const L1_ICACHE1_AUTOLOAD_SCT1_SIZE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:27] Those bits are used to configure the size of the second section for autoload operation on L1-ICache1. Note that it should be used together with L1_ICACHE1_AUTOLOAD_SCT1_ADDR and L1_ICACHE_AUTOLOAD_SCT1_ENA.
                    L1_ICACHE1_AUTOLOAD_SCT1_SIZE:  u28, 
                    
                    /// [28:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600c8108));
                
                /// L1 instruction Cache 2 autoload-operation control register
                pub const L1_ICACHE2_AUTOLOAD_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] The bit is used to enable and disable autoload operation on L1-ICache2.1: enable, 0: disable.
                    L1_ICACHE2_AUTOLOAD_ENA:  u1, 
                    
                    /// [1:1] The bit is used to indicate whether autoload operation on L1-ICache2 is finished or not. 0: not finished. 1: finished.
                    L1_ICACHE2_AUTOLOAD_DONE:  u1, 
                    
                    /// [2:2] The bit is used to configure the direction of autoload operation on L1-ICache2. 0: ascending. 1: descending.
                    L1_ICACHE2_AUTOLOAD_ORDER:  u1, 
                    
                    /// [3:4] The field is used to configure trigger mode of autoload operation on L1-ICache2. 0/3: miss-trigger, 1: hit-trigger, 2: miss-hit-trigger.
                    L1_ICACHE2_AUTOLOAD_TRIGGER_MODE:  u2, 
                    
                    /// [5:7] 
                    res0:  u0, 
                    
                    /// [8:8] The bit is used to enable the first section for autoload operation on L1-ICache2.
                    L1_ICACHE2_AUTOLOAD_SCT0_ENA:  u1, 
                    
                    /// [9:9] The bit is used to enable the second section for autoload operation on L1-ICache2.
                    L1_ICACHE2_AUTOLOAD_SCT1_ENA:  u1, 
                    
                    /// [10:13] The bit is used to setthe gid of l1 icache2 autoload.
                    L1_ICACHE2_AUTOLOAD_RGID:  u4, 
                    
                    /// [14:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x600c810c));
                
                /// L1 instruction Cache 2 autoload section 0 address configure register
                pub const L1_ICACHE2_AUTOLOAD_SCT0_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Those bits are used to configure the start virtual address of the first section for autoload operation on L1-ICache2. Note that it should be used together with L1_ICACHE2_AUTOLOAD_SCT0_SIZE and L1_ICACHE_AUTOLOAD_SCT0_ENA.
                    L1_ICACHE2_AUTOLOAD_SCT0_ADDR:  u32, 
                    
                }), @ptrFromInt(0x600c8110));
                
                /// L1 instruction Cache 2 autoload section 0 size configure register
                pub const L1_ICACHE2_AUTOLOAD_SCT0_SIZE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:27] Those bits are used to configure the size of the first section for autoload operation on L1-ICache2. Note that it should be used together with L1_ICACHE2_AUTOLOAD_SCT0_ADDR and L1_ICACHE_AUTOLOAD_SCT0_ENA.
                    L1_ICACHE2_AUTOLOAD_SCT0_SIZE:  u28, 
                    
                    /// [28:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600c8114));
                
                /// L1 instruction Cache 2 autoload section 1 address configure register
                pub const L1_ICACHE2_AUTOLOAD_SCT1_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Those bits are used to configure the start virtual address of the second section for autoload operation on L1-ICache2. Note that it should be used together with L1_ICACHE2_AUTOLOAD_SCT1_SIZE and L1_ICACHE_AUTOLOAD_SCT1_ENA.
                    L1_ICACHE2_AUTOLOAD_SCT1_ADDR:  u32, 
                    
                }), @ptrFromInt(0x600c8118));
                
                /// L1 instruction Cache 2 autoload section 1 size configure register
                pub const L1_ICACHE2_AUTOLOAD_SCT1_SIZE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:27] Those bits are used to configure the size of the second section for autoload operation on L1-ICache2. Note that it should be used together with L1_ICACHE2_AUTOLOAD_SCT1_ADDR and L1_ICACHE_AUTOLOAD_SCT1_ENA.
                    L1_ICACHE2_AUTOLOAD_SCT1_SIZE:  u28, 
                    
                    /// [28:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600c811c));
                
                /// L1 instruction Cache 3 autoload-operation control register
                pub const L1_ICACHE3_AUTOLOAD_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] The bit is used to enable and disable autoload operation on L1-ICache3.1: enable, 0: disable.
                    L1_ICACHE3_AUTOLOAD_ENA:  u1, 
                    
                    /// [1:1] The bit is used to indicate whether autoload operation on L1-ICache3 is finished or not. 0: not finished. 1: finished.
                    L1_ICACHE3_AUTOLOAD_DONE:  u1, 
                    
                    /// [2:2] The bit is used to configure the direction of autoload operation on L1-ICache3. 0: ascending. 1: descending.
                    L1_ICACHE3_AUTOLOAD_ORDER:  u1, 
                    
                    /// [3:4] The field is used to configure trigger mode of autoload operation on L1-ICache3. 0/3: miss-trigger, 1: hit-trigger, 2: miss-hit-trigger.
                    L1_ICACHE3_AUTOLOAD_TRIGGER_MODE:  u2, 
                    
                    /// [5:7] 
                    res0:  u0, 
                    
                    /// [8:8] The bit is used to enable the first section for autoload operation on L1-ICache3.
                    L1_ICACHE3_AUTOLOAD_SCT0_ENA:  u1, 
                    
                    /// [9:9] The bit is used to enable the second section for autoload operation on L1-ICache3.
                    L1_ICACHE3_AUTOLOAD_SCT1_ENA:  u1, 
                    
                    /// [10:13] The bit is used to setthe gid of l1 icache3 autoload.
                    L1_ICACHE3_AUTOLOAD_RGID:  u4, 
                    
                    /// [14:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x600c8120));
                
                /// L1 instruction Cache 3 autoload section 0 address configure register
                pub const L1_ICACHE3_AUTOLOAD_SCT0_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Those bits are used to configure the start virtual address of the first section for autoload operation on L1-ICache3. Note that it should be used together with L1_ICACHE3_AUTOLOAD_SCT0_SIZE and L1_ICACHE_AUTOLOAD_SCT0_ENA.
                    L1_ICACHE3_AUTOLOAD_SCT0_ADDR:  u32, 
                    
                }), @ptrFromInt(0x600c8124));
                
                /// L1 instruction Cache 3 autoload section 0 size configure register
                pub const L1_ICACHE3_AUTOLOAD_SCT0_SIZE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:27] Those bits are used to configure the size of the first section for autoload operation on L1-ICache3. Note that it should be used together with L1_ICACHE3_AUTOLOAD_SCT0_ADDR and L1_ICACHE_AUTOLOAD_SCT0_ENA.
                    L1_ICACHE3_AUTOLOAD_SCT0_SIZE:  u28, 
                    
                    /// [28:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600c8128));
                
                /// L1 instruction Cache 3 autoload section 1 address configure register
                pub const L1_ICACHE3_AUTOLOAD_SCT1_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Those bits are used to configure the start virtual address of the second section for autoload operation on L1-ICache3. Note that it should be used together with L1_ICACHE3_AUTOLOAD_SCT1_SIZE and L1_ICACHE_AUTOLOAD_SCT1_ENA.
                    L1_ICACHE3_AUTOLOAD_SCT1_ADDR:  u32, 
                    
                }), @ptrFromInt(0x600c812c));
                
                /// L1 instruction Cache 3 autoload section 1 size configure register
                pub const L1_ICACHE3_AUTOLOAD_SCT1_SIZE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:27] Reserved
                    L1_ICACHE3_AUTOLOAD_SCT1_SIZE:  u28, 
                    
                    /// [28:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600c8130));
                
                /// L1 Cache autoload-operation control register
                pub const L1_CACHE_AUTOLOAD_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] The bit is used to enable and disable autoload operation on L1-Cache.1: enable, 0: disable.
                    L1_CACHE_AUTOLOAD_ENA:  u1, 
                    
                    /// [1:1] The bit is used to indicate whether autoload operation on L1-Cache is finished or not. 0: not finished. 1: finished.
                    L1_CACHE_AUTOLOAD_DONE:  u1, 
                    
                    /// [2:2] The bit is used to configure the direction of autoload operation on L1-Cache. 0: ascending. 1: descending.
                    L1_CACHE_AUTOLOAD_ORDER:  u1, 
                    
                    /// [3:4] The field is used to configure trigger mode of autoload operation on L1-Cache. 0/3: miss-trigger, 1: hit-trigger, 2: miss-hit-trigger.
                    L1_CACHE_AUTOLOAD_TRIGGER_MODE:  u2, 
                    
                    /// [5:7] 
                    res0:  u0, 
                    
                    /// [8:8] The bit is used to enable the first section for autoload operation on L1-Cache.
                    L1_CACHE_AUTOLOAD_SCT0_ENA:  u1, 
                    
                    /// [9:9] The bit is used to enable the second section for autoload operation on L1-Cache.
                    L1_CACHE_AUTOLOAD_SCT1_ENA:  u1, 
                    
                    /// [10:10] The bit is used to enable the third section for autoload operation on L1-Cache.
                    L1_CACHE_AUTOLOAD_SCT2_ENA:  u1, 
                    
                    /// [11:11] The bit is used to enable the fourth section for autoload operation on L1-Cache.
                    L1_CACHE_AUTOLOAD_SCT3_ENA:  u1, 
                    
                    /// [12:15] The bit is used to setthe gid of l1 cache autoload.
                    L1_CACHE_AUTOLOAD_RGID:  u4, 
                    
                    /// [16:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x600c8134));
                
                /// L1 Cache autoload section 0 address configure register
                pub const L1_CACHE_AUTOLOAD_SCT0_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Those bits are used to configure the start virtual address of the first section for autoload operation on L1-Cache. Note that it should be used together with L1_CACHE_AUTOLOAD_SCT0_SIZE and L1_CACHE_AUTOLOAD_SCT0_ENA.
                    L1_CACHE_AUTOLOAD_SCT0_ADDR:  u32, 
                    
                }), @ptrFromInt(0x600c8138));
                
                /// L1 Cache autoload section 0 size configure register
                pub const L1_CACHE_AUTOLOAD_SCT0_SIZE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:27] Those bits are used to configure the size of the first section for autoload operation on L1-Cache. Note that it should be used together with L1_CACHE_AUTOLOAD_SCT0_ADDR and L1_CACHE_AUTOLOAD_SCT0_ENA.
                    L1_CACHE_AUTOLOAD_SCT0_SIZE:  u28, 
                    
                    /// [28:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600c813c));
                
                /// L1 Cache autoload section 1 address configure register
                pub const L1_CACHE_AUTOLOAD_SCT1_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Those bits are used to configure the start virtual address of the second section for autoload operation on L1-Cache. Note that it should be used together with L1_CACHE_AUTOLOAD_SCT1_SIZE and L1_CACHE_AUTOLOAD_SCT1_ENA.
                    L1_CACHE_AUTOLOAD_SCT1_ADDR:  u32, 
                    
                }), @ptrFromInt(0x600c8140));
                
                /// L1 Cache autoload section 1 size configure register
                pub const L1_CACHE_AUTOLOAD_SCT1_SIZE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:27] Those bits are used to configure the size of the second section for autoload operation on L1-Cache. Note that it should be used together with L1_CACHE_AUTOLOAD_SCT1_ADDR and L1_CACHE_AUTOLOAD_SCT1_ENA.
                    L1_CACHE_AUTOLOAD_SCT1_SIZE:  u28, 
                    
                    /// [28:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600c8144));
                
                /// L1 Cache autoload section 2 address configure register
                pub const L1_CACHE_AUTOLOAD_SCT2_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Those bits are used to configure the start virtual address of the third section for autoload operation on L1-Cache. Note that it should be used together with L1_CACHE_AUTOLOAD_SCT2_SIZE and L1_CACHE_AUTOLOAD_SCT2_ENA.
                    L1_CACHE_AUTOLOAD_SCT2_ADDR:  u32, 
                    
                }), @ptrFromInt(0x600c8148));
                
                /// L1 Cache autoload section 2 size configure register
                pub const L1_CACHE_AUTOLOAD_SCT2_SIZE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:27] Those bits are used to configure the size of the third section for autoload operation on L1-Cache. Note that it should be used together with L1_CACHE_AUTOLOAD_SCT2_ADDR and L1_CACHE_AUTOLOAD_SCT2_ENA.
                    L1_CACHE_AUTOLOAD_SCT2_SIZE:  u28, 
                    
                    /// [28:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600c814c));
                
                /// L1 Cache autoload section 1 address configure register
                pub const L1_CACHE_AUTOLOAD_SCT3_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Those bits are used to configure the start virtual address of the fourth section for autoload operation on L1-Cache. Note that it should be used together with L1_CACHE_AUTOLOAD_SCT3_SIZE and L1_CACHE_AUTOLOAD_SCT3_ENA.
                    L1_CACHE_AUTOLOAD_SCT3_ADDR:  u32, 
                    
                }), @ptrFromInt(0x600c8150));
                
                /// L1 Cache autoload section 1 size configure register
                pub const L1_CACHE_AUTOLOAD_SCT3_SIZE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:27] Those bits are used to configure the size of the fourth section for autoload operation on L1-Cache. Note that it should be used together with L1_CACHE_AUTOLOAD_SCT3_ADDR and L1_CACHE_AUTOLOAD_SCT3_ENA.
                    L1_CACHE_AUTOLOAD_SCT3_SIZE:  u28, 
                    
                    /// [28:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600c8154));
                
                /// Cache Access Counter Interrupt enable register
                pub const L1_CACHE_ACS_CNT_INT_ENA = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] The bit is used to enable interrupt of one of counters overflow that occurs in L1-ICache0 due to bus0 accesses L1-ICache0.
                    L1_IBUS0_OVF_INT_ENA:  u1, 
                    
                    /// [1:1] The bit is used to enable interrupt of one of counters overflow that occurs in L1-ICache1 due to bus1 accesses L1-ICache1.
                    L1_IBUS1_OVF_INT_ENA:  u1, 
                    
                    /// [2:2] Reserved
                    L1_IBUS2_OVF_INT_ENA:  u1, 
                    
                    /// [3:3] Reserved
                    L1_IBUS3_OVF_INT_ENA:  u1, 
                    
                    /// [4:4] The bit is used to enable interrupt of one of counters overflow that occurs in L1-DCache due to bus0 accesses L1-DCache.
                    L1_BUS0_OVF_INT_ENA:  u1, 
                    
                    /// [5:5] The bit is used to enable interrupt of one of counters overflow that occurs in L1-DCache due to bus1 accesses L1-DCache.
                    L1_BUS1_OVF_INT_ENA:  u1, 
                    
                    /// [6:6] Reserved
                    L1_DBUS2_OVF_INT_ENA:  u1, 
                    
                    /// [7:7] Reserved
                    L1_DBUS3_OVF_INT_ENA:  u1, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600c8158));
                
                /// Cache Access Counter Interrupt clear register
                pub const L1_CACHE_ACS_CNT_INT_CLR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] The bit is used to clear counters overflow interrupt and counters in L1-ICache0 due to bus0 accesses L1-ICache0.
                    L1_IBUS0_OVF_INT_CLR:  u1, 
                    
                    /// [1:1] The bit is used to clear counters overflow interrupt and counters in L1-ICache1 due to bus1 accesses L1-ICache1.
                    L1_IBUS1_OVF_INT_CLR:  u1, 
                    
                    /// [2:2] Reserved
                    L1_IBUS2_OVF_INT_CLR:  u1, 
                    
                    /// [3:3] Reserved
                    L1_IBUS3_OVF_INT_CLR:  u1, 
                    
                    /// [4:4] The bit is used to clear counters overflow interrupt and counters in L1-DCache due to bus0 accesses L1-DCache.
                    L1_BUS0_OVF_INT_CLR:  u1, 
                    
                    /// [5:5] The bit is used to clear counters overflow interrupt and counters in L1-DCache due to bus1 accesses L1-DCache.
                    L1_BUS1_OVF_INT_CLR:  u1, 
                    
                    /// [6:6] Reserved
                    L1_DBUS2_OVF_INT_CLR:  u1, 
                    
                    /// [7:7] Reserved
                    L1_DBUS3_OVF_INT_CLR:  u1, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600c815c));
                
                /// Cache Access Counter Interrupt raw register
                pub const L1_CACHE_ACS_CNT_INT_RAW = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] The raw bit of the interrupt of one of counters overflow that occurs in L1-ICache0 due to bus0 accesses L1-ICache0.
                    L1_IBUS0_OVF_INT_RAW:  u1, 
                    
                    /// [1:1] The raw bit of the interrupt of one of counters overflow that occurs in L1-ICache1 due to bus1 accesses L1-ICache1.
                    L1_IBUS1_OVF_INT_RAW:  u1, 
                    
                    /// [2:2] The raw bit of the interrupt of one of counters overflow that occurs in L1-ICache2 due to bus2 accesses L1-ICache2.
                    L1_IBUS2_OVF_INT_RAW:  u1, 
                    
                    /// [3:3] The raw bit of the interrupt of one of counters overflow that occurs in L1-ICache3 due to bus3 accesses L1-ICache3.
                    L1_IBUS3_OVF_INT_RAW:  u1, 
                    
                    /// [4:4] The raw bit of the interrupt of one of counters overflow that occurs in L1-DCache due to bus0 accesses L1-DCache.
                    L1_BUS0_OVF_INT_RAW:  u1, 
                    
                    /// [5:5] The raw bit of the interrupt of one of counters overflow that occurs in L1-DCache due to bus1 accesses L1-DCache.
                    L1_BUS1_OVF_INT_RAW:  u1, 
                    
                    /// [6:6] The raw bit of the interrupt of one of counters overflow that occurs in L1-DCache due to bus2 accesses L1-DCache.
                    L1_DBUS2_OVF_INT_RAW:  u1, 
                    
                    /// [7:7] The raw bit of the interrupt of one of counters overflow that occurs in L1-DCache due to bus3 accesses L1-DCache.
                    L1_DBUS3_OVF_INT_RAW:  u1, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600c8160));
                
                /// Cache Access Counter Interrupt status register
                pub const L1_CACHE_ACS_CNT_INT_ST = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] The bit indicates the interrupt status of one of counters overflow that occurs in L1-ICache0 due to bus0 accesses L1-ICache0.
                    L1_IBUS0_OVF_INT_ST:  u1, 
                    
                    /// [1:1] The bit indicates the interrupt status of one of counters overflow that occurs in L1-ICache1 due to bus1 accesses L1-ICache1.
                    L1_IBUS1_OVF_INT_ST:  u1, 
                    
                    /// [2:2] Reserved
                    L1_IBUS2_OVF_INT_ST:  u1, 
                    
                    /// [3:3] Reserved
                    L1_IBUS3_OVF_INT_ST:  u1, 
                    
                    /// [4:4] The bit indicates the interrupt status of one of counters overflow that occurs in L1-DCache due to bus0 accesses L1-DCache.
                    L1_BUS0_OVF_INT_ST:  u1, 
                    
                    /// [5:5] The bit indicates the interrupt status of one of counters overflow that occurs in L1-DCache due to bus1 accesses L1-DCache.
                    L1_BUS1_OVF_INT_ST:  u1, 
                    
                    /// [6:6] Reserved
                    L1_DBUS2_OVF_INT_ST:  u1, 
                    
                    /// [7:7] Reserved
                    L1_DBUS3_OVF_INT_ST:  u1, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600c8164));
                
                /// Cache Access Fail Interrupt enable register
                pub const L1_CACHE_ACS_FAIL_INT_ENA = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] The bit is used to enable interrupt of access fail that occurs in L1-ICache0 due to cpu accesses L1-ICache0.
                    L1_ICACHE0_FAIL_INT_ENA:  u1, 
                    
                    /// [1:1] The bit is used to enable interrupt of access fail that occurs in L1-ICache1 due to cpu accesses L1-ICache1.
                    L1_ICACHE1_FAIL_INT_ENA:  u1, 
                    
                    /// [2:2] Reserved
                    L1_ICACHE2_FAIL_INT_ENA:  u1, 
                    
                    /// [3:3] Reserved
                    L1_ICACHE3_FAIL_INT_ENA:  u1, 
                    
                    /// [4:4] The bit is used to enable interrupt of access fail that occurs in L1-DCache due to cpu accesses L1-DCache.
                    L1_CACHE_FAIL_INT_ENA:  u1, 
                    
                    /// [5:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600c8168));
                
                /// L1-Cache Access Fail Interrupt clear register
                pub const L1_CACHE_ACS_FAIL_INT_CLR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] The bit is used to clear interrupt of access fail that occurs in L1-ICache0 due to cpu accesses L1-ICache0.
                    L1_ICACHE0_FAIL_INT_CLR:  u1, 
                    
                    /// [1:1] The bit is used to clear interrupt of access fail that occurs in L1-ICache1 due to cpu accesses L1-ICache1.
                    L1_ICACHE1_FAIL_INT_CLR:  u1, 
                    
                    /// [2:2] Reserved
                    L1_ICACHE2_FAIL_INT_CLR:  u1, 
                    
                    /// [3:3] Reserved
                    L1_ICACHE3_FAIL_INT_CLR:  u1, 
                    
                    /// [4:4] The bit is used to clear interrupt of access fail that occurs in L1-DCache due to cpu accesses L1-DCache.
                    L1_CACHE_FAIL_INT_CLR:  u1, 
                    
                    /// [5:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600c816c));
                
                /// Cache Access Fail Interrupt raw register
                pub const L1_CACHE_ACS_FAIL_INT_RAW = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] The raw bit of the interrupt of access fail that occurs in L1-ICache0.
                    L1_ICACHE0_FAIL_INT_RAW:  u1, 
                    
                    /// [1:1] The raw bit of the interrupt of access fail that occurs in L1-ICache1.
                    L1_ICACHE1_FAIL_INT_RAW:  u1, 
                    
                    /// [2:2] The raw bit of the interrupt of access fail that occurs in L1-ICache2.
                    L1_ICACHE2_FAIL_INT_RAW:  u1, 
                    
                    /// [3:3] The raw bit of the interrupt of access fail that occurs in L1-ICache3.
                    L1_ICACHE3_FAIL_INT_RAW:  u1, 
                    
                    /// [4:4] The raw bit of the interrupt of access fail that occurs in L1-DCache.
                    L1_CACHE_FAIL_INT_RAW:  u1, 
                    
                    /// [5:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600c8170));
                
                /// Cache Access Fail Interrupt status register
                pub const L1_CACHE_ACS_FAIL_INT_ST = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] The bit indicates the interrupt status of access fail that occurs in L1-ICache0 due to cpu accesses L1-ICache.
                    L1_ICACHE0_FAIL_INT_ST:  u1, 
                    
                    /// [1:1] The bit indicates the interrupt status of access fail that occurs in L1-ICache1 due to cpu accesses L1-ICache.
                    L1_ICACHE1_FAIL_INT_ST:  u1, 
                    
                    /// [2:2] Reserved
                    L1_ICACHE2_FAIL_INT_ST:  u1, 
                    
                    /// [3:3] Reserved
                    L1_ICACHE3_FAIL_INT_ST:  u1, 
                    
                    /// [4:4] The bit indicates the interrupt status of access fail that occurs in L1-DCache due to cpu accesses L1-DCache.
                    L1_CACHE_FAIL_INT_ST:  u1, 
                    
                    /// [5:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600c8174));
                
                /// Cache Access Counter enable and clear register
                pub const L1_CACHE_ACS_CNT_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] The bit is used to enable ibus0 counter in L1-ICache0.
                    L1_IBUS0_CNT_ENA:  u1, 
                    
                    /// [1:1] The bit is used to enable ibus1 counter in L1-ICache1.
                    L1_IBUS1_CNT_ENA:  u1, 
                    
                    /// [2:2] Reserved
                    L1_IBUS2_CNT_ENA:  u1, 
                    
                    /// [3:3] Reserved
                    L1_IBUS3_CNT_ENA:  u1, 
                    
                    /// [4:4] The bit is used to enable dbus0 counter in L1-DCache.
                    L1_BUS0_CNT_ENA:  u1, 
                    
                    /// [5:5] The bit is used to enable dbus1 counter in L1-DCache.
                    L1_BUS1_CNT_ENA:  u1, 
                    
                    /// [6:6] Reserved
                    L1_DBUS2_CNT_ENA:  u1, 
                    
                    /// [7:7] Reserved
                    L1_DBUS3_CNT_ENA:  u1, 
                    
                    /// [8:15] 
                    res0:  u0, 
                    
                    /// [16:16] The bit is used to clear ibus0 counter in L1-ICache0.
                    L1_IBUS0_CNT_CLR:  u1, 
                    
                    /// [17:17] The bit is used to clear ibus1 counter in L1-ICache1.
                    L1_IBUS1_CNT_CLR:  u1, 
                    
                    /// [18:18] Reserved
                    L1_IBUS2_CNT_CLR:  u1, 
                    
                    /// [19:19] Reserved
                    L1_IBUS3_CNT_CLR:  u1, 
                    
                    /// [20:20] The bit is used to clear dbus0 counter in L1-DCache.
                    L1_BUS0_CNT_CLR:  u1, 
                    
                    /// [21:21] The bit is used to clear dbus1 counter in L1-DCache.
                    L1_BUS1_CNT_CLR:  u1, 
                    
                    /// [22:22] Reserved
                    L1_DBUS2_CNT_CLR:  u1, 
                    
                    /// [23:23] Reserved
                    L1_DBUS3_CNT_CLR:  u1, 
                    
                    /// [24:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x600c8178));
                
                /// L1-ICache bus0 Hit-Access Counter register
                pub const L1_IBUS0_ACS_HIT_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] The register records the number of hits when bus0 accesses L1-ICache0.
                    L1_IBUS0_HIT_CNT:  u32, 
                    
                }), @ptrFromInt(0x600c817c));
                
                /// L1-ICache bus0 Miss-Access Counter register
                pub const L1_IBUS0_ACS_MISS_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] The register records the number of missing when bus0 accesses L1-ICache0.
                    L1_IBUS0_MISS_CNT:  u32, 
                    
                }), @ptrFromInt(0x600c8180));
                
                /// L1-ICache bus0 Conflict-Access Counter register
                pub const L1_IBUS0_ACS_CONFLICT_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] The register records the number of access-conflicts when bus0 accesses L1-ICache0.
                    L1_IBUS0_CONFLICT_CNT:  u32, 
                    
                }), @ptrFromInt(0x600c8184));
                
                /// L1-ICache bus0 Next-Level-Access Counter register
                pub const L1_IBUS0_ACS_NXTLVL_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] The register records the number of times that L1-ICache accesses L2-Cache due to bus0 accessing L1-ICache0.
                    L1_IBUS0_NXTLVL_CNT:  u32, 
                    
                }), @ptrFromInt(0x600c8188));
                
                /// L1-ICache bus1 Hit-Access Counter register
                pub const L1_IBUS1_ACS_HIT_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] The register records the number of hits when bus1 accesses L1-ICache1.
                    L1_IBUS1_HIT_CNT:  u32, 
                    
                }), @ptrFromInt(0x600c818c));
                
                /// L1-ICache bus1 Miss-Access Counter register
                pub const L1_IBUS1_ACS_MISS_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] The register records the number of missing when bus1 accesses L1-ICache1.
                    L1_IBUS1_MISS_CNT:  u32, 
                    
                }), @ptrFromInt(0x600c8190));
                
                /// L1-ICache bus1 Conflict-Access Counter register
                pub const L1_IBUS1_ACS_CONFLICT_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] The register records the number of access-conflicts when bus1 accesses L1-ICache1.
                    L1_IBUS1_CONFLICT_CNT:  u32, 
                    
                }), @ptrFromInt(0x600c8194));
                
                /// L1-ICache bus1 Next-Level-Access Counter register
                pub const L1_IBUS1_ACS_NXTLVL_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] The register records the number of times that L1-ICache accesses L2-Cache due to bus1 accessing L1-ICache1.
                    L1_IBUS1_NXTLVL_CNT:  u32, 
                    
                }), @ptrFromInt(0x600c8198));
                
                /// L1-ICache bus2 Hit-Access Counter register
                pub const L1_IBUS2_ACS_HIT_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] The register records the number of hits when bus2 accesses L1-ICache2.
                    L1_IBUS2_HIT_CNT:  u32, 
                    
                }), @ptrFromInt(0x600c819c));
                
                /// L1-ICache bus2 Miss-Access Counter register
                pub const L1_IBUS2_ACS_MISS_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] The register records the number of missing when bus2 accesses L1-ICache2.
                    L1_IBUS2_MISS_CNT:  u32, 
                    
                }), @ptrFromInt(0x600c81a0));
                
                /// L1-ICache bus2 Conflict-Access Counter register
                pub const L1_IBUS2_ACS_CONFLICT_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] The register records the number of access-conflicts when bus2 accesses L1-ICache2.
                    L1_IBUS2_CONFLICT_CNT:  u32, 
                    
                }), @ptrFromInt(0x600c81a4));
                
                /// L1-ICache bus2 Next-Level-Access Counter register
                pub const L1_IBUS2_ACS_NXTLVL_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] The register records the number of times that L1-ICache accesses L2-Cache due to bus2 accessing L1-ICache2.
                    L1_IBUS2_NXTLVL_CNT:  u32, 
                    
                }), @ptrFromInt(0x600c81a8));
                
                /// L1-ICache bus3 Hit-Access Counter register
                pub const L1_IBUS3_ACS_HIT_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] The register records the number of hits when bus3 accesses L1-ICache3.
                    L1_IBUS3_HIT_CNT:  u32, 
                    
                }), @ptrFromInt(0x600c81ac));
                
                /// L1-ICache bus3 Miss-Access Counter register
                pub const L1_IBUS3_ACS_MISS_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] The register records the number of missing when bus3 accesses L1-ICache3.
                    L1_IBUS3_MISS_CNT:  u32, 
                    
                }), @ptrFromInt(0x600c81b0));
                
                /// L1-ICache bus3 Conflict-Access Counter register
                pub const L1_IBUS3_ACS_CONFLICT_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] The register records the number of access-conflicts when bus3 accesses L1-ICache3.
                    L1_IBUS3_CONFLICT_CNT:  u32, 
                    
                }), @ptrFromInt(0x600c81b4));
                
                /// L1-ICache bus3 Next-Level-Access Counter register
                pub const L1_IBUS3_ACS_NXTLVL_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] The register records the number of times that L1-ICache accesses L2-Cache due to bus3 accessing L1-ICache3.
                    L1_IBUS3_NXTLVL_CNT:  u32, 
                    
                }), @ptrFromInt(0x600c81b8));
                
                /// L1-Cache bus0 Hit-Access Counter register
                pub const L1_BUS0_ACS_HIT_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] The register records the number of hits when bus0 accesses L1-Cache.
                    L1_BUS0_HIT_CNT:  u32, 
                    
                }), @ptrFromInt(0x600c81bc));
                
                /// L1-Cache bus0 Miss-Access Counter register
                pub const L1_BUS0_ACS_MISS_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] The register records the number of missing when bus0 accesses L1-Cache.
                    L1_BUS0_MISS_CNT:  u32, 
                    
                }), @ptrFromInt(0x600c81c0));
                
                /// L1-Cache bus0 Conflict-Access Counter register
                pub const L1_BUS0_ACS_CONFLICT_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] The register records the number of access-conflicts when bus0 accesses L1-Cache.
                    L1_BUS0_CONFLICT_CNT:  u32, 
                    
                }), @ptrFromInt(0x600c81c4));
                
                /// L1-Cache bus0 Next-Level-Access Counter register
                pub const L1_BUS0_ACS_NXTLVL_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] The register records the number of times that L1-Cache accesses L2-Cache due to bus0 accessing L1-Cache.
                    L1_BUS0_NXTLVL_CNT:  u32, 
                    
                }), @ptrFromInt(0x600c81c8));
                
                /// L1-Cache bus1 Hit-Access Counter register
                pub const L1_BUS1_ACS_HIT_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] The register records the number of hits when bus1 accesses L1-Cache.
                    L1_BUS1_HIT_CNT:  u32, 
                    
                }), @ptrFromInt(0x600c81cc));
                
                /// L1-Cache bus1 Miss-Access Counter register
                pub const L1_BUS1_ACS_MISS_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] The register records the number of missing when bus1 accesses L1-Cache.
                    L1_BUS1_MISS_CNT:  u32, 
                    
                }), @ptrFromInt(0x600c81d0));
                
                /// L1-Cache bus1 Conflict-Access Counter register
                pub const L1_BUS1_ACS_CONFLICT_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] The register records the number of access-conflicts when bus1 accesses L1-Cache.
                    L1_BUS1_CONFLICT_CNT:  u32, 
                    
                }), @ptrFromInt(0x600c81d4));
                
                /// L1-Cache bus1 Next-Level-Access Counter register
                pub const L1_BUS1_ACS_NXTLVL_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] The register records the number of times that L1-Cache accesses L2-Cache due to bus1 accessing L1-Cache.
                    L1_BUS1_NXTLVL_CNT:  u32, 
                    
                }), @ptrFromInt(0x600c81d8));
                
                /// L1-DCache bus2 Hit-Access Counter register
                pub const L1_DBUS2_ACS_HIT_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] The register records the number of hits when bus2 accesses L1-DCache.
                    L1_DBUS2_HIT_CNT:  u32, 
                    
                }), @ptrFromInt(0x600c81dc));
                
                /// L1-DCache bus2 Miss-Access Counter register
                pub const L1_DBUS2_ACS_MISS_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] The register records the number of missing when bus2 accesses L1-DCache.
                    L1_DBUS2_MISS_CNT:  u32, 
                    
                }), @ptrFromInt(0x600c81e0));
                
                /// L1-DCache bus2 Conflict-Access Counter register
                pub const L1_DBUS2_ACS_CONFLICT_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] The register records the number of access-conflicts when bus2 accesses L1-DCache.
                    L1_DBUS2_CONFLICT_CNT:  u32, 
                    
                }), @ptrFromInt(0x600c81e4));
                
                /// L1-DCache bus2 Next-Level-Access Counter register
                pub const L1_DBUS2_ACS_NXTLVL_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] The register records the number of times that L1-DCache accesses L2-Cache due to bus2 accessing L1-DCache.
                    L1_DBUS2_NXTLVL_CNT:  u32, 
                    
                }), @ptrFromInt(0x600c81e8));
                
                /// L1-DCache bus3 Hit-Access Counter register
                pub const L1_DBUS3_ACS_HIT_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] The register records the number of hits when bus3 accesses L1-DCache.
                    L1_DBUS3_HIT_CNT:  u32, 
                    
                }), @ptrFromInt(0x600c81ec));
                
                /// L1-DCache bus3 Miss-Access Counter register
                pub const L1_DBUS3_ACS_MISS_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] The register records the number of missing when bus3 accesses L1-DCache.
                    L1_DBUS3_MISS_CNT:  u32, 
                    
                }), @ptrFromInt(0x600c81f0));
                
                /// L1-DCache bus3 Conflict-Access Counter register
                pub const L1_DBUS3_ACS_CONFLICT_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] The register records the number of access-conflicts when bus3 accesses L1-DCache.
                    L1_DBUS3_CONFLICT_CNT:  u32, 
                    
                }), @ptrFromInt(0x600c81f4));
                
                /// L1-DCache bus3 Next-Level-Access Counter register
                pub const L1_DBUS3_ACS_NXTLVL_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] The register records the number of times that L1-DCache accesses L2-Cache due to bus3 accessing L1-DCache.
                    L1_DBUS3_NXTLVL_CNT:  u32, 
                    
                }), @ptrFromInt(0x600c81f8));
                
                /// L1-ICache0 Access Fail ID/attribution information register
                pub const L1_ICACHE0_ACS_FAIL_ID_ATTR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:15] The register records the ID of fail-access when cache0 accesses L1-ICache.
                    L1_ICACHE0_FAIL_ID:  u16, 
                    
                    /// [16:31] The register records the attribution of fail-access when cache0 accesses L1-ICache.
                    L1_ICACHE0_FAIL_ATTR:  u16, 
                    
                }), @ptrFromInt(0x600c81fc));
                
                /// L1-ICache0 Access Fail Address information register
                pub const L1_ICACHE0_ACS_FAIL_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] The register records the address of fail-access when cache0 accesses L1-ICache.
                    L1_ICACHE0_FAIL_ADDR:  u32, 
                    
                }), @ptrFromInt(0x600c8200));
                
                /// L1-ICache0 Access Fail ID/attribution information register
                pub const L1_ICACHE1_ACS_FAIL_ID_ATTR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:15] The register records the ID of fail-access when cache1 accesses L1-ICache.
                    L1_ICACHE1_FAIL_ID:  u16, 
                    
                    /// [16:31] The register records the attribution of fail-access when cache1 accesses L1-ICache.
                    L1_ICACHE1_FAIL_ATTR:  u16, 
                    
                }), @ptrFromInt(0x600c8204));
                
                /// L1-ICache0 Access Fail Address information register
                pub const L1_ICACHE1_ACS_FAIL_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] The register records the address of fail-access when cache1 accesses L1-ICache.
                    L1_ICACHE1_FAIL_ADDR:  u32, 
                    
                }), @ptrFromInt(0x600c8208));
                
                /// L1-ICache0 Access Fail ID/attribution information register
                pub const L1_ICACHE2_ACS_FAIL_ID_ATTR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:15] The register records the ID of fail-access when cache2 accesses L1-ICache.
                    L1_ICACHE2_FAIL_ID:  u16, 
                    
                    /// [16:31] The register records the attribution of fail-access when cache2 accesses L1-ICache.
                    L1_ICACHE2_FAIL_ATTR:  u16, 
                    
                }), @ptrFromInt(0x600c820c));
                
                /// L1-ICache0 Access Fail Address information register
                pub const L1_ICACHE2_ACS_FAIL_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] The register records the address of fail-access when cache2 accesses L1-ICache.
                    L1_ICACHE2_FAIL_ADDR:  u32, 
                    
                }), @ptrFromInt(0x600c8210));
                
                /// L1-ICache0 Access Fail ID/attribution information register
                pub const L1_ICACHE3_ACS_FAIL_ID_ATTR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:15] The register records the ID of fail-access when cache3 accesses L1-ICache.
                    L1_ICACHE3_FAIL_ID:  u16, 
                    
                    /// [16:31] The register records the attribution of fail-access when cache3 accesses L1-ICache.
                    L1_ICACHE3_FAIL_ATTR:  u16, 
                    
                }), @ptrFromInt(0x600c8214));
                
                /// L1-ICache0 Access Fail Address information register
                pub const L1_ICACHE3_ACS_FAIL_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] The register records the address of fail-access when cache3 accesses L1-ICache.
                    L1_ICACHE3_FAIL_ADDR:  u32, 
                    
                }), @ptrFromInt(0x600c8218));
                
                /// L1-Cache Access Fail ID/attribution information register
                pub const L1_CACHE_ACS_FAIL_ID_ATTR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:15] The register records the ID of fail-access when cache accesses L1-Cache.
                    L1_CACHE_FAIL_ID:  u16, 
                    
                    /// [16:31] The register records the attribution of fail-access when cache accesses L1-Cache.
                    L1_CACHE_FAIL_ATTR:  u16, 
                    
                }), @ptrFromInt(0x600c821c));
                
                /// L1-Cache Access Fail Address information register
                pub const L1_DCACHE_ACS_FAIL_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] The register records the address of fail-access when cache accesses L1-Cache.
                    L1_CACHE_FAIL_ADDR:  u32, 
                    
                }), @ptrFromInt(0x600c8220));
                
                /// L1-Cache Access Fail Interrupt enable register
                pub const L1_CACHE_SYNC_PRELOAD_INT_ENA = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] The bit is used to enable interrupt of L1-ICache0 preload-operation. If preload operation is done, interrupt occurs.
                    L1_ICACHE0_PLD_DONE_INT_ENA:  u1, 
                    
                    /// [1:1] The bit is used to enable interrupt of L1-ICache1 preload-operation. If preload operation is done, interrupt occurs.
                    L1_ICACHE1_PLD_DONE_INT_ENA:  u1, 
                    
                    /// [2:2] Reserved
                    L1_ICACHE2_PLD_DONE_INT_ENA:  u1, 
                    
                    /// [3:3] Reserved
                    L1_ICACHE3_PLD_DONE_INT_ENA:  u1, 
                    
                    /// [4:4] The bit is used to enable interrupt of L1-Cache preload-operation. If preload operation is done, interrupt occurs.
                    L1_CACHE_PLD_DONE_INT_ENA:  u1, 
                    
                    /// [5:5] 
                    res0:  u0, 
                    
                    /// [6:6] The bit is used to enable interrupt of Cache sync-operation done.
                    CACHE_SYNC_DONE_INT_ENA:  u1, 
                    
                    /// [7:7] The bit is used to enable interrupt of L1-ICache0 preload-operation error.
                    L1_ICACHE0_PLD_ERR_INT_ENA:  u1, 
                    
                    /// [8:8] The bit is used to enable interrupt of L1-ICache1 preload-operation error.
                    L1_ICACHE1_PLD_ERR_INT_ENA:  u1, 
                    
                    /// [9:9] Reserved
                    L1_ICACHE2_PLD_ERR_INT_ENA:  u1, 
                    
                    /// [10:10] Reserved
                    L1_ICACHE3_PLD_ERR_INT_ENA:  u1, 
                    
                    /// [11:11] The bit is used to enable interrupt of L1-Cache preload-operation error.
                    L1_CACHE_PLD_ERR_INT_ENA:  u1, 
                    
                    /// [12:12] 
                    res1:  u0, 
                    
                    /// [13:13] The bit is used to enable interrupt of Cache sync-operation error.
                    CACHE_SYNC_ERR_INT_ENA:  u1, 
                    
                    /// [14:31] 
                    res2:  u0, 
                    
                }), @ptrFromInt(0x600c8224));
                
                /// Sync Preload operation Interrupt clear register
                pub const L1_CACHE_SYNC_PRELOAD_INT_CLR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] The bit is used to clear interrupt that occurs only when L1-ICache0 preload-operation is done.
                    L1_ICACHE0_PLD_DONE_INT_CLR:  u1, 
                    
                    /// [1:1] The bit is used to clear interrupt that occurs only when L1-ICache1 preload-operation is done.
                    L1_ICACHE1_PLD_DONE_INT_CLR:  u1, 
                    
                    /// [2:2] Reserved
                    L1_ICACHE2_PLD_DONE_INT_CLR:  u1, 
                    
                    /// [3:3] Reserved
                    L1_ICACHE3_PLD_DONE_INT_CLR:  u1, 
                    
                    /// [4:4] The bit is used to clear interrupt that occurs only when L1-Cache preload-operation is done.
                    L1_CACHE_PLD_DONE_INT_CLR:  u1, 
                    
                    /// [5:5] 
                    res0:  u0, 
                    
                    /// [6:6] The bit is used to clear interrupt that occurs only when Cache sync-operation is done.
                    CACHE_SYNC_DONE_INT_CLR:  u1, 
                    
                    /// [7:7] The bit is used to clear interrupt of L1-ICache0 preload-operation error.
                    L1_ICACHE0_PLD_ERR_INT_CLR:  u1, 
                    
                    /// [8:8] The bit is used to clear interrupt of L1-ICache1 preload-operation error.
                    L1_ICACHE1_PLD_ERR_INT_CLR:  u1, 
                    
                    /// [9:9] Reserved
                    L1_ICACHE2_PLD_ERR_INT_CLR:  u1, 
                    
                    /// [10:10] Reserved
                    L1_ICACHE3_PLD_ERR_INT_CLR:  u1, 
                    
                    /// [11:11] The bit is used to clear interrupt of L1-Cache preload-operation error.
                    L1_CACHE_PLD_ERR_INT_CLR:  u1, 
                    
                    /// [12:12] 
                    res1:  u0, 
                    
                    /// [13:13] The bit is used to clear interrupt of Cache sync-operation error.
                    CACHE_SYNC_ERR_INT_CLR:  u1, 
                    
                    /// [14:31] 
                    res2:  u0, 
                    
                }), @ptrFromInt(0x600c8228));
                
                /// Sync Preload operation Interrupt raw register
                pub const L1_CACHE_SYNC_PRELOAD_INT_RAW = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] The raw bit of the interrupt that occurs only when L1-ICache0 preload-operation is done.
                    L1_ICACHE0_PLD_DONE_INT_RAW:  u1, 
                    
                    /// [1:1] The raw bit of the interrupt that occurs only when L1-ICache1 preload-operation is done.
                    L1_ICACHE1_PLD_DONE_INT_RAW:  u1, 
                    
                    /// [2:2] Reserved
                    L1_ICACHE2_PLD_DONE_INT_RAW:  u1, 
                    
                    /// [3:3] Reserved
                    L1_ICACHE3_PLD_DONE_INT_RAW:  u1, 
                    
                    /// [4:4] The raw bit of the interrupt that occurs only when L1-Cache preload-operation is done.
                    L1_CACHE_PLD_DONE_INT_RAW:  u1, 
                    
                    /// [5:5] 
                    res0:  u0, 
                    
                    /// [6:6] The raw bit of the interrupt that occurs only when Cache sync-operation is done.
                    CACHE_SYNC_DONE_INT_RAW:  u1, 
                    
                    /// [7:7] The raw bit of the interrupt that occurs only when L1-ICache0 preload-operation error occurs.
                    L1_ICACHE0_PLD_ERR_INT_RAW:  u1, 
                    
                    /// [8:8] The raw bit of the interrupt that occurs only when L1-ICache1 preload-operation error occurs.
                    L1_ICACHE1_PLD_ERR_INT_RAW:  u1, 
                    
                    /// [9:9] Reserved
                    L1_ICACHE2_PLD_ERR_INT_RAW:  u1, 
                    
                    /// [10:10] Reserved
                    L1_ICACHE3_PLD_ERR_INT_RAW:  u1, 
                    
                    /// [11:11] The raw bit of the interrupt that occurs only when L1-Cache preload-operation error occurs.
                    L1_CACHE_PLD_ERR_INT_RAW:  u1, 
                    
                    /// [12:12] 
                    res1:  u0, 
                    
                    /// [13:13] The raw bit of the interrupt that occurs only when Cache sync-operation error occurs.
                    CACHE_SYNC_ERR_INT_RAW:  u1, 
                    
                    /// [14:31] 
                    res2:  u0, 
                    
                }), @ptrFromInt(0x600c822c));
                
                /// L1-Cache Access Fail Interrupt status register
                pub const L1_CACHE_SYNC_PRELOAD_INT_ST = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] The bit indicates the status of the interrupt that occurs only when L1-ICache0 preload-operation is done.
                    L1_ICACHE0_PLD_DONE_INT_ST:  u1, 
                    
                    /// [1:1] The bit indicates the status of the interrupt that occurs only when L1-ICache1 preload-operation is done.
                    L1_ICACHE1_PLD_DONE_INT_ST:  u1, 
                    
                    /// [2:2] Reserved
                    L1_ICACHE2_PLD_DONE_INT_ST:  u1, 
                    
                    /// [3:3] Reserved
                    L1_ICACHE3_PLD_DONE_INT_ST:  u1, 
                    
                    /// [4:4] The bit indicates the status of the interrupt that occurs only when L1-Cache preload-operation is done.
                    L1_CACHE_PLD_DONE_INT_ST:  u1, 
                    
                    /// [5:5] 
                    res0:  u0, 
                    
                    /// [6:6] The bit indicates the status of the interrupt that occurs only when Cache sync-operation is done.
                    CACHE_SYNC_DONE_INT_ST:  u1, 
                    
                    /// [7:7] The bit indicates the status of the interrupt of L1-ICache0 preload-operation error.
                    L1_ICACHE0_PLD_ERR_INT_ST:  u1, 
                    
                    /// [8:8] The bit indicates the status of the interrupt of L1-ICache1 preload-operation error.
                    L1_ICACHE1_PLD_ERR_INT_ST:  u1, 
                    
                    /// [9:9] Reserved
                    L1_ICACHE2_PLD_ERR_INT_ST:  u1, 
                    
                    /// [10:10] Reserved
                    L1_ICACHE3_PLD_ERR_INT_ST:  u1, 
                    
                    /// [11:11] The bit indicates the status of the interrupt of L1-Cache preload-operation error.
                    L1_CACHE_PLD_ERR_INT_ST:  u1, 
                    
                    /// [12:12] 
                    res1:  u0, 
                    
                    /// [13:13] The bit indicates the status of the interrupt of Cache sync-operation error.
                    CACHE_SYNC_ERR_INT_ST:  u1, 
                    
                    /// [14:31] 
                    res2:  u0, 
                    
                }), @ptrFromInt(0x600c8230));
                
                /// Cache Sync/Preload Operation exception register
                pub const L1_CACHE_SYNC_PRELOAD_EXCEPTION = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:1] The value 2 is Only available which means preload size is error in L1-ICache0.
                    L1_ICACHE0_PLD_ERR_CODE:  u2, 
                    
                    /// [2:3] The value 2 is Only available which means preload size is error in L1-ICache1.
                    L1_ICACHE1_PLD_ERR_CODE:  u2, 
                    
                    /// [4:5] Reserved
                    L1_ICACHE2_PLD_ERR_CODE:  u2, 
                    
                    /// [6:7] Reserved
                    L1_ICACHE3_PLD_ERR_CODE:  u2, 
                    
                    /// [8:9] The value 2 is Only available which means preload size is error in L1-Cache.
                    L1_CACHE_PLD_ERR_CODE:  u2, 
                    
                    /// [10:11] 
                    res0:  u0, 
                    
                    /// [12:13] The values 0-2 are available which means sync map, command conflict and size are error in Cache System.
                    CACHE_SYNC_ERR_CODE:  u2, 
                    
                    /// [14:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x600c8234));
                
                /// Cache Sync Reset control register
                pub const L1_CACHE_SYNC_RST_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] set this bit to reset sync-logic inside L1-ICache0. Recommend that this should only be used to initialize sync-logic when some fatal error of sync-logic occurs.
                    L1_ICACHE0_SYNC_RST:  u1, 
                    
                    /// [1:1] set this bit to reset sync-logic inside L1-ICache1. Recommend that this should only be used to initialize sync-logic when some fatal error of sync-logic occurs.
                    L1_ICACHE1_SYNC_RST:  u1, 
                    
                    /// [2:2] Reserved
                    L1_ICACHE2_SYNC_RST:  u1, 
                    
                    /// [3:3] Reserved
                    L1_ICACHE3_SYNC_RST:  u1, 
                    
                    /// [4:4] set this bit to reset sync-logic inside L1-Cache. Recommend that this should only be used to initialize sync-logic when some fatal error of sync-logic occurs.
                    L1_CACHE_SYNC_RST:  u1, 
                    
                    /// [5:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600c8238));
                
                /// Cache Preload Reset control register
                pub const L1_CACHE_PRELOAD_RST_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] set this bit to reset preload-logic inside L1-ICache0. Recommend that this should only be used to initialize preload-logic when some fatal error of preload-logic occurs.
                    L1_ICACHE0_PLD_RST:  u1, 
                    
                    /// [1:1] set this bit to reset preload-logic inside L1-ICache1. Recommend that this should only be used to initialize preload-logic when some fatal error of preload-logic occurs.
                    L1_ICACHE1_PLD_RST:  u1, 
                    
                    /// [2:2] Reserved
                    L1_ICACHE2_PLD_RST:  u1, 
                    
                    /// [3:3] Reserved
                    L1_ICACHE3_PLD_RST:  u1, 
                    
                    /// [4:4] set this bit to reset preload-logic inside L1-Cache. Recommend that this should only be used to initialize preload-logic when some fatal error of preload-logic occurs.
                    L1_CACHE_PLD_RST:  u1, 
                    
                    /// [5:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600c823c));
                
                /// Cache Autoload buffer clear control register
                pub const L1_CACHE_AUTOLOAD_BUF_CLR_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] set this bit to clear autoload-buffer inside L1-ICache0. If this bit is active, autoload will not work in L1-ICache0. This bit should not be active when autoload works in L1-ICache0.
                    L1_ICACHE0_ALD_BUF_CLR:  u1, 
                    
                    /// [1:1] set this bit to clear autoload-buffer inside L1-ICache1. If this bit is active, autoload will not work in L1-ICache1. This bit should not be active when autoload works in L1-ICache1.
                    L1_ICACHE1_ALD_BUF_CLR:  u1, 
                    
                    /// [2:2] Reserved
                    L1_ICACHE2_ALD_BUF_CLR:  u1, 
                    
                    /// [3:3] Reserved
                    L1_ICACHE3_ALD_BUF_CLR:  u1, 
                    
                    /// [4:4] set this bit to clear autoload-buffer inside L1-Cache. If this bit is active, autoload will not work in L1-Cache. This bit should not be active when autoload works in L1-Cache.
                    L1_CACHE_ALD_BUF_CLR:  u1, 
                    
                    /// [5:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600c8240));
                
                /// Unallocate request buffer clear registers
                pub const L1_UNALLOCATE_BUFFER_CLEAR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] The bit is used to clear the unallocate request buffer of l1 icache0 where the unallocate request is responsed but not completed.
                    L1_ICACHE0_UNALLOC_CLR:  u1, 
                    
                    /// [1:1] The bit is used to clear the unallocate request buffer of l1 icache1 where the unallocate request is responsed but not completed.
                    L1_ICACHE1_UNALLOC_CLR:  u1, 
                    
                    /// [2:2] Reserved
                    L1_ICACHE2_UNALLOC_CLR:  u1, 
                    
                    /// [3:3] Reserved
                    L1_ICACHE3_UNALLOC_CLR:  u1, 
                    
                    /// [4:4] The bit is used to clear the unallocate request buffer of l1 cache where the unallocate request is responsed but not completed.
                    L1_CACHE_UNALLOC_CLR:  u1, 
                    
                    /// [5:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600c8244));
                
                /// Cache Tag and Data memory Object control register
                pub const L1_CACHE_OBJECT_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Set this bit to set L1-ICache0 tag memory as object. This bit should be onehot with the others fields inside this register.
                    L1_ICACHE0_TAG_OBJECT:  u1, 
                    
                    /// [1:1] Set this bit to set L1-ICache1 tag memory as object. This bit should be onehot with the others fields inside this register.
                    L1_ICACHE1_TAG_OBJECT:  u1, 
                    
                    /// [2:2] Reserved
                    L1_ICACHE2_TAG_OBJECT:  u1, 
                    
                    /// [3:3] Reserved
                    L1_ICACHE3_TAG_OBJECT:  u1, 
                    
                    /// [4:4] Set this bit to set L1-Cache tag memory as object. This bit should be onehot with the others fields inside this register.
                    L1_CACHE_TAG_OBJECT:  u1, 
                    
                    /// [5:5] 
                    res0:  u0, 
                    
                    /// [6:6] Set this bit to set L1-ICache0 data memory as object. This bit should be onehot with the others fields inside this register.
                    L1_ICACHE0_MEM_OBJECT:  u1, 
                    
                    /// [7:7] Set this bit to set L1-ICache1 data memory as object. This bit should be onehot with the others fields inside this register.
                    L1_ICACHE1_MEM_OBJECT:  u1, 
                    
                    /// [8:8] Reserved
                    L1_ICACHE2_MEM_OBJECT:  u1, 
                    
                    /// [9:9] Reserved
                    L1_ICACHE3_MEM_OBJECT:  u1, 
                    
                    /// [10:10] Set this bit to set L1-Cache data memory as object. This bit should be onehot with the others fields inside this register.
                    L1_CACHE_MEM_OBJECT:  u1, 
                    
                    /// [11:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x600c8248));
                
                /// Cache Tag and Data memory way register
                pub const L1_CACHE_WAY_OBJECT = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:2] Set this bits to select which way of the tag-object will be accessed. 0: way0, 1: way1, 2: way2, 3: way3, ?, 7: way7.
                    L1_CACHE_WAY_OBJECT:  u3, 
                    
                    /// [3:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600c824c));
                
                /// Cache Vaddr register
                pub const L1_CACHE_VADDR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Those bits stores the virtual address which will decide where inside the specified tag memory object will be accessed.
                    L1_CACHE_VADDR:  u32, 
                    
                }), @ptrFromInt(0x600c8250));
                
                /// Cache Tag/data memory content register
                pub const L1_CACHE_DEBUG_BUS = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] This is a constant place where we can write data to or read data from the tag/data memory on the specified cache.
                    L1_CACHE_DEBUG_BUS:  u32, 
                    
                }), @ptrFromInt(0x600c8254));
                
                /// USED TO SPLIT L1 CACHE AND L2 CACHE
                pub const LEVEL_SPLIT0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Reserved
                    LEVEL_SPLIT0:  u32, 
                    
                }), @ptrFromInt(0x600c8258));
                
                /// L2 Cache(L2-Cache) control register
                pub const L2_CACHE_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:3] 
                    res0:  u0, 
                    
                    /// [4:4] The bit is used to disable DMA access L2-Cache, 0: enable, 1: disable
                    L2_CACHE_SHUT_DMA:  u1, 
                    
                    /// [5:8] Reserved
                    L2_CACHE_UNDEF_OP:  u4, 
                    
                    /// [9:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x600c825c));
                
                /// Bypass Cache configure register
                pub const L2_BYPASS_CACHE_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:4] 
                    res0:  u0, 
                    
                    /// [5:5] The bit is used to enable bypass L2-Cache. 0: disable bypass, 1: enable bypass.
                    BYPASS_L2_CACHE_EN:  u1, 
                    
                    /// [6:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x600c8260));
                
                /// L2 Cache CacheSize mode configure register
                pub const L2_CACHE_CACHESIZE_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] The field is used to configure cachesize of L2-Cache as 1k bytes. This field and all other fields within this register is onehot.
                    L2_CACHE_CACHESIZE_1K:  u1, 
                    
                    /// [1:1] The field is used to configure cachesize of L2-Cache as 2k bytes. This field and all other fields within this register is onehot.
                    L2_CACHE_CACHESIZE_2K:  u1, 
                    
                    /// [2:2] The field is used to configure cachesize of L2-Cache as 4k bytes. This field and all other fields within this register is onehot.
                    L2_CACHE_CACHESIZE_4K:  u1, 
                    
                    /// [3:3] The field is used to configure cachesize of L2-Cache as 8k bytes. This field and all other fields within this register is onehot.
                    L2_CACHE_CACHESIZE_8K:  u1, 
                    
                    /// [4:4] The field is used to configure cachesize of L2-Cache as 16k bytes. This field and all other fields within this register is onehot.
                    L2_CACHE_CACHESIZE_16K:  u1, 
                    
                    /// [5:5] The field is used to configure cachesize of L2-Cache as 32k bytes. This field and all other fields within this register is onehot.
                    L2_CACHE_CACHESIZE_32K:  u1, 
                    
                    /// [6:6] The field is used to configure cachesize of L2-Cache as 64k bytes. This field and all other fields within this register is onehot.
                    L2_CACHE_CACHESIZE_64K:  u1, 
                    
                    /// [7:7] The field is used to configure cachesize of L2-Cache as 128k bytes. This field and all other fields within this register is onehot.
                    L2_CACHE_CACHESIZE_128K:  u1, 
                    
                    /// [8:8] The field is used to configure cachesize of L2-Cache as 256k bytes. This field and all other fields within this register is onehot.
                    L2_CACHE_CACHESIZE_256K:  u1, 
                    
                    /// [9:9] The field is used to configure cachesize of L2-Cache as 512k bytes. This field and all other fields within this register is onehot.
                    L2_CACHE_CACHESIZE_512K:  u1, 
                    
                    /// [10:10] The field is used to configure cachesize of L2-Cache as 1024k bytes. This field and all other fields within this register is onehot.
                    L2_CACHE_CACHESIZE_1024K:  u1, 
                    
                    /// [11:11] The field is used to configure cachesize of L2-Cache as 2048k bytes. This field and all other fields within this register is onehot.
                    L2_CACHE_CACHESIZE_2048K:  u1, 
                    
                    /// [12:12] The field is used to configure cachesize of L2-Cache as 4096k bytes. This field and all other fields within this register is onehot.
                    L2_CACHE_CACHESIZE_4096K:  u1, 
                    
                    /// [13:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600c8264));
                
                /// L2 Cache BlockSize mode configure register
                pub const L2_CACHE_BLOCKSIZE_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] The field is used to configureblocksize of L2-Cache as 8 bytes. This field and all other fields within this register is onehot.
                    L2_CACHE_BLOCKSIZE_8:  u1, 
                    
                    /// [1:1] The field is used to configureblocksize of L2-Cache as 16 bytes. This field and all other fields within this register is onehot.
                    L2_CACHE_BLOCKSIZE_16:  u1, 
                    
                    /// [2:2] The field is used to configureblocksize of L2-Cache as 32 bytes. This field and all other fields within this register is onehot.
                    L2_CACHE_BLOCKSIZE_32:  u1, 
                    
                    /// [3:3] The field is used to configureblocksize of L2-Cache as 64 bytes. This field and all other fields within this register is onehot.
                    L2_CACHE_BLOCKSIZE_64:  u1, 
                    
                    /// [4:4] The field is used to configureblocksize of L2-Cache as 128 bytes. This field and all other fields within this register is onehot.
                    L2_CACHE_BLOCKSIZE_128:  u1, 
                    
                    /// [5:5] The field is used to configureblocksize of L2-Cache as 256 bytes. This field and all other fields within this register is onehot.
                    L2_CACHE_BLOCKSIZE_256:  u1, 
                    
                    /// [6:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600c8268));
                
                /// Cache wrap around control register
                pub const L2_CACHE_WRAP_AROUND_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:4] 
                    res0:  u0, 
                    
                    /// [5:5] Set this bit as 1 to enable L2-Cache wrap around mode.
                    L2_CACHE_WRAP:  u1, 
                    
                    /// [6:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x600c826c));
                
                /// Cache tag memory power control register
                pub const L2_CACHE_TAG_MEM_POWER_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:19] 
                    res0:  u0, 
                    
                    /// [20:20] The bit is used to close clock gating ofL2-Cache tag memory. 1: close gating, 0: open clock gating.
                    L2_CACHE_TAG_MEM_FORCE_ON:  u1, 
                    
                    /// [21:21] The bit is used to power L2-Cache tag memory down. 0: follow rtc_lslp, 1: power down
                    L2_CACHE_TAG_MEM_FORCE_PD:  u1, 
                    
                    /// [22:22] The bit is used to power L2-Cache tag memory up. 0: follow rtc_lslp, 1: power up
                    L2_CACHE_TAG_MEM_FORCE_PU:  u1, 
                    
                    /// [23:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x600c8270));
                
                /// Cache data memory power control register
                pub const L2_CACHE_DATA_MEM_POWER_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:19] 
                    res0:  u0, 
                    
                    /// [20:20] The bit is used to close clock gating ofL2-Cache data memory. 1: close gating, 0: open clock gating.
                    L2_CACHE_DATA_MEM_FORCE_ON:  u1, 
                    
                    /// [21:21] The bit is used to power L2-Cache data memory down. 0: follow rtc_lslp, 1: power down
                    L2_CACHE_DATA_MEM_FORCE_PD:  u1, 
                    
                    /// [22:22] The bit is used to power L2-Cache data memory up. 0: follow rtc_lslp, 1: power up
                    L2_CACHE_DATA_MEM_FORCE_PU:  u1, 
                    
                    /// [23:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x600c8274));
                
                /// Cache Freeze control register
                pub const L2_CACHE_FREEZE_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:19] 
                    res0:  u0, 
                    
                    /// [20:20] The bit is used to enable freeze operation on L2-Cache. It can be cleared by software.
                    L2_CACHE_FREEZE_EN:  u1, 
                    
                    /// [21:21] The bit is used to configure mode of freeze operation L2-Cache. 0: a miss-access will not stuck. 1: a miss-access will stuck.
                    L2_CACHE_FREEZE_MODE:  u1, 
                    
                    /// [22:22] The bit is used to indicate whether freeze operation on L2-Cache is finished or not. 0: not finished. 1: finished.
                    L2_CACHE_FREEZE_DONE:  u1, 
                    
                    /// [23:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x600c8278));
                
                /// Cache data memory access configure register
                pub const L2_CACHE_DATA_MEM_ACS_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:19] 
                    res0:  u0, 
                    
                    /// [20:20] The bit is used to enable config-bus read L2-Cache data memoryory. 0: disable, 1: enable.
                    L2_CACHE_DATA_MEM_RD_EN:  u1, 
                    
                    /// [21:21] The bit is used to enable config-bus write L2-Cache data memoryory. 0: disable, 1: enable.
                    L2_CACHE_DATA_MEM_WR_EN:  u1, 
                    
                    /// [22:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x600c827c));
                
                /// Cache tag memory access configure register
                pub const L2_CACHE_TAG_MEM_ACS_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:19] 
                    res0:  u0, 
                    
                    /// [20:20] The bit is used to enable config-bus read L2-Cache tag memoryory. 0: disable, 1: enable.
                    L2_CACHE_TAG_MEM_RD_EN:  u1, 
                    
                    /// [21:21] The bit is used to enable config-bus write L2-Cache tag memoryory. 0: disable, 1: enable.
                    L2_CACHE_TAG_MEM_WR_EN:  u1, 
                    
                    /// [22:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x600c8280));
                
                /// L2 Cache prelock configure register
                pub const L2_CACHE_PRELOCK_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] The bit is used to enable the first section of prelock function on L2-Cache.
                    L2_CACHE_PRELOCK_SCT0_EN:  u1, 
                    
                    /// [1:1] The bit is used to enable the second section of prelock function on L2-Cache.
                    L2_CACHE_PRELOCK_SCT1_EN:  u1, 
                    
                    /// [2:5] The bit is used to setthe gid of l2 cache prelock.
                    L2_CACHE_PRELOCK_RGID:  u4, 
                    
                    /// [6:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600c8284));
                
                /// L2 Cache prelock section0 address configure register
                pub const L2_CACHE_PRELOCK_SCT0_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Those bits are used to configure the start virtual address of the first section of prelock on L2-Cache, which should be used together with L2_CACHE_PRELOCK_SCT0_SIZE_REG
                    L2_CACHE_PRELOCK_SCT0_ADDR:  u32, 
                    
                }), @ptrFromInt(0x600c8288));
                
                /// L2 Cache prelock section1 address configure register
                pub const L2_CACHE_PRELOCK_SCT1_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Those bits are used to configure the start virtual address of the second section of prelock on L2-Cache, which should be used together with L2_CACHE_PRELOCK_SCT1_SIZE_REG
                    L2_CACHE_PRELOCK_SCT1_ADDR:  u32, 
                    
                }), @ptrFromInt(0x600c828c));
                
                /// L2 Cache prelock section size configure register
                pub const L2_CACHE_PRELOCK_SCT_SIZE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:15] Those bits are used to configure the size of the first section of prelock on L2-Cache, which should be used together with L2_CACHE_PRELOCK_SCT0_ADDR_REG
                    L2_CACHE_PRELOCK_SCT0_SIZE:  u16, 
                    
                    /// [16:31] Those bits are used to configure the size of the second section of prelock on L2-Cache, which should be used together with L2_CACHE_PRELOCK_SCT1_ADDR_REG
                    L2_CACHE_PRELOCK_SCT1_SIZE:  u16, 
                    
                }), @ptrFromInt(0x600c8290));
                
                /// L2 Cache preload-operation control register
                pub const L2_CACHE_PRELOAD_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] The bit is used to enable preload operation on L2-Cache. It will be cleared by hardware automatically after preload operation is done.
                    L2_CACHE_PRELOAD_ENA:  u1, 
                    
                    /// [1:1] The bit is used to indicate whether preload operation is finished or not. 0: not finished. 1: finished.
                    L2_CACHE_PRELOAD_DONE:  u1, 
                    
                    /// [2:2] The bit is used to configure the direction of preload operation. 0: ascending, 1: descending.
                    L2_CACHE_PRELOAD_ORDER:  u1, 
                    
                    /// [3:6] The bit is used to setthe gid of l2 cache preload.
                    L2_CACHE_PRELOAD_RGID:  u4, 
                    
                    /// [7:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600c8294));
                
                /// L2 Cache preload address configure register
                pub const L2_CACHE_PRELOAD_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Those bits are used to configure the start virtual address of preload on L2-Cache, which should be used together with L2_CACHE_PRELOAD_SIZE_REG
                    L2_CACHE_PRELOAD_ADDR:  u32, 
                    
                }), @ptrFromInt(0x600c8298));
                
                /// L2 Cache preload size configure register
                pub const L2_CACHE_PRELOAD_SIZE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:15] Those bits are used to configure the size of the first section of prelock on L2-Cache, which should be used together with L2_CACHE_PRELOAD_ADDR_REG
                    L2_CACHE_PRELOAD_SIZE:  u16, 
                    
                    /// [16:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600c829c));
                
                /// L2 Cache autoload-operation control register
                pub const L2_CACHE_AUTOLOAD_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] The bit is used to enable and disable autoload operation on L2-Cache.1: enable, 0: disable.
                    L2_CACHE_AUTOLOAD_ENA:  u1, 
                    
                    /// [1:1] The bit is used to indicate whether autoload operation on L2-Cache is finished or not. 0: not finished. 1: finished.
                    L2_CACHE_AUTOLOAD_DONE:  u1, 
                    
                    /// [2:2] The bit is used to configure the direction of autoload operation on L2-Cache. 0: ascending. 1: descending.
                    L2_CACHE_AUTOLOAD_ORDER:  u1, 
                    
                    /// [3:4] The field is used to configure trigger mode of autoload operation on L2-Cache. 0/3: miss-trigger, 1: hit-trigger, 2: miss-hit-trigger.
                    L2_CACHE_AUTOLOAD_TRIGGER_MODE:  u2, 
                    
                    /// [5:7] 
                    res0:  u0, 
                    
                    /// [8:8] The bit is used to enable the first section for autoload operation on L2-Cache.
                    L2_CACHE_AUTOLOAD_SCT0_ENA:  u1, 
                    
                    /// [9:9] The bit is used to enable the second section for autoload operation on L2-Cache.
                    L2_CACHE_AUTOLOAD_SCT1_ENA:  u1, 
                    
                    /// [10:10] The bit is used to enable the third section for autoload operation on L2-Cache.
                    L2_CACHE_AUTOLOAD_SCT2_ENA:  u1, 
                    
                    /// [11:11] The bit is used to enable the fourth section for autoload operation on L2-Cache.
                    L2_CACHE_AUTOLOAD_SCT3_ENA:  u1, 
                    
                    /// [12:15] The bit is used to setthe gid of l2 cache autoload.
                    L2_CACHE_AUTOLOAD_RGID:  u4, 
                    
                    /// [16:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x600c82a0));
                
                /// L2 Cache autoload section 0 address configure register
                pub const L2_CACHE_AUTOLOAD_SCT0_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Those bits are used to configure the start virtual address of the first section for autoload operation on L2-Cache. Note that it should be used together with L2_CACHE_AUTOLOAD_SCT0_SIZE and L2_CACHE_AUTOLOAD_SCT0_ENA.
                    L2_CACHE_AUTOLOAD_SCT0_ADDR:  u32, 
                    
                }), @ptrFromInt(0x600c82a4));
                
                /// L2 Cache autoload section 0 size configure register
                pub const L2_CACHE_AUTOLOAD_SCT0_SIZE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:27] Those bits are used to configure the size of the first section for autoload operation on L2-Cache. Note that it should be used together with L2_CACHE_AUTOLOAD_SCT0_ADDR and L2_CACHE_AUTOLOAD_SCT0_ENA.
                    L2_CACHE_AUTOLOAD_SCT0_SIZE:  u28, 
                    
                    /// [28:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600c82a8));
                
                /// L2 Cache autoload section 1 address configure register
                pub const L2_CACHE_AUTOLOAD_SCT1_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Those bits are used to configure the start virtual address of the second section for autoload operation on L2-Cache. Note that it should be used together with L2_CACHE_AUTOLOAD_SCT1_SIZE and L2_CACHE_AUTOLOAD_SCT1_ENA.
                    L2_CACHE_AUTOLOAD_SCT1_ADDR:  u32, 
                    
                }), @ptrFromInt(0x600c82ac));
                
                /// L2 Cache autoload section 1 size configure register
                pub const L2_CACHE_AUTOLOAD_SCT1_SIZE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:27] Those bits are used to configure the size of the second section for autoload operation on L2-Cache. Note that it should be used together with L2_CACHE_AUTOLOAD_SCT1_ADDR and L2_CACHE_AUTOLOAD_SCT1_ENA.
                    L2_CACHE_AUTOLOAD_SCT1_SIZE:  u28, 
                    
                    /// [28:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600c82b0));
                
                /// L2 Cache autoload section 2 address configure register
                pub const L2_CACHE_AUTOLOAD_SCT2_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Those bits are used to configure the start virtual address of the third section for autoload operation on L2-Cache. Note that it should be used together with L2_CACHE_AUTOLOAD_SCT2_SIZE and L2_CACHE_AUTOLOAD_SCT2_ENA.
                    L2_CACHE_AUTOLOAD_SCT2_ADDR:  u32, 
                    
                }), @ptrFromInt(0x600c82b4));
                
                /// L2 Cache autoload section 2 size configure register
                pub const L2_CACHE_AUTOLOAD_SCT2_SIZE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:27] Those bits are used to configure the size of the third section for autoload operation on L2-Cache. Note that it should be used together with L2_CACHE_AUTOLOAD_SCT2_ADDR and L2_CACHE_AUTOLOAD_SCT2_ENA.
                    L2_CACHE_AUTOLOAD_SCT2_SIZE:  u28, 
                    
                    /// [28:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600c82b8));
                
                /// L2 Cache autoload section 3 address configure register
                pub const L2_CACHE_AUTOLOAD_SCT3_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Those bits are used to configure the start virtual address of the fourth section for autoload operation on L2-Cache. Note that it should be used together with L2_CACHE_AUTOLOAD_SCT3_SIZE and L2_CACHE_AUTOLOAD_SCT3_ENA.
                    L2_CACHE_AUTOLOAD_SCT3_ADDR:  u32, 
                    
                }), @ptrFromInt(0x600c82bc));
                
                /// L2 Cache autoload section 3 size configure register
                pub const L2_CACHE_AUTOLOAD_SCT3_SIZE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:27] Those bits are used to configure the size of the fourth section for autoload operation on L2-Cache. Note that it should be used together with L2_CACHE_AUTOLOAD_SCT3_ADDR and L2_CACHE_AUTOLOAD_SCT3_ENA.
                    L2_CACHE_AUTOLOAD_SCT3_SIZE:  u28, 
                    
                    /// [28:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600c82c0));
                
                /// Cache Access Counter Interrupt enable register
                pub const L2_CACHE_ACS_CNT_INT_ENA = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] 
                    res0:  u0, 
                    
                    /// [8:8] The bit is used to enable interrupt of one of counters overflow that occurs in L2-Cache due to bus0 accesses L2-Cache.
                    L2_IBUS0_OVF_INT_ENA:  u1, 
                    
                    /// [9:9] The bit is used to enable interrupt of one of counters overflow that occurs in L2-Cache due to bus1 accesses L2-Cache.
                    L2_IBUS1_OVF_INT_ENA:  u1, 
                    
                    /// [10:10] Reserved
                    L2_IBUS2_OVF_INT_ENA:  u1, 
                    
                    /// [11:11] Reserved
                    L2_IBUS3_OVF_INT_ENA:  u1, 
                    
                    /// [12:12] The bit is used to enable interrupt of one of counters overflow that occurs in L2-Cache due to bus0 accesses L2-Cache.
                    L2_DBUS0_OVF_INT_ENA:  u1, 
                    
                    /// [13:13] The bit is used to enable interrupt of one of counters overflow that occurs in L2-Cache due to bus1 accesses L2-Cache.
                    L2_DBUS1_OVF_INT_ENA:  u1, 
                    
                    /// [14:14] Reserved
                    L2_DBUS2_OVF_INT_ENA:  u1, 
                    
                    /// [15:15] Reserved
                    L2_DBUS3_OVF_INT_ENA:  u1, 
                    
                    /// [16:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x600c82c4));
                
                /// Cache Access Counter Interrupt clear register
                pub const L2_CACHE_ACS_CNT_INT_CLR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] 
                    res0:  u0, 
                    
                    /// [8:8] The bit is used to clear counters overflow interrupt and counters in L2-Cache due to bus0 accesses L2-Cache.
                    L2_IBUS0_OVF_INT_CLR:  u1, 
                    
                    /// [9:9] The bit is used to clear counters overflow interrupt and counters in L2-Cache due to bus1 accesses L2-Cache.
                    L2_IBUS1_OVF_INT_CLR:  u1, 
                    
                    /// [10:10] Reserved
                    L2_IBUS2_OVF_INT_CLR:  u1, 
                    
                    /// [11:11] Reserved
                    L2_IBUS3_OVF_INT_CLR:  u1, 
                    
                    /// [12:12] The bit is used to clear counters overflow interrupt and counters in L2-Cache due to bus0 accesses L2-Cache.
                    L2_DBUS0_OVF_INT_CLR:  u1, 
                    
                    /// [13:13] The bit is used to clear counters overflow interrupt and counters in L2-Cache due to bus1 accesses L2-Cache.
                    L2_DBUS1_OVF_INT_CLR:  u1, 
                    
                    /// [14:14] Reserved
                    L2_DBUS2_OVF_INT_CLR:  u1, 
                    
                    /// [15:15] Reserved
                    L2_DBUS3_OVF_INT_CLR:  u1, 
                    
                    /// [16:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x600c82c8));
                
                /// Cache Access Counter Interrupt raw register
                pub const L2_CACHE_ACS_CNT_INT_RAW = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] 
                    res0:  u0, 
                    
                    /// [8:8] The raw bit of the interrupt of one of counters overflow that occurs in L2-Cache due to bus0 accesses L2-ICache0.
                    L2_IBUS0_OVF_INT_RAW:  u1, 
                    
                    /// [9:9] The raw bit of the interrupt of one of counters overflow that occurs in L2-Cache due to bus1 accesses L2-ICache1.
                    L2_IBUS1_OVF_INT_RAW:  u1, 
                    
                    /// [10:10] The raw bit of the interrupt of one of counters overflow that occurs in L2-Cache due to bus2 accesses L2-ICache2.
                    L2_IBUS2_OVF_INT_RAW:  u1, 
                    
                    /// [11:11] The raw bit of the interrupt of one of counters overflow that occurs in L2-Cache due to bus3 accesses L2-ICache3.
                    L2_IBUS3_OVF_INT_RAW:  u1, 
                    
                    /// [12:12] The raw bit of the interrupt of one of counters overflow that occurs in L2-Cache due to bus0 accesses L2-DCache.
                    L2_DBUS0_OVF_INT_RAW:  u1, 
                    
                    /// [13:13] The raw bit of the interrupt of one of counters overflow that occurs in L2-Cache due to bus1 accesses L2-DCache.
                    L2_DBUS1_OVF_INT_RAW:  u1, 
                    
                    /// [14:14] The raw bit of the interrupt of one of counters overflow that occurs in L2-Cache due to bus2 accesses L2-DCache.
                    L2_DBUS2_OVF_INT_RAW:  u1, 
                    
                    /// [15:15] The raw bit of the interrupt of one of counters overflow that occurs in L2-Cache due to bus3 accesses L2-DCache.
                    L2_DBUS3_OVF_INT_RAW:  u1, 
                    
                    /// [16:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x600c82cc));
                
                /// Cache Access Counter Interrupt status register
                pub const L2_CACHE_ACS_CNT_INT_ST = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] 
                    res0:  u0, 
                    
                    /// [8:8] The bit indicates the interrupt status of one of counters overflow that occurs in L2-Cache due to bus0 accesses L2-Cache.
                    L2_IBUS0_OVF_INT_ST:  u1, 
                    
                    /// [9:9] The bit indicates the interrupt status of one of counters overflow that occurs in L2-Cache due to bus1 accesses L2-Cache.
                    L2_IBUS1_OVF_INT_ST:  u1, 
                    
                    /// [10:10] Reserved
                    L2_IBUS2_OVF_INT_ST:  u1, 
                    
                    /// [11:11] Reserved
                    L2_IBUS3_OVF_INT_ST:  u1, 
                    
                    /// [12:12] The bit indicates the interrupt status of one of counters overflow that occurs in L2-Cache due to bus0 accesses L2-Cache.
                    L2_DBUS0_OVF_INT_ST:  u1, 
                    
                    /// [13:13] The bit indicates the interrupt status of one of counters overflow that occurs in L2-Cache due to bus1 accesses L2-Cache.
                    L2_DBUS1_OVF_INT_ST:  u1, 
                    
                    /// [14:14] Reserved
                    L2_DBUS2_OVF_INT_ST:  u1, 
                    
                    /// [15:15] Reserved
                    L2_DBUS3_OVF_INT_ST:  u1, 
                    
                    /// [16:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x600c82d0));
                
                /// Cache Access Fail Interrupt enable register
                pub const L2_CACHE_ACS_FAIL_INT_ENA = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:4] 
                    res0:  u0, 
                    
                    /// [5:5] The bit is used to enable interrupt of access fail that occurs in L2-Cache due to l1 cache accesses L2-Cache.
                    L2_CACHE_FAIL_INT_ENA:  u1, 
                    
                    /// [6:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x600c82d4));
                
                /// L1-Cache Access Fail Interrupt clear register
                pub const L2_CACHE_ACS_FAIL_INT_CLR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:4] 
                    res0:  u0, 
                    
                    /// [5:5] The bit is used to clear interrupt of access fail that occurs in L2-Cache due to l1 cache accesses L2-Cache.
                    L2_CACHE_FAIL_INT_CLR:  u1, 
                    
                    /// [6:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x600c82d8));
                
                /// Cache Access Fail Interrupt raw register
                pub const L2_CACHE_ACS_FAIL_INT_RAW = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:4] 
                    res0:  u0, 
                    
                    /// [5:5] The raw bit of the interrupt of access fail that occurs in L2-Cache.
                    L2_CACHE_FAIL_INT_RAW:  u1, 
                    
                    /// [6:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x600c82dc));
                
                /// Cache Access Fail Interrupt status register
                pub const L2_CACHE_ACS_FAIL_INT_ST = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:4] 
                    res0:  u0, 
                    
                    /// [5:5] The bit indicates the interrupt status of access fail that occurs in L2-Cache due to l1 cache accesses L2-Cache.
                    L2_CACHE_FAIL_INT_ST:  u1, 
                    
                    /// [6:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x600c82e0));
                
                /// Cache Access Counter enable and clear register
                pub const L2_CACHE_ACS_CNT_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] 
                    res0:  u0, 
                    
                    /// [8:8] The bit is used to enable ibus0 counter in L2-Cache.
                    L2_IBUS0_CNT_ENA:  u1, 
                    
                    /// [9:9] The bit is used to enable ibus1 counter in L2-Cache.
                    L2_IBUS1_CNT_ENA:  u1, 
                    
                    /// [10:10] Reserved
                    L2_IBUS2_CNT_ENA:  u1, 
                    
                    /// [11:11] Reserved
                    L2_IBUS3_CNT_ENA:  u1, 
                    
                    /// [12:12] The bit is used to enable dbus0 counter in L2-Cache.
                    L2_DBUS0_CNT_ENA:  u1, 
                    
                    /// [13:13] The bit is used to enable dbus1 counter in L2-Cache.
                    L2_DBUS1_CNT_ENA:  u1, 
                    
                    /// [14:14] Reserved
                    L2_DBUS2_CNT_ENA:  u1, 
                    
                    /// [15:15] Reserved
                    L2_DBUS3_CNT_ENA:  u1, 
                    
                    /// [16:23] 
                    res1:  u0, 
                    
                    /// [24:24] The bit is used to clear ibus0 counter in L2-Cache.
                    L2_IBUS0_CNT_CLR:  u1, 
                    
                    /// [25:25] The bit is used to clear ibus1 counter in L2-Cache.
                    L2_IBUS1_CNT_CLR:  u1, 
                    
                    /// [26:26] Reserved
                    L2_IBUS2_CNT_CLR:  u1, 
                    
                    /// [27:27] Reserved
                    L2_IBUS3_CNT_CLR:  u1, 
                    
                    /// [28:28] The bit is used to clear dbus0 counter in L2-Cache.
                    L2_DBUS0_CNT_CLR:  u1, 
                    
                    /// [29:29] The bit is used to clear dbus1 counter in L2-Cache.
                    L2_DBUS1_CNT_CLR:  u1, 
                    
                    /// [30:30] Reserved
                    L2_DBUS2_CNT_CLR:  u1, 
                    
                    /// [31:31] Reserved
                    L2_DBUS3_CNT_CLR:  u1, 
                    
                }), @ptrFromInt(0x600c82e4));
                
                /// L2-Cache bus0 Hit-Access Counter register
                pub const L2_IBUS0_ACS_HIT_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] The register records the number of hits when L1-ICache0 accesses L2-Cache due to bus0 accessing L1-ICache0.
                    L2_IBUS0_HIT_CNT:  u32, 
                    
                }), @ptrFromInt(0x600c82e8));
                
                /// L2-Cache bus0 Miss-Access Counter register
                pub const L2_IBUS0_ACS_MISS_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] The register records the number of missing when L1-ICache0 accesses L2-Cache due to bus0 accessing L1-ICache0.
                    L2_IBUS0_MISS_CNT:  u32, 
                    
                }), @ptrFromInt(0x600c82ec));
                
                /// L2-Cache bus0 Conflict-Access Counter register
                pub const L2_IBUS0_ACS_CONFLICT_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] The register records the number of access-conflicts when L1-ICache0 accesses L2-Cache due to bus0 accessing L1-ICache0.
                    L2_IBUS0_CONFLICT_CNT:  u32, 
                    
                }), @ptrFromInt(0x600c82f0));
                
                /// L2-Cache bus0 Next-Level-Access Counter register
                pub const L2_IBUS0_ACS_NXTLVL_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] The register records the number of times that L2-Cache accesses external memory due to L1-ICache0 accessing L2-Cache due to bus0 accessing L1-ICache0.
                    L2_IBUS0_NXTLVL_CNT:  u32, 
                    
                }), @ptrFromInt(0x600c82f4));
                
                /// L2-Cache bus1 Hit-Access Counter register
                pub const L2_IBUS1_ACS_HIT_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] The register records the number of hits when L1-ICache1 accesses L2-Cache due to bus1 accessing L1-ICache1.
                    L2_IBUS1_HIT_CNT:  u32, 
                    
                }), @ptrFromInt(0x600c82f8));
                
                /// L2-Cache bus1 Miss-Access Counter register
                pub const L2_IBUS1_ACS_MISS_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] The register records the number of missing when L1-ICache1 accesses L2-Cache due to bus1 accessing L1-ICache1.
                    L2_IBUS1_MISS_CNT:  u32, 
                    
                }), @ptrFromInt(0x600c82fc));
                
                /// L2-Cache bus1 Conflict-Access Counter register
                pub const L2_IBUS1_ACS_CONFLICT_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] The register records the number of access-conflicts when L1-ICache1 accesses L2-Cache due to bus1 accessing L1-ICache1.
                    L2_IBUS1_CONFLICT_CNT:  u32, 
                    
                }), @ptrFromInt(0x600c8300));
                
                /// L2-Cache bus1 Next-Level-Access Counter register
                pub const L2_IBUS1_ACS_NXTLVL_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] The register records the number of times that L2-Cache accesses external memory due to L1-ICache1 accessing L2-Cache due to bus1 accessing L1-ICache1.
                    L2_IBUS1_NXTLVL_CNT:  u32, 
                    
                }), @ptrFromInt(0x600c8304));
                
                /// L2-Cache bus2 Hit-Access Counter register
                pub const L2_IBUS2_ACS_HIT_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] The register records the number of hits when L1-ICache2 accesses L2-Cache due to bus2 accessing L1-ICache2.
                    L2_IBUS2_HIT_CNT:  u32, 
                    
                }), @ptrFromInt(0x600c8308));
                
                /// L2-Cache bus2 Miss-Access Counter register
                pub const L2_IBUS2_ACS_MISS_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] The register records the number of missing when L1-ICache2 accesses L2-Cache due to bus2 accessing L1-ICache2.
                    L2_IBUS2_MISS_CNT:  u32, 
                    
                }), @ptrFromInt(0x600c830c));
                
                /// L2-Cache bus2 Conflict-Access Counter register
                pub const L2_IBUS2_ACS_CONFLICT_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] The register records the number of access-conflicts when L1-ICache2 accesses L2-Cache due to bus2 accessing L1-ICache2.
                    L2_IBUS2_CONFLICT_CNT:  u32, 
                    
                }), @ptrFromInt(0x600c8310));
                
                /// L2-Cache bus2 Next-Level-Access Counter register
                pub const L2_IBUS2_ACS_NXTLVL_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] The register records the number of times that L2-Cache accesses external memory due to L1-ICache2 accessing L2-Cache due to bus2 accessing L1-ICache2.
                    L2_IBUS2_NXTLVL_CNT:  u32, 
                    
                }), @ptrFromInt(0x600c8314));
                
                /// L2-Cache bus3 Hit-Access Counter register
                pub const L2_IBUS3_ACS_HIT_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] The register records the number of hits when L1-ICache3 accesses L2-Cache due to bus3 accessing L1-ICache3.
                    L2_IBUS3_HIT_CNT:  u32, 
                    
                }), @ptrFromInt(0x600c8318));
                
                /// L2-Cache bus3 Miss-Access Counter register
                pub const L2_IBUS3_ACS_MISS_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] The register records the number of missing when L1-ICache3 accesses L2-Cache due to bus3 accessing L1-ICache3.
                    L2_IBUS3_MISS_CNT:  u32, 
                    
                }), @ptrFromInt(0x600c831c));
                
                /// L2-Cache bus3 Conflict-Access Counter register
                pub const L2_IBUS3_ACS_CONFLICT_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] The register records the number of access-conflicts when L1-ICache3 accesses L2-Cache due to bus3 accessing L1-ICache3.
                    L2_IBUS3_CONFLICT_CNT:  u32, 
                    
                }), @ptrFromInt(0x600c8320));
                
                /// L2-Cache bus3 Next-Level-Access Counter register
                pub const L2_IBUS3_ACS_NXTLVL_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] The register records the number of times that L2-Cache accesses external memory due to L1-ICache3 accessing L2-Cache due to bus3 accessing L1-ICache3.
                    L2_IBUS3_NXTLVL_CNT:  u32, 
                    
                }), @ptrFromInt(0x600c8324));
                
                /// L2-Cache bus0 Hit-Access Counter register
                pub const L2_DBUS0_ACS_HIT_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] The register records the number of hits when L1-DCache accesses L2-Cache due to bus0 accessing L1-DCache.
                    L2_DBUS0_HIT_CNT:  u32, 
                    
                }), @ptrFromInt(0x600c8328));
                
                /// L2-Cache bus0 Miss-Access Counter register
                pub const L2_DBUS0_ACS_MISS_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] The register records the number of missing when L1-DCache accesses L2-Cache due to bus0 accessing L1-DCache.
                    L2_DBUS0_MISS_CNT:  u32, 
                    
                }), @ptrFromInt(0x600c832c));
                
                /// L2-Cache bus0 Conflict-Access Counter register
                pub const L2_DBUS0_ACS_CONFLICT_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] The register records the number of access-conflicts when L1-DCache accesses L2-Cache due to bus0 accessing L1-DCache.
                    L2_DBUS0_CONFLICT_CNT:  u32, 
                    
                }), @ptrFromInt(0x600c8330));
                
                /// L2-Cache bus0 Next-Level-Access Counter register
                pub const L2_DBUS0_ACS_NXTLVL_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] The register records the number of times that L2-Cache accesses external memory due to L1-DCache accessing L2-Cache due to bus0 accessing L1-DCache.
                    L2_DBUS0_NXTLVL_CNT:  u32, 
                    
                }), @ptrFromInt(0x600c8334));
                
                /// L2-Cache bus1 Hit-Access Counter register
                pub const L2_DBUS1_ACS_HIT_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] The register records the number of hits when L1-DCache accesses L2-Cache due to bus1 accessing L1-DCache.
                    L2_DBUS1_HIT_CNT:  u32, 
                    
                }), @ptrFromInt(0x600c8338));
                
                /// L2-Cache bus1 Miss-Access Counter register
                pub const L2_DBUS1_ACS_MISS_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] The register records the number of missing when L1-DCache accesses L2-Cache due to bus1 accessing L1-DCache.
                    L2_DBUS1_MISS_CNT:  u32, 
                    
                }), @ptrFromInt(0x600c833c));
                
                /// L2-Cache bus1 Conflict-Access Counter register
                pub const L2_DBUS1_ACS_CONFLICT_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] The register records the number of access-conflicts when L1-DCache accesses L2-Cache due to bus1 accessing L1-DCache.
                    L2_DBUS1_CONFLICT_CNT:  u32, 
                    
                }), @ptrFromInt(0x600c8340));
                
                /// L2-Cache bus1 Next-Level-Access Counter register
                pub const L2_DBUS1_ACS_NXTLVL_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] The register records the number of times that L2-Cache accesses external memory due to L1-DCache accessing L2-Cache due to bus1 accessing L1-DCache.
                    L2_DBUS1_NXTLVL_CNT:  u32, 
                    
                }), @ptrFromInt(0x600c8344));
                
                /// L2-Cache bus2 Hit-Access Counter register
                pub const L2_DBUS2_ACS_HIT_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] The register records the number of hits when L1-DCache accesses L2-Cache due to bus2 accessing L1-DCache.
                    L2_DBUS2_HIT_CNT:  u32, 
                    
                }), @ptrFromInt(0x600c8348));
                
                /// L2-Cache bus2 Miss-Access Counter register
                pub const L2_DBUS2_ACS_MISS_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] The register records the number of missing when L1-DCache accesses L2-Cache due to bus2 accessing L1-DCache.
                    L2_DBUS2_MISS_CNT:  u32, 
                    
                }), @ptrFromInt(0x600c834c));
                
                /// L2-Cache bus2 Conflict-Access Counter register
                pub const L2_DBUS2_ACS_CONFLICT_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] The register records the number of access-conflicts when L1-DCache accesses L2-Cache due to bus2 accessing L1-DCache.
                    L2_DBUS2_CONFLICT_CNT:  u32, 
                    
                }), @ptrFromInt(0x600c8350));
                
                /// L2-Cache bus2 Next-Level-Access Counter register
                pub const L2_DBUS2_ACS_NXTLVL_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] The register records the number of times that L2-Cache accesses external memory due to L1-DCache accessing L2-Cache due to bus2 accessing L1-DCache.
                    L2_DBUS2_NXTLVL_CNT:  u32, 
                    
                }), @ptrFromInt(0x600c8354));
                
                /// L2-Cache bus3 Hit-Access Counter register
                pub const L2_DBUS3_ACS_HIT_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] The register records the number of hits when L1-DCache accesses L2-Cache due to bus3 accessing L1-DCache.
                    L2_DBUS3_HIT_CNT:  u32, 
                    
                }), @ptrFromInt(0x600c8358));
                
                /// L2-Cache bus3 Miss-Access Counter register
                pub const L2_DBUS3_ACS_MISS_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] The register records the number of missing when L1-DCache accesses L2-Cache due to bus3 accessing L1-DCache.
                    L2_DBUS3_MISS_CNT:  u32, 
                    
                }), @ptrFromInt(0x600c835c));
                
                /// L2-Cache bus3 Conflict-Access Counter register
                pub const L2_DBUS3_ACS_CONFLICT_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] The register records the number of access-conflicts when L1-DCache accesses L2-Cache due to bus3 accessing L1-DCache.
                    L2_DBUS3_CONFLICT_CNT:  u32, 
                    
                }), @ptrFromInt(0x600c8360));
                
                /// L2-Cache bus3 Next-Level-Access Counter register
                pub const L2_DBUS3_ACS_NXTLVL_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] The register records the number of times that L2-Cache accesses external memory due to L1-DCache accessing L2-Cache due to bus3 accessing L1-DCache.
                    L2_DBUS3_NXTLVL_CNT:  u32, 
                    
                }), @ptrFromInt(0x600c8364));
                
                /// L2-Cache Access Fail ID/attribution information register
                pub const L2_CACHE_ACS_FAIL_ID_ATTR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:15] The register records the ID of fail-access when L1-Cache accesses L2-Cache.
                    L2_CACHE_FAIL_ID:  u16, 
                    
                    /// [16:31] The register records the attribution of fail-access when L1-Cache accesses L2-Cache due to cache accessing L1-Cache.
                    L2_CACHE_FAIL_ATTR:  u16, 
                    
                }), @ptrFromInt(0x600c8368));
                
                /// L2-Cache Access Fail Address information register
                pub const L2_CACHE_ACS_FAIL_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] The register records the address of fail-access when L1-Cache accesses L2-Cache.
                    L2_CACHE_FAIL_ADDR:  u32, 
                    
                }), @ptrFromInt(0x600c836c));
                
                /// L1-Cache Access Fail Interrupt enable register
                pub const L2_CACHE_SYNC_PRELOAD_INT_ENA = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:4] 
                    res0:  u0, 
                    
                    /// [5:5] The bit is used to enable interrupt of L2-Cache preload-operation done.
                    L2_CACHE_PLD_DONE_INT_ENA:  u1, 
                    
                    /// [6:11] 
                    res1:  u0, 
                    
                    /// [12:12] The bit is used to enable interrupt of L2-Cache preload-operation error.
                    L2_CACHE_PLD_ERR_INT_ENA:  u1, 
                    
                    /// [13:31] 
                    res2:  u0, 
                    
                }), @ptrFromInt(0x600c8370));
                
                /// Sync Preload operation Interrupt clear register
                pub const L2_CACHE_SYNC_PRELOAD_INT_CLR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:4] 
                    res0:  u0, 
                    
                    /// [5:5] The bit is used to clear interrupt that occurs only when L2-Cache preload-operation is done.
                    L2_CACHE_PLD_DONE_INT_CLR:  u1, 
                    
                    /// [6:11] 
                    res1:  u0, 
                    
                    /// [12:12] The bit is used to clear interrupt of L2-Cache preload-operation error.
                    L2_CACHE_PLD_ERR_INT_CLR:  u1, 
                    
                    /// [13:31] 
                    res2:  u0, 
                    
                }), @ptrFromInt(0x600c8374));
                
                /// Sync Preload operation Interrupt raw register
                pub const L2_CACHE_SYNC_PRELOAD_INT_RAW = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:4] 
                    res0:  u0, 
                    
                    /// [5:5] The raw bit of the interrupt that occurs only when L2-Cache preload-operation is done.
                    L2_CACHE_PLD_DONE_INT_RAW:  u1, 
                    
                    /// [6:11] 
                    res1:  u0, 
                    
                    /// [12:12] The raw bit of the interrupt that occurs only when L2-Cache preload-operation error occurs.
                    L2_CACHE_PLD_ERR_INT_RAW:  u1, 
                    
                    /// [13:31] 
                    res2:  u0, 
                    
                }), @ptrFromInt(0x600c8378));
                
                /// L1-Cache Access Fail Interrupt status register
                pub const L2_CACHE_SYNC_PRELOAD_INT_ST = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:4] 
                    res0:  u0, 
                    
                    /// [5:5] The bit indicates the status of the interrupt that occurs only when L2-Cache preload-operation is done.
                    L2_CACHE_PLD_DONE_INT_ST:  u1, 
                    
                    /// [6:11] 
                    res1:  u0, 
                    
                    /// [12:12] The bit indicates the status of the interrupt of L2-Cache preload-operation error.
                    L2_CACHE_PLD_ERR_INT_ST:  u1, 
                    
                    /// [13:31] 
                    res2:  u0, 
                    
                }), @ptrFromInt(0x600c837c));
                
                /// Cache Sync/Preload Operation exception register
                pub const L2_CACHE_SYNC_PRELOAD_EXCEPTION = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:9] 
                    res0:  u0, 
                    
                    /// [10:11] The value 2 is Only available which means preload size is error in L2-Cache.
                    L2_CACHE_PLD_ERR_CODE:  u2, 
                    
                    /// [12:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x600c8380));
                
                /// Cache Sync Reset control register
                pub const L2_CACHE_SYNC_RST_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:4] 
                    res0:  u0, 
                    
                    /// [5:5] set this bit to reset sync-logic inside L2-Cache. Recommend that this should only be used to initialize sync-logic when some fatal error of sync-logic occurs.
                    L2_CACHE_SYNC_RST:  u1, 
                    
                    /// [6:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x600c8384));
                
                /// Cache Preload Reset control register
                pub const L2_CACHE_PRELOAD_RST_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:4] 
                    res0:  u0, 
                    
                    /// [5:5] set this bit to reset preload-logic inside L2-Cache. Recommend that this should only be used to initialize preload-logic when some fatal error of preload-logic occurs.
                    L2_CACHE_PLD_RST:  u1, 
                    
                    /// [6:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x600c8388));
                
                /// Cache Autoload buffer clear control register
                pub const L2_CACHE_AUTOLOAD_BUF_CLR_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:4] 
                    res0:  u0, 
                    
                    /// [5:5] set this bit to clear autoload-buffer inside L2-Cache. If this bit is active, autoload will not work in L2-Cache. This bit should not be active when autoload works in L2-Cache.
                    L2_CACHE_ALD_BUF_CLR:  u1, 
                    
                    /// [6:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x600c838c));
                
                /// Unallocate request buffer clear registers
                pub const L2_UNALLOCATE_BUFFER_CLEAR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:4] 
                    res0:  u0, 
                    
                    /// [5:5] The bit is used to clear the unallocate request buffer of l2 icache where the unallocate request is responsed but not completed.
                    L2_CACHE_UNALLOC_CLR:  u1, 
                    
                    /// [6:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x600c8390));
                
                /// L1 Cache access Attribute propagation control register
                pub const L2_CACHE_ACCESS_ATTR_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Set this bit to force the request to l2 cache with cacheable attribute, otherwise, the attribute is propagated from L1 cache or CPU, it could be one of cacheable and non-cacheable.
                    L2_CACHE_ACCESS_FORCE_CC:  u1, 
                    
                    /// [1:1] Set this bit to force the request to l2 cache with write-back attribute, otherwise, the attribute is propagated from L1 cache or CPU, it could be one of write-back and write-through.
                    L2_CACHE_ACCESS_FORCE_WB:  u1, 
                    
                    /// [2:2] Set this bit to force the request to l2 cache with write-miss-allocate attribute, otherwise, the attribute is propagated from L1 cache or CPU, it could be one of write-miss-allocate and write-miss-no-allocate.
                    L2_CACHE_ACCESS_FORCE_WMA:  u1, 
                    
                    /// [3:3] Set this bit to force the request to l2 cache with read-miss-allocate attribute, otherwise, the attribute is propagated from L1 cache or CPU, it could be one of read-miss-allocate and read-miss-no-allocate.
                    L2_CACHE_ACCESS_FORCE_RMA:  u1, 
                    
                    /// [4:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600c8394));
                
                /// Cache Tag and Data memory Object control register
                pub const L2_CACHE_OBJECT_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:4] 
                    res0:  u0, 
                    
                    /// [5:5] Set this bit to set L2-Cache tag memory as object. This bit should be onehot with the others fields inside this register.
                    L2_CACHE_TAG_OBJECT:  u1, 
                    
                    /// [6:10] 
                    res1:  u0, 
                    
                    /// [11:11] Set this bit to set L2-Cache data memory as object. This bit should be onehot with the others fields inside this register.
                    L2_CACHE_MEM_OBJECT:  u1, 
                    
                    /// [12:31] 
                    res2:  u0, 
                    
                }), @ptrFromInt(0x600c8398));
                
                /// Cache Tag and Data memory way register
                pub const L2_CACHE_WAY_OBJECT = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:2] Set this bits to select which way of the tag-object will be accessed. 0: way0, 1: way1, 2: way2, 3: way3, ?, 7: way7.
                    L2_CACHE_WAY_OBJECT:  u3, 
                    
                    /// [3:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600c839c));
                
                /// Cache Vaddr register
                pub const L2_CACHE_VADDR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Those bits stores the virtual address which will decide where inside the specified tag memory object will be accessed.
                    L2_CACHE_VADDR:  u32, 
                    
                }), @ptrFromInt(0x600c83a0));
                
                /// Cache Tag/data memory content register
                pub const L2_CACHE_DEBUG_BUS = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] This is a constant place where we can write data to or read data from the tag/data memory on the specified cache.
                    L2_CACHE_DEBUG_BUS:  u32, 
                    
                }), @ptrFromInt(0x600c83a4));
                
                /// USED TO SPLIT L1 CACHE AND L2 CACHE
                pub const LEVEL_SPLIT1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Reserved
                    LEVEL_SPLIT1:  u32, 
                    
                }), @ptrFromInt(0x600c83a8));
                
                /// Clock gate control register
                pub const CLOCK_GATE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] The bit is used to enable clock gate when access all registers in this module.
                    CLK_EN:  u1, 
                    
                    /// [1:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600c83ac));
                
                /// Cache redundancy signal 0 register
                pub const REDUNDANCY_SIG0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Those bits are prepared for ECO.
                    CACHE_REDCY_SIG0:  u32, 
                    
                }), @ptrFromInt(0x600c83b0));
                
                /// Cache redundancy signal 1 register
                pub const REDUNDANCY_SIG1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Those bits are prepared for ECO.
                    CACHE_REDCY_SIG1:  u32, 
                    
                }), @ptrFromInt(0x600c83b4));
                
                /// Cache redundancy signal 2 register
                pub const REDUNDANCY_SIG2 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Those bits are prepared for ECO.
                    CACHE_REDCY_SIG2:  u32, 
                    
                }), @ptrFromInt(0x600c83b8));
                
                /// Cache redundancy signal 3 register
                pub const REDUNDANCY_SIG3 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Those bits are prepared for ECO.
                    CACHE_REDCY_SIG3:  u32, 
                    
                }), @ptrFromInt(0x600c83bc));
                
                /// Cache redundancy signal 0 register
                pub const REDUNDANCY_SIG4 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:3] Those bits are prepared for ECO.
                    CACHE_REDCY_SIG4:  u4, 
                    
                    /// [4:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600c83c0));
                
                /// Version control register
                pub const DATE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:27] version control register. Note that this default value stored is the latest date when the hardware logic was updated.
                    DATE:  u28, 
                    
                    /// [28:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600c83fc));
                
            };
            
            /// General Purpose Input/Output
            pub const GPIO = struct {
                
                /// GPIO bit select register
                pub const BT_SELECT = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] GPIO bit select register
                    BT_SEL:  u32, 
                    
                }), @ptrFromInt(0x60091000));
                
                /// GPIO output register for GPIO0-31
                pub const OUT = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] GPIO output register for GPIO0-31
                    DATA_ORIG:  u32, 
                    
                }), @ptrFromInt(0x60091004));
                
                /// GPIO output set register for GPIO0-31
                pub const OUT_W1TS = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] GPIO output set register for GPIO0-31
                    OUT_W1TS:  u32, 
                    
                }), @ptrFromInt(0x60091008));
                
                /// GPIO output clear register for GPIO0-31
                pub const OUT_W1TC = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] GPIO output clear register for GPIO0-31
                    OUT_W1TC:  u32, 
                    
                }), @ptrFromInt(0x6009100c));
                
                /// GPIO output register for GPIO32-34
                pub const OUT1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:2] GPIO output register for GPIO32-34
                    DATA_ORIG:  u3, 
                    
                    /// [3:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60091010));
                
                /// GPIO output set register for GPIO32-34
                pub const OUT1_W1TS = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:2] GPIO output set register for GPIO32-34
                    OUT1_W1TS:  u3, 
                    
                    /// [3:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60091014));
                
                /// GPIO output clear register for GPIO32-34
                pub const OUT1_W1TC = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:2] GPIO output clear register for GPIO32-34
                    OUT1_W1TC:  u3, 
                    
                    /// [3:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60091018));
                
                /// GPIO sdio select register
                pub const SDIO_SELECT = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] GPIO sdio select register
                    SDIO_SEL:  u8, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6009101c));
                
                /// GPIO output enable register for GPIO0-31
                pub const ENABLE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] GPIO output enable register for GPIO0-31
                    DATA:  u32, 
                    
                }), @ptrFromInt(0x60091020));
                
                /// GPIO output enable set register for GPIO0-31
                pub const ENABLE_W1TS = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] GPIO output enable set register for GPIO0-31
                    ENABLE_W1TS:  u32, 
                    
                }), @ptrFromInt(0x60091024));
                
                /// GPIO output enable clear register for GPIO0-31
                pub const ENABLE_W1TC = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] GPIO output enable clear register for GPIO0-31
                    ENABLE_W1TC:  u32, 
                    
                }), @ptrFromInt(0x60091028));
                
                /// GPIO output enable register for GPIO32-34
                pub const ENABLE1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:2] GPIO output enable register for GPIO32-34
                    DATA:  u3, 
                    
                    /// [3:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6009102c));
                
                /// GPIO output enable set register for GPIO32-34
                pub const ENABLE1_W1TS = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:2] GPIO output enable set register for GPIO32-34
                    ENABLE1_W1TS:  u3, 
                    
                    /// [3:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60091030));
                
                /// GPIO output enable clear register for GPIO32-34
                pub const ENABLE1_W1TC = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:2] GPIO output enable clear register for GPIO32-34
                    ENABLE1_W1TC:  u3, 
                    
                    /// [3:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60091034));
                
                /// pad strapping register
                pub const STRAP = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:15] pad strapping register
                    STRAPPING:  u16, 
                    
                    /// [16:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60091038));
                
                /// GPIO input register for GPIO0-31
                pub const IN = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] GPIO input register for GPIO0-31
                    DATA_NEXT:  u32, 
                    
                }), @ptrFromInt(0x6009103c));
                
                /// GPIO input register for GPIO32-34
                pub const IN1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:2] GPIO input register for GPIO32-34
                    DATA_NEXT:  u3, 
                    
                    /// [3:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60091040));
                
                /// GPIO interrupt status register for GPIO0-31
                pub const STATUS = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] GPIO interrupt status register for GPIO0-31
                    INTERRUPT:  u32, 
                    
                }), @ptrFromInt(0x60091044));
                
                /// GPIO interrupt status set register for GPIO0-31
                pub const STATUS_W1TS = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] GPIO interrupt status set register for GPIO0-31
                    STATUS_W1TS:  u32, 
                    
                }), @ptrFromInt(0x60091048));
                
                /// GPIO interrupt status clear register for GPIO0-31
                pub const STATUS_W1TC = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] GPIO interrupt status clear register for GPIO0-31
                    STATUS_W1TC:  u32, 
                    
                }), @ptrFromInt(0x6009104c));
                
                /// GPIO interrupt status register for GPIO32-34
                pub const STATUS1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:2] GPIO interrupt status register for GPIO32-34
                    INTERRUPT:  u3, 
                    
                    /// [3:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60091050));
                
                /// GPIO interrupt status set register for GPIO32-34
                pub const STATUS1_W1TS = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:2] GPIO interrupt status set register for GPIO32-34
                    STATUS1_W1TS:  u3, 
                    
                    /// [3:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60091054));
                
                /// GPIO interrupt status clear register for GPIO32-34
                pub const STATUS1_W1TC = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:2] GPIO interrupt status clear register for GPIO32-34
                    STATUS1_W1TC:  u3, 
                    
                    /// [3:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60091058));
                
                /// GPIO PRO_CPU interrupt status register for GPIO0-31
                pub const PCPU_INT = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] GPIO PRO_CPU interrupt status register for GPIO0-31
                    PROCPU_INT:  u32, 
                    
                }), @ptrFromInt(0x6009105c));
                
                /// GPIO PRO_CPU(not shielded) interrupt status register for GPIO0-31
                pub const PCPU_NMI_INT = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] GPIO PRO_CPU(not shielded) interrupt status register for GPIO0-31
                    PROCPU_NMI_INT:  u32, 
                    
                }), @ptrFromInt(0x60091060));
                
                /// GPIO CPUSDIO interrupt status register for GPIO0-31
                pub const CPUSDIO_INT = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] GPIO CPUSDIO interrupt status register for GPIO0-31
                    SDIO_INT:  u32, 
                    
                }), @ptrFromInt(0x60091064));
                
                /// GPIO PRO_CPU interrupt status register for GPIO32-34
                pub const PCPU_INT1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:2] GPIO PRO_CPU interrupt status register for GPIO32-34
                    PROCPU_INT1:  u3, 
                    
                    /// [3:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60091068));
                
                /// GPIO PRO_CPU(not shielded) interrupt status register for GPIO32-34
                pub const PCPU_NMI_INT1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:2] GPIO PRO_CPU(not shielded) interrupt status register for GPIO32-34
                    PROCPU_NMI_INT1:  u3, 
                    
                    /// [3:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6009106c));
                
                /// GPIO CPUSDIO interrupt status register for GPIO32-34
                pub const CPUSDIO_INT1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:2] GPIO CPUSDIO interrupt status register for GPIO32-34
                    SDIO_INT1:  u3, 
                    
                    /// [3:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60091070));
                
                /// GPIO pin configuration register
                pub const PIN0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:1] set GPIO input_sync2 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
                    SYNC2_BYPASS:  u2, 
                    
                    /// [2:2] set this bit to select pad driver. 1:open-drain. 0:normal.
                    PAD_DRIVER:  u1, 
                    
                    /// [3:4] set GPIO input_sync1 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
                    SYNC1_BYPASS:  u2, 
                    
                    /// [5:6] 
                    res0:  u0, 
                    
                    /// [7:9] set this value to choose interrupt mode. 0:disable GPIO interrupt. 1:trigger at posedge. 2:trigger at negedge. 3:trigger at any edge. 4:valid at low level. 5:valid at high level
                    INT_TYPE:  u3, 
                    
                    /// [10:10] set this bit to enable GPIO wakeup.(can only wakeup CPU from Light-sleep Mode)
                    WAKEUP_ENABLE:  u1, 
                    
                    /// [11:12] reserved
                    CONFIG:  u2, 
                    
                    /// [13:17] set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not shielded) interrupt.
                    INT_ENA:  u5, 
                    
                    /// [18:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x60091074));
                
                /// GPIO pin configuration register
                pub const PIN0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:1] set GPIO input_sync2 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
                    SYNC2_BYPASS:  u2, 
                    
                    /// [2:2] set this bit to select pad driver. 1:open-drain. 0:normal.
                    PAD_DRIVER:  u1, 
                    
                    /// [3:4] set GPIO input_sync1 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
                    SYNC1_BYPASS:  u2, 
                    
                    /// [5:6] 
                    res0:  u0, 
                    
                    /// [7:9] set this value to choose interrupt mode. 0:disable GPIO interrupt. 1:trigger at posedge. 2:trigger at negedge. 3:trigger at any edge. 4:valid at low level. 5:valid at high level
                    INT_TYPE:  u3, 
                    
                    /// [10:10] set this bit to enable GPIO wakeup.(can only wakeup CPU from Light-sleep Mode)
                    WAKEUP_ENABLE:  u1, 
                    
                    /// [11:12] reserved
                    CONFIG:  u2, 
                    
                    /// [13:17] set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not shielded) interrupt.
                    INT_ENA:  u5, 
                    
                    /// [18:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x60091078));
                
                /// GPIO pin configuration register
                pub const PIN0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:1] set GPIO input_sync2 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
                    SYNC2_BYPASS:  u2, 
                    
                    /// [2:2] set this bit to select pad driver. 1:open-drain. 0:normal.
                    PAD_DRIVER:  u1, 
                    
                    /// [3:4] set GPIO input_sync1 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
                    SYNC1_BYPASS:  u2, 
                    
                    /// [5:6] 
                    res0:  u0, 
                    
                    /// [7:9] set this value to choose interrupt mode. 0:disable GPIO interrupt. 1:trigger at posedge. 2:trigger at negedge. 3:trigger at any edge. 4:valid at low level. 5:valid at high level
                    INT_TYPE:  u3, 
                    
                    /// [10:10] set this bit to enable GPIO wakeup.(can only wakeup CPU from Light-sleep Mode)
                    WAKEUP_ENABLE:  u1, 
                    
                    /// [11:12] reserved
                    CONFIG:  u2, 
                    
                    /// [13:17] set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not shielded) interrupt.
                    INT_ENA:  u5, 
                    
                    /// [18:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x6009107c));
                
                /// GPIO pin configuration register
                pub const PIN0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:1] set GPIO input_sync2 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
                    SYNC2_BYPASS:  u2, 
                    
                    /// [2:2] set this bit to select pad driver. 1:open-drain. 0:normal.
                    PAD_DRIVER:  u1, 
                    
                    /// [3:4] set GPIO input_sync1 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
                    SYNC1_BYPASS:  u2, 
                    
                    /// [5:6] 
                    res0:  u0, 
                    
                    /// [7:9] set this value to choose interrupt mode. 0:disable GPIO interrupt. 1:trigger at posedge. 2:trigger at negedge. 3:trigger at any edge. 4:valid at low level. 5:valid at high level
                    INT_TYPE:  u3, 
                    
                    /// [10:10] set this bit to enable GPIO wakeup.(can only wakeup CPU from Light-sleep Mode)
                    WAKEUP_ENABLE:  u1, 
                    
                    /// [11:12] reserved
                    CONFIG:  u2, 
                    
                    /// [13:17] set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not shielded) interrupt.
                    INT_ENA:  u5, 
                    
                    /// [18:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x60091080));
                
                /// GPIO pin configuration register
                pub const PIN0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:1] set GPIO input_sync2 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
                    SYNC2_BYPASS:  u2, 
                    
                    /// [2:2] set this bit to select pad driver. 1:open-drain. 0:normal.
                    PAD_DRIVER:  u1, 
                    
                    /// [3:4] set GPIO input_sync1 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
                    SYNC1_BYPASS:  u2, 
                    
                    /// [5:6] 
                    res0:  u0, 
                    
                    /// [7:9] set this value to choose interrupt mode. 0:disable GPIO interrupt. 1:trigger at posedge. 2:trigger at negedge. 3:trigger at any edge. 4:valid at low level. 5:valid at high level
                    INT_TYPE:  u3, 
                    
                    /// [10:10] set this bit to enable GPIO wakeup.(can only wakeup CPU from Light-sleep Mode)
                    WAKEUP_ENABLE:  u1, 
                    
                    /// [11:12] reserved
                    CONFIG:  u2, 
                    
                    /// [13:17] set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not shielded) interrupt.
                    INT_ENA:  u5, 
                    
                    /// [18:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x60091084));
                
                /// GPIO pin configuration register
                pub const PIN0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:1] set GPIO input_sync2 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
                    SYNC2_BYPASS:  u2, 
                    
                    /// [2:2] set this bit to select pad driver. 1:open-drain. 0:normal.
                    PAD_DRIVER:  u1, 
                    
                    /// [3:4] set GPIO input_sync1 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
                    SYNC1_BYPASS:  u2, 
                    
                    /// [5:6] 
                    res0:  u0, 
                    
                    /// [7:9] set this value to choose interrupt mode. 0:disable GPIO interrupt. 1:trigger at posedge. 2:trigger at negedge. 3:trigger at any edge. 4:valid at low level. 5:valid at high level
                    INT_TYPE:  u3, 
                    
                    /// [10:10] set this bit to enable GPIO wakeup.(can only wakeup CPU from Light-sleep Mode)
                    WAKEUP_ENABLE:  u1, 
                    
                    /// [11:12] reserved
                    CONFIG:  u2, 
                    
                    /// [13:17] set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not shielded) interrupt.
                    INT_ENA:  u5, 
                    
                    /// [18:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x60091088));
                
                /// GPIO pin configuration register
                pub const PIN0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:1] set GPIO input_sync2 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
                    SYNC2_BYPASS:  u2, 
                    
                    /// [2:2] set this bit to select pad driver. 1:open-drain. 0:normal.
                    PAD_DRIVER:  u1, 
                    
                    /// [3:4] set GPIO input_sync1 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
                    SYNC1_BYPASS:  u2, 
                    
                    /// [5:6] 
                    res0:  u0, 
                    
                    /// [7:9] set this value to choose interrupt mode. 0:disable GPIO interrupt. 1:trigger at posedge. 2:trigger at negedge. 3:trigger at any edge. 4:valid at low level. 5:valid at high level
                    INT_TYPE:  u3, 
                    
                    /// [10:10] set this bit to enable GPIO wakeup.(can only wakeup CPU from Light-sleep Mode)
                    WAKEUP_ENABLE:  u1, 
                    
                    /// [11:12] reserved
                    CONFIG:  u2, 
                    
                    /// [13:17] set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not shielded) interrupt.
                    INT_ENA:  u5, 
                    
                    /// [18:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x6009108c));
                
                /// GPIO pin configuration register
                pub const PIN0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:1] set GPIO input_sync2 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
                    SYNC2_BYPASS:  u2, 
                    
                    /// [2:2] set this bit to select pad driver. 1:open-drain. 0:normal.
                    PAD_DRIVER:  u1, 
                    
                    /// [3:4] set GPIO input_sync1 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
                    SYNC1_BYPASS:  u2, 
                    
                    /// [5:6] 
                    res0:  u0, 
                    
                    /// [7:9] set this value to choose interrupt mode. 0:disable GPIO interrupt. 1:trigger at posedge. 2:trigger at negedge. 3:trigger at any edge. 4:valid at low level. 5:valid at high level
                    INT_TYPE:  u3, 
                    
                    /// [10:10] set this bit to enable GPIO wakeup.(can only wakeup CPU from Light-sleep Mode)
                    WAKEUP_ENABLE:  u1, 
                    
                    /// [11:12] reserved
                    CONFIG:  u2, 
                    
                    /// [13:17] set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not shielded) interrupt.
                    INT_ENA:  u5, 
                    
                    /// [18:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x60091090));
                
                /// GPIO pin configuration register
                pub const PIN0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:1] set GPIO input_sync2 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
                    SYNC2_BYPASS:  u2, 
                    
                    /// [2:2] set this bit to select pad driver. 1:open-drain. 0:normal.
                    PAD_DRIVER:  u1, 
                    
                    /// [3:4] set GPIO input_sync1 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
                    SYNC1_BYPASS:  u2, 
                    
                    /// [5:6] 
                    res0:  u0, 
                    
                    /// [7:9] set this value to choose interrupt mode. 0:disable GPIO interrupt. 1:trigger at posedge. 2:trigger at negedge. 3:trigger at any edge. 4:valid at low level. 5:valid at high level
                    INT_TYPE:  u3, 
                    
                    /// [10:10] set this bit to enable GPIO wakeup.(can only wakeup CPU from Light-sleep Mode)
                    WAKEUP_ENABLE:  u1, 
                    
                    /// [11:12] reserved
                    CONFIG:  u2, 
                    
                    /// [13:17] set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not shielded) interrupt.
                    INT_ENA:  u5, 
                    
                    /// [18:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x60091094));
                
                /// GPIO pin configuration register
                pub const PIN0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:1] set GPIO input_sync2 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
                    SYNC2_BYPASS:  u2, 
                    
                    /// [2:2] set this bit to select pad driver. 1:open-drain. 0:normal.
                    PAD_DRIVER:  u1, 
                    
                    /// [3:4] set GPIO input_sync1 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
                    SYNC1_BYPASS:  u2, 
                    
                    /// [5:6] 
                    res0:  u0, 
                    
                    /// [7:9] set this value to choose interrupt mode. 0:disable GPIO interrupt. 1:trigger at posedge. 2:trigger at negedge. 3:trigger at any edge. 4:valid at low level. 5:valid at high level
                    INT_TYPE:  u3, 
                    
                    /// [10:10] set this bit to enable GPIO wakeup.(can only wakeup CPU from Light-sleep Mode)
                    WAKEUP_ENABLE:  u1, 
                    
                    /// [11:12] reserved
                    CONFIG:  u2, 
                    
                    /// [13:17] set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not shielded) interrupt.
                    INT_ENA:  u5, 
                    
                    /// [18:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x60091098));
                
                /// GPIO pin configuration register
                pub const PIN0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:1] set GPIO input_sync2 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
                    SYNC2_BYPASS:  u2, 
                    
                    /// [2:2] set this bit to select pad driver. 1:open-drain. 0:normal.
                    PAD_DRIVER:  u1, 
                    
                    /// [3:4] set GPIO input_sync1 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
                    SYNC1_BYPASS:  u2, 
                    
                    /// [5:6] 
                    res0:  u0, 
                    
                    /// [7:9] set this value to choose interrupt mode. 0:disable GPIO interrupt. 1:trigger at posedge. 2:trigger at negedge. 3:trigger at any edge. 4:valid at low level. 5:valid at high level
                    INT_TYPE:  u3, 
                    
                    /// [10:10] set this bit to enable GPIO wakeup.(can only wakeup CPU from Light-sleep Mode)
                    WAKEUP_ENABLE:  u1, 
                    
                    /// [11:12] reserved
                    CONFIG:  u2, 
                    
                    /// [13:17] set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not shielded) interrupt.
                    INT_ENA:  u5, 
                    
                    /// [18:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x6009109c));
                
                /// GPIO pin configuration register
                pub const PIN0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:1] set GPIO input_sync2 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
                    SYNC2_BYPASS:  u2, 
                    
                    /// [2:2] set this bit to select pad driver. 1:open-drain. 0:normal.
                    PAD_DRIVER:  u1, 
                    
                    /// [3:4] set GPIO input_sync1 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
                    SYNC1_BYPASS:  u2, 
                    
                    /// [5:6] 
                    res0:  u0, 
                    
                    /// [7:9] set this value to choose interrupt mode. 0:disable GPIO interrupt. 1:trigger at posedge. 2:trigger at negedge. 3:trigger at any edge. 4:valid at low level. 5:valid at high level
                    INT_TYPE:  u3, 
                    
                    /// [10:10] set this bit to enable GPIO wakeup.(can only wakeup CPU from Light-sleep Mode)
                    WAKEUP_ENABLE:  u1, 
                    
                    /// [11:12] reserved
                    CONFIG:  u2, 
                    
                    /// [13:17] set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not shielded) interrupt.
                    INT_ENA:  u5, 
                    
                    /// [18:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x600910a0));
                
                /// GPIO pin configuration register
                pub const PIN0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:1] set GPIO input_sync2 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
                    SYNC2_BYPASS:  u2, 
                    
                    /// [2:2] set this bit to select pad driver. 1:open-drain. 0:normal.
                    PAD_DRIVER:  u1, 
                    
                    /// [3:4] set GPIO input_sync1 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
                    SYNC1_BYPASS:  u2, 
                    
                    /// [5:6] 
                    res0:  u0, 
                    
                    /// [7:9] set this value to choose interrupt mode. 0:disable GPIO interrupt. 1:trigger at posedge. 2:trigger at negedge. 3:trigger at any edge. 4:valid at low level. 5:valid at high level
                    INT_TYPE:  u3, 
                    
                    /// [10:10] set this bit to enable GPIO wakeup.(can only wakeup CPU from Light-sleep Mode)
                    WAKEUP_ENABLE:  u1, 
                    
                    /// [11:12] reserved
                    CONFIG:  u2, 
                    
                    /// [13:17] set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not shielded) interrupt.
                    INT_ENA:  u5, 
                    
                    /// [18:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x600910a4));
                
                /// GPIO pin configuration register
                pub const PIN0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:1] set GPIO input_sync2 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
                    SYNC2_BYPASS:  u2, 
                    
                    /// [2:2] set this bit to select pad driver. 1:open-drain. 0:normal.
                    PAD_DRIVER:  u1, 
                    
                    /// [3:4] set GPIO input_sync1 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
                    SYNC1_BYPASS:  u2, 
                    
                    /// [5:6] 
                    res0:  u0, 
                    
                    /// [7:9] set this value to choose interrupt mode. 0:disable GPIO interrupt. 1:trigger at posedge. 2:trigger at negedge. 3:trigger at any edge. 4:valid at low level. 5:valid at high level
                    INT_TYPE:  u3, 
                    
                    /// [10:10] set this bit to enable GPIO wakeup.(can only wakeup CPU from Light-sleep Mode)
                    WAKEUP_ENABLE:  u1, 
                    
                    /// [11:12] reserved
                    CONFIG:  u2, 
                    
                    /// [13:17] set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not shielded) interrupt.
                    INT_ENA:  u5, 
                    
                    /// [18:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x600910a8));
                
                /// GPIO pin configuration register
                pub const PIN0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:1] set GPIO input_sync2 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
                    SYNC2_BYPASS:  u2, 
                    
                    /// [2:2] set this bit to select pad driver. 1:open-drain. 0:normal.
                    PAD_DRIVER:  u1, 
                    
                    /// [3:4] set GPIO input_sync1 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
                    SYNC1_BYPASS:  u2, 
                    
                    /// [5:6] 
                    res0:  u0, 
                    
                    /// [7:9] set this value to choose interrupt mode. 0:disable GPIO interrupt. 1:trigger at posedge. 2:trigger at negedge. 3:trigger at any edge. 4:valid at low level. 5:valid at high level
                    INT_TYPE:  u3, 
                    
                    /// [10:10] set this bit to enable GPIO wakeup.(can only wakeup CPU from Light-sleep Mode)
                    WAKEUP_ENABLE:  u1, 
                    
                    /// [11:12] reserved
                    CONFIG:  u2, 
                    
                    /// [13:17] set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not shielded) interrupt.
                    INT_ENA:  u5, 
                    
                    /// [18:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x600910ac));
                
                /// GPIO pin configuration register
                pub const PIN0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:1] set GPIO input_sync2 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
                    SYNC2_BYPASS:  u2, 
                    
                    /// [2:2] set this bit to select pad driver. 1:open-drain. 0:normal.
                    PAD_DRIVER:  u1, 
                    
                    /// [3:4] set GPIO input_sync1 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
                    SYNC1_BYPASS:  u2, 
                    
                    /// [5:6] 
                    res0:  u0, 
                    
                    /// [7:9] set this value to choose interrupt mode. 0:disable GPIO interrupt. 1:trigger at posedge. 2:trigger at negedge. 3:trigger at any edge. 4:valid at low level. 5:valid at high level
                    INT_TYPE:  u3, 
                    
                    /// [10:10] set this bit to enable GPIO wakeup.(can only wakeup CPU from Light-sleep Mode)
                    WAKEUP_ENABLE:  u1, 
                    
                    /// [11:12] reserved
                    CONFIG:  u2, 
                    
                    /// [13:17] set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not shielded) interrupt.
                    INT_ENA:  u5, 
                    
                    /// [18:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x600910b0));
                
                /// GPIO pin configuration register
                pub const PIN0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:1] set GPIO input_sync2 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
                    SYNC2_BYPASS:  u2, 
                    
                    /// [2:2] set this bit to select pad driver. 1:open-drain. 0:normal.
                    PAD_DRIVER:  u1, 
                    
                    /// [3:4] set GPIO input_sync1 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
                    SYNC1_BYPASS:  u2, 
                    
                    /// [5:6] 
                    res0:  u0, 
                    
                    /// [7:9] set this value to choose interrupt mode. 0:disable GPIO interrupt. 1:trigger at posedge. 2:trigger at negedge. 3:trigger at any edge. 4:valid at low level. 5:valid at high level
                    INT_TYPE:  u3, 
                    
                    /// [10:10] set this bit to enable GPIO wakeup.(can only wakeup CPU from Light-sleep Mode)
                    WAKEUP_ENABLE:  u1, 
                    
                    /// [11:12] reserved
                    CONFIG:  u2, 
                    
                    /// [13:17] set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not shielded) interrupt.
                    INT_ENA:  u5, 
                    
                    /// [18:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x600910b4));
                
                /// GPIO pin configuration register
                pub const PIN0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:1] set GPIO input_sync2 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
                    SYNC2_BYPASS:  u2, 
                    
                    /// [2:2] set this bit to select pad driver. 1:open-drain. 0:normal.
                    PAD_DRIVER:  u1, 
                    
                    /// [3:4] set GPIO input_sync1 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
                    SYNC1_BYPASS:  u2, 
                    
                    /// [5:6] 
                    res0:  u0, 
                    
                    /// [7:9] set this value to choose interrupt mode. 0:disable GPIO interrupt. 1:trigger at posedge. 2:trigger at negedge. 3:trigger at any edge. 4:valid at low level. 5:valid at high level
                    INT_TYPE:  u3, 
                    
                    /// [10:10] set this bit to enable GPIO wakeup.(can only wakeup CPU from Light-sleep Mode)
                    WAKEUP_ENABLE:  u1, 
                    
                    /// [11:12] reserved
                    CONFIG:  u2, 
                    
                    /// [13:17] set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not shielded) interrupt.
                    INT_ENA:  u5, 
                    
                    /// [18:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x600910b8));
                
                /// GPIO pin configuration register
                pub const PIN0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:1] set GPIO input_sync2 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
                    SYNC2_BYPASS:  u2, 
                    
                    /// [2:2] set this bit to select pad driver. 1:open-drain. 0:normal.
                    PAD_DRIVER:  u1, 
                    
                    /// [3:4] set GPIO input_sync1 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
                    SYNC1_BYPASS:  u2, 
                    
                    /// [5:6] 
                    res0:  u0, 
                    
                    /// [7:9] set this value to choose interrupt mode. 0:disable GPIO interrupt. 1:trigger at posedge. 2:trigger at negedge. 3:trigger at any edge. 4:valid at low level. 5:valid at high level
                    INT_TYPE:  u3, 
                    
                    /// [10:10] set this bit to enable GPIO wakeup.(can only wakeup CPU from Light-sleep Mode)
                    WAKEUP_ENABLE:  u1, 
                    
                    /// [11:12] reserved
                    CONFIG:  u2, 
                    
                    /// [13:17] set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not shielded) interrupt.
                    INT_ENA:  u5, 
                    
                    /// [18:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x600910bc));
                
                /// GPIO pin configuration register
                pub const PIN0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:1] set GPIO input_sync2 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
                    SYNC2_BYPASS:  u2, 
                    
                    /// [2:2] set this bit to select pad driver. 1:open-drain. 0:normal.
                    PAD_DRIVER:  u1, 
                    
                    /// [3:4] set GPIO input_sync1 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
                    SYNC1_BYPASS:  u2, 
                    
                    /// [5:6] 
                    res0:  u0, 
                    
                    /// [7:9] set this value to choose interrupt mode. 0:disable GPIO interrupt. 1:trigger at posedge. 2:trigger at negedge. 3:trigger at any edge. 4:valid at low level. 5:valid at high level
                    INT_TYPE:  u3, 
                    
                    /// [10:10] set this bit to enable GPIO wakeup.(can only wakeup CPU from Light-sleep Mode)
                    WAKEUP_ENABLE:  u1, 
                    
                    /// [11:12] reserved
                    CONFIG:  u2, 
                    
                    /// [13:17] set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not shielded) interrupt.
                    INT_ENA:  u5, 
                    
                    /// [18:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x600910c0));
                
                /// GPIO pin configuration register
                pub const PIN0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:1] set GPIO input_sync2 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
                    SYNC2_BYPASS:  u2, 
                    
                    /// [2:2] set this bit to select pad driver. 1:open-drain. 0:normal.
                    PAD_DRIVER:  u1, 
                    
                    /// [3:4] set GPIO input_sync1 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
                    SYNC1_BYPASS:  u2, 
                    
                    /// [5:6] 
                    res0:  u0, 
                    
                    /// [7:9] set this value to choose interrupt mode. 0:disable GPIO interrupt. 1:trigger at posedge. 2:trigger at negedge. 3:trigger at any edge. 4:valid at low level. 5:valid at high level
                    INT_TYPE:  u3, 
                    
                    /// [10:10] set this bit to enable GPIO wakeup.(can only wakeup CPU from Light-sleep Mode)
                    WAKEUP_ENABLE:  u1, 
                    
                    /// [11:12] reserved
                    CONFIG:  u2, 
                    
                    /// [13:17] set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not shielded) interrupt.
                    INT_ENA:  u5, 
                    
                    /// [18:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x600910c4));
                
                /// GPIO pin configuration register
                pub const PIN0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:1] set GPIO input_sync2 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
                    SYNC2_BYPASS:  u2, 
                    
                    /// [2:2] set this bit to select pad driver. 1:open-drain. 0:normal.
                    PAD_DRIVER:  u1, 
                    
                    /// [3:4] set GPIO input_sync1 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
                    SYNC1_BYPASS:  u2, 
                    
                    /// [5:6] 
                    res0:  u0, 
                    
                    /// [7:9] set this value to choose interrupt mode. 0:disable GPIO interrupt. 1:trigger at posedge. 2:trigger at negedge. 3:trigger at any edge. 4:valid at low level. 5:valid at high level
                    INT_TYPE:  u3, 
                    
                    /// [10:10] set this bit to enable GPIO wakeup.(can only wakeup CPU from Light-sleep Mode)
                    WAKEUP_ENABLE:  u1, 
                    
                    /// [11:12] reserved
                    CONFIG:  u2, 
                    
                    /// [13:17] set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not shielded) interrupt.
                    INT_ENA:  u5, 
                    
                    /// [18:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x600910c8));
                
                /// GPIO pin configuration register
                pub const PIN0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:1] set GPIO input_sync2 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
                    SYNC2_BYPASS:  u2, 
                    
                    /// [2:2] set this bit to select pad driver. 1:open-drain. 0:normal.
                    PAD_DRIVER:  u1, 
                    
                    /// [3:4] set GPIO input_sync1 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
                    SYNC1_BYPASS:  u2, 
                    
                    /// [5:6] 
                    res0:  u0, 
                    
                    /// [7:9] set this value to choose interrupt mode. 0:disable GPIO interrupt. 1:trigger at posedge. 2:trigger at negedge. 3:trigger at any edge. 4:valid at low level. 5:valid at high level
                    INT_TYPE:  u3, 
                    
                    /// [10:10] set this bit to enable GPIO wakeup.(can only wakeup CPU from Light-sleep Mode)
                    WAKEUP_ENABLE:  u1, 
                    
                    /// [11:12] reserved
                    CONFIG:  u2, 
                    
                    /// [13:17] set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not shielded) interrupt.
                    INT_ENA:  u5, 
                    
                    /// [18:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x600910cc));
                
                /// GPIO pin configuration register
                pub const PIN0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:1] set GPIO input_sync2 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
                    SYNC2_BYPASS:  u2, 
                    
                    /// [2:2] set this bit to select pad driver. 1:open-drain. 0:normal.
                    PAD_DRIVER:  u1, 
                    
                    /// [3:4] set GPIO input_sync1 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
                    SYNC1_BYPASS:  u2, 
                    
                    /// [5:6] 
                    res0:  u0, 
                    
                    /// [7:9] set this value to choose interrupt mode. 0:disable GPIO interrupt. 1:trigger at posedge. 2:trigger at negedge. 3:trigger at any edge. 4:valid at low level. 5:valid at high level
                    INT_TYPE:  u3, 
                    
                    /// [10:10] set this bit to enable GPIO wakeup.(can only wakeup CPU from Light-sleep Mode)
                    WAKEUP_ENABLE:  u1, 
                    
                    /// [11:12] reserved
                    CONFIG:  u2, 
                    
                    /// [13:17] set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not shielded) interrupt.
                    INT_ENA:  u5, 
                    
                    /// [18:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x600910d0));
                
                /// GPIO pin configuration register
                pub const PIN0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:1] set GPIO input_sync2 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
                    SYNC2_BYPASS:  u2, 
                    
                    /// [2:2] set this bit to select pad driver. 1:open-drain. 0:normal.
                    PAD_DRIVER:  u1, 
                    
                    /// [3:4] set GPIO input_sync1 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
                    SYNC1_BYPASS:  u2, 
                    
                    /// [5:6] 
                    res0:  u0, 
                    
                    /// [7:9] set this value to choose interrupt mode. 0:disable GPIO interrupt. 1:trigger at posedge. 2:trigger at negedge. 3:trigger at any edge. 4:valid at low level. 5:valid at high level
                    INT_TYPE:  u3, 
                    
                    /// [10:10] set this bit to enable GPIO wakeup.(can only wakeup CPU from Light-sleep Mode)
                    WAKEUP_ENABLE:  u1, 
                    
                    /// [11:12] reserved
                    CONFIG:  u2, 
                    
                    /// [13:17] set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not shielded) interrupt.
                    INT_ENA:  u5, 
                    
                    /// [18:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x600910d4));
                
                /// GPIO pin configuration register
                pub const PIN0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:1] set GPIO input_sync2 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
                    SYNC2_BYPASS:  u2, 
                    
                    /// [2:2] set this bit to select pad driver. 1:open-drain. 0:normal.
                    PAD_DRIVER:  u1, 
                    
                    /// [3:4] set GPIO input_sync1 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
                    SYNC1_BYPASS:  u2, 
                    
                    /// [5:6] 
                    res0:  u0, 
                    
                    /// [7:9] set this value to choose interrupt mode. 0:disable GPIO interrupt. 1:trigger at posedge. 2:trigger at negedge. 3:trigger at any edge. 4:valid at low level. 5:valid at high level
                    INT_TYPE:  u3, 
                    
                    /// [10:10] set this bit to enable GPIO wakeup.(can only wakeup CPU from Light-sleep Mode)
                    WAKEUP_ENABLE:  u1, 
                    
                    /// [11:12] reserved
                    CONFIG:  u2, 
                    
                    /// [13:17] set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not shielded) interrupt.
                    INT_ENA:  u5, 
                    
                    /// [18:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x600910d8));
                
                /// GPIO pin configuration register
                pub const PIN0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:1] set GPIO input_sync2 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
                    SYNC2_BYPASS:  u2, 
                    
                    /// [2:2] set this bit to select pad driver. 1:open-drain. 0:normal.
                    PAD_DRIVER:  u1, 
                    
                    /// [3:4] set GPIO input_sync1 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
                    SYNC1_BYPASS:  u2, 
                    
                    /// [5:6] 
                    res0:  u0, 
                    
                    /// [7:9] set this value to choose interrupt mode. 0:disable GPIO interrupt. 1:trigger at posedge. 2:trigger at negedge. 3:trigger at any edge. 4:valid at low level. 5:valid at high level
                    INT_TYPE:  u3, 
                    
                    /// [10:10] set this bit to enable GPIO wakeup.(can only wakeup CPU from Light-sleep Mode)
                    WAKEUP_ENABLE:  u1, 
                    
                    /// [11:12] reserved
                    CONFIG:  u2, 
                    
                    /// [13:17] set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not shielded) interrupt.
                    INT_ENA:  u5, 
                    
                    /// [18:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x600910dc));
                
                /// GPIO pin configuration register
                pub const PIN0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:1] set GPIO input_sync2 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
                    SYNC2_BYPASS:  u2, 
                    
                    /// [2:2] set this bit to select pad driver. 1:open-drain. 0:normal.
                    PAD_DRIVER:  u1, 
                    
                    /// [3:4] set GPIO input_sync1 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
                    SYNC1_BYPASS:  u2, 
                    
                    /// [5:6] 
                    res0:  u0, 
                    
                    /// [7:9] set this value to choose interrupt mode. 0:disable GPIO interrupt. 1:trigger at posedge. 2:trigger at negedge. 3:trigger at any edge. 4:valid at low level. 5:valid at high level
                    INT_TYPE:  u3, 
                    
                    /// [10:10] set this bit to enable GPIO wakeup.(can only wakeup CPU from Light-sleep Mode)
                    WAKEUP_ENABLE:  u1, 
                    
                    /// [11:12] reserved
                    CONFIG:  u2, 
                    
                    /// [13:17] set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not shielded) interrupt.
                    INT_ENA:  u5, 
                    
                    /// [18:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x600910e0));
                
                /// GPIO pin configuration register
                pub const PIN0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:1] set GPIO input_sync2 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
                    SYNC2_BYPASS:  u2, 
                    
                    /// [2:2] set this bit to select pad driver. 1:open-drain. 0:normal.
                    PAD_DRIVER:  u1, 
                    
                    /// [3:4] set GPIO input_sync1 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
                    SYNC1_BYPASS:  u2, 
                    
                    /// [5:6] 
                    res0:  u0, 
                    
                    /// [7:9] set this value to choose interrupt mode. 0:disable GPIO interrupt. 1:trigger at posedge. 2:trigger at negedge. 3:trigger at any edge. 4:valid at low level. 5:valid at high level
                    INT_TYPE:  u3, 
                    
                    /// [10:10] set this bit to enable GPIO wakeup.(can only wakeup CPU from Light-sleep Mode)
                    WAKEUP_ENABLE:  u1, 
                    
                    /// [11:12] reserved
                    CONFIG:  u2, 
                    
                    /// [13:17] set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not shielded) interrupt.
                    INT_ENA:  u5, 
                    
                    /// [18:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x600910e4));
                
                /// GPIO pin configuration register
                pub const PIN0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:1] set GPIO input_sync2 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
                    SYNC2_BYPASS:  u2, 
                    
                    /// [2:2] set this bit to select pad driver. 1:open-drain. 0:normal.
                    PAD_DRIVER:  u1, 
                    
                    /// [3:4] set GPIO input_sync1 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
                    SYNC1_BYPASS:  u2, 
                    
                    /// [5:6] 
                    res0:  u0, 
                    
                    /// [7:9] set this value to choose interrupt mode. 0:disable GPIO interrupt. 1:trigger at posedge. 2:trigger at negedge. 3:trigger at any edge. 4:valid at low level. 5:valid at high level
                    INT_TYPE:  u3, 
                    
                    /// [10:10] set this bit to enable GPIO wakeup.(can only wakeup CPU from Light-sleep Mode)
                    WAKEUP_ENABLE:  u1, 
                    
                    /// [11:12] reserved
                    CONFIG:  u2, 
                    
                    /// [13:17] set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not shielded) interrupt.
                    INT_ENA:  u5, 
                    
                    /// [18:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x600910e8));
                
                /// GPIO pin configuration register
                pub const PIN0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:1] set GPIO input_sync2 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
                    SYNC2_BYPASS:  u2, 
                    
                    /// [2:2] set this bit to select pad driver. 1:open-drain. 0:normal.
                    PAD_DRIVER:  u1, 
                    
                    /// [3:4] set GPIO input_sync1 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
                    SYNC1_BYPASS:  u2, 
                    
                    /// [5:6] 
                    res0:  u0, 
                    
                    /// [7:9] set this value to choose interrupt mode. 0:disable GPIO interrupt. 1:trigger at posedge. 2:trigger at negedge. 3:trigger at any edge. 4:valid at low level. 5:valid at high level
                    INT_TYPE:  u3, 
                    
                    /// [10:10] set this bit to enable GPIO wakeup.(can only wakeup CPU from Light-sleep Mode)
                    WAKEUP_ENABLE:  u1, 
                    
                    /// [11:12] reserved
                    CONFIG:  u2, 
                    
                    /// [13:17] set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not shielded) interrupt.
                    INT_ENA:  u5, 
                    
                    /// [18:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x600910ec));
                
                /// GPIO pin configuration register
                pub const PIN0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:1] set GPIO input_sync2 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
                    SYNC2_BYPASS:  u2, 
                    
                    /// [2:2] set this bit to select pad driver. 1:open-drain. 0:normal.
                    PAD_DRIVER:  u1, 
                    
                    /// [3:4] set GPIO input_sync1 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
                    SYNC1_BYPASS:  u2, 
                    
                    /// [5:6] 
                    res0:  u0, 
                    
                    /// [7:9] set this value to choose interrupt mode. 0:disable GPIO interrupt. 1:trigger at posedge. 2:trigger at negedge. 3:trigger at any edge. 4:valid at low level. 5:valid at high level
                    INT_TYPE:  u3, 
                    
                    /// [10:10] set this bit to enable GPIO wakeup.(can only wakeup CPU from Light-sleep Mode)
                    WAKEUP_ENABLE:  u1, 
                    
                    /// [11:12] reserved
                    CONFIG:  u2, 
                    
                    /// [13:17] set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not shielded) interrupt.
                    INT_ENA:  u5, 
                    
                    /// [18:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x600910f0));
                
                /// GPIO pin configuration register
                pub const PIN0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:1] set GPIO input_sync2 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
                    SYNC2_BYPASS:  u2, 
                    
                    /// [2:2] set this bit to select pad driver. 1:open-drain. 0:normal.
                    PAD_DRIVER:  u1, 
                    
                    /// [3:4] set GPIO input_sync1 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
                    SYNC1_BYPASS:  u2, 
                    
                    /// [5:6] 
                    res0:  u0, 
                    
                    /// [7:9] set this value to choose interrupt mode. 0:disable GPIO interrupt. 1:trigger at posedge. 2:trigger at negedge. 3:trigger at any edge. 4:valid at low level. 5:valid at high level
                    INT_TYPE:  u3, 
                    
                    /// [10:10] set this bit to enable GPIO wakeup.(can only wakeup CPU from Light-sleep Mode)
                    WAKEUP_ENABLE:  u1, 
                    
                    /// [11:12] reserved
                    CONFIG:  u2, 
                    
                    /// [13:17] set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not shielded) interrupt.
                    INT_ENA:  u5, 
                    
                    /// [18:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x600910f4));
                
                /// GPIO pin configuration register
                pub const PIN0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:1] set GPIO input_sync2 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
                    SYNC2_BYPASS:  u2, 
                    
                    /// [2:2] set this bit to select pad driver. 1:open-drain. 0:normal.
                    PAD_DRIVER:  u1, 
                    
                    /// [3:4] set GPIO input_sync1 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
                    SYNC1_BYPASS:  u2, 
                    
                    /// [5:6] 
                    res0:  u0, 
                    
                    /// [7:9] set this value to choose interrupt mode. 0:disable GPIO interrupt. 1:trigger at posedge. 2:trigger at negedge. 3:trigger at any edge. 4:valid at low level. 5:valid at high level
                    INT_TYPE:  u3, 
                    
                    /// [10:10] set this bit to enable GPIO wakeup.(can only wakeup CPU from Light-sleep Mode)
                    WAKEUP_ENABLE:  u1, 
                    
                    /// [11:12] reserved
                    CONFIG:  u2, 
                    
                    /// [13:17] set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not shielded) interrupt.
                    INT_ENA:  u5, 
                    
                    /// [18:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x600910f8));
                
                /// GPIO pin configuration register
                pub const PIN0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:1] set GPIO input_sync2 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
                    SYNC2_BYPASS:  u2, 
                    
                    /// [2:2] set this bit to select pad driver. 1:open-drain. 0:normal.
                    PAD_DRIVER:  u1, 
                    
                    /// [3:4] set GPIO input_sync1 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
                    SYNC1_BYPASS:  u2, 
                    
                    /// [5:6] 
                    res0:  u0, 
                    
                    /// [7:9] set this value to choose interrupt mode. 0:disable GPIO interrupt. 1:trigger at posedge. 2:trigger at negedge. 3:trigger at any edge. 4:valid at low level. 5:valid at high level
                    INT_TYPE:  u3, 
                    
                    /// [10:10] set this bit to enable GPIO wakeup.(can only wakeup CPU from Light-sleep Mode)
                    WAKEUP_ENABLE:  u1, 
                    
                    /// [11:12] reserved
                    CONFIG:  u2, 
                    
                    /// [13:17] set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not shielded) interrupt.
                    INT_ENA:  u5, 
                    
                    /// [18:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x600910fc));
                
                /// GPIO interrupt source register for GPIO0-31
                pub const STATUS_NEXT = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] GPIO interrupt source register for GPIO0-31
                    STATUS_INTERRUPT_NEXT:  u32, 
                    
                }), @ptrFromInt(0x6009114c));
                
                /// GPIO interrupt source register for GPIO32-34
                pub const STATUS_NEXT1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:2] GPIO interrupt source register for GPIO32-34
                    STATUS_INTERRUPT_NEXT1:  u3, 
                    
                    /// [3:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60091150));
                
                /// GPIO input function configuration register
                pub const FUNC0_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
                    IN_SEL:  u6, 
                    
                    /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
                    IN_INV_SEL:  u1, 
                    
                    /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
                    SEL:  u1, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60091154));
                
                /// GPIO input function configuration register
                pub const FUNC0_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
                    IN_SEL:  u6, 
                    
                    /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
                    IN_INV_SEL:  u1, 
                    
                    /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
                    SEL:  u1, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60091158));
                
                /// GPIO input function configuration register
                pub const FUNC0_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
                    IN_SEL:  u6, 
                    
                    /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
                    IN_INV_SEL:  u1, 
                    
                    /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
                    SEL:  u1, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6009115c));
                
                /// GPIO input function configuration register
                pub const FUNC0_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
                    IN_SEL:  u6, 
                    
                    /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
                    IN_INV_SEL:  u1, 
                    
                    /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
                    SEL:  u1, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60091160));
                
                /// GPIO input function configuration register
                pub const FUNC0_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
                    IN_SEL:  u6, 
                    
                    /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
                    IN_INV_SEL:  u1, 
                    
                    /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
                    SEL:  u1, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60091164));
                
                /// GPIO input function configuration register
                pub const FUNC0_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
                    IN_SEL:  u6, 
                    
                    /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
                    IN_INV_SEL:  u1, 
                    
                    /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
                    SEL:  u1, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60091168));
                
                /// GPIO input function configuration register
                pub const FUNC0_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
                    IN_SEL:  u6, 
                    
                    /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
                    IN_INV_SEL:  u1, 
                    
                    /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
                    SEL:  u1, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6009116c));
                
                /// GPIO input function configuration register
                pub const FUNC0_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
                    IN_SEL:  u6, 
                    
                    /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
                    IN_INV_SEL:  u1, 
                    
                    /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
                    SEL:  u1, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60091170));
                
                /// GPIO input function configuration register
                pub const FUNC0_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
                    IN_SEL:  u6, 
                    
                    /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
                    IN_INV_SEL:  u1, 
                    
                    /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
                    SEL:  u1, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60091174));
                
                /// GPIO input function configuration register
                pub const FUNC0_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
                    IN_SEL:  u6, 
                    
                    /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
                    IN_INV_SEL:  u1, 
                    
                    /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
                    SEL:  u1, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60091178));
                
                /// GPIO input function configuration register
                pub const FUNC0_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
                    IN_SEL:  u6, 
                    
                    /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
                    IN_INV_SEL:  u1, 
                    
                    /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
                    SEL:  u1, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6009117c));
                
                /// GPIO input function configuration register
                pub const FUNC0_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
                    IN_SEL:  u6, 
                    
                    /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
                    IN_INV_SEL:  u1, 
                    
                    /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
                    SEL:  u1, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60091180));
                
                /// GPIO input function configuration register
                pub const FUNC0_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
                    IN_SEL:  u6, 
                    
                    /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
                    IN_INV_SEL:  u1, 
                    
                    /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
                    SEL:  u1, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60091184));
                
                /// GPIO input function configuration register
                pub const FUNC0_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
                    IN_SEL:  u6, 
                    
                    /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
                    IN_INV_SEL:  u1, 
                    
                    /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
                    SEL:  u1, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60091188));
                
                /// GPIO input function configuration register
                pub const FUNC0_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
                    IN_SEL:  u6, 
                    
                    /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
                    IN_INV_SEL:  u1, 
                    
                    /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
                    SEL:  u1, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6009118c));
                
                /// GPIO input function configuration register
                pub const FUNC0_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
                    IN_SEL:  u6, 
                    
                    /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
                    IN_INV_SEL:  u1, 
                    
                    /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
                    SEL:  u1, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60091190));
                
                /// GPIO input function configuration register
                pub const FUNC0_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
                    IN_SEL:  u6, 
                    
                    /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
                    IN_INV_SEL:  u1, 
                    
                    /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
                    SEL:  u1, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60091194));
                
                /// GPIO input function configuration register
                pub const FUNC0_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
                    IN_SEL:  u6, 
                    
                    /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
                    IN_INV_SEL:  u1, 
                    
                    /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
                    SEL:  u1, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60091198));
                
                /// GPIO input function configuration register
                pub const FUNC0_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
                    IN_SEL:  u6, 
                    
                    /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
                    IN_INV_SEL:  u1, 
                    
                    /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
                    SEL:  u1, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6009119c));
                
                /// GPIO input function configuration register
                pub const FUNC0_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
                    IN_SEL:  u6, 
                    
                    /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
                    IN_INV_SEL:  u1, 
                    
                    /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
                    SEL:  u1, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600911a0));
                
                /// GPIO input function configuration register
                pub const FUNC0_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
                    IN_SEL:  u6, 
                    
                    /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
                    IN_INV_SEL:  u1, 
                    
                    /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
                    SEL:  u1, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600911a4));
                
                /// GPIO input function configuration register
                pub const FUNC0_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
                    IN_SEL:  u6, 
                    
                    /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
                    IN_INV_SEL:  u1, 
                    
                    /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
                    SEL:  u1, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600911a8));
                
                /// GPIO input function configuration register
                pub const FUNC0_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
                    IN_SEL:  u6, 
                    
                    /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
                    IN_INV_SEL:  u1, 
                    
                    /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
                    SEL:  u1, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600911ac));
                
                /// GPIO input function configuration register
                pub const FUNC0_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
                    IN_SEL:  u6, 
                    
                    /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
                    IN_INV_SEL:  u1, 
                    
                    /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
                    SEL:  u1, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600911b0));
                
                /// GPIO input function configuration register
                pub const FUNC0_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
                    IN_SEL:  u6, 
                    
                    /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
                    IN_INV_SEL:  u1, 
                    
                    /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
                    SEL:  u1, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600911b4));
                
                /// GPIO input function configuration register
                pub const FUNC0_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
                    IN_SEL:  u6, 
                    
                    /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
                    IN_INV_SEL:  u1, 
                    
                    /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
                    SEL:  u1, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600911b8));
                
                /// GPIO input function configuration register
                pub const FUNC0_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
                    IN_SEL:  u6, 
                    
                    /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
                    IN_INV_SEL:  u1, 
                    
                    /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
                    SEL:  u1, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600911bc));
                
                /// GPIO input function configuration register
                pub const FUNC0_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
                    IN_SEL:  u6, 
                    
                    /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
                    IN_INV_SEL:  u1, 
                    
                    /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
                    SEL:  u1, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600911c0));
                
                /// GPIO input function configuration register
                pub const FUNC0_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
                    IN_SEL:  u6, 
                    
                    /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
                    IN_INV_SEL:  u1, 
                    
                    /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
                    SEL:  u1, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600911c4));
                
                /// GPIO input function configuration register
                pub const FUNC0_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
                    IN_SEL:  u6, 
                    
                    /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
                    IN_INV_SEL:  u1, 
                    
                    /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
                    SEL:  u1, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600911c8));
                
                /// GPIO input function configuration register
                pub const FUNC0_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
                    IN_SEL:  u6, 
                    
                    /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
                    IN_INV_SEL:  u1, 
                    
                    /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
                    SEL:  u1, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600911cc));
                
                /// GPIO input function configuration register
                pub const FUNC0_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
                    IN_SEL:  u6, 
                    
                    /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
                    IN_INV_SEL:  u1, 
                    
                    /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
                    SEL:  u1, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600911d0));
                
                /// GPIO input function configuration register
                pub const FUNC0_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
                    IN_SEL:  u6, 
                    
                    /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
                    IN_INV_SEL:  u1, 
                    
                    /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
                    SEL:  u1, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600911d4));
                
                /// GPIO input function configuration register
                pub const FUNC0_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
                    IN_SEL:  u6, 
                    
                    /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
                    IN_INV_SEL:  u1, 
                    
                    /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
                    SEL:  u1, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600911d8));
                
                /// GPIO input function configuration register
                pub const FUNC0_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
                    IN_SEL:  u6, 
                    
                    /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
                    IN_INV_SEL:  u1, 
                    
                    /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
                    SEL:  u1, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600911dc));
                
                /// GPIO input function configuration register
                pub const FUNC0_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
                    IN_SEL:  u6, 
                    
                    /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
                    IN_INV_SEL:  u1, 
                    
                    /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
                    SEL:  u1, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600911e0));
                
                /// GPIO input function configuration register
                pub const FUNC0_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
                    IN_SEL:  u6, 
                    
                    /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
                    IN_INV_SEL:  u1, 
                    
                    /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
                    SEL:  u1, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600911e4));
                
                /// GPIO input function configuration register
                pub const FUNC0_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
                    IN_SEL:  u6, 
                    
                    /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
                    IN_INV_SEL:  u1, 
                    
                    /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
                    SEL:  u1, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600911e8));
                
                /// GPIO input function configuration register
                pub const FUNC0_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
                    IN_SEL:  u6, 
                    
                    /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
                    IN_INV_SEL:  u1, 
                    
                    /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
                    SEL:  u1, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600911ec));
                
                /// GPIO input function configuration register
                pub const FUNC0_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
                    IN_SEL:  u6, 
                    
                    /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
                    IN_INV_SEL:  u1, 
                    
                    /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
                    SEL:  u1, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600911f0));
                
                /// GPIO input function configuration register
                pub const FUNC0_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
                    IN_SEL:  u6, 
                    
                    /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
                    IN_INV_SEL:  u1, 
                    
                    /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
                    SEL:  u1, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600911f4));
                
                /// GPIO input function configuration register
                pub const FUNC0_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
                    IN_SEL:  u6, 
                    
                    /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
                    IN_INV_SEL:  u1, 
                    
                    /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
                    SEL:  u1, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600911f8));
                
                /// GPIO input function configuration register
                pub const FUNC0_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
                    IN_SEL:  u6, 
                    
                    /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
                    IN_INV_SEL:  u1, 
                    
                    /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
                    SEL:  u1, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600911fc));
                
                /// GPIO input function configuration register
                pub const FUNC0_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
                    IN_SEL:  u6, 
                    
                    /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
                    IN_INV_SEL:  u1, 
                    
                    /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
                    SEL:  u1, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60091200));
                
                /// GPIO input function configuration register
                pub const FUNC0_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
                    IN_SEL:  u6, 
                    
                    /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
                    IN_INV_SEL:  u1, 
                    
                    /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
                    SEL:  u1, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60091204));
                
                /// GPIO input function configuration register
                pub const FUNC0_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
                    IN_SEL:  u6, 
                    
                    /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
                    IN_INV_SEL:  u1, 
                    
                    /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
                    SEL:  u1, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60091208));
                
                /// GPIO input function configuration register
                pub const FUNC0_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
                    IN_SEL:  u6, 
                    
                    /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
                    IN_INV_SEL:  u1, 
                    
                    /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
                    SEL:  u1, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6009120c));
                
                /// GPIO input function configuration register
                pub const FUNC0_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
                    IN_SEL:  u6, 
                    
                    /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
                    IN_INV_SEL:  u1, 
                    
                    /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
                    SEL:  u1, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60091210));
                
                /// GPIO input function configuration register
                pub const FUNC0_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
                    IN_SEL:  u6, 
                    
                    /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
                    IN_INV_SEL:  u1, 
                    
                    /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
                    SEL:  u1, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60091214));
                
                /// GPIO input function configuration register
                pub const FUNC0_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
                    IN_SEL:  u6, 
                    
                    /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
                    IN_INV_SEL:  u1, 
                    
                    /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
                    SEL:  u1, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60091218));
                
                /// GPIO input function configuration register
                pub const FUNC0_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
                    IN_SEL:  u6, 
                    
                    /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
                    IN_INV_SEL:  u1, 
                    
                    /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
                    SEL:  u1, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6009121c));
                
                /// GPIO input function configuration register
                pub const FUNC0_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
                    IN_SEL:  u6, 
                    
                    /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
                    IN_INV_SEL:  u1, 
                    
                    /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
                    SEL:  u1, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60091220));
                
                /// GPIO input function configuration register
                pub const FUNC0_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
                    IN_SEL:  u6, 
                    
                    /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
                    IN_INV_SEL:  u1, 
                    
                    /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
                    SEL:  u1, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60091224));
                
                /// GPIO input function configuration register
                pub const FUNC0_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
                    IN_SEL:  u6, 
                    
                    /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
                    IN_INV_SEL:  u1, 
                    
                    /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
                    SEL:  u1, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60091228));
                
                /// GPIO input function configuration register
                pub const FUNC0_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
                    IN_SEL:  u6, 
                    
                    /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
                    IN_INV_SEL:  u1, 
                    
                    /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
                    SEL:  u1, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6009122c));
                
                /// GPIO input function configuration register
                pub const FUNC0_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
                    IN_SEL:  u6, 
                    
                    /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
                    IN_INV_SEL:  u1, 
                    
                    /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
                    SEL:  u1, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60091230));
                
                /// GPIO input function configuration register
                pub const FUNC0_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
                    IN_SEL:  u6, 
                    
                    /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
                    IN_INV_SEL:  u1, 
                    
                    /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
                    SEL:  u1, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60091234));
                
                /// GPIO input function configuration register
                pub const FUNC0_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
                    IN_SEL:  u6, 
                    
                    /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
                    IN_INV_SEL:  u1, 
                    
                    /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
                    SEL:  u1, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60091238));
                
                /// GPIO input function configuration register
                pub const FUNC0_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
                    IN_SEL:  u6, 
                    
                    /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
                    IN_INV_SEL:  u1, 
                    
                    /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
                    SEL:  u1, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6009123c));
                
                /// GPIO input function configuration register
                pub const FUNC0_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
                    IN_SEL:  u6, 
                    
                    /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
                    IN_INV_SEL:  u1, 
                    
                    /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
                    SEL:  u1, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60091240));
                
                /// GPIO input function configuration register
                pub const FUNC0_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
                    IN_SEL:  u6, 
                    
                    /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
                    IN_INV_SEL:  u1, 
                    
                    /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
                    SEL:  u1, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60091244));
                
                /// GPIO input function configuration register
                pub const FUNC0_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
                    IN_SEL:  u6, 
                    
                    /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
                    IN_INV_SEL:  u1, 
                    
                    /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
                    SEL:  u1, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60091248));
                
                /// GPIO input function configuration register
                pub const FUNC0_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
                    IN_SEL:  u6, 
                    
                    /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
                    IN_INV_SEL:  u1, 
                    
                    /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
                    SEL:  u1, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6009124c));
                
                /// GPIO input function configuration register
                pub const FUNC0_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
                    IN_SEL:  u6, 
                    
                    /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
                    IN_INV_SEL:  u1, 
                    
                    /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
                    SEL:  u1, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60091250));
                
                /// GPIO input function configuration register
                pub const FUNC0_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
                    IN_SEL:  u6, 
                    
                    /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
                    IN_INV_SEL:  u1, 
                    
                    /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
                    SEL:  u1, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60091254));
                
                /// GPIO input function configuration register
                pub const FUNC0_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
                    IN_SEL:  u6, 
                    
                    /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
                    IN_INV_SEL:  u1, 
                    
                    /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
                    SEL:  u1, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60091258));
                
                /// GPIO input function configuration register
                pub const FUNC0_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
                    IN_SEL:  u6, 
                    
                    /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
                    IN_INV_SEL:  u1, 
                    
                    /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
                    SEL:  u1, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6009125c));
                
                /// GPIO input function configuration register
                pub const FUNC0_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
                    IN_SEL:  u6, 
                    
                    /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
                    IN_INV_SEL:  u1, 
                    
                    /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
                    SEL:  u1, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60091260));
                
                /// GPIO input function configuration register
                pub const FUNC0_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
                    IN_SEL:  u6, 
                    
                    /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
                    IN_INV_SEL:  u1, 
                    
                    /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
                    SEL:  u1, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60091264));
                
                /// GPIO input function configuration register
                pub const FUNC0_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
                    IN_SEL:  u6, 
                    
                    /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
                    IN_INV_SEL:  u1, 
                    
                    /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
                    SEL:  u1, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60091268));
                
                /// GPIO input function configuration register
                pub const FUNC0_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
                    IN_SEL:  u6, 
                    
                    /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
                    IN_INV_SEL:  u1, 
                    
                    /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
                    SEL:  u1, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6009126c));
                
                /// GPIO input function configuration register
                pub const FUNC0_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
                    IN_SEL:  u6, 
                    
                    /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
                    IN_INV_SEL:  u1, 
                    
                    /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
                    SEL:  u1, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60091270));
                
                /// GPIO input function configuration register
                pub const FUNC0_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
                    IN_SEL:  u6, 
                    
                    /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
                    IN_INV_SEL:  u1, 
                    
                    /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
                    SEL:  u1, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60091274));
                
                /// GPIO input function configuration register
                pub const FUNC0_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
                    IN_SEL:  u6, 
                    
                    /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
                    IN_INV_SEL:  u1, 
                    
                    /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
                    SEL:  u1, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60091278));
                
                /// GPIO input function configuration register
                pub const FUNC0_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
                    IN_SEL:  u6, 
                    
                    /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
                    IN_INV_SEL:  u1, 
                    
                    /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
                    SEL:  u1, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6009127c));
                
                /// GPIO input function configuration register
                pub const FUNC0_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
                    IN_SEL:  u6, 
                    
                    /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
                    IN_INV_SEL:  u1, 
                    
                    /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
                    SEL:  u1, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60091280));
                
                /// GPIO input function configuration register
                pub const FUNC0_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
                    IN_SEL:  u6, 
                    
                    /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
                    IN_INV_SEL:  u1, 
                    
                    /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
                    SEL:  u1, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60091284));
                
                /// GPIO input function configuration register
                pub const FUNC0_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
                    IN_SEL:  u6, 
                    
                    /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
                    IN_INV_SEL:  u1, 
                    
                    /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
                    SEL:  u1, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60091288));
                
                /// GPIO input function configuration register
                pub const FUNC0_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
                    IN_SEL:  u6, 
                    
                    /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
                    IN_INV_SEL:  u1, 
                    
                    /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
                    SEL:  u1, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6009128c));
                
                /// GPIO input function configuration register
                pub const FUNC0_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
                    IN_SEL:  u6, 
                    
                    /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
                    IN_INV_SEL:  u1, 
                    
                    /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
                    SEL:  u1, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60091290));
                
                /// GPIO input function configuration register
                pub const FUNC0_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
                    IN_SEL:  u6, 
                    
                    /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
                    IN_INV_SEL:  u1, 
                    
                    /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
                    SEL:  u1, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60091294));
                
                /// GPIO input function configuration register
                pub const FUNC0_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
                    IN_SEL:  u6, 
                    
                    /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
                    IN_INV_SEL:  u1, 
                    
                    /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
                    SEL:  u1, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60091298));
                
                /// GPIO input function configuration register
                pub const FUNC0_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
                    IN_SEL:  u6, 
                    
                    /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
                    IN_INV_SEL:  u1, 
                    
                    /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
                    SEL:  u1, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6009129c));
                
                /// GPIO input function configuration register
                pub const FUNC0_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
                    IN_SEL:  u6, 
                    
                    /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
                    IN_INV_SEL:  u1, 
                    
                    /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
                    SEL:  u1, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600912a0));
                
                /// GPIO input function configuration register
                pub const FUNC0_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
                    IN_SEL:  u6, 
                    
                    /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
                    IN_INV_SEL:  u1, 
                    
                    /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
                    SEL:  u1, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600912a4));
                
                /// GPIO input function configuration register
                pub const FUNC0_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
                    IN_SEL:  u6, 
                    
                    /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
                    IN_INV_SEL:  u1, 
                    
                    /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
                    SEL:  u1, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600912a8));
                
                /// GPIO input function configuration register
                pub const FUNC0_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
                    IN_SEL:  u6, 
                    
                    /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
                    IN_INV_SEL:  u1, 
                    
                    /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
                    SEL:  u1, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600912ac));
                
                /// GPIO input function configuration register
                pub const FUNC0_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
                    IN_SEL:  u6, 
                    
                    /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
                    IN_INV_SEL:  u1, 
                    
                    /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
                    SEL:  u1, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600912b0));
                
                /// GPIO input function configuration register
                pub const FUNC0_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
                    IN_SEL:  u6, 
                    
                    /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
                    IN_INV_SEL:  u1, 
                    
                    /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
                    SEL:  u1, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600912b4));
                
                /// GPIO input function configuration register
                pub const FUNC0_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
                    IN_SEL:  u6, 
                    
                    /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
                    IN_INV_SEL:  u1, 
                    
                    /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
                    SEL:  u1, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600912b8));
                
                /// GPIO input function configuration register
                pub const FUNC0_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
                    IN_SEL:  u6, 
                    
                    /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
                    IN_INV_SEL:  u1, 
                    
                    /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
                    SEL:  u1, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600912bc));
                
                /// GPIO input function configuration register
                pub const FUNC0_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
                    IN_SEL:  u6, 
                    
                    /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
                    IN_INV_SEL:  u1, 
                    
                    /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
                    SEL:  u1, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600912c0));
                
                /// GPIO input function configuration register
                pub const FUNC0_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
                    IN_SEL:  u6, 
                    
                    /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
                    IN_INV_SEL:  u1, 
                    
                    /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
                    SEL:  u1, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600912c4));
                
                /// GPIO input function configuration register
                pub const FUNC0_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
                    IN_SEL:  u6, 
                    
                    /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
                    IN_INV_SEL:  u1, 
                    
                    /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
                    SEL:  u1, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600912c8));
                
                /// GPIO input function configuration register
                pub const FUNC0_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
                    IN_SEL:  u6, 
                    
                    /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
                    IN_INV_SEL:  u1, 
                    
                    /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
                    SEL:  u1, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600912cc));
                
                /// GPIO input function configuration register
                pub const FUNC0_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
                    IN_SEL:  u6, 
                    
                    /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
                    IN_INV_SEL:  u1, 
                    
                    /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
                    SEL:  u1, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600912d0));
                
                /// GPIO input function configuration register
                pub const FUNC0_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
                    IN_SEL:  u6, 
                    
                    /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
                    IN_INV_SEL:  u1, 
                    
                    /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
                    SEL:  u1, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600912d4));
                
                /// GPIO input function configuration register
                pub const FUNC0_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
                    IN_SEL:  u6, 
                    
                    /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
                    IN_INV_SEL:  u1, 
                    
                    /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
                    SEL:  u1, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600912d8));
                
                /// GPIO input function configuration register
                pub const FUNC0_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
                    IN_SEL:  u6, 
                    
                    /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
                    IN_INV_SEL:  u1, 
                    
                    /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
                    SEL:  u1, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600912dc));
                
                /// GPIO input function configuration register
                pub const FUNC0_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
                    IN_SEL:  u6, 
                    
                    /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
                    IN_INV_SEL:  u1, 
                    
                    /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
                    SEL:  u1, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600912e0));
                
                /// GPIO input function configuration register
                pub const FUNC0_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
                    IN_SEL:  u6, 
                    
                    /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
                    IN_INV_SEL:  u1, 
                    
                    /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
                    SEL:  u1, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600912e4));
                
                /// GPIO input function configuration register
                pub const FUNC0_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
                    IN_SEL:  u6, 
                    
                    /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
                    IN_INV_SEL:  u1, 
                    
                    /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
                    SEL:  u1, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600912e8));
                
                /// GPIO input function configuration register
                pub const FUNC0_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
                    IN_SEL:  u6, 
                    
                    /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
                    IN_INV_SEL:  u1, 
                    
                    /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
                    SEL:  u1, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600912ec));
                
                /// GPIO input function configuration register
                pub const FUNC0_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
                    IN_SEL:  u6, 
                    
                    /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
                    IN_INV_SEL:  u1, 
                    
                    /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
                    SEL:  u1, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600912f0));
                
                /// GPIO input function configuration register
                pub const FUNC0_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
                    IN_SEL:  u6, 
                    
                    /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
                    IN_INV_SEL:  u1, 
                    
                    /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
                    SEL:  u1, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600912f4));
                
                /// GPIO input function configuration register
                pub const FUNC0_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
                    IN_SEL:  u6, 
                    
                    /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
                    IN_INV_SEL:  u1, 
                    
                    /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
                    SEL:  u1, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600912f8));
                
                /// GPIO input function configuration register
                pub const FUNC0_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
                    IN_SEL:  u6, 
                    
                    /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
                    IN_INV_SEL:  u1, 
                    
                    /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
                    SEL:  u1, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600912fc));
                
                /// GPIO input function configuration register
                pub const FUNC0_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
                    IN_SEL:  u6, 
                    
                    /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
                    IN_INV_SEL:  u1, 
                    
                    /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
                    SEL:  u1, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60091300));
                
                /// GPIO input function configuration register
                pub const FUNC0_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
                    IN_SEL:  u6, 
                    
                    /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
                    IN_INV_SEL:  u1, 
                    
                    /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
                    SEL:  u1, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60091304));
                
                /// GPIO input function configuration register
                pub const FUNC0_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
                    IN_SEL:  u6, 
                    
                    /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
                    IN_INV_SEL:  u1, 
                    
                    /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
                    SEL:  u1, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60091308));
                
                /// GPIO input function configuration register
                pub const FUNC0_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
                    IN_SEL:  u6, 
                    
                    /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
                    IN_INV_SEL:  u1, 
                    
                    /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
                    SEL:  u1, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6009130c));
                
                /// GPIO input function configuration register
                pub const FUNC0_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
                    IN_SEL:  u6, 
                    
                    /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
                    IN_INV_SEL:  u1, 
                    
                    /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
                    SEL:  u1, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60091310));
                
                /// GPIO input function configuration register
                pub const FUNC0_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
                    IN_SEL:  u6, 
                    
                    /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
                    IN_INV_SEL:  u1, 
                    
                    /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
                    SEL:  u1, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60091314));
                
                /// GPIO input function configuration register
                pub const FUNC0_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
                    IN_SEL:  u6, 
                    
                    /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
                    IN_INV_SEL:  u1, 
                    
                    /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
                    SEL:  u1, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60091318));
                
                /// GPIO input function configuration register
                pub const FUNC0_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
                    IN_SEL:  u6, 
                    
                    /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
                    IN_INV_SEL:  u1, 
                    
                    /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
                    SEL:  u1, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6009131c));
                
                /// GPIO input function configuration register
                pub const FUNC0_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
                    IN_SEL:  u6, 
                    
                    /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
                    IN_INV_SEL:  u1, 
                    
                    /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
                    SEL:  u1, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60091320));
                
                /// GPIO input function configuration register
                pub const FUNC0_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
                    IN_SEL:  u6, 
                    
                    /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
                    IN_INV_SEL:  u1, 
                    
                    /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
                    SEL:  u1, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60091324));
                
                /// GPIO input function configuration register
                pub const FUNC0_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
                    IN_SEL:  u6, 
                    
                    /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
                    IN_INV_SEL:  u1, 
                    
                    /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
                    SEL:  u1, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60091328));
                
                /// GPIO input function configuration register
                pub const FUNC0_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
                    IN_SEL:  u6, 
                    
                    /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
                    IN_INV_SEL:  u1, 
                    
                    /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
                    SEL:  u1, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6009132c));
                
                /// GPIO input function configuration register
                pub const FUNC0_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
                    IN_SEL:  u6, 
                    
                    /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
                    IN_INV_SEL:  u1, 
                    
                    /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
                    SEL:  u1, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60091330));
                
                /// GPIO input function configuration register
                pub const FUNC0_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
                    IN_SEL:  u6, 
                    
                    /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
                    IN_INV_SEL:  u1, 
                    
                    /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
                    SEL:  u1, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60091334));
                
                /// GPIO input function configuration register
                pub const FUNC0_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
                    IN_SEL:  u6, 
                    
                    /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
                    IN_INV_SEL:  u1, 
                    
                    /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
                    SEL:  u1, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60091338));
                
                /// GPIO input function configuration register
                pub const FUNC0_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
                    IN_SEL:  u6, 
                    
                    /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
                    IN_INV_SEL:  u1, 
                    
                    /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
                    SEL:  u1, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6009133c));
                
                /// GPIO input function configuration register
                pub const FUNC0_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
                    IN_SEL:  u6, 
                    
                    /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
                    IN_INV_SEL:  u1, 
                    
                    /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
                    SEL:  u1, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60091340));
                
                /// GPIO input function configuration register
                pub const FUNC0_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
                    IN_SEL:  u6, 
                    
                    /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
                    IN_INV_SEL:  u1, 
                    
                    /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
                    SEL:  u1, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60091344));
                
                /// GPIO input function configuration register
                pub const FUNC0_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
                    IN_SEL:  u6, 
                    
                    /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
                    IN_INV_SEL:  u1, 
                    
                    /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
                    SEL:  u1, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60091348));
                
                /// GPIO input function configuration register
                pub const FUNC0_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
                    IN_SEL:  u6, 
                    
                    /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
                    IN_INV_SEL:  u1, 
                    
                    /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
                    SEL:  u1, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6009134c));
                
                /// GPIO input function configuration register
                pub const FUNC0_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
                    IN_SEL:  u6, 
                    
                    /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
                    IN_INV_SEL:  u1, 
                    
                    /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
                    SEL:  u1, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60091350));
                
                /// GPIO output function select register
                pub const FUNC0_OUT_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] The value of the bits: 0<=s<=256. Set the value to select output signal. s=0-127: output of GPIO[n] equals input of peripheral[s]. s=128: output of GPIO[n] equals GPIO_OUT_REG[n].
                    OUT_SEL:  u8, 
                    
                    /// [8:8] set this bit to invert output signal.1:invert.0:not invert.
                    INV_SEL:  u1, 
                    
                    /// [9:9] set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n] as output enable signal.0:use peripheral output enable signal.
                    OEN_SEL:  u1, 
                    
                    /// [10:10] set this bit to invert output enable signal.1:invert.0:not invert.
                    OEN_INV_SEL:  u1, 
                    
                    /// [11:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60091554));
                
                /// GPIO output function select register
                pub const FUNC0_OUT_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] The value of the bits: 0<=s<=256. Set the value to select output signal. s=0-127: output of GPIO[n] equals input of peripheral[s]. s=128: output of GPIO[n] equals GPIO_OUT_REG[n].
                    OUT_SEL:  u8, 
                    
                    /// [8:8] set this bit to invert output signal.1:invert.0:not invert.
                    INV_SEL:  u1, 
                    
                    /// [9:9] set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n] as output enable signal.0:use peripheral output enable signal.
                    OEN_SEL:  u1, 
                    
                    /// [10:10] set this bit to invert output enable signal.1:invert.0:not invert.
                    OEN_INV_SEL:  u1, 
                    
                    /// [11:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60091558));
                
                /// GPIO output function select register
                pub const FUNC0_OUT_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] The value of the bits: 0<=s<=256. Set the value to select output signal. s=0-127: output of GPIO[n] equals input of peripheral[s]. s=128: output of GPIO[n] equals GPIO_OUT_REG[n].
                    OUT_SEL:  u8, 
                    
                    /// [8:8] set this bit to invert output signal.1:invert.0:not invert.
                    INV_SEL:  u1, 
                    
                    /// [9:9] set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n] as output enable signal.0:use peripheral output enable signal.
                    OEN_SEL:  u1, 
                    
                    /// [10:10] set this bit to invert output enable signal.1:invert.0:not invert.
                    OEN_INV_SEL:  u1, 
                    
                    /// [11:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6009155c));
                
                /// GPIO output function select register
                pub const FUNC0_OUT_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] The value of the bits: 0<=s<=256. Set the value to select output signal. s=0-127: output of GPIO[n] equals input of peripheral[s]. s=128: output of GPIO[n] equals GPIO_OUT_REG[n].
                    OUT_SEL:  u8, 
                    
                    /// [8:8] set this bit to invert output signal.1:invert.0:not invert.
                    INV_SEL:  u1, 
                    
                    /// [9:9] set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n] as output enable signal.0:use peripheral output enable signal.
                    OEN_SEL:  u1, 
                    
                    /// [10:10] set this bit to invert output enable signal.1:invert.0:not invert.
                    OEN_INV_SEL:  u1, 
                    
                    /// [11:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60091560));
                
                /// GPIO output function select register
                pub const FUNC0_OUT_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] The value of the bits: 0<=s<=256. Set the value to select output signal. s=0-127: output of GPIO[n] equals input of peripheral[s]. s=128: output of GPIO[n] equals GPIO_OUT_REG[n].
                    OUT_SEL:  u8, 
                    
                    /// [8:8] set this bit to invert output signal.1:invert.0:not invert.
                    INV_SEL:  u1, 
                    
                    /// [9:9] set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n] as output enable signal.0:use peripheral output enable signal.
                    OEN_SEL:  u1, 
                    
                    /// [10:10] set this bit to invert output enable signal.1:invert.0:not invert.
                    OEN_INV_SEL:  u1, 
                    
                    /// [11:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60091564));
                
                /// GPIO output function select register
                pub const FUNC0_OUT_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] The value of the bits: 0<=s<=256. Set the value to select output signal. s=0-127: output of GPIO[n] equals input of peripheral[s]. s=128: output of GPIO[n] equals GPIO_OUT_REG[n].
                    OUT_SEL:  u8, 
                    
                    /// [8:8] set this bit to invert output signal.1:invert.0:not invert.
                    INV_SEL:  u1, 
                    
                    /// [9:9] set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n] as output enable signal.0:use peripheral output enable signal.
                    OEN_SEL:  u1, 
                    
                    /// [10:10] set this bit to invert output enable signal.1:invert.0:not invert.
                    OEN_INV_SEL:  u1, 
                    
                    /// [11:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60091568));
                
                /// GPIO output function select register
                pub const FUNC0_OUT_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] The value of the bits: 0<=s<=256. Set the value to select output signal. s=0-127: output of GPIO[n] equals input of peripheral[s]. s=128: output of GPIO[n] equals GPIO_OUT_REG[n].
                    OUT_SEL:  u8, 
                    
                    /// [8:8] set this bit to invert output signal.1:invert.0:not invert.
                    INV_SEL:  u1, 
                    
                    /// [9:9] set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n] as output enable signal.0:use peripheral output enable signal.
                    OEN_SEL:  u1, 
                    
                    /// [10:10] set this bit to invert output enable signal.1:invert.0:not invert.
                    OEN_INV_SEL:  u1, 
                    
                    /// [11:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6009156c));
                
                /// GPIO output function select register
                pub const FUNC0_OUT_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] The value of the bits: 0<=s<=256. Set the value to select output signal. s=0-127: output of GPIO[n] equals input of peripheral[s]. s=128: output of GPIO[n] equals GPIO_OUT_REG[n].
                    OUT_SEL:  u8, 
                    
                    /// [8:8] set this bit to invert output signal.1:invert.0:not invert.
                    INV_SEL:  u1, 
                    
                    /// [9:9] set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n] as output enable signal.0:use peripheral output enable signal.
                    OEN_SEL:  u1, 
                    
                    /// [10:10] set this bit to invert output enable signal.1:invert.0:not invert.
                    OEN_INV_SEL:  u1, 
                    
                    /// [11:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60091570));
                
                /// GPIO output function select register
                pub const FUNC0_OUT_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] The value of the bits: 0<=s<=256. Set the value to select output signal. s=0-127: output of GPIO[n] equals input of peripheral[s]. s=128: output of GPIO[n] equals GPIO_OUT_REG[n].
                    OUT_SEL:  u8, 
                    
                    /// [8:8] set this bit to invert output signal.1:invert.0:not invert.
                    INV_SEL:  u1, 
                    
                    /// [9:9] set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n] as output enable signal.0:use peripheral output enable signal.
                    OEN_SEL:  u1, 
                    
                    /// [10:10] set this bit to invert output enable signal.1:invert.0:not invert.
                    OEN_INV_SEL:  u1, 
                    
                    /// [11:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60091574));
                
                /// GPIO output function select register
                pub const FUNC0_OUT_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] The value of the bits: 0<=s<=256. Set the value to select output signal. s=0-127: output of GPIO[n] equals input of peripheral[s]. s=128: output of GPIO[n] equals GPIO_OUT_REG[n].
                    OUT_SEL:  u8, 
                    
                    /// [8:8] set this bit to invert output signal.1:invert.0:not invert.
                    INV_SEL:  u1, 
                    
                    /// [9:9] set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n] as output enable signal.0:use peripheral output enable signal.
                    OEN_SEL:  u1, 
                    
                    /// [10:10] set this bit to invert output enable signal.1:invert.0:not invert.
                    OEN_INV_SEL:  u1, 
                    
                    /// [11:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60091578));
                
                /// GPIO output function select register
                pub const FUNC0_OUT_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] The value of the bits: 0<=s<=256. Set the value to select output signal. s=0-127: output of GPIO[n] equals input of peripheral[s]. s=128: output of GPIO[n] equals GPIO_OUT_REG[n].
                    OUT_SEL:  u8, 
                    
                    /// [8:8] set this bit to invert output signal.1:invert.0:not invert.
                    INV_SEL:  u1, 
                    
                    /// [9:9] set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n] as output enable signal.0:use peripheral output enable signal.
                    OEN_SEL:  u1, 
                    
                    /// [10:10] set this bit to invert output enable signal.1:invert.0:not invert.
                    OEN_INV_SEL:  u1, 
                    
                    /// [11:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6009157c));
                
                /// GPIO output function select register
                pub const FUNC0_OUT_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] The value of the bits: 0<=s<=256. Set the value to select output signal. s=0-127: output of GPIO[n] equals input of peripheral[s]. s=128: output of GPIO[n] equals GPIO_OUT_REG[n].
                    OUT_SEL:  u8, 
                    
                    /// [8:8] set this bit to invert output signal.1:invert.0:not invert.
                    INV_SEL:  u1, 
                    
                    /// [9:9] set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n] as output enable signal.0:use peripheral output enable signal.
                    OEN_SEL:  u1, 
                    
                    /// [10:10] set this bit to invert output enable signal.1:invert.0:not invert.
                    OEN_INV_SEL:  u1, 
                    
                    /// [11:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60091580));
                
                /// GPIO output function select register
                pub const FUNC0_OUT_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] The value of the bits: 0<=s<=256. Set the value to select output signal. s=0-127: output of GPIO[n] equals input of peripheral[s]. s=128: output of GPIO[n] equals GPIO_OUT_REG[n].
                    OUT_SEL:  u8, 
                    
                    /// [8:8] set this bit to invert output signal.1:invert.0:not invert.
                    INV_SEL:  u1, 
                    
                    /// [9:9] set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n] as output enable signal.0:use peripheral output enable signal.
                    OEN_SEL:  u1, 
                    
                    /// [10:10] set this bit to invert output enable signal.1:invert.0:not invert.
                    OEN_INV_SEL:  u1, 
                    
                    /// [11:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60091584));
                
                /// GPIO output function select register
                pub const FUNC0_OUT_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] The value of the bits: 0<=s<=256. Set the value to select output signal. s=0-127: output of GPIO[n] equals input of peripheral[s]. s=128: output of GPIO[n] equals GPIO_OUT_REG[n].
                    OUT_SEL:  u8, 
                    
                    /// [8:8] set this bit to invert output signal.1:invert.0:not invert.
                    INV_SEL:  u1, 
                    
                    /// [9:9] set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n] as output enable signal.0:use peripheral output enable signal.
                    OEN_SEL:  u1, 
                    
                    /// [10:10] set this bit to invert output enable signal.1:invert.0:not invert.
                    OEN_INV_SEL:  u1, 
                    
                    /// [11:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60091588));
                
                /// GPIO output function select register
                pub const FUNC0_OUT_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] The value of the bits: 0<=s<=256. Set the value to select output signal. s=0-127: output of GPIO[n] equals input of peripheral[s]. s=128: output of GPIO[n] equals GPIO_OUT_REG[n].
                    OUT_SEL:  u8, 
                    
                    /// [8:8] set this bit to invert output signal.1:invert.0:not invert.
                    INV_SEL:  u1, 
                    
                    /// [9:9] set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n] as output enable signal.0:use peripheral output enable signal.
                    OEN_SEL:  u1, 
                    
                    /// [10:10] set this bit to invert output enable signal.1:invert.0:not invert.
                    OEN_INV_SEL:  u1, 
                    
                    /// [11:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6009158c));
                
                /// GPIO output function select register
                pub const FUNC0_OUT_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] The value of the bits: 0<=s<=256. Set the value to select output signal. s=0-127: output of GPIO[n] equals input of peripheral[s]. s=128: output of GPIO[n] equals GPIO_OUT_REG[n].
                    OUT_SEL:  u8, 
                    
                    /// [8:8] set this bit to invert output signal.1:invert.0:not invert.
                    INV_SEL:  u1, 
                    
                    /// [9:9] set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n] as output enable signal.0:use peripheral output enable signal.
                    OEN_SEL:  u1, 
                    
                    /// [10:10] set this bit to invert output enable signal.1:invert.0:not invert.
                    OEN_INV_SEL:  u1, 
                    
                    /// [11:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60091590));
                
                /// GPIO output function select register
                pub const FUNC0_OUT_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] The value of the bits: 0<=s<=256. Set the value to select output signal. s=0-127: output of GPIO[n] equals input of peripheral[s]. s=128: output of GPIO[n] equals GPIO_OUT_REG[n].
                    OUT_SEL:  u8, 
                    
                    /// [8:8] set this bit to invert output signal.1:invert.0:not invert.
                    INV_SEL:  u1, 
                    
                    /// [9:9] set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n] as output enable signal.0:use peripheral output enable signal.
                    OEN_SEL:  u1, 
                    
                    /// [10:10] set this bit to invert output enable signal.1:invert.0:not invert.
                    OEN_INV_SEL:  u1, 
                    
                    /// [11:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60091594));
                
                /// GPIO output function select register
                pub const FUNC0_OUT_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] The value of the bits: 0<=s<=256. Set the value to select output signal. s=0-127: output of GPIO[n] equals input of peripheral[s]. s=128: output of GPIO[n] equals GPIO_OUT_REG[n].
                    OUT_SEL:  u8, 
                    
                    /// [8:8] set this bit to invert output signal.1:invert.0:not invert.
                    INV_SEL:  u1, 
                    
                    /// [9:9] set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n] as output enable signal.0:use peripheral output enable signal.
                    OEN_SEL:  u1, 
                    
                    /// [10:10] set this bit to invert output enable signal.1:invert.0:not invert.
                    OEN_INV_SEL:  u1, 
                    
                    /// [11:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60091598));
                
                /// GPIO output function select register
                pub const FUNC0_OUT_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] The value of the bits: 0<=s<=256. Set the value to select output signal. s=0-127: output of GPIO[n] equals input of peripheral[s]. s=128: output of GPIO[n] equals GPIO_OUT_REG[n].
                    OUT_SEL:  u8, 
                    
                    /// [8:8] set this bit to invert output signal.1:invert.0:not invert.
                    INV_SEL:  u1, 
                    
                    /// [9:9] set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n] as output enable signal.0:use peripheral output enable signal.
                    OEN_SEL:  u1, 
                    
                    /// [10:10] set this bit to invert output enable signal.1:invert.0:not invert.
                    OEN_INV_SEL:  u1, 
                    
                    /// [11:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6009159c));
                
                /// GPIO output function select register
                pub const FUNC0_OUT_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] The value of the bits: 0<=s<=256. Set the value to select output signal. s=0-127: output of GPIO[n] equals input of peripheral[s]. s=128: output of GPIO[n] equals GPIO_OUT_REG[n].
                    OUT_SEL:  u8, 
                    
                    /// [8:8] set this bit to invert output signal.1:invert.0:not invert.
                    INV_SEL:  u1, 
                    
                    /// [9:9] set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n] as output enable signal.0:use peripheral output enable signal.
                    OEN_SEL:  u1, 
                    
                    /// [10:10] set this bit to invert output enable signal.1:invert.0:not invert.
                    OEN_INV_SEL:  u1, 
                    
                    /// [11:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600915a0));
                
                /// GPIO output function select register
                pub const FUNC0_OUT_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] The value of the bits: 0<=s<=256. Set the value to select output signal. s=0-127: output of GPIO[n] equals input of peripheral[s]. s=128: output of GPIO[n] equals GPIO_OUT_REG[n].
                    OUT_SEL:  u8, 
                    
                    /// [8:8] set this bit to invert output signal.1:invert.0:not invert.
                    INV_SEL:  u1, 
                    
                    /// [9:9] set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n] as output enable signal.0:use peripheral output enable signal.
                    OEN_SEL:  u1, 
                    
                    /// [10:10] set this bit to invert output enable signal.1:invert.0:not invert.
                    OEN_INV_SEL:  u1, 
                    
                    /// [11:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600915a4));
                
                /// GPIO output function select register
                pub const FUNC0_OUT_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] The value of the bits: 0<=s<=256. Set the value to select output signal. s=0-127: output of GPIO[n] equals input of peripheral[s]. s=128: output of GPIO[n] equals GPIO_OUT_REG[n].
                    OUT_SEL:  u8, 
                    
                    /// [8:8] set this bit to invert output signal.1:invert.0:not invert.
                    INV_SEL:  u1, 
                    
                    /// [9:9] set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n] as output enable signal.0:use peripheral output enable signal.
                    OEN_SEL:  u1, 
                    
                    /// [10:10] set this bit to invert output enable signal.1:invert.0:not invert.
                    OEN_INV_SEL:  u1, 
                    
                    /// [11:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600915a8));
                
                /// GPIO output function select register
                pub const FUNC0_OUT_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] The value of the bits: 0<=s<=256. Set the value to select output signal. s=0-127: output of GPIO[n] equals input of peripheral[s]. s=128: output of GPIO[n] equals GPIO_OUT_REG[n].
                    OUT_SEL:  u8, 
                    
                    /// [8:8] set this bit to invert output signal.1:invert.0:not invert.
                    INV_SEL:  u1, 
                    
                    /// [9:9] set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n] as output enable signal.0:use peripheral output enable signal.
                    OEN_SEL:  u1, 
                    
                    /// [10:10] set this bit to invert output enable signal.1:invert.0:not invert.
                    OEN_INV_SEL:  u1, 
                    
                    /// [11:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600915ac));
                
                /// GPIO output function select register
                pub const FUNC0_OUT_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] The value of the bits: 0<=s<=256. Set the value to select output signal. s=0-127: output of GPIO[n] equals input of peripheral[s]. s=128: output of GPIO[n] equals GPIO_OUT_REG[n].
                    OUT_SEL:  u8, 
                    
                    /// [8:8] set this bit to invert output signal.1:invert.0:not invert.
                    INV_SEL:  u1, 
                    
                    /// [9:9] set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n] as output enable signal.0:use peripheral output enable signal.
                    OEN_SEL:  u1, 
                    
                    /// [10:10] set this bit to invert output enable signal.1:invert.0:not invert.
                    OEN_INV_SEL:  u1, 
                    
                    /// [11:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600915b0));
                
                /// GPIO output function select register
                pub const FUNC0_OUT_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] The value of the bits: 0<=s<=256. Set the value to select output signal. s=0-127: output of GPIO[n] equals input of peripheral[s]. s=128: output of GPIO[n] equals GPIO_OUT_REG[n].
                    OUT_SEL:  u8, 
                    
                    /// [8:8] set this bit to invert output signal.1:invert.0:not invert.
                    INV_SEL:  u1, 
                    
                    /// [9:9] set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n] as output enable signal.0:use peripheral output enable signal.
                    OEN_SEL:  u1, 
                    
                    /// [10:10] set this bit to invert output enable signal.1:invert.0:not invert.
                    OEN_INV_SEL:  u1, 
                    
                    /// [11:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600915b4));
                
                /// GPIO output function select register
                pub const FUNC0_OUT_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] The value of the bits: 0<=s<=256. Set the value to select output signal. s=0-127: output of GPIO[n] equals input of peripheral[s]. s=128: output of GPIO[n] equals GPIO_OUT_REG[n].
                    OUT_SEL:  u8, 
                    
                    /// [8:8] set this bit to invert output signal.1:invert.0:not invert.
                    INV_SEL:  u1, 
                    
                    /// [9:9] set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n] as output enable signal.0:use peripheral output enable signal.
                    OEN_SEL:  u1, 
                    
                    /// [10:10] set this bit to invert output enable signal.1:invert.0:not invert.
                    OEN_INV_SEL:  u1, 
                    
                    /// [11:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600915b8));
                
                /// GPIO output function select register
                pub const FUNC0_OUT_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] The value of the bits: 0<=s<=256. Set the value to select output signal. s=0-127: output of GPIO[n] equals input of peripheral[s]. s=128: output of GPIO[n] equals GPIO_OUT_REG[n].
                    OUT_SEL:  u8, 
                    
                    /// [8:8] set this bit to invert output signal.1:invert.0:not invert.
                    INV_SEL:  u1, 
                    
                    /// [9:9] set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n] as output enable signal.0:use peripheral output enable signal.
                    OEN_SEL:  u1, 
                    
                    /// [10:10] set this bit to invert output enable signal.1:invert.0:not invert.
                    OEN_INV_SEL:  u1, 
                    
                    /// [11:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600915bc));
                
                /// GPIO output function select register
                pub const FUNC0_OUT_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] The value of the bits: 0<=s<=256. Set the value to select output signal. s=0-127: output of GPIO[n] equals input of peripheral[s]. s=128: output of GPIO[n] equals GPIO_OUT_REG[n].
                    OUT_SEL:  u8, 
                    
                    /// [8:8] set this bit to invert output signal.1:invert.0:not invert.
                    INV_SEL:  u1, 
                    
                    /// [9:9] set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n] as output enable signal.0:use peripheral output enable signal.
                    OEN_SEL:  u1, 
                    
                    /// [10:10] set this bit to invert output enable signal.1:invert.0:not invert.
                    OEN_INV_SEL:  u1, 
                    
                    /// [11:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600915c0));
                
                /// GPIO output function select register
                pub const FUNC0_OUT_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] The value of the bits: 0<=s<=256. Set the value to select output signal. s=0-127: output of GPIO[n] equals input of peripheral[s]. s=128: output of GPIO[n] equals GPIO_OUT_REG[n].
                    OUT_SEL:  u8, 
                    
                    /// [8:8] set this bit to invert output signal.1:invert.0:not invert.
                    INV_SEL:  u1, 
                    
                    /// [9:9] set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n] as output enable signal.0:use peripheral output enable signal.
                    OEN_SEL:  u1, 
                    
                    /// [10:10] set this bit to invert output enable signal.1:invert.0:not invert.
                    OEN_INV_SEL:  u1, 
                    
                    /// [11:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600915c4));
                
                /// GPIO output function select register
                pub const FUNC0_OUT_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] The value of the bits: 0<=s<=256. Set the value to select output signal. s=0-127: output of GPIO[n] equals input of peripheral[s]. s=128: output of GPIO[n] equals GPIO_OUT_REG[n].
                    OUT_SEL:  u8, 
                    
                    /// [8:8] set this bit to invert output signal.1:invert.0:not invert.
                    INV_SEL:  u1, 
                    
                    /// [9:9] set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n] as output enable signal.0:use peripheral output enable signal.
                    OEN_SEL:  u1, 
                    
                    /// [10:10] set this bit to invert output enable signal.1:invert.0:not invert.
                    OEN_INV_SEL:  u1, 
                    
                    /// [11:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600915c8));
                
                /// GPIO clock gate register
                pub const CLOCK_GATE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] set this bit to enable GPIO clock gate
                    CLK_EN:  u1, 
                    
                    /// [1:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6009162c));
                
                /// GPIO version register
                pub const DATE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:27] version register
                    DATE:  u28, 
                    
                    /// [28:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600916fc));
                
            };
            
            /// Sigma-Delta Modulation
            pub const GPIO_SD = struct {
                
                /// Duty Cycle Configure Register of SDM%s
                pub const SIGMADELTA0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] This field is used to configure the duty cycle of sigma delta modulation output.
                    SD0_IN:  u8, 
                    
                    /// [8:15] This field is used to set a divider value to divide APB clock.
                    SD0_PRESCALE:  u8, 
                    
                    /// [16:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60004f00));
                
                /// Duty Cycle Configure Register of SDM%s
                pub const SIGMADELTA0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] This field is used to configure the duty cycle of sigma delta modulation output.
                    SD0_IN:  u8, 
                    
                    /// [8:15] This field is used to set a divider value to divide APB clock.
                    SD0_PRESCALE:  u8, 
                    
                    /// [16:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60004f04));
                
                /// Duty Cycle Configure Register of SDM%s
                pub const SIGMADELTA0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] This field is used to configure the duty cycle of sigma delta modulation output.
                    SD0_IN:  u8, 
                    
                    /// [8:15] This field is used to set a divider value to divide APB clock.
                    SD0_PRESCALE:  u8, 
                    
                    /// [16:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60004f08));
                
                /// Duty Cycle Configure Register of SDM%s
                pub const SIGMADELTA0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] This field is used to configure the duty cycle of sigma delta modulation output.
                    SD0_IN:  u8, 
                    
                    /// [8:15] This field is used to set a divider value to divide APB clock.
                    SD0_PRESCALE:  u8, 
                    
                    /// [16:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60004f0c));
                
                /// Clock Gating Configure Register
                pub const CLOCK_GATE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Clock enable bit of configuration registers for sigma delta modulation.
                    CLK_EN:  u1, 
                    
                    /// [1:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60004f20));
                
                /// MISC Register
                pub const SIGMADELTA_MISC = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:29] 
                    res0:  u0, 
                    
                    /// [30:30] Clock enable bit of sigma delta modulation.
                    FUNCTION_CLK_EN:  u1, 
                    
                    /// [31:31] Reserved.
                    SPI_SWAP:  u1, 
                    
                }), @ptrFromInt(0x60004f24));
                
                /// Glitch Filter Configure Register of Channel%s
                pub const GLITCH_FILTER_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Glitch Filter channel enable bit.
                    FILTER_CH0_EN:  u1, 
                    
                    /// [1:6] Glitch Filter input io number.
                    FILTER_CH0_INPUT_IO_NUM:  u6, 
                    
                    /// [7:12] Glitch Filter window threshold.
                    FILTER_CH0_WINDOW_THRES:  u6, 
                    
                    /// [13:18] Glitch Filter window width.
                    FILTER_CH0_WINDOW_WIDTH:  u6, 
                    
                    /// [19:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60004f30));
                
                /// Glitch Filter Configure Register of Channel%s
                pub const GLITCH_FILTER_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Glitch Filter channel enable bit.
                    FILTER_CH0_EN:  u1, 
                    
                    /// [1:6] Glitch Filter input io number.
                    FILTER_CH0_INPUT_IO_NUM:  u6, 
                    
                    /// [7:12] Glitch Filter window threshold.
                    FILTER_CH0_WINDOW_THRES:  u6, 
                    
                    /// [13:18] Glitch Filter window width.
                    FILTER_CH0_WINDOW_WIDTH:  u6, 
                    
                    /// [19:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60004f34));
                
                /// Glitch Filter Configure Register of Channel%s
                pub const GLITCH_FILTER_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Glitch Filter channel enable bit.
                    FILTER_CH0_EN:  u1, 
                    
                    /// [1:6] Glitch Filter input io number.
                    FILTER_CH0_INPUT_IO_NUM:  u6, 
                    
                    /// [7:12] Glitch Filter window threshold.
                    FILTER_CH0_WINDOW_THRES:  u6, 
                    
                    /// [13:18] Glitch Filter window width.
                    FILTER_CH0_WINDOW_WIDTH:  u6, 
                    
                    /// [19:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60004f38));
                
                /// Glitch Filter Configure Register of Channel%s
                pub const GLITCH_FILTER_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Glitch Filter channel enable bit.
                    FILTER_CH0_EN:  u1, 
                    
                    /// [1:6] Glitch Filter input io number.
                    FILTER_CH0_INPUT_IO_NUM:  u6, 
                    
                    /// [7:12] Glitch Filter window threshold.
                    FILTER_CH0_WINDOW_THRES:  u6, 
                    
                    /// [13:18] Glitch Filter window width.
                    FILTER_CH0_WINDOW_WIDTH:  u6, 
                    
                    /// [19:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60004f3c));
                
                /// Glitch Filter Configure Register of Channel%s
                pub const GLITCH_FILTER_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Glitch Filter channel enable bit.
                    FILTER_CH0_EN:  u1, 
                    
                    /// [1:6] Glitch Filter input io number.
                    FILTER_CH0_INPUT_IO_NUM:  u6, 
                    
                    /// [7:12] Glitch Filter window threshold.
                    FILTER_CH0_WINDOW_THRES:  u6, 
                    
                    /// [13:18] Glitch Filter window width.
                    FILTER_CH0_WINDOW_WIDTH:  u6, 
                    
                    /// [19:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60004f40));
                
                /// Glitch Filter Configure Register of Channel%s
                pub const GLITCH_FILTER_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Glitch Filter channel enable bit.
                    FILTER_CH0_EN:  u1, 
                    
                    /// [1:6] Glitch Filter input io number.
                    FILTER_CH0_INPUT_IO_NUM:  u6, 
                    
                    /// [7:12] Glitch Filter window threshold.
                    FILTER_CH0_WINDOW_THRES:  u6, 
                    
                    /// [13:18] Glitch Filter window width.
                    FILTER_CH0_WINDOW_WIDTH:  u6, 
                    
                    /// [19:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60004f44));
                
                /// Glitch Filter Configure Register of Channel%s
                pub const GLITCH_FILTER_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Glitch Filter channel enable bit.
                    FILTER_CH0_EN:  u1, 
                    
                    /// [1:6] Glitch Filter input io number.
                    FILTER_CH0_INPUT_IO_NUM:  u6, 
                    
                    /// [7:12] Glitch Filter window threshold.
                    FILTER_CH0_WINDOW_THRES:  u6, 
                    
                    /// [13:18] Glitch Filter window width.
                    FILTER_CH0_WINDOW_WIDTH:  u6, 
                    
                    /// [19:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60004f48));
                
                /// Glitch Filter Configure Register of Channel%s
                pub const GLITCH_FILTER_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Glitch Filter channel enable bit.
                    FILTER_CH0_EN:  u1, 
                    
                    /// [1:6] Glitch Filter input io number.
                    FILTER_CH0_INPUT_IO_NUM:  u6, 
                    
                    /// [7:12] Glitch Filter window threshold.
                    FILTER_CH0_WINDOW_THRES:  u6, 
                    
                    /// [13:18] Glitch Filter window width.
                    FILTER_CH0_WINDOW_WIDTH:  u6, 
                    
                    /// [19:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60004f4c));
                
                /// Etm Config register of Channel%s
                pub const ETM_EVENT_CH0_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:4] Etm event channel select gpio.
                    ETM_CH0_EVENT_SEL:  u5, 
                    
                    /// [5:6] 
                    res0:  u0, 
                    
                    /// [7:7] Etm event send enable bit.
                    ETM_CH0_EVENT_EN:  u1, 
                    
                    /// [8:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x60004f60));
                
                /// Etm Config register of Channel%s
                pub const ETM_EVENT_CH0_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:4] Etm event channel select gpio.
                    ETM_CH0_EVENT_SEL:  u5, 
                    
                    /// [5:6] 
                    res0:  u0, 
                    
                    /// [7:7] Etm event send enable bit.
                    ETM_CH0_EVENT_EN:  u1, 
                    
                    /// [8:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x60004f64));
                
                /// Etm Config register of Channel%s
                pub const ETM_EVENT_CH0_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:4] Etm event channel select gpio.
                    ETM_CH0_EVENT_SEL:  u5, 
                    
                    /// [5:6] 
                    res0:  u0, 
                    
                    /// [7:7] Etm event send enable bit.
                    ETM_CH0_EVENT_EN:  u1, 
                    
                    /// [8:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x60004f68));
                
                /// Etm Config register of Channel%s
                pub const ETM_EVENT_CH0_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:4] Etm event channel select gpio.
                    ETM_CH0_EVENT_SEL:  u5, 
                    
                    /// [5:6] 
                    res0:  u0, 
                    
                    /// [7:7] Etm event send enable bit.
                    ETM_CH0_EVENT_EN:  u1, 
                    
                    /// [8:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x60004f6c));
                
                /// Etm Config register of Channel%s
                pub const ETM_EVENT_CH0_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:4] Etm event channel select gpio.
                    ETM_CH0_EVENT_SEL:  u5, 
                    
                    /// [5:6] 
                    res0:  u0, 
                    
                    /// [7:7] Etm event send enable bit.
                    ETM_CH0_EVENT_EN:  u1, 
                    
                    /// [8:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x60004f70));
                
                /// Etm Config register of Channel%s
                pub const ETM_EVENT_CH0_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:4] Etm event channel select gpio.
                    ETM_CH0_EVENT_SEL:  u5, 
                    
                    /// [5:6] 
                    res0:  u0, 
                    
                    /// [7:7] Etm event send enable bit.
                    ETM_CH0_EVENT_EN:  u1, 
                    
                    /// [8:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x60004f74));
                
                /// Etm Config register of Channel%s
                pub const ETM_EVENT_CH0_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:4] Etm event channel select gpio.
                    ETM_CH0_EVENT_SEL:  u5, 
                    
                    /// [5:6] 
                    res0:  u0, 
                    
                    /// [7:7] Etm event send enable bit.
                    ETM_CH0_EVENT_EN:  u1, 
                    
                    /// [8:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x60004f78));
                
                /// Etm Config register of Channel%s
                pub const ETM_EVENT_CH0_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:4] Etm event channel select gpio.
                    ETM_CH0_EVENT_SEL:  u5, 
                    
                    /// [5:6] 
                    res0:  u0, 
                    
                    /// [7:7] Etm event send enable bit.
                    ETM_CH0_EVENT_EN:  u1, 
                    
                    /// [8:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x60004f7c));
                
                /// Etm Configure Register to decide which GPIO been chosen
                pub const ETM_TASK_P0_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Enable bit of GPIO response etm task.
                    ETM_TASK_GPIO0_EN:  u1, 
                    
                    /// [1:3] GPIO choose a etm task channel.
                    ETM_TASK_GPIO0_SEL:  u3, 
                    
                    /// [4:7] 
                    res0:  u0, 
                    
                    /// [8:8] Enable bit of GPIO response etm task.
                    ETM_TASK_GPIO1_EN:  u1, 
                    
                    /// [9:11] GPIO choose a etm task channel.
                    ETM_TASK_GPIO1_SEL:  u3, 
                    
                    /// [12:15] 
                    res1:  u0, 
                    
                    /// [16:16] Enable bit of GPIO response etm task.
                    ETM_TASK_GPIO2_EN:  u1, 
                    
                    /// [17:19] GPIO choose a etm task channel.
                    ETM_TASK_GPIO2_SEL:  u3, 
                    
                    /// [20:23] 
                    res2:  u0, 
                    
                    /// [24:24] Enable bit of GPIO response etm task.
                    ETM_TASK_GPIO3_EN:  u1, 
                    
                    /// [25:27] GPIO choose a etm task channel.
                    ETM_TASK_GPIO3_SEL:  u3, 
                    
                    /// [28:31] 
                    res3:  u0, 
                    
                }), @ptrFromInt(0x60004fa0));
                
                /// Etm Configure Register to decide which GPIO been chosen
                pub const ETM_TASK_P1_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Enable bit of GPIO response etm task.
                    ETM_TASK_GPIO4_EN:  u1, 
                    
                    /// [1:3] GPIO choose a etm task channel.
                    ETM_TASK_GPIO4_SEL:  u3, 
                    
                    /// [4:7] 
                    res0:  u0, 
                    
                    /// [8:8] Enable bit of GPIO response etm task.
                    ETM_TASK_GPIO5_EN:  u1, 
                    
                    /// [9:11] GPIO choose a etm task channel.
                    ETM_TASK_GPIO5_SEL:  u3, 
                    
                    /// [12:15] 
                    res1:  u0, 
                    
                    /// [16:16] Enable bit of GPIO response etm task.
                    ETM_TASK_GPIO6_EN:  u1, 
                    
                    /// [17:19] GPIO choose a etm task channel.
                    ETM_TASK_GPIO6_SEL:  u3, 
                    
                    /// [20:23] 
                    res2:  u0, 
                    
                    /// [24:24] Enable bit of GPIO response etm task.
                    ETM_TASK_GPIO7_EN:  u1, 
                    
                    /// [25:27] GPIO choose a etm task channel.
                    ETM_TASK_GPIO7_SEL:  u3, 
                    
                    /// [28:31] 
                    res3:  u0, 
                    
                }), @ptrFromInt(0x60004fa4));
                
                /// Etm Configure Register to decide which GPIO been chosen
                pub const ETM_TASK_P2_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Enable bit of GPIO response etm task.
                    ETM_TASK_GPIO8_EN:  u1, 
                    
                    /// [1:3] GPIO choose a etm task channel.
                    ETM_TASK_GPIO8_SEL:  u3, 
                    
                    /// [4:7] 
                    res0:  u0, 
                    
                    /// [8:8] Enable bit of GPIO response etm task.
                    ETM_TASK_GPIO9_EN:  u1, 
                    
                    /// [9:11] GPIO choose a etm task channel.
                    ETM_TASK_GPIO9_SEL:  u3, 
                    
                    /// [12:15] 
                    res1:  u0, 
                    
                    /// [16:16] Enable bit of GPIO response etm task.
                    ETM_TASK_GPIO10_EN:  u1, 
                    
                    /// [17:19] GPIO choose a etm task channel.
                    ETM_TASK_GPIO10_SEL:  u3, 
                    
                    /// [20:23] 
                    res2:  u0, 
                    
                    /// [24:24] Enable bit of GPIO response etm task.
                    ETM_TASK_GPIO11_EN:  u1, 
                    
                    /// [25:27] GPIO choose a etm task channel.
                    ETM_TASK_GPIO11_SEL:  u3, 
                    
                    /// [28:31] 
                    res3:  u0, 
                    
                }), @ptrFromInt(0x60004fa8));
                
                /// Etm Configure Register to decide which GPIO been chosen
                pub const ETM_TASK_P3_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Enable bit of GPIO response etm task.
                    ETM_TASK_GPIO12_EN:  u1, 
                    
                    /// [1:3] GPIO choose a etm task channel.
                    ETM_TASK_GPIO12_SEL:  u3, 
                    
                    /// [4:7] 
                    res0:  u0, 
                    
                    /// [8:8] Enable bit of GPIO response etm task.
                    ETM_TASK_GPIO13_EN:  u1, 
                    
                    /// [9:11] GPIO choose a etm task channel.
                    ETM_TASK_GPIO13_SEL:  u3, 
                    
                    /// [12:15] 
                    res1:  u0, 
                    
                    /// [16:16] Enable bit of GPIO response etm task.
                    ETM_TASK_GPIO14_EN:  u1, 
                    
                    /// [17:19] GPIO choose a etm task channel.
                    ETM_TASK_GPIO14_SEL:  u3, 
                    
                    /// [20:23] 
                    res2:  u0, 
                    
                    /// [24:24] Enable bit of GPIO response etm task.
                    ETM_TASK_GPIO15_EN:  u1, 
                    
                    /// [25:27] GPIO choose a etm task channel.
                    ETM_TASK_GPIO15_SEL:  u3, 
                    
                    /// [28:31] 
                    res3:  u0, 
                    
                }), @ptrFromInt(0x60004fac));
                
                /// Etm Configure Register to decide which GPIO been chosen
                pub const ETM_TASK_P4_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Enable bit of GPIO response etm task.
                    ETM_TASK_GPIO16_EN:  u1, 
                    
                    /// [1:3] GPIO choose a etm task channel.
                    ETM_TASK_GPIO16_SEL:  u3, 
                    
                    /// [4:7] 
                    res0:  u0, 
                    
                    /// [8:8] Enable bit of GPIO response etm task.
                    ETM_TASK_GPIO17_EN:  u1, 
                    
                    /// [9:11] GPIO choose a etm task channel.
                    ETM_TASK_GPIO17_SEL:  u3, 
                    
                    /// [12:15] 
                    res1:  u0, 
                    
                    /// [16:16] Enable bit of GPIO response etm task.
                    ETM_TASK_GPIO18_EN:  u1, 
                    
                    /// [17:19] GPIO choose a etm task channel.
                    ETM_TASK_GPIO18_SEL:  u3, 
                    
                    /// [20:23] 
                    res2:  u0, 
                    
                    /// [24:24] Enable bit of GPIO response etm task.
                    ETM_TASK_GPIO19_EN:  u1, 
                    
                    /// [25:27] GPIO choose a etm task channel.
                    ETM_TASK_GPIO19_SEL:  u3, 
                    
                    /// [28:31] 
                    res3:  u0, 
                    
                }), @ptrFromInt(0x60004fb0));
                
                /// Etm Configure Register to decide which GPIO been chosen
                pub const ETM_TASK_P5_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Enable bit of GPIO response etm task.
                    ETM_TASK_GPIO20_EN:  u1, 
                    
                    /// [1:3] GPIO choose a etm task channel.
                    ETM_TASK_GPIO20_SEL:  u3, 
                    
                    /// [4:7] 
                    res0:  u0, 
                    
                    /// [8:8] Enable bit of GPIO response etm task.
                    ETM_TASK_GPIO21_EN:  u1, 
                    
                    /// [9:11] GPIO choose a etm task channel.
                    ETM_TASK_GPIO21_SEL:  u3, 
                    
                    /// [12:15] 
                    res1:  u0, 
                    
                    /// [16:16] Enable bit of GPIO response etm task.
                    ETM_TASK_GPIO22_EN:  u1, 
                    
                    /// [17:19] GPIO choose a etm task channel.
                    ETM_TASK_GPIO22_SEL:  u3, 
                    
                    /// [20:23] 
                    res2:  u0, 
                    
                    /// [24:24] Enable bit of GPIO response etm task.
                    ETM_TASK_GPIO23_EN:  u1, 
                    
                    /// [25:27] GPIO choose a etm task channel.
                    ETM_TASK_GPIO23_SEL:  u3, 
                    
                    /// [28:31] 
                    res3:  u0, 
                    
                }), @ptrFromInt(0x60004fb4));
                
                /// Etm Configure Register to decide which GPIO been chosen
                pub const ETM_TASK_P6_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Enable bit of GPIO response etm task.
                    ETM_TASK_GPIO24_EN:  u1, 
                    
                    /// [1:3] GPIO choose a etm task channel.
                    ETM_TASK_GPIO24_SEL:  u3, 
                    
                    /// [4:7] 
                    res0:  u0, 
                    
                    /// [8:8] Enable bit of GPIO response etm task.
                    ETM_TASK_GPIO25_EN:  u1, 
                    
                    /// [9:11] GPIO choose a etm task channel.
                    ETM_TASK_GPIO25_SEL:  u3, 
                    
                    /// [12:15] 
                    res1:  u0, 
                    
                    /// [16:16] Enable bit of GPIO response etm task.
                    ETM_TASK_GPIO26_EN:  u1, 
                    
                    /// [17:19] GPIO choose a etm task channel.
                    ETM_TASK_GPIO26_SEL:  u3, 
                    
                    /// [20:23] 
                    res2:  u0, 
                    
                    /// [24:24] Enable bit of GPIO response etm task.
                    ETM_TASK_GPIO27_EN:  u1, 
                    
                    /// [25:27] GPIO choose a etm task channel.
                    ETM_TASK_GPIO27_SEL:  u3, 
                    
                    /// [28:31] 
                    res3:  u0, 
                    
                }), @ptrFromInt(0x60004fb8));
                
                /// Etm Configure Register to decide which GPIO been chosen
                pub const ETM_TASK_P7_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Enable bit of GPIO response etm task.
                    ETM_TASK_GPIO28_EN:  u1, 
                    
                    /// [1:3] GPIO choose a etm task channel.
                    ETM_TASK_GPIO28_SEL:  u3, 
                    
                    /// [4:7] 
                    res0:  u0, 
                    
                    /// [8:8] Enable bit of GPIO response etm task.
                    ETM_TASK_GPIO29_EN:  u1, 
                    
                    /// [9:11] GPIO choose a etm task channel.
                    ETM_TASK_GPIO29_SEL:  u3, 
                    
                    /// [12:15] 
                    res1:  u0, 
                    
                    /// [16:16] Enable bit of GPIO response etm task.
                    ETM_TASK_GPIO30_EN:  u1, 
                    
                    /// [17:19] GPIO choose a etm task channel.
                    ETM_TASK_GPIO30_SEL:  u3, 
                    
                    /// [20:31] 
                    res2:  u0, 
                    
                }), @ptrFromInt(0x60004fbc));
                
                /// Version Control Register
                pub const VERSION = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:27] Version control register.
                    GPIO_SD_DATE:  u28, 
                    
                    /// [28:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60004ffc));
                
            };
            
            /// HINF Peripheral
            pub const HINF = struct {
                
                /// Configure sdio cis content
                pub const CFG_DATA0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:15] configure device id of function1 in cis
                    DEVICE_ID_FN1:  u16, 
                    
                    /// [16:31] configure user id of function1 in cis
                    USER_ID_FN1:  u16, 
                    
                }), @ptrFromInt(0x60016000));
                
                /// SDIO configuration register
                pub const CFG_DATA1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Sdio clock enable
                    SDIO_ENABLE:  u1, 
                    
                    /// [1:1] sdio function1 io ready signal in cis
                    SDIO_IOREADY1:  u1, 
                    
                    /// [2:2] Highspeed enable in cccr
                    HIGHSPEED_ENABLE:  u1, 
                    
                    /// [3:3] highspeed mode status in cccr
                    HIGHSPEED_MODE:  u1, 
                    
                    /// [4:4] sdio card detect enable
                    SDIO_CD_ENABLE:  u1, 
                    
                    /// [5:5] sdio function1 io ready signal in cis
                    SDIO_IOREADY2:  u1, 
                    
                    /// [6:6] mask sdio interrupt in cccr, high active
                    SDIO_INT_MASK:  u1, 
                    
                    /// [7:7] ioe2 status in cccr
                    IOENABLE2:  u1, 
                    
                    /// [8:8] card disable status in cccr
                    CD_DISABLE:  u1, 
                    
                    /// [9:9] function1 eps status in fbr
                    FUNC1_EPS:  u1, 
                    
                    /// [10:10] empc status in cccr
                    EMP:  u1, 
                    
                    /// [11:11] ioe1 status in cccr
                    IOENABLE1:  u1, 
                    
                    /// [12:23] sdio version in cccr
                    SDIO_VER:  u12, 
                    
                    /// [24:24] function2 eps status in fbr
                    FUNC2_EPS:  u1, 
                    
                    /// [25:31] [29],sdio negedge sample enablel.[30],sdio posedge sample enable.[31],sdio cmd/dat in delayed cycles control,0:no delay, 1:delay 1 cycle.[25]: sdio1.1 dat/cmd sending out edge control,1:negedge,0:posedge when highseed mode. [26]: sdio2.0 dat/cmd sending out edge control,1:negedge when [12]=0,0:negedge when [12]=0,posedge when highspeed mode enable.[27]: sdio interrupt sending out delay control,1:delay one cycle, 0: no delay.[28]: sdio data pad pull up enable
                    SDIO20_CONF:  u7, 
                    
                }), @ptrFromInt(0x60016004));
                
                /// Timing configuration registers
                pub const CFG_TIMING = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:2] configure Ncrc parameter in sdr50/104 mode, no more than 6.
                    NCRC:  u3, 
                    
                    /// [3:9] configure cycles to lower cmd after voltage is changed to 1.8V.
                    PST_END_CMD_LOW_VALUE:  u7, 
                    
                    /// [10:15] configure cycles to lower data after voltage is changed to 1.8V.
                    PST_END_DATA_LOW_VALUE:  u6, 
                    
                    /// [16:26] Configure the number of cycles of module clk to judge sdclk has stopped
                    SDCLK_STOP_THRES:  u11, 
                    
                    /// [27:27] 
                    res0:  u0, 
                    
                    /// [28:31] module clk divider to sample sdclk
                    SAMPLE_CLK_DIVIDER:  u4, 
                    
                }), @ptrFromInt(0x60016008));
                
                /// update sdio configurations
                pub const CFG_UPDATE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] update the timing configurations
                    CONF_UPDATE:  u1, 
                    
                    /// [1:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6001600c));
                
                /// SDIO configuration register
                pub const CFG_DATA7 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] configure cis addr 318 and 574
                    PIN_STATE:  u8, 
                    
                    /// [8:15] configure cis addr 312, 315, 568 and 571
                    CHIP_STATE:  u8, 
                    
                    /// [16:16] soft reset control for sdio module
                    SDIO_RST:  u1, 
                    
                    /// [17:17] sdio io ready, high enable
                    SDIO_IOREADY0:  u1, 
                    
                    /// [18:18] sdio memory power down, high active
                    SDIO_MEM_PD:  u1, 
                    
                    /// [19:19] enable sdio interrupt on data1 line
                    ESDIO_DATA1_INT_EN:  u1, 
                    
                    /// [20:20] control switch voltage change to 1.8V by software. 0:3.3V,1:1.8V
                    SDIO_SWITCH_VOLT_SW:  u1, 
                    
                    /// [21:21] enable block length to be fixed to 512 bytes in ddr50 mode
                    DDR50_BLK_LEN_FIX_EN:  u1, 
                    
                    /// [22:22] sdio apb clock for configuration force on control:0-gating,1-force on.
                    CLK_EN:  u1, 
                    
                    /// [23:23] configure if support sdr50 mode in cccr
                    SDDR50:  u1, 
                    
                    /// [24:24] configure if support sdr104 mode in cccr
                    SSDR104:  u1, 
                    
                    /// [25:25] configure if support ddr50 mode in cccr
                    SSDR50:  u1, 
                    
                    /// [26:26] configure if support driver type D in cccr
                    SDTD:  u1, 
                    
                    /// [27:27] configure if support driver type A in cccr
                    SDTA:  u1, 
                    
                    /// [28:28] configure if support driver type C in cccr
                    SDTC:  u1, 
                    
                    /// [29:29] configure if support asynchronous interrupt in cccr
                    SAI:  u1, 
                    
                    /// [30:30] clear sdio_wake_up signal after the chip wakes up
                    SDIO_WAKEUP_CLR:  u1, 
                    
                    /// [31:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6001601c));
                
                /// SDIO cis configuration register
                pub const CIS_CONF_W0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Configure cis addr 39~36
                    CIS_CONF_W0:  u32, 
                    
                }), @ptrFromInt(0x60016020));
                
                /// SDIO cis configuration register
                pub const CIS_CONF_W1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Configure cis addr 43~40
                    CIS_CONF_W1:  u32, 
                    
                }), @ptrFromInt(0x60016024));
                
                /// SDIO cis configuration register
                pub const CIS_CONF_W2 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Configure cis addr 47~44
                    CIS_CONF_W2:  u32, 
                    
                }), @ptrFromInt(0x60016028));
                
                /// SDIO cis configuration register
                pub const CIS_CONF_W3 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Configure cis addr 51~48
                    CIS_CONF_W3:  u32, 
                    
                }), @ptrFromInt(0x6001602c));
                
                /// SDIO cis configuration register
                pub const CIS_CONF_W4 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Configure cis addr 55~52
                    CIS_CONF_W4:  u32, 
                    
                }), @ptrFromInt(0x60016030));
                
                /// SDIO cis configuration register
                pub const CIS_CONF_W5 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Configure cis addr 59~56
                    CIS_CONF_W5:  u32, 
                    
                }), @ptrFromInt(0x60016034));
                
                /// SDIO cis configuration register
                pub const CIS_CONF_W6 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Configure cis addr 63~60
                    CIS_CONF_W6:  u32, 
                    
                }), @ptrFromInt(0x60016038));
                
                /// SDIO cis configuration register
                pub const CIS_CONF_W7 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Configure cis addr 67~64
                    CIS_CONF_W7:  u32, 
                    
                }), @ptrFromInt(0x6001603c));
                
                /// SDIO cis configuration register
                pub const CFG_DATA16 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:15] configure device id of function2 in cis
                    DEVICE_ID_FN2:  u16, 
                    
                    /// [16:31] configure user id of function2 in cis
                    USER_ID_FN2:  u16, 
                    
                }), @ptrFromInt(0x60016040));
                
                /// configure int to start and end ahead of time in uhs1 mode
                pub const CFG_UHS1_INT_MODE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:1] intoe on dat1 end ahead of time: 0/3-no, 1-ahead 1sdclk, 2-ahead 2sdclk
                    INTOE_END_AHEAD_MODE:  u2, 
                    
                    /// [2:3] int on dat1 end ahead of time: 0/3-no, 1-ahead 1sdclk, 2-ahead 2sdclk
                    INT_END_AHEAD_MODE:  u2, 
                    
                    /// [4:5] intoe on dat1 start ahead of time: 0/3-no, 1-ahead 1sdclk, 2-ahead 2sdclk
                    INTOE_ST_AHEAD_MODE:  u2, 
                    
                    /// [6:7] int on dat1 start ahead of time: 0/3-no, 1-ahead 1sdclk, 2-ahead 2sdclk
                    INT_ST_AHEAD_MODE:  u2, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60016044));
                
                /// func0 config0 status
                pub const CONF_STATUS = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] func0 config0 (addr: 0x20f0 ) status
                    FUNC0_CONFIG0:  u8, 
                    
                    /// [8:8] sdr25 status
                    SDR25_ST:  u1, 
                    
                    /// [9:9] sdr50 status
                    SDR50_ST:  u1, 
                    
                    /// [10:10] sdr104 status
                    SDR104_ST:  u1, 
                    
                    /// [11:11] ddr50 status
                    DDR50_ST:  u1, 
                    
                    /// [12:14] tune_st fsm status
                    TUNE_ST:  u3, 
                    
                    /// [15:15] sdio switch voltage status:0-3.3V, 1-1.8V.
                    SDIO_SWITCH_VOLT_ST:  u1, 
                    
                    /// [16:16] sdio switch voltage ldo ready
                    SDIO_SWITCH_END:  u1, 
                    
                    /// [17:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60016054));
                
                /// sdio_slave redundant control registers
                pub const SDIO_SLAVE_ECO_LOW = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] redundant registers for sdio_slave
                    RDN_ECO_LOW:  u32, 
                    
                }), @ptrFromInt(0x600160a4));
                
                /// sdio_slave redundant control registers
                pub const SDIO_SLAVE_ECO_HIGH = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] redundant registers for sdio_slave
                    RDN_ECO_HIGH:  u32, 
                    
                }), @ptrFromInt(0x600160a8));
                
                /// sdio_slave redundant control registers
                pub const SDIO_SLAVE_ECO_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] redundant registers for sdio_slave
                    SDIO_SLAVE_RDN_RESULT:  u1, 
                    
                    /// [1:1] redundant registers for sdio_slave
                    SDIO_SLAVE_RDN_ENA:  u1, 
                    
                    /// [2:2] redundant registers for sdio_slave
                    SDIO_SLAVE_SDIO_CLK_RDN_RESULT:  u1, 
                    
                    /// [3:3] redundant registers for sdio_slave
                    SDIO_SLAVE_SDIO_CLK_RDN_ENA:  u1, 
                    
                    /// [4:4] redundant registers for sdio_slave
                    SDIO_SLAVE_SDCLK_PAD_RDN_RESULT:  u1, 
                    
                    /// [5:5] redundant registers for sdio_slave
                    SDIO_SLAVE_SDCLK_PAD_RDN_ENA:  u1, 
                    
                    /// [6:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600160ac));
                
                /// sdio slave ldo control register
                pub const SDIO_SLAVE_LDO_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] control ldo ready signal by sdio slave itself
                    LDO_READY_CTL_IN_EN:  u1, 
                    
                    /// [1:5] configure ldo ready counting threshold value, the actual counting target is 2^(ldo_ready_thres)-1
                    LDO_READY_THRES:  u5, 
                    
                    /// [6:6] ignore ldo ready signal
                    LDO_READY_IGNORE_EN:  u1, 
                    
                    /// [7:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600160b0));
                
                /// ******* Description ***********
                pub const SDIO_DATE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] sdio version date.
                    SDIO_DATE:  u32, 
                    
                }), @ptrFromInt(0x600160fc));
                
            };
            
            /// HMAC (Hash-based Message Authentication Code) Accelerator
            pub const HMAC = struct {
                
                /// Process control register 0.
                pub const SET_START = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Start hmac operation.
                    SET_START:  u1, 
                    
                    /// [1:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6008d040));
                
                /// Configure purpose.
                pub const SET_PARA_PURPOSE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:3] Set hmac parameter purpose.
                    PURPOSE_SET:  u4, 
                    
                    /// [4:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6008d044));
                
                /// Configure key.
                pub const SET_PARA_KEY = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:2] Set hmac parameter key.
                    KEY_SET:  u3, 
                    
                    /// [3:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6008d048));
                
                /// Finish initial configuration.
                pub const SET_PARA_FINISH = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Finish hmac configuration.
                    SET_PARA_END:  u1, 
                    
                    /// [1:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6008d04c));
                
                /// Process control register 1.
                pub const SET_MESSAGE_ONE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Call SHA to calculate one message block.
                    SET_TEXT_ONE:  u1, 
                    
                    /// [1:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6008d050));
                
                /// Process control register 2.
                pub const SET_MESSAGE_ING = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Continue typical hmac.
                    SET_TEXT_ING:  u1, 
                    
                    /// [1:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6008d054));
                
                /// Process control register 3.
                pub const SET_MESSAGE_END = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Start hardware padding.
                    SET_TEXT_END:  u1, 
                    
                    /// [1:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6008d058));
                
                /// Process control register 4.
                pub const SET_RESULT_FINISH = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] After read result from upstream, then let hmac back to idle.
                    SET_RESULT_END:  u1, 
                    
                    /// [1:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6008d05c));
                
                /// Invalidate register 0.
                pub const SET_INVALIDATE_JTAG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Clear result from hmac downstream JTAG.
                    SET_INVALIDATE_JTAG:  u1, 
                    
                    /// [1:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6008d060));
                
                /// Invalidate register 1.
                pub const SET_INVALIDATE_DS = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Clear result from hmac downstream DS.
                    SET_INVALIDATE_DS:  u1, 
                    
                    /// [1:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6008d064));
                
                /// Error register.
                pub const QUERY_ERROR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Hmac configuration state. 0: key are agree with purpose. 1: error
                    QUREY_CHECK:  u1, 
                    
                    /// [1:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6008d068));
                
                /// Busy register.
                pub const QUERY_BUSY = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Hmac state. 1'b0: idle. 1'b1: busy
                    BUSY_STATE:  u1, 
                    
                    /// [1:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6008d06c));
                
                /// Message block memory.
                pub const WR_MESSAGE_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008d080));
                
                /// Message block memory.
                pub const WR_MESSAGE_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008d081));
                
                /// Message block memory.
                pub const WR_MESSAGE_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008d082));
                
                /// Message block memory.
                pub const WR_MESSAGE_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008d083));
                
                /// Message block memory.
                pub const WR_MESSAGE_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008d084));
                
                /// Message block memory.
                pub const WR_MESSAGE_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008d085));
                
                /// Message block memory.
                pub const WR_MESSAGE_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008d086));
                
                /// Message block memory.
                pub const WR_MESSAGE_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008d087));
                
                /// Message block memory.
                pub const WR_MESSAGE_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008d088));
                
                /// Message block memory.
                pub const WR_MESSAGE_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008d089));
                
                /// Message block memory.
                pub const WR_MESSAGE_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008d08a));
                
                /// Message block memory.
                pub const WR_MESSAGE_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008d08b));
                
                /// Message block memory.
                pub const WR_MESSAGE_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008d08c));
                
                /// Message block memory.
                pub const WR_MESSAGE_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008d08d));
                
                /// Message block memory.
                pub const WR_MESSAGE_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008d08e));
                
                /// Message block memory.
                pub const WR_MESSAGE_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008d08f));
                
                /// Message block memory.
                pub const WR_MESSAGE_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008d090));
                
                /// Message block memory.
                pub const WR_MESSAGE_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008d091));
                
                /// Message block memory.
                pub const WR_MESSAGE_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008d092));
                
                /// Message block memory.
                pub const WR_MESSAGE_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008d093));
                
                /// Message block memory.
                pub const WR_MESSAGE_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008d094));
                
                /// Message block memory.
                pub const WR_MESSAGE_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008d095));
                
                /// Message block memory.
                pub const WR_MESSAGE_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008d096));
                
                /// Message block memory.
                pub const WR_MESSAGE_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008d097));
                
                /// Message block memory.
                pub const WR_MESSAGE_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008d098));
                
                /// Message block memory.
                pub const WR_MESSAGE_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008d099));
                
                /// Message block memory.
                pub const WR_MESSAGE_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008d09a));
                
                /// Message block memory.
                pub const WR_MESSAGE_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008d09b));
                
                /// Message block memory.
                pub const WR_MESSAGE_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008d09c));
                
                /// Message block memory.
                pub const WR_MESSAGE_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008d09d));
                
                /// Message block memory.
                pub const WR_MESSAGE_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008d09e));
                
                /// Message block memory.
                pub const WR_MESSAGE_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008d09f));
                
                /// Message block memory.
                pub const WR_MESSAGE_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008d0a0));
                
                /// Message block memory.
                pub const WR_MESSAGE_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008d0a1));
                
                /// Message block memory.
                pub const WR_MESSAGE_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008d0a2));
                
                /// Message block memory.
                pub const WR_MESSAGE_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008d0a3));
                
                /// Message block memory.
                pub const WR_MESSAGE_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008d0a4));
                
                /// Message block memory.
                pub const WR_MESSAGE_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008d0a5));
                
                /// Message block memory.
                pub const WR_MESSAGE_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008d0a6));
                
                /// Message block memory.
                pub const WR_MESSAGE_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008d0a7));
                
                /// Message block memory.
                pub const WR_MESSAGE_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008d0a8));
                
                /// Message block memory.
                pub const WR_MESSAGE_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008d0a9));
                
                /// Message block memory.
                pub const WR_MESSAGE_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008d0aa));
                
                /// Message block memory.
                pub const WR_MESSAGE_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008d0ab));
                
                /// Message block memory.
                pub const WR_MESSAGE_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008d0ac));
                
                /// Message block memory.
                pub const WR_MESSAGE_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008d0ad));
                
                /// Message block memory.
                pub const WR_MESSAGE_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008d0ae));
                
                /// Message block memory.
                pub const WR_MESSAGE_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008d0af));
                
                /// Message block memory.
                pub const WR_MESSAGE_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008d0b0));
                
                /// Message block memory.
                pub const WR_MESSAGE_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008d0b1));
                
                /// Message block memory.
                pub const WR_MESSAGE_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008d0b2));
                
                /// Message block memory.
                pub const WR_MESSAGE_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008d0b3));
                
                /// Message block memory.
                pub const WR_MESSAGE_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008d0b4));
                
                /// Message block memory.
                pub const WR_MESSAGE_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008d0b5));
                
                /// Message block memory.
                pub const WR_MESSAGE_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008d0b6));
                
                /// Message block memory.
                pub const WR_MESSAGE_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008d0b7));
                
                /// Message block memory.
                pub const WR_MESSAGE_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008d0b8));
                
                /// Message block memory.
                pub const WR_MESSAGE_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008d0b9));
                
                /// Message block memory.
                pub const WR_MESSAGE_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008d0ba));
                
                /// Message block memory.
                pub const WR_MESSAGE_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008d0bb));
                
                /// Message block memory.
                pub const WR_MESSAGE_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008d0bc));
                
                /// Message block memory.
                pub const WR_MESSAGE_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008d0bd));
                
                /// Message block memory.
                pub const WR_MESSAGE_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008d0be));
                
                /// Message block memory.
                pub const WR_MESSAGE_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008d0bf));
                
                /// Result from upstream.
                pub const RD_RESULT_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008d0c0));
                
                /// Result from upstream.
                pub const RD_RESULT_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008d0c1));
                
                /// Result from upstream.
                pub const RD_RESULT_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008d0c2));
                
                /// Result from upstream.
                pub const RD_RESULT_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008d0c3));
                
                /// Result from upstream.
                pub const RD_RESULT_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008d0c4));
                
                /// Result from upstream.
                pub const RD_RESULT_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008d0c5));
                
                /// Result from upstream.
                pub const RD_RESULT_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008d0c6));
                
                /// Result from upstream.
                pub const RD_RESULT_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008d0c7));
                
                /// Result from upstream.
                pub const RD_RESULT_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008d0c8));
                
                /// Result from upstream.
                pub const RD_RESULT_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008d0c9));
                
                /// Result from upstream.
                pub const RD_RESULT_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008d0ca));
                
                /// Result from upstream.
                pub const RD_RESULT_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008d0cb));
                
                /// Result from upstream.
                pub const RD_RESULT_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008d0cc));
                
                /// Result from upstream.
                pub const RD_RESULT_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008d0cd));
                
                /// Result from upstream.
                pub const RD_RESULT_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008d0ce));
                
                /// Result from upstream.
                pub const RD_RESULT_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008d0cf));
                
                /// Result from upstream.
                pub const RD_RESULT_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008d0d0));
                
                /// Result from upstream.
                pub const RD_RESULT_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008d0d1));
                
                /// Result from upstream.
                pub const RD_RESULT_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008d0d2));
                
                /// Result from upstream.
                pub const RD_RESULT_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008d0d3));
                
                /// Result from upstream.
                pub const RD_RESULT_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008d0d4));
                
                /// Result from upstream.
                pub const RD_RESULT_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008d0d5));
                
                /// Result from upstream.
                pub const RD_RESULT_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008d0d6));
                
                /// Result from upstream.
                pub const RD_RESULT_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008d0d7));
                
                /// Result from upstream.
                pub const RD_RESULT_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008d0d8));
                
                /// Result from upstream.
                pub const RD_RESULT_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008d0d9));
                
                /// Result from upstream.
                pub const RD_RESULT_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008d0da));
                
                /// Result from upstream.
                pub const RD_RESULT_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008d0db));
                
                /// Result from upstream.
                pub const RD_RESULT_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008d0dc));
                
                /// Result from upstream.
                pub const RD_RESULT_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008d0dd));
                
                /// Result from upstream.
                pub const RD_RESULT_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008d0de));
                
                /// Result from upstream.
                pub const RD_RESULT_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008d0df));
                
                /// Process control register 5.
                pub const SET_MESSAGE_PAD = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Start software padding.
                    SET_TEXT_PAD:  u1, 
                    
                    /// [1:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6008d0f0));
                
                /// Process control register 6.
                pub const ONE_BLOCK = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Don't have to do padding.
                    SET_ONE_BLOCK:  u1, 
                    
                    /// [1:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6008d0f4));
                
                /// Jtag register 0.
                pub const SOFT_JTAG_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Turn on JTAG verification.
                    SOFT_JTAG_CTRL:  u1, 
                    
                    /// [1:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6008d0f8));
                
                /// Jtag register 1.
                pub const WR_JTAG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] 32-bit of key to be compared.
                    WR_JTAG:  u32, 
                    
                }), @ptrFromInt(0x6008d0fc));
                
                /// Date register.
                pub const DATE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:29] Hmac date information/ hmac version information.
                    DATE:  u30, 
                    
                    /// [30:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6008d1fc));
                
            };
            
            /// HP_APM Peripheral
            pub const HP_APM = struct {
                
                /// Region filter enable register
                pub const REGION_FILTER_EN = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:15] Region filter enable
                    REGION_FILTER_EN:  u16, 
                    
                    /// [16:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60099000));
                
                /// Region address register
                pub const REGION0_ADDR_START = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Start address of region0
                    REGION0_ADDR_START:  u32, 
                    
                }), @ptrFromInt(0x60099004));
                
                /// Region address register
                pub const REGION0_ADDR_END = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] End address of region0
                    REGION0_ADDR_END:  u32, 
                    
                }), @ptrFromInt(0x60099008));
                
                /// Region access authority attribute register
                pub const REGION0_PMS_ATTR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Region execute authority in REE_MODE0
                    REGION0_R0_PMS_X:  u1, 
                    
                    /// [1:1] Region write authority in REE_MODE0
                    REGION0_R0_PMS_W:  u1, 
                    
                    /// [2:2] Region read authority in REE_MODE0
                    REGION0_R0_PMS_R:  u1, 
                    
                    /// [3:3] 
                    res0:  u0, 
                    
                    /// [4:4] Region execute authority in REE_MODE1
                    REGION0_R1_PMS_X:  u1, 
                    
                    /// [5:5] Region write authority in REE_MODE1
                    REGION0_R1_PMS_W:  u1, 
                    
                    /// [6:6] Region read authority in REE_MODE1
                    REGION0_R1_PMS_R:  u1, 
                    
                    /// [7:7] 
                    res1:  u0, 
                    
                    /// [8:8] Region execute authority in REE_MODE2
                    REGION0_R2_PMS_X:  u1, 
                    
                    /// [9:9] Region write authority in REE_MODE2
                    REGION0_R2_PMS_W:  u1, 
                    
                    /// [10:10] Region read authority in REE_MODE2
                    REGION0_R2_PMS_R:  u1, 
                    
                    /// [11:31] 
                    res2:  u0, 
                    
                }), @ptrFromInt(0x6009900c));
                
                /// Region address register
                pub const REGION1_ADDR_START = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Start address of region1
                    REGION1_ADDR_START:  u32, 
                    
                }), @ptrFromInt(0x60099010));
                
                /// Region address register
                pub const REGION1_ADDR_END = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] End address of region1
                    REGION1_ADDR_END:  u32, 
                    
                }), @ptrFromInt(0x60099014));
                
                /// Region access authority attribute register
                pub const REGION1_PMS_ATTR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Region execute authority in REE_MODE0
                    REGION1_R0_PMS_X:  u1, 
                    
                    /// [1:1] Region write authority in REE_MODE0
                    REGION1_R0_PMS_W:  u1, 
                    
                    /// [2:2] Region read authority in REE_MODE0
                    REGION1_R0_PMS_R:  u1, 
                    
                    /// [3:3] 
                    res0:  u0, 
                    
                    /// [4:4] Region execute authority in REE_MODE1
                    REGION1_R1_PMS_X:  u1, 
                    
                    /// [5:5] Region write authority in REE_MODE1
                    REGION1_R1_PMS_W:  u1, 
                    
                    /// [6:6] Region read authority in REE_MODE1
                    REGION1_R1_PMS_R:  u1, 
                    
                    /// [7:7] 
                    res1:  u0, 
                    
                    /// [8:8] Region execute authority in REE_MODE2
                    REGION1_R2_PMS_X:  u1, 
                    
                    /// [9:9] Region write authority in REE_MODE2
                    REGION1_R2_PMS_W:  u1, 
                    
                    /// [10:10] Region read authority in REE_MODE2
                    REGION1_R2_PMS_R:  u1, 
                    
                    /// [11:31] 
                    res2:  u0, 
                    
                }), @ptrFromInt(0x60099018));
                
                /// Region address register
                pub const REGION2_ADDR_START = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Start address of region2
                    REGION2_ADDR_START:  u32, 
                    
                }), @ptrFromInt(0x6009901c));
                
                /// Region address register
                pub const REGION2_ADDR_END = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] End address of region2
                    REGION2_ADDR_END:  u32, 
                    
                }), @ptrFromInt(0x60099020));
                
                /// Region access authority attribute register
                pub const REGION2_PMS_ATTR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Region execute authority in REE_MODE0
                    REGION2_R0_PMS_X:  u1, 
                    
                    /// [1:1] Region write authority in REE_MODE0
                    REGION2_R0_PMS_W:  u1, 
                    
                    /// [2:2] Region read authority in REE_MODE0
                    REGION2_R0_PMS_R:  u1, 
                    
                    /// [3:3] 
                    res0:  u0, 
                    
                    /// [4:4] Region execute authority in REE_MODE1
                    REGION2_R1_PMS_X:  u1, 
                    
                    /// [5:5] Region write authority in REE_MODE1
                    REGION2_R1_PMS_W:  u1, 
                    
                    /// [6:6] Region read authority in REE_MODE1
                    REGION2_R1_PMS_R:  u1, 
                    
                    /// [7:7] 
                    res1:  u0, 
                    
                    /// [8:8] Region execute authority in REE_MODE2
                    REGION2_R2_PMS_X:  u1, 
                    
                    /// [9:9] Region write authority in REE_MODE2
                    REGION2_R2_PMS_W:  u1, 
                    
                    /// [10:10] Region read authority in REE_MODE2
                    REGION2_R2_PMS_R:  u1, 
                    
                    /// [11:31] 
                    res2:  u0, 
                    
                }), @ptrFromInt(0x60099024));
                
                /// Region address register
                pub const REGION3_ADDR_START = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Start address of region3
                    REGION3_ADDR_START:  u32, 
                    
                }), @ptrFromInt(0x60099028));
                
                /// Region address register
                pub const REGION3_ADDR_END = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] End address of region3
                    REGION3_ADDR_END:  u32, 
                    
                }), @ptrFromInt(0x6009902c));
                
                /// Region access authority attribute register
                pub const REGION3_PMS_ATTR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Region execute authority in REE_MODE0
                    REGION3_R0_PMS_X:  u1, 
                    
                    /// [1:1] Region write authority in REE_MODE0
                    REGION3_R0_PMS_W:  u1, 
                    
                    /// [2:2] Region read authority in REE_MODE0
                    REGION3_R0_PMS_R:  u1, 
                    
                    /// [3:3] 
                    res0:  u0, 
                    
                    /// [4:4] Region execute authority in REE_MODE1
                    REGION3_R1_PMS_X:  u1, 
                    
                    /// [5:5] Region write authority in REE_MODE1
                    REGION3_R1_PMS_W:  u1, 
                    
                    /// [6:6] Region read authority in REE_MODE1
                    REGION3_R1_PMS_R:  u1, 
                    
                    /// [7:7] 
                    res1:  u0, 
                    
                    /// [8:8] Region execute authority in REE_MODE2
                    REGION3_R2_PMS_X:  u1, 
                    
                    /// [9:9] Region write authority in REE_MODE2
                    REGION3_R2_PMS_W:  u1, 
                    
                    /// [10:10] Region read authority in REE_MODE2
                    REGION3_R2_PMS_R:  u1, 
                    
                    /// [11:31] 
                    res2:  u0, 
                    
                }), @ptrFromInt(0x60099030));
                
                /// Region address register
                pub const REGION4_ADDR_START = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Start address of region4
                    REGION4_ADDR_START:  u32, 
                    
                }), @ptrFromInt(0x60099034));
                
                /// Region address register
                pub const REGION4_ADDR_END = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] End address of region4
                    REGION4_ADDR_END:  u32, 
                    
                }), @ptrFromInt(0x60099038));
                
                /// Region access authority attribute register
                pub const REGION4_PMS_ATTR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Region execute authority in REE_MODE0
                    REGION4_R0_PMS_X:  u1, 
                    
                    /// [1:1] Region write authority in REE_MODE0
                    REGION4_R0_PMS_W:  u1, 
                    
                    /// [2:2] Region read authority in REE_MODE0
                    REGION4_R0_PMS_R:  u1, 
                    
                    /// [3:3] 
                    res0:  u0, 
                    
                    /// [4:4] Region execute authority in REE_MODE1
                    REGION4_R1_PMS_X:  u1, 
                    
                    /// [5:5] Region write authority in REE_MODE1
                    REGION4_R1_PMS_W:  u1, 
                    
                    /// [6:6] Region read authority in REE_MODE1
                    REGION4_R1_PMS_R:  u1, 
                    
                    /// [7:7] 
                    res1:  u0, 
                    
                    /// [8:8] Region execute authority in REE_MODE2
                    REGION4_R2_PMS_X:  u1, 
                    
                    /// [9:9] Region write authority in REE_MODE2
                    REGION4_R2_PMS_W:  u1, 
                    
                    /// [10:10] Region read authority in REE_MODE2
                    REGION4_R2_PMS_R:  u1, 
                    
                    /// [11:31] 
                    res2:  u0, 
                    
                }), @ptrFromInt(0x6009903c));
                
                /// Region address register
                pub const REGION5_ADDR_START = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Start address of region5
                    REGION5_ADDR_START:  u32, 
                    
                }), @ptrFromInt(0x60099040));
                
                /// Region address register
                pub const REGION5_ADDR_END = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] End address of region5
                    REGION5_ADDR_END:  u32, 
                    
                }), @ptrFromInt(0x60099044));
                
                /// Region access authority attribute register
                pub const REGION5_PMS_ATTR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Region execute authority in REE_MODE0
                    REGION5_R0_PMS_X:  u1, 
                    
                    /// [1:1] Region write authority in REE_MODE0
                    REGION5_R0_PMS_W:  u1, 
                    
                    /// [2:2] Region read authority in REE_MODE0
                    REGION5_R0_PMS_R:  u1, 
                    
                    /// [3:3] 
                    res0:  u0, 
                    
                    /// [4:4] Region execute authority in REE_MODE1
                    REGION5_R1_PMS_X:  u1, 
                    
                    /// [5:5] Region write authority in REE_MODE1
                    REGION5_R1_PMS_W:  u1, 
                    
                    /// [6:6] Region read authority in REE_MODE1
                    REGION5_R1_PMS_R:  u1, 
                    
                    /// [7:7] 
                    res1:  u0, 
                    
                    /// [8:8] Region execute authority in REE_MODE2
                    REGION5_R2_PMS_X:  u1, 
                    
                    /// [9:9] Region write authority in REE_MODE2
                    REGION5_R2_PMS_W:  u1, 
                    
                    /// [10:10] Region read authority in REE_MODE2
                    REGION5_R2_PMS_R:  u1, 
                    
                    /// [11:31] 
                    res2:  u0, 
                    
                }), @ptrFromInt(0x60099048));
                
                /// Region address register
                pub const REGION6_ADDR_START = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Start address of region6
                    REGION6_ADDR_START:  u32, 
                    
                }), @ptrFromInt(0x6009904c));
                
                /// Region address register
                pub const REGION6_ADDR_END = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] End address of region6
                    REGION6_ADDR_END:  u32, 
                    
                }), @ptrFromInt(0x60099050));
                
                /// Region access authority attribute register
                pub const REGION6_PMS_ATTR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Region execute authority in REE_MODE0
                    REGION6_R0_PMS_X:  u1, 
                    
                    /// [1:1] Region write authority in REE_MODE0
                    REGION6_R0_PMS_W:  u1, 
                    
                    /// [2:2] Region read authority in REE_MODE0
                    REGION6_R0_PMS_R:  u1, 
                    
                    /// [3:3] 
                    res0:  u0, 
                    
                    /// [4:4] Region execute authority in REE_MODE1
                    REGION6_R1_PMS_X:  u1, 
                    
                    /// [5:5] Region write authority in REE_MODE1
                    REGION6_R1_PMS_W:  u1, 
                    
                    /// [6:6] Region read authority in REE_MODE1
                    REGION6_R1_PMS_R:  u1, 
                    
                    /// [7:7] 
                    res1:  u0, 
                    
                    /// [8:8] Region execute authority in REE_MODE2
                    REGION6_R2_PMS_X:  u1, 
                    
                    /// [9:9] Region write authority in REE_MODE2
                    REGION6_R2_PMS_W:  u1, 
                    
                    /// [10:10] Region read authority in REE_MODE2
                    REGION6_R2_PMS_R:  u1, 
                    
                    /// [11:31] 
                    res2:  u0, 
                    
                }), @ptrFromInt(0x60099054));
                
                /// Region address register
                pub const REGION7_ADDR_START = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Start address of region7
                    REGION7_ADDR_START:  u32, 
                    
                }), @ptrFromInt(0x60099058));
                
                /// Region address register
                pub const REGION7_ADDR_END = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] End address of region7
                    REGION7_ADDR_END:  u32, 
                    
                }), @ptrFromInt(0x6009905c));
                
                /// Region access authority attribute register
                pub const REGION7_PMS_ATTR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Region execute authority in REE_MODE0
                    REGION7_R0_PMS_X:  u1, 
                    
                    /// [1:1] Region write authority in REE_MODE0
                    REGION7_R0_PMS_W:  u1, 
                    
                    /// [2:2] Region read authority in REE_MODE0
                    REGION7_R0_PMS_R:  u1, 
                    
                    /// [3:3] 
                    res0:  u0, 
                    
                    /// [4:4] Region execute authority in REE_MODE1
                    REGION7_R1_PMS_X:  u1, 
                    
                    /// [5:5] Region write authority in REE_MODE1
                    REGION7_R1_PMS_W:  u1, 
                    
                    /// [6:6] Region read authority in REE_MODE1
                    REGION7_R1_PMS_R:  u1, 
                    
                    /// [7:7] 
                    res1:  u0, 
                    
                    /// [8:8] Region execute authority in REE_MODE2
                    REGION7_R2_PMS_X:  u1, 
                    
                    /// [9:9] Region write authority in REE_MODE2
                    REGION7_R2_PMS_W:  u1, 
                    
                    /// [10:10] Region read authority in REE_MODE2
                    REGION7_R2_PMS_R:  u1, 
                    
                    /// [11:31] 
                    res2:  u0, 
                    
                }), @ptrFromInt(0x60099060));
                
                /// Region address register
                pub const REGION8_ADDR_START = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Start address of region8
                    REGION8_ADDR_START:  u32, 
                    
                }), @ptrFromInt(0x60099064));
                
                /// Region address register
                pub const REGION8_ADDR_END = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] End address of region8
                    REGION8_ADDR_END:  u32, 
                    
                }), @ptrFromInt(0x60099068));
                
                /// Region access authority attribute register
                pub const REGION8_PMS_ATTR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Region execute authority in REE_MODE0
                    REGION8_R0_PMS_X:  u1, 
                    
                    /// [1:1] Region write authority in REE_MODE0
                    REGION8_R0_PMS_W:  u1, 
                    
                    /// [2:2] Region read authority in REE_MODE0
                    REGION8_R0_PMS_R:  u1, 
                    
                    /// [3:3] 
                    res0:  u0, 
                    
                    /// [4:4] Region execute authority in REE_MODE1
                    REGION8_R1_PMS_X:  u1, 
                    
                    /// [5:5] Region write authority in REE_MODE1
                    REGION8_R1_PMS_W:  u1, 
                    
                    /// [6:6] Region read authority in REE_MODE1
                    REGION8_R1_PMS_R:  u1, 
                    
                    /// [7:7] 
                    res1:  u0, 
                    
                    /// [8:8] Region execute authority in REE_MODE2
                    REGION8_R2_PMS_X:  u1, 
                    
                    /// [9:9] Region write authority in REE_MODE2
                    REGION8_R2_PMS_W:  u1, 
                    
                    /// [10:10] Region read authority in REE_MODE2
                    REGION8_R2_PMS_R:  u1, 
                    
                    /// [11:31] 
                    res2:  u0, 
                    
                }), @ptrFromInt(0x6009906c));
                
                /// Region address register
                pub const REGION9_ADDR_START = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Start address of region9
                    REGION9_ADDR_START:  u32, 
                    
                }), @ptrFromInt(0x60099070));
                
                /// Region address register
                pub const REGION9_ADDR_END = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] End address of region9
                    REGION9_ADDR_END:  u32, 
                    
                }), @ptrFromInt(0x60099074));
                
                /// Region access authority attribute register
                pub const REGION9_PMS_ATTR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Region execute authority in REE_MODE0
                    REGION9_R0_PMS_X:  u1, 
                    
                    /// [1:1] Region write authority in REE_MODE0
                    REGION9_R0_PMS_W:  u1, 
                    
                    /// [2:2] Region read authority in REE_MODE0
                    REGION9_R0_PMS_R:  u1, 
                    
                    /// [3:3] 
                    res0:  u0, 
                    
                    /// [4:4] Region execute authority in REE_MODE1
                    REGION9_R1_PMS_X:  u1, 
                    
                    /// [5:5] Region write authority in REE_MODE1
                    REGION9_R1_PMS_W:  u1, 
                    
                    /// [6:6] Region read authority in REE_MODE1
                    REGION9_R1_PMS_R:  u1, 
                    
                    /// [7:7] 
                    res1:  u0, 
                    
                    /// [8:8] Region execute authority in REE_MODE2
                    REGION9_R2_PMS_X:  u1, 
                    
                    /// [9:9] Region write authority in REE_MODE2
                    REGION9_R2_PMS_W:  u1, 
                    
                    /// [10:10] Region read authority in REE_MODE2
                    REGION9_R2_PMS_R:  u1, 
                    
                    /// [11:31] 
                    res2:  u0, 
                    
                }), @ptrFromInt(0x60099078));
                
                /// Region address register
                pub const REGION10_ADDR_START = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Start address of region10
                    REGION10_ADDR_START:  u32, 
                    
                }), @ptrFromInt(0x6009907c));
                
                /// Region address register
                pub const REGION10_ADDR_END = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] End address of region10
                    REGION10_ADDR_END:  u32, 
                    
                }), @ptrFromInt(0x60099080));
                
                /// Region access authority attribute register
                pub const REGION10_PMS_ATTR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Region execute authority in REE_MODE0
                    REGION10_R0_PMS_X:  u1, 
                    
                    /// [1:1] Region write authority in REE_MODE0
                    REGION10_R0_PMS_W:  u1, 
                    
                    /// [2:2] Region read authority in REE_MODE0
                    REGION10_R0_PMS_R:  u1, 
                    
                    /// [3:3] 
                    res0:  u0, 
                    
                    /// [4:4] Region execute authority in REE_MODE1
                    REGION10_R1_PMS_X:  u1, 
                    
                    /// [5:5] Region write authority in REE_MODE1
                    REGION10_R1_PMS_W:  u1, 
                    
                    /// [6:6] Region read authority in REE_MODE1
                    REGION10_R1_PMS_R:  u1, 
                    
                    /// [7:7] 
                    res1:  u0, 
                    
                    /// [8:8] Region execute authority in REE_MODE2
                    REGION10_R2_PMS_X:  u1, 
                    
                    /// [9:9] Region write authority in REE_MODE2
                    REGION10_R2_PMS_W:  u1, 
                    
                    /// [10:10] Region read authority in REE_MODE2
                    REGION10_R2_PMS_R:  u1, 
                    
                    /// [11:31] 
                    res2:  u0, 
                    
                }), @ptrFromInt(0x60099084));
                
                /// Region address register
                pub const REGION11_ADDR_START = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Start address of region11
                    REGION11_ADDR_START:  u32, 
                    
                }), @ptrFromInt(0x60099088));
                
                /// Region address register
                pub const REGION11_ADDR_END = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] End address of region11
                    REGION11_ADDR_END:  u32, 
                    
                }), @ptrFromInt(0x6009908c));
                
                /// Region access authority attribute register
                pub const REGION11_PMS_ATTR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Region execute authority in REE_MODE0
                    REGION11_R0_PMS_X:  u1, 
                    
                    /// [1:1] Region write authority in REE_MODE0
                    REGION11_R0_PMS_W:  u1, 
                    
                    /// [2:2] Region read authority in REE_MODE0
                    REGION11_R0_PMS_R:  u1, 
                    
                    /// [3:3] 
                    res0:  u0, 
                    
                    /// [4:4] Region execute authority in REE_MODE1
                    REGION11_R1_PMS_X:  u1, 
                    
                    /// [5:5] Region write authority in REE_MODE1
                    REGION11_R1_PMS_W:  u1, 
                    
                    /// [6:6] Region read authority in REE_MODE1
                    REGION11_R1_PMS_R:  u1, 
                    
                    /// [7:7] 
                    res1:  u0, 
                    
                    /// [8:8] Region execute authority in REE_MODE2
                    REGION11_R2_PMS_X:  u1, 
                    
                    /// [9:9] Region write authority in REE_MODE2
                    REGION11_R2_PMS_W:  u1, 
                    
                    /// [10:10] Region read authority in REE_MODE2
                    REGION11_R2_PMS_R:  u1, 
                    
                    /// [11:31] 
                    res2:  u0, 
                    
                }), @ptrFromInt(0x60099090));
                
                /// Region address register
                pub const REGION12_ADDR_START = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Start address of region12
                    REGION12_ADDR_START:  u32, 
                    
                }), @ptrFromInt(0x60099094));
                
                /// Region address register
                pub const REGION12_ADDR_END = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] End address of region12
                    REGION12_ADDR_END:  u32, 
                    
                }), @ptrFromInt(0x60099098));
                
                /// Region access authority attribute register
                pub const REGION12_PMS_ATTR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Region execute authority in REE_MODE0
                    REGION12_R0_PMS_X:  u1, 
                    
                    /// [1:1] Region write authority in REE_MODE0
                    REGION12_R0_PMS_W:  u1, 
                    
                    /// [2:2] Region read authority in REE_MODE0
                    REGION12_R0_PMS_R:  u1, 
                    
                    /// [3:3] 
                    res0:  u0, 
                    
                    /// [4:4] Region execute authority in REE_MODE1
                    REGION12_R1_PMS_X:  u1, 
                    
                    /// [5:5] Region write authority in REE_MODE1
                    REGION12_R1_PMS_W:  u1, 
                    
                    /// [6:6] Region read authority in REE_MODE1
                    REGION12_R1_PMS_R:  u1, 
                    
                    /// [7:7] 
                    res1:  u0, 
                    
                    /// [8:8] Region execute authority in REE_MODE2
                    REGION12_R2_PMS_X:  u1, 
                    
                    /// [9:9] Region write authority in REE_MODE2
                    REGION12_R2_PMS_W:  u1, 
                    
                    /// [10:10] Region read authority in REE_MODE2
                    REGION12_R2_PMS_R:  u1, 
                    
                    /// [11:31] 
                    res2:  u0, 
                    
                }), @ptrFromInt(0x6009909c));
                
                /// Region address register
                pub const REGION13_ADDR_START = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Start address of region13
                    REGION13_ADDR_START:  u32, 
                    
                }), @ptrFromInt(0x600990a0));
                
                /// Region address register
                pub const REGION13_ADDR_END = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] End address of region13
                    REGION13_ADDR_END:  u32, 
                    
                }), @ptrFromInt(0x600990a4));
                
                /// Region access authority attribute register
                pub const REGION13_PMS_ATTR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Region execute authority in REE_MODE0
                    REGION13_R0_PMS_X:  u1, 
                    
                    /// [1:1] Region write authority in REE_MODE0
                    REGION13_R0_PMS_W:  u1, 
                    
                    /// [2:2] Region read authority in REE_MODE0
                    REGION13_R0_PMS_R:  u1, 
                    
                    /// [3:3] 
                    res0:  u0, 
                    
                    /// [4:4] Region execute authority in REE_MODE1
                    REGION13_R1_PMS_X:  u1, 
                    
                    /// [5:5] Region write authority in REE_MODE1
                    REGION13_R1_PMS_W:  u1, 
                    
                    /// [6:6] Region read authority in REE_MODE1
                    REGION13_R1_PMS_R:  u1, 
                    
                    /// [7:7] 
                    res1:  u0, 
                    
                    /// [8:8] Region execute authority in REE_MODE2
                    REGION13_R2_PMS_X:  u1, 
                    
                    /// [9:9] Region write authority in REE_MODE2
                    REGION13_R2_PMS_W:  u1, 
                    
                    /// [10:10] Region read authority in REE_MODE2
                    REGION13_R2_PMS_R:  u1, 
                    
                    /// [11:31] 
                    res2:  u0, 
                    
                }), @ptrFromInt(0x600990a8));
                
                /// Region address register
                pub const REGION14_ADDR_START = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Start address of region14
                    REGION14_ADDR_START:  u32, 
                    
                }), @ptrFromInt(0x600990ac));
                
                /// Region address register
                pub const REGION14_ADDR_END = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] End address of region14
                    REGION14_ADDR_END:  u32, 
                    
                }), @ptrFromInt(0x600990b0));
                
                /// Region access authority attribute register
                pub const REGION14_PMS_ATTR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Region execute authority in REE_MODE0
                    REGION14_R0_PMS_X:  u1, 
                    
                    /// [1:1] Region write authority in REE_MODE0
                    REGION14_R0_PMS_W:  u1, 
                    
                    /// [2:2] Region read authority in REE_MODE0
                    REGION14_R0_PMS_R:  u1, 
                    
                    /// [3:3] 
                    res0:  u0, 
                    
                    /// [4:4] Region execute authority in REE_MODE1
                    REGION14_R1_PMS_X:  u1, 
                    
                    /// [5:5] Region write authority in REE_MODE1
                    REGION14_R1_PMS_W:  u1, 
                    
                    /// [6:6] Region read authority in REE_MODE1
                    REGION14_R1_PMS_R:  u1, 
                    
                    /// [7:7] 
                    res1:  u0, 
                    
                    /// [8:8] Region execute authority in REE_MODE2
                    REGION14_R2_PMS_X:  u1, 
                    
                    /// [9:9] Region write authority in REE_MODE2
                    REGION14_R2_PMS_W:  u1, 
                    
                    /// [10:10] Region read authority in REE_MODE2
                    REGION14_R2_PMS_R:  u1, 
                    
                    /// [11:31] 
                    res2:  u0, 
                    
                }), @ptrFromInt(0x600990b4));
                
                /// Region address register
                pub const REGION15_ADDR_START = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Start address of region15
                    REGION15_ADDR_START:  u32, 
                    
                }), @ptrFromInt(0x600990b8));
                
                /// Region address register
                pub const REGION15_ADDR_END = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] End address of region15
                    REGION15_ADDR_END:  u32, 
                    
                }), @ptrFromInt(0x600990bc));
                
                /// Region access authority attribute register
                pub const REGION15_PMS_ATTR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Region execute authority in REE_MODE0
                    REGION15_R0_PMS_X:  u1, 
                    
                    /// [1:1] Region write authority in REE_MODE0
                    REGION15_R0_PMS_W:  u1, 
                    
                    /// [2:2] Region read authority in REE_MODE0
                    REGION15_R0_PMS_R:  u1, 
                    
                    /// [3:3] 
                    res0:  u0, 
                    
                    /// [4:4] Region execute authority in REE_MODE1
                    REGION15_R1_PMS_X:  u1, 
                    
                    /// [5:5] Region write authority in REE_MODE1
                    REGION15_R1_PMS_W:  u1, 
                    
                    /// [6:6] Region read authority in REE_MODE1
                    REGION15_R1_PMS_R:  u1, 
                    
                    /// [7:7] 
                    res1:  u0, 
                    
                    /// [8:8] Region execute authority in REE_MODE2
                    REGION15_R2_PMS_X:  u1, 
                    
                    /// [9:9] Region write authority in REE_MODE2
                    REGION15_R2_PMS_W:  u1, 
                    
                    /// [10:10] Region read authority in REE_MODE2
                    REGION15_R2_PMS_R:  u1, 
                    
                    /// [11:31] 
                    res2:  u0, 
                    
                }), @ptrFromInt(0x600990c0));
                
                /// PMS function control register
                pub const FUNC_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] PMS M0 function enable
                    M0_PMS_FUNC_EN:  u1, 
                    
                    /// [1:1] PMS M1 function enable
                    M1_PMS_FUNC_EN:  u1, 
                    
                    /// [2:2] PMS M2 function enable
                    M2_PMS_FUNC_EN:  u1, 
                    
                    /// [3:3] PMS M3 function enable
                    M3_PMS_FUNC_EN:  u1, 
                    
                    /// [4:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600990c4));
                
                /// M0 status register
                pub const M0_STATUS = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:1] Exception status
                    M0_EXCEPTION_STATUS:  u2, 
                    
                    /// [2:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600990c8));
                
                /// M0 status clear register
                pub const M0_STATUS_CLR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Clear exception status
                    M0_REGION_STATUS_CLR:  u1, 
                    
                    /// [1:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600990cc));
                
                /// M0 exception_info0 register
                pub const M0_EXCEPTION_INFO0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:15] Exception region
                    M0_EXCEPTION_REGION:  u16, 
                    
                    /// [16:17] Exception mode
                    M0_EXCEPTION_MODE:  u2, 
                    
                    /// [18:22] Exception id information
                    M0_EXCEPTION_ID:  u5, 
                    
                    /// [23:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600990d0));
                
                /// M0 exception_info1 register
                pub const M0_EXCEPTION_INFO1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Exception addr
                    M0_EXCEPTION_ADDR:  u32, 
                    
                }), @ptrFromInt(0x600990d4));
                
                /// M1 status register
                pub const M1_STATUS = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:1] Exception status
                    M1_EXCEPTION_STATUS:  u2, 
                    
                    /// [2:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600990d8));
                
                /// M1 status clear register
                pub const M1_STATUS_CLR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Clear exception status
                    M1_REGION_STATUS_CLR:  u1, 
                    
                    /// [1:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600990dc));
                
                /// M1 exception_info0 register
                pub const M1_EXCEPTION_INFO0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:15] Exception region
                    M1_EXCEPTION_REGION:  u16, 
                    
                    /// [16:17] Exception mode
                    M1_EXCEPTION_MODE:  u2, 
                    
                    /// [18:22] Exception id information
                    M1_EXCEPTION_ID:  u5, 
                    
                    /// [23:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600990e0));
                
                /// M1 exception_info1 register
                pub const M1_EXCEPTION_INFO1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Exception addr
                    M1_EXCEPTION_ADDR:  u32, 
                    
                }), @ptrFromInt(0x600990e4));
                
                /// M2 status register
                pub const M2_STATUS = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:1] Exception status
                    M2_EXCEPTION_STATUS:  u2, 
                    
                    /// [2:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600990e8));
                
                /// M2 status clear register
                pub const M2_STATUS_CLR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Clear exception status
                    M2_REGION_STATUS_CLR:  u1, 
                    
                    /// [1:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600990ec));
                
                /// M2 exception_info0 register
                pub const M2_EXCEPTION_INFO0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:15] Exception region
                    M2_EXCEPTION_REGION:  u16, 
                    
                    /// [16:17] Exception mode
                    M2_EXCEPTION_MODE:  u2, 
                    
                    /// [18:22] Exception id information
                    M2_EXCEPTION_ID:  u5, 
                    
                    /// [23:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600990f0));
                
                /// M2 exception_info1 register
                pub const M2_EXCEPTION_INFO1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Exception addr
                    M2_EXCEPTION_ADDR:  u32, 
                    
                }), @ptrFromInt(0x600990f4));
                
                /// M3 status register
                pub const M3_STATUS = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:1] Exception status
                    M3_EXCEPTION_STATUS:  u2, 
                    
                    /// [2:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600990f8));
                
                /// M3 status clear register
                pub const M3_STATUS_CLR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Clear exception status
                    M3_REGION_STATUS_CLR:  u1, 
                    
                    /// [1:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600990fc));
                
                /// M3 exception_info0 register
                pub const M3_EXCEPTION_INFO0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:15] Exception region
                    M3_EXCEPTION_REGION:  u16, 
                    
                    /// [16:17] Exception mode
                    M3_EXCEPTION_MODE:  u2, 
                    
                    /// [18:22] Exception id information
                    M3_EXCEPTION_ID:  u5, 
                    
                    /// [23:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60099100));
                
                /// M3 exception_info1 register
                pub const M3_EXCEPTION_INFO1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Exception addr
                    M3_EXCEPTION_ADDR:  u32, 
                    
                }), @ptrFromInt(0x60099104));
                
                /// APM interrupt enable register
                pub const INT_EN = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] APM M0 interrupt enable
                    M0_APM_INT_EN:  u1, 
                    
                    /// [1:1] APM M1 interrupt enable
                    M1_APM_INT_EN:  u1, 
                    
                    /// [2:2] APM M2 interrupt enable
                    M2_APM_INT_EN:  u1, 
                    
                    /// [3:3] APM M3 interrupt enable
                    M3_APM_INT_EN:  u1, 
                    
                    /// [4:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60099108));
                
                /// clock gating register
                pub const CLOCK_GATE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] reg_clk_en
                    CLK_EN:  u1, 
                    
                    /// [1:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6009910c));
                
                /// Version register
                pub const DATE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:27] reg_date
                    DATE:  u28, 
                    
                    /// [28:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600997fc));
                
            };
            
            /// High-Power System
            pub const HP_SYS = struct {
                
                /// EXTERNAL DEVICE ENCRYPTION/DECRYPTION configuration register
                pub const EXTERNAL_DEVICE_ENCRYPT_DECRYPT_CONTROL = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Set this bit as 1 to enable mspi xts manual encrypt in spi boot mode.
                    ENABLE_SPI_MANUAL_ENCRYPT:  u1, 
                    
                    /// [1:1] reserved
                    ENABLE_DOWNLOAD_DB_ENCRYPT:  u1, 
                    
                    /// [2:2] Set this bit as 1 to enable mspi xts auto decrypt in download boot mode.
                    ENABLE_DOWNLOAD_G0CB_DECRYPT:  u1, 
                    
                    /// [3:3] Set this bit as 1 to enable mspi xts manual encrypt in download boot mode.
                    ENABLE_DOWNLOAD_MANUAL_ENCRYPT:  u1, 
                    
                    /// [4:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60095000));
                
                /// HP memory usage configuration register
                pub const SRAM_USAGE_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] reserved
                    CACHE_USAGE:  u1, 
                    
                    /// [1:7] 
                    res0:  u0, 
                    
                    /// [8:11] 0: cpu use hp-memory. 1:mac-dump accessing hp-memory.
                    SRAM_USAGE:  u4, 
                    
                    /// [12:15] 
                    res1:  u0, 
                    
                    /// [16:16] Set this bit as 1 to add an offset (64KB) when mac-dump accessing hp-memory.
                    MAC_DUMP_ALLOC:  u1, 
                    
                    /// [17:31] 
                    res2:  u0, 
                    
                }), @ptrFromInt(0x60095004));
                
                /// HP anti-DPA security configuration register
                pub const SEC_DPA_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:1] 0: anti-DPA disable. 1~3: anti-DPA enable with different security level. The larger the number, the stronger the ability to resist DPA attacks and the higher the security level, but it will increase the computational overhead of the hardware crypto-accelerators. Only avaliable if HP_SYS_SEC_DPA_CFG_SEL is 0.
                    SEC_DPA_LEVEL:  u2, 
                    
                    /// [2:2] This field is used to select either HP_SYS_SEC_DPA_LEVEL or EFUSE_SEC_DPA_LEVEL (from efuse) to control dpa_level. 0: EFUSE_SEC_DPA_LEVEL, 1: HP_SYS_SEC_DPA_LEVEL.
                    SEC_DPA_CFG_SEL:  u1, 
                    
                    /// [3:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60095008));
                
                /// CPU_PERI_TIMEOUT configuration register
                pub const CPU_PERI_TIMEOUT_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:15] Set the timeout threshold for bus access, corresponding to the number of clock cycles of the clock domain.
                    CPU_PERI_TIMEOUT_THRES:  u16, 
                    
                    /// [16:16] Set this bit as 1 to clear timeout interrupt
                    CPU_PERI_TIMEOUT_INT_CLEAR:  u1, 
                    
                    /// [17:17] Set this bit as 1 to enable timeout protection for accessing cpu peripheral registers
                    CPU_PERI_TIMEOUT_PROTECT_EN:  u1, 
                    
                    /// [18:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6009500c));
                
                /// CPU_PERI_TIMEOUT_ADDR register
                pub const CPU_PERI_TIMEOUT_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Record the address information of abnormal access
                    CPU_PERI_TIMEOUT_ADDR:  u32, 
                    
                }), @ptrFromInt(0x60095010));
                
                /// CPU_PERI_TIMEOUT_UID register
                pub const CPU_PERI_TIMEOUT_UID = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:6] Record master id[4:0] & master permission[6:5] when trigger timeout. This register will be cleared after the interrupt is cleared.
                    CPU_PERI_TIMEOUT_UID:  u7, 
                    
                    /// [7:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60095014));
                
                /// HP_PERI_TIMEOUT configuration register
                pub const HP_PERI_TIMEOUT_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:15] Set the timeout threshold for bus access, corresponding to the number of clock cycles of the clock domain.
                    HP_PERI_TIMEOUT_THRES:  u16, 
                    
                    /// [16:16] Set this bit as 1 to clear timeout interrupt
                    HP_PERI_TIMEOUT_INT_CLEAR:  u1, 
                    
                    /// [17:17] Set this bit as 1 to enable timeout protection for accessing hp peripheral registers
                    HP_PERI_TIMEOUT_PROTECT_EN:  u1, 
                    
                    /// [18:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60095018));
                
                /// HP_PERI_TIMEOUT_ADDR register
                pub const HP_PERI_TIMEOUT_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Record the address information of abnormal access
                    HP_PERI_TIMEOUT_ADDR:  u32, 
                    
                }), @ptrFromInt(0x6009501c));
                
                /// HP_PERI_TIMEOUT_UID register
                pub const HP_PERI_TIMEOUT_UID = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:6] Record master id[4:0] & master permission[6:5] when trigger timeout. This register will be cleared after the interrupt is cleared.
                    HP_PERI_TIMEOUT_UID:  u7, 
                    
                    /// [7:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60095020));
                
                /// MODEM_PERI_TIMEOUT configuration register
                pub const MODEM_PERI_TIMEOUT_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:15] Set the timeout threshold for bus access, corresponding to the number of clock cycles of the clock domain.
                    MODEM_PERI_TIMEOUT_THRES:  u16, 
                    
                    /// [16:16] Set this bit as 1 to clear timeout interrupt
                    MODEM_PERI_TIMEOUT_INT_CLEAR:  u1, 
                    
                    /// [17:17] Set this bit as 1 to enable timeout protection for accessing modem registers
                    MODEM_PERI_TIMEOUT_PROTECT_EN:  u1, 
                    
                    /// [18:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60095024));
                
                /// MODEM_PERI_TIMEOUT_ADDR register
                pub const MODEM_PERI_TIMEOUT_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Record the address information of abnormal access
                    MODEM_PERI_TIMEOUT_ADDR:  u32, 
                    
                }), @ptrFromInt(0x60095028));
                
                /// MODEM_PERI_TIMEOUT_UID register
                pub const MODEM_PERI_TIMEOUT_UID = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:6] Record master id[4:0] & master permission[6:5] when trigger timeout. This register will be cleared after the interrupt is cleared.
                    MODEM_PERI_TIMEOUT_UID:  u7, 
                    
                    /// [7:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6009502c));
                
                /// SDIO Control configuration register
                pub const SDIO_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Set this bit as 1 to disable SDIO_PROB function. disable by default.
                    DIS_SDIO_PROB:  u1, 
                    
                    /// [1:1] Enable sdio slave to access other peripherals on the chip
                    SDIO_WIN_ACCESS_EN:  u1, 
                    
                    /// [2:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60095030));
                
                /// Retention configuration register
                pub const RETENTION_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Set this bit as 1 to disable retention function. Not disable by default.
                    RETENTION_DISABLE:  u1, 
                    
                    /// [1:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60095034));
                
                /// Rom-Table lock register
                pub const ROM_TABLE_LOCK = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] XXXX
                    ROM_TABLE_LOCK:  u1, 
                    
                    /// [1:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60095038));
                
                /// Rom-Table register
                pub const ROM_TABLE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] XXXX
                    ROM_TABLE:  u32, 
                    
                }), @ptrFromInt(0x6009503c));
                
                /// Core Debug runstall configure register
                pub const CORE_DEBUG_RUNSTALL_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Set this field to 1 to enable debug runstall feature between HP-core and LP-core.
                    CORE_DEBUG_RUNSTALL_ENABLE:  u1, 
                    
                    /// [1:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60095040));
                
                /// MEM_TEST configuration register
                pub const MEM_TEST_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:2] This field controls hp system memory WPULSE parameter.
                    HP_MEM_WPULSE:  u3, 
                    
                    /// [3:5] This field controls hp system memory WA parameter.
                    HP_MEM_WA:  u3, 
                    
                    /// [6:7] This field controls hp system memory RA parameter.
                    HP_MEM_RA:  u2, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60095044));
                
                /// redcy eco register.
                pub const RND_ECO = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Only reserved for ECO.
                    REDCY_ENA:  u1, 
                    
                    /// [1:1] Only reserved for ECO.
                    REDCY_RESULT:  u1, 
                    
                    /// [2:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600953e0));
                
                /// redcy eco low register.
                pub const RND_ECO_LOW = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Only reserved for ECO.
                    REDCY_LOW:  u32, 
                    
                }), @ptrFromInt(0x600953e4));
                
                /// redcy eco high register.
                pub const RND_ECO_HIGH = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Only reserved for ECO.
                    REDCY_HIGH:  u32, 
                    
                }), @ptrFromInt(0x600953e8));
                
                /// HP-SYSTEM clock gating configure register
                pub const CLOCK_GATE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Set this bit as 1 to force on clock gating.
                    CLK_EN:  u1, 
                    
                    /// [1:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600953f8));
                
                /// Date register.
                pub const DATE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:27] HP-SYSTEM date information/ HP-SYSTEM version information.
                    DATE:  u28, 
                    
                    /// [28:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600953fc));
                
            };
            
            /// I2C (Inter-Integrated Circuit) Controller 0
            pub const I2C0 = struct {
                
                /// Configures the low level width of the SCLClock
                pub const SCL_LOW_PERIOD = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:8] This register is used to configure for how long SCL remains low in master mode, in I2C module clock cycles.
                    SCL_LOW_PERIOD:  u9, 
                    
                    /// [9:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60004000));
                
                /// Transmission setting
                pub const CTR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] 1: direct output, 0: open drain output.
                    SDA_FORCE_OUT:  u1, 
                    
                    /// [1:1] 1: direct output, 0: open drain output.
                    SCL_FORCE_OUT:  u1, 
                    
                    /// [2:2] This register is used to select the sample mode.1: sample SDA data on the SCL low level.0: sample SDA data on the SCL high level.
                    SAMPLE_SCL_LEVEL:  u1, 
                    
                    /// [3:3] This register is used to configure the ACK value that need to sent by master when the rx_fifo_cnt has reached the threshold.
                    RX_FULL_ACK_LEVEL:  u1, 
                    
                    /// [4:4] Set this bit to configure the module as an I2C Master. Clear this bit to configure themodule as an I2C Slave.
                    MS_MODE:  u1, 
                    
                    /// [5:5] Set this bit to start sending the data in txfifo.
                    TRANS_START:  u1, 
                    
                    /// [6:6] This bit is used to control the sending mode for data needing to be sent. 1: send data from the least significant bit,0: send data from the most significant bit.
                    TX_LSB_FIRST:  u1, 
                    
                    /// [7:7] This bit is used to control the storage mode for received data.1: receive data from the least significant bit,0: receive data from the most significant bit.
                    RX_LSB_FIRST:  u1, 
                    
                    /// [8:8] Reserved
                    CLK_EN:  u1, 
                    
                    /// [9:9] This is the enable bit for arbitration_lost.
                    ARBITRATION_EN:  u1, 
                    
                    /// [10:10] This register is used to reset the scl FMS.
                    FSM_RST:  u1, 
                    
                    /// [11:11] synchronization bit
                    CONF_UPGATE:  u1, 
                    
                    /// [12:12] This is the enable bit for slave to send data automatically
                    SLV_TX_AUTO_START_EN:  u1, 
                    
                    /// [13:13] This is the enable bit to check if the r/w bit of 10bit addressing consists with I2C protocol
                    ADDR_10BIT_RW_CHECK_EN:  u1, 
                    
                    /// [14:14] This is the enable bit to support the 7bit general call function.
                    ADDR_BROADCASTING_EN:  u1, 
                    
                    /// [15:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60004004));
                
                /// Describe I2C work status.
                pub const SR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] The received ACK value in master mode or slave mode. 0: ACK, 1: NACK.
                    RESP_REC:  u1, 
                    
                    /// [1:1] When in slave mode, 1: master reads from slave, 0: master writes to slave.
                    SLAVE_RW:  u1, 
                    
                    /// [2:2] 
                    res0:  u0, 
                    
                    /// [3:3] When the I2C controller loses control of SCL line, this register changes to 1.
                    ARB_LOST:  u1, 
                    
                    /// [4:4] 1: the I2C bus is busy transferring data, 0: the I2C bus is in idle state.
                    BUS_BUSY:  u1, 
                    
                    /// [5:5] When configured as an I2C Slave, and the address sent by the master isequal to the address of the slave, then this bit will be of high level.
                    SLAVE_ADDRESSED:  u1, 
                    
                    /// [6:7] 
                    res1:  u0, 
                    
                    /// [8:13] This field represents the amount of data needed to be sent.
                    RXFIFO_CNT:  u6, 
                    
                    /// [14:15] The cause of stretching SCL low in slave mode. 0:stretching SCL low at the beginning of I2C read data state. 1: stretching SCL low when I2C Tx FIFO is empty in slave mode. 2: stretching SCL low when I2C Rx FIFO is full in slave mode.
                    STRETCH_CAUSE:  u2, 
                    
                    /// [16:17] 
                    res2:  u0, 
                    
                    /// [18:23] This field stores the amount of received data in RAM.
                    TXFIFO_CNT:  u6, 
                    
                    /// [24:26] This field indicates the states of the I2C module state machine. 0: Idle, 1: Address shift, 2: ACK address, 3: Rx data, 4: Tx data, 5: Send ACK, 6: Wait ACK
                    SCL_MAIN_STATE_LAST:  u3, 
                    
                    /// [27:27] 
                    res3:  u0, 
                    
                    /// [28:30] This field indicates the states of the state machine used to produce SCL.0: Idle, 1: Start, 2: Negative edge, 3: Low, 4: Positive edge, 5: High, 6: Stop
                    SCL_STATE_LAST:  u3, 
                    
                    /// [31:31] 
                    res4:  u0, 
                    
                }), @ptrFromInt(0x60004008));
                
                /// Setting time out control for receiving data.
                pub const TO = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:4] This register is used to configure the timeout for receiving a data bit in APBclock cycles.
                    TIME_OUT_VALUE:  u5, 
                    
                    /// [5:5] This is the enable bit for time out control.
                    TIME_OUT_EN:  u1, 
                    
                    /// [6:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000400c));
                
                /// Local slave address setting
                pub const SLAVE_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:14] When configured as an I2C Slave, this field is used to configure the slave address.
                    SLAVE_ADDR:  u15, 
                    
                    /// [15:30] 
                    res0:  u0, 
                    
                    /// [31:31] This field is used to enable the slave 10-bit addressing mode in master mode.
                    ADDR_10BIT_EN:  u1, 
                    
                }), @ptrFromInt(0x60004010));
                
                /// FIFO status register.
                pub const FIFO_ST = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:4] This is the offset address of the APB reading from rxfifo
                    RXFIFO_RADDR:  u5, 
                    
                    /// [5:9] This is the offset address of i2c module receiving data and writing to rxfifo.
                    RXFIFO_WADDR:  u5, 
                    
                    /// [10:14] This is the offset address of i2c module reading from txfifo.
                    TXFIFO_RADDR:  u5, 
                    
                    /// [15:19] This is the offset address of APB bus writing to txfifo.
                    TXFIFO_WADDR:  u5, 
                    
                    /// [20:21] 
                    res0:  u0, 
                    
                    /// [22:29] The received data in I2C slave mode.
                    SLAVE_RW_POINT:  u8, 
                    
                    /// [30:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x60004014));
                
                /// FIFO configuration register.
                pub const FIFO_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:4] The water mark threshold of rx FIFO in nonfifo access mode. When reg_reg_fifo_prt_en is 1 and rx FIFO counter is bigger than reg_rxfifo_wm_thrhd[4:0], reg_rxfifo_wm_int_raw bit will be valid.
                    RXFIFO_WM_THRHD:  u5, 
                    
                    /// [5:9] The water mark threshold of tx FIFO in nonfifo access mode. When reg_reg_fifo_prt_en is 1 and tx FIFO counter is smaller than reg_txfifo_wm_thrhd[4:0], reg_txfifo_wm_int_raw bit will be valid.
                    TXFIFO_WM_THRHD:  u5, 
                    
                    /// [10:10] Set this bit to enable APB nonfifo access.
                    NONFIFO_EN:  u1, 
                    
                    /// [11:11] When this bit is set to 1, the byte received after the I2C address byte represents the offset address in the I2C Slave RAM.
                    FIFO_ADDR_CFG_EN:  u1, 
                    
                    /// [12:12] Set this bit to reset rx-fifo.
                    RX_FIFO_RST:  u1, 
                    
                    /// [13:13] Set this bit to reset tx-fifo.
                    TX_FIFO_RST:  u1, 
                    
                    /// [14:14] The control enable bit of FIFO pointer in non-fifo access mode. This bit controls the valid bits and the interrupts of tx/rx_fifo overflow, underflow, full and empty.
                    FIFO_PRT_EN:  u1, 
                    
                    /// [15:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60004018));
                
                /// Rx FIFO read data.
                pub const DATA = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] The value of rx FIFO read data.
                    FIFO_RDATA:  u8, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000401c));
                
                /// Raw interrupt status
                pub const INT_RAW = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] The raw interrupt bit for I2C_RXFIFO_WM_INT interrupt.
                    RXFIFO_WM_INT_RAW:  u1, 
                    
                    /// [1:1] The raw interrupt bit for I2C_TXFIFO_WM_INT interrupt.
                    TXFIFO_WM_INT_RAW:  u1, 
                    
                    /// [2:2] The raw interrupt bit for I2C_RXFIFO_OVF_INT interrupt.
                    RXFIFO_OVF_INT_RAW:  u1, 
                    
                    /// [3:3] The raw interrupt bit for the I2C_END_DETECT_INT interrupt.
                    END_DETECT_INT_RAW:  u1, 
                    
                    /// [4:4] The raw interrupt bit for the I2C_END_DETECT_INT interrupt.
                    BYTE_TRANS_DONE_INT_RAW:  u1, 
                    
                    /// [5:5] The raw interrupt bit for the I2C_ARBITRATION_LOST_INT interrupt.
                    ARBITRATION_LOST_INT_RAW:  u1, 
                    
                    /// [6:6] The raw interrupt bit for I2C_TRANS_COMPLETE_INT interrupt.
                    MST_TXFIFO_UDF_INT_RAW:  u1, 
                    
                    /// [7:7] The raw interrupt bit for the I2C_TRANS_COMPLETE_INT interrupt.
                    TRANS_COMPLETE_INT_RAW:  u1, 
                    
                    /// [8:8] The raw interrupt bit for the I2C_TIME_OUT_INT interrupt.
                    TIME_OUT_INT_RAW:  u1, 
                    
                    /// [9:9] The raw interrupt bit for the I2C_TRANS_START_INT interrupt.
                    TRANS_START_INT_RAW:  u1, 
                    
                    /// [10:10] The raw interrupt bit for I2C_SLAVE_STRETCH_INT interrupt.
                    NACK_INT_RAW:  u1, 
                    
                    /// [11:11] The raw interrupt bit for I2C_TXFIFO_OVF_INT interrupt.
                    TXFIFO_OVF_INT_RAW:  u1, 
                    
                    /// [12:12] The raw interrupt bit for I2C_RXFIFO_UDF_INTinterrupt.
                    RXFIFO_UDF_INT_RAW:  u1, 
                    
                    /// [13:13] The raw interrupt bit for I2C_SCL_ST_TO_INT interrupt.
                    SCL_ST_TO_INT_RAW:  u1, 
                    
                    /// [14:14] The raw interrupt bit for I2C_SCL_MAIN_ST_TO_INT interrupt.
                    SCL_MAIN_ST_TO_INT_RAW:  u1, 
                    
                    /// [15:15] The raw interrupt bit for I2C_DET_START_INT interrupt.
                    DET_START_INT_RAW:  u1, 
                    
                    /// [16:16] The raw interrupt bit for I2C_SLAVE_STRETCH_INT interrupt.
                    SLAVE_STRETCH_INT_RAW:  u1, 
                    
                    /// [17:17] The raw interrupt bit for I2C_GENARAL_CALL_INT interrupt.
                    GENERAL_CALL_INT_RAW:  u1, 
                    
                    /// [18:18] The raw interrupt bit for I2C_SLAVE_ADDR_UNMATCH_INT_RAW interrupt.
                    SLAVE_ADDR_UNMATCH_INT_RAW:  u1, 
                    
                    /// [19:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60004020));
                
                /// Interrupt clear bits
                pub const INT_CLR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Set this bit to clear I2C_RXFIFO_WM_INT interrupt.
                    RXFIFO_WM_INT_CLR:  u1, 
                    
                    /// [1:1] Set this bit to clear I2C_TXFIFO_WM_INT interrupt.
                    TXFIFO_WM_INT_CLR:  u1, 
                    
                    /// [2:2] Set this bit to clear I2C_RXFIFO_OVF_INT interrupt.
                    RXFIFO_OVF_INT_CLR:  u1, 
                    
                    /// [3:3] Set this bit to clear the I2C_END_DETECT_INT interrupt.
                    END_DETECT_INT_CLR:  u1, 
                    
                    /// [4:4] Set this bit to clear the I2C_END_DETECT_INT interrupt.
                    BYTE_TRANS_DONE_INT_CLR:  u1, 
                    
                    /// [5:5] Set this bit to clear the I2C_ARBITRATION_LOST_INT interrupt.
                    ARBITRATION_LOST_INT_CLR:  u1, 
                    
                    /// [6:6] Set this bit to clear I2C_TRANS_COMPLETE_INT interrupt.
                    MST_TXFIFO_UDF_INT_CLR:  u1, 
                    
                    /// [7:7] Set this bit to clear the I2C_TRANS_COMPLETE_INT interrupt.
                    TRANS_COMPLETE_INT_CLR:  u1, 
                    
                    /// [8:8] Set this bit to clear the I2C_TIME_OUT_INT interrupt.
                    TIME_OUT_INT_CLR:  u1, 
                    
                    /// [9:9] Set this bit to clear the I2C_TRANS_START_INT interrupt.
                    TRANS_START_INT_CLR:  u1, 
                    
                    /// [10:10] Set this bit to clear I2C_SLAVE_STRETCH_INT interrupt.
                    NACK_INT_CLR:  u1, 
                    
                    /// [11:11] Set this bit to clear I2C_TXFIFO_OVF_INT interrupt.
                    TXFIFO_OVF_INT_CLR:  u1, 
                    
                    /// [12:12] Set this bit to clear I2C_RXFIFO_UDF_INTinterrupt.
                    RXFIFO_UDF_INT_CLR:  u1, 
                    
                    /// [13:13] Set this bit to clear I2C_SCL_ST_TO_INT interrupt.
                    SCL_ST_TO_INT_CLR:  u1, 
                    
                    /// [14:14] Set this bit to clear I2C_SCL_MAIN_ST_TO_INT interrupt.
                    SCL_MAIN_ST_TO_INT_CLR:  u1, 
                    
                    /// [15:15] Set this bit to clear I2C_DET_START_INT interrupt.
                    DET_START_INT_CLR:  u1, 
                    
                    /// [16:16] Set this bit to clear I2C_SLAVE_STRETCH_INT interrupt.
                    SLAVE_STRETCH_INT_CLR:  u1, 
                    
                    /// [17:17] Set this bit to clear I2C_GENARAL_CALL_INT interrupt.
                    GENERAL_CALL_INT_CLR:  u1, 
                    
                    /// [18:18] Set this bit to clear I2C_SLAVE_ADDR_UNMATCH_INT_RAW interrupt.
                    SLAVE_ADDR_UNMATCH_INT_CLR:  u1, 
                    
                    /// [19:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60004024));
                
                /// Interrupt enable bits
                pub const INT_ENA = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] The interrupt enable bit for I2C_RXFIFO_WM_INT interrupt.
                    RXFIFO_WM_INT_ENA:  u1, 
                    
                    /// [1:1] The interrupt enable bit for I2C_TXFIFO_WM_INT interrupt.
                    TXFIFO_WM_INT_ENA:  u1, 
                    
                    /// [2:2] The interrupt enable bit for I2C_RXFIFO_OVF_INT interrupt.
                    RXFIFO_OVF_INT_ENA:  u1, 
                    
                    /// [3:3] The interrupt enable bit for the I2C_END_DETECT_INT interrupt.
                    END_DETECT_INT_ENA:  u1, 
                    
                    /// [4:4] The interrupt enable bit for the I2C_END_DETECT_INT interrupt.
                    BYTE_TRANS_DONE_INT_ENA:  u1, 
                    
                    /// [5:5] The interrupt enable bit for the I2C_ARBITRATION_LOST_INT interrupt.
                    ARBITRATION_LOST_INT_ENA:  u1, 
                    
                    /// [6:6] The interrupt enable bit for I2C_TRANS_COMPLETE_INT interrupt.
                    MST_TXFIFO_UDF_INT_ENA:  u1, 
                    
                    /// [7:7] The interrupt enable bit for the I2C_TRANS_COMPLETE_INT interrupt.
                    TRANS_COMPLETE_INT_ENA:  u1, 
                    
                    /// [8:8] The interrupt enable bit for the I2C_TIME_OUT_INT interrupt.
                    TIME_OUT_INT_ENA:  u1, 
                    
                    /// [9:9] The interrupt enable bit for the I2C_TRANS_START_INT interrupt.
                    TRANS_START_INT_ENA:  u1, 
                    
                    /// [10:10] The interrupt enable bit for I2C_SLAVE_STRETCH_INT interrupt.
                    NACK_INT_ENA:  u1, 
                    
                    /// [11:11] The interrupt enable bit for I2C_TXFIFO_OVF_INT interrupt.
                    TXFIFO_OVF_INT_ENA:  u1, 
                    
                    /// [12:12] The interrupt enable bit for I2C_RXFIFO_UDF_INTinterrupt.
                    RXFIFO_UDF_INT_ENA:  u1, 
                    
                    /// [13:13] The interrupt enable bit for I2C_SCL_ST_TO_INT interrupt.
                    SCL_ST_TO_INT_ENA:  u1, 
                    
                    /// [14:14] The interrupt enable bit for I2C_SCL_MAIN_ST_TO_INT interrupt.
                    SCL_MAIN_ST_TO_INT_ENA:  u1, 
                    
                    /// [15:15] The interrupt enable bit for I2C_DET_START_INT interrupt.
                    DET_START_INT_ENA:  u1, 
                    
                    /// [16:16] The interrupt enable bit for I2C_SLAVE_STRETCH_INT interrupt.
                    SLAVE_STRETCH_INT_ENA:  u1, 
                    
                    /// [17:17] The interrupt enable bit for I2C_GENARAL_CALL_INT interrupt.
                    GENERAL_CALL_INT_ENA:  u1, 
                    
                    /// [18:18] The interrupt enable bit for I2C_SLAVE_ADDR_UNMATCH_INT interrupt.
                    SLAVE_ADDR_UNMATCH_INT_ENA:  u1, 
                    
                    /// [19:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60004028));
                
                /// Status of captured I2C communication events
                pub const INT_STATUS = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] The masked interrupt status bit for I2C_RXFIFO_WM_INT interrupt.
                    RXFIFO_WM_INT_ST:  u1, 
                    
                    /// [1:1] The masked interrupt status bit for I2C_TXFIFO_WM_INT interrupt.
                    TXFIFO_WM_INT_ST:  u1, 
                    
                    /// [2:2] The masked interrupt status bit for I2C_RXFIFO_OVF_INT interrupt.
                    RXFIFO_OVF_INT_ST:  u1, 
                    
                    /// [3:3] The masked interrupt status bit for the I2C_END_DETECT_INT interrupt.
                    END_DETECT_INT_ST:  u1, 
                    
                    /// [4:4] The masked interrupt status bit for the I2C_END_DETECT_INT interrupt.
                    BYTE_TRANS_DONE_INT_ST:  u1, 
                    
                    /// [5:5] The masked interrupt status bit for the I2C_ARBITRATION_LOST_INT interrupt.
                    ARBITRATION_LOST_INT_ST:  u1, 
                    
                    /// [6:6] The masked interrupt status bit for I2C_TRANS_COMPLETE_INT interrupt.
                    MST_TXFIFO_UDF_INT_ST:  u1, 
                    
                    /// [7:7] The masked interrupt status bit for the I2C_TRANS_COMPLETE_INT interrupt.
                    TRANS_COMPLETE_INT_ST:  u1, 
                    
                    /// [8:8] The masked interrupt status bit for the I2C_TIME_OUT_INT interrupt.
                    TIME_OUT_INT_ST:  u1, 
                    
                    /// [9:9] The masked interrupt status bit for the I2C_TRANS_START_INT interrupt.
                    TRANS_START_INT_ST:  u1, 
                    
                    /// [10:10] The masked interrupt status bit for I2C_SLAVE_STRETCH_INT interrupt.
                    NACK_INT_ST:  u1, 
                    
                    /// [11:11] The masked interrupt status bit for I2C_TXFIFO_OVF_INT interrupt.
                    TXFIFO_OVF_INT_ST:  u1, 
                    
                    /// [12:12] The masked interrupt status bit for I2C_RXFIFO_UDF_INTinterrupt.
                    RXFIFO_UDF_INT_ST:  u1, 
                    
                    /// [13:13] The masked interrupt status bit for I2C_SCL_ST_TO_INT interrupt.
                    SCL_ST_TO_INT_ST:  u1, 
                    
                    /// [14:14] The masked interrupt status bit for I2C_SCL_MAIN_ST_TO_INT interrupt.
                    SCL_MAIN_ST_TO_INT_ST:  u1, 
                    
                    /// [15:15] The masked interrupt status bit for I2C_DET_START_INT interrupt.
                    DET_START_INT_ST:  u1, 
                    
                    /// [16:16] The masked interrupt status bit for I2C_SLAVE_STRETCH_INT interrupt.
                    SLAVE_STRETCH_INT_ST:  u1, 
                    
                    /// [17:17] The masked interrupt status bit for I2C_GENARAL_CALL_INT interrupt.
                    GENERAL_CALL_INT_ST:  u1, 
                    
                    /// [18:18] The masked interrupt status bit for I2C_SLAVE_ADDR_UNMATCH_INT interrupt.
                    SLAVE_ADDR_UNMATCH_INT_ST:  u1, 
                    
                    /// [19:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000402c));
                
                /// Configures the hold time after a negative SCL edge.
                pub const SDA_HOLD = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:8] This register is used to configure the time to hold the data after the negativeedge of SCL, in I2C module clock cycles.
                    TIME:  u9, 
                    
                    /// [9:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60004030));
                
                /// Configures the sample time after a positive SCL edge.
                pub const SDA_SAMPLE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:8] This register is used to configure for how long SDA is sampled, in I2C module clock cycles.
                    TIME:  u9, 
                    
                    /// [9:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60004034));
                
                /// Configures the high level width of SCL
                pub const SCL_HIGH_PERIOD = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:8] This register is used to configure for how long SCL remains high in master mode, in I2C module clock cycles.
                    SCL_HIGH_PERIOD:  u9, 
                    
                    /// [9:15] This register is used to configure for the SCL_FSM's waiting period for SCL high level in master mode, in I2C module clock cycles.
                    SCL_WAIT_HIGH_PERIOD:  u7, 
                    
                    /// [16:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60004038));
                
                /// Configures the delay between the SDA and SCL negative edge for a start condition
                pub const SCL_START_HOLD = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:8] This register is used to configure the time between the negative edgeof SDA and the negative edge of SCL for a START condition, in I2C module clock cycles.
                    TIME:  u9, 
                    
                    /// [9:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60004040));
                
                /// Configures the delay between the positiveedge of SCL and the negative edge of SDA
                pub const SCL_RSTART_SETUP = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:8] This register is used to configure the time between the positiveedge of SCL and the negative edge of SDA for a RESTART condition, in I2C module clock cycles.
                    TIME:  u9, 
                    
                    /// [9:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60004044));
                
                /// Configures the delay after the SCL clockedge for a stop condition
                pub const SCL_STOP_HOLD = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:8] This register is used to configure the delay after the STOP condition,in I2C module clock cycles.
                    TIME:  u9, 
                    
                    /// [9:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60004048));
                
                /// Configures the delay between the SDA andSCL positive edge for a stop condition
                pub const SCL_STOP_SETUP = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:8] This register is used to configure the time between the positive edgeof SCL and the positive edge of SDA, in I2C module clock cycles.
                    TIME:  u9, 
                    
                    /// [9:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000404c));
                
                /// SCL and SDA filter configuration register
                pub const FILTER_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:3] When a pulse on the SCL input has smaller width than this register valuein I2C module clock cycles, the I2C controller will ignore that pulse.
                    SCL_FILTER_THRES:  u4, 
                    
                    /// [4:7] When a pulse on the SDA input has smaller width than this register valuein I2C module clock cycles, the I2C controller will ignore that pulse.
                    SDA_FILTER_THRES:  u4, 
                    
                    /// [8:8] This is the filter enable bit for SCL.
                    SCL_FILTER_EN:  u1, 
                    
                    /// [9:9] This is the filter enable bit for SDA.
                    SDA_FILTER_EN:  u1, 
                    
                    /// [10:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60004050));
                
                /// I2C CLK configuration register
                pub const CLK_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] the integral part of the fractional divisor for i2c module
                    SCLK_DIV_NUM:  u8, 
                    
                    /// [8:13] the numerator of the fractional part of the fractional divisor for i2c module
                    SCLK_DIV_A:  u6, 
                    
                    /// [14:19] the denominator of the fractional part of the fractional divisor for i2c module
                    SCLK_DIV_B:  u6, 
                    
                    /// [20:20] The clock selection for i2c module:0-XTAL,1-CLK_8MHz.
                    SCLK_SEL:  u1, 
                    
                    /// [21:21] The clock switch for i2c module
                    SCLK_ACTIVE:  u1, 
                    
                    /// [22:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60004054));
                
                /// I2C command register %s
                pub const COMD0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:13] This is the content of command 0. It consists of three parts: op_code is the command, 0: RSTART, 1: WRITE, 2: READ, 3: STOP, 4: END.Byte_num represents the number of bytes that need to be sent or received.ack_check_en, ack_exp and ack are used to control the ACK bit. See I2C cmd structure for moreInformation.
                    COMMAND:  u14, 
                    
                    /// [14:30] 
                    res0:  u0, 
                    
                    /// [31:31] When command 0 is done in I2C Master mode, this bit changes to highlevel.
                    COMMAND_DONE:  u1, 
                    
                }), @ptrFromInt(0x60004058));
                
                /// I2C command register %s
                pub const COMD0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:13] This is the content of command 0. It consists of three parts: op_code is the command, 0: RSTART, 1: WRITE, 2: READ, 3: STOP, 4: END.Byte_num represents the number of bytes that need to be sent or received.ack_check_en, ack_exp and ack are used to control the ACK bit. See I2C cmd structure for moreInformation.
                    COMMAND:  u14, 
                    
                    /// [14:30] 
                    res0:  u0, 
                    
                    /// [31:31] When command 0 is done in I2C Master mode, this bit changes to highlevel.
                    COMMAND_DONE:  u1, 
                    
                }), @ptrFromInt(0x6000405c));
                
                /// I2C command register %s
                pub const COMD0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:13] This is the content of command 0. It consists of three parts: op_code is the command, 0: RSTART, 1: WRITE, 2: READ, 3: STOP, 4: END.Byte_num represents the number of bytes that need to be sent or received.ack_check_en, ack_exp and ack are used to control the ACK bit. See I2C cmd structure for moreInformation.
                    COMMAND:  u14, 
                    
                    /// [14:30] 
                    res0:  u0, 
                    
                    /// [31:31] When command 0 is done in I2C Master mode, this bit changes to highlevel.
                    COMMAND_DONE:  u1, 
                    
                }), @ptrFromInt(0x60004060));
                
                /// I2C command register %s
                pub const COMD0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:13] This is the content of command 0. It consists of three parts: op_code is the command, 0: RSTART, 1: WRITE, 2: READ, 3: STOP, 4: END.Byte_num represents the number of bytes that need to be sent or received.ack_check_en, ack_exp and ack are used to control the ACK bit. See I2C cmd structure for moreInformation.
                    COMMAND:  u14, 
                    
                    /// [14:30] 
                    res0:  u0, 
                    
                    /// [31:31] When command 0 is done in I2C Master mode, this bit changes to highlevel.
                    COMMAND_DONE:  u1, 
                    
                }), @ptrFromInt(0x60004064));
                
                /// I2C command register %s
                pub const COMD0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:13] This is the content of command 0. It consists of three parts: op_code is the command, 0: RSTART, 1: WRITE, 2: READ, 3: STOP, 4: END.Byte_num represents the number of bytes that need to be sent or received.ack_check_en, ack_exp and ack are used to control the ACK bit. See I2C cmd structure for moreInformation.
                    COMMAND:  u14, 
                    
                    /// [14:30] 
                    res0:  u0, 
                    
                    /// [31:31] When command 0 is done in I2C Master mode, this bit changes to highlevel.
                    COMMAND_DONE:  u1, 
                    
                }), @ptrFromInt(0x60004068));
                
                /// I2C command register %s
                pub const COMD0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:13] This is the content of command 0. It consists of three parts: op_code is the command, 0: RSTART, 1: WRITE, 2: READ, 3: STOP, 4: END.Byte_num represents the number of bytes that need to be sent or received.ack_check_en, ack_exp and ack are used to control the ACK bit. See I2C cmd structure for moreInformation.
                    COMMAND:  u14, 
                    
                    /// [14:30] 
                    res0:  u0, 
                    
                    /// [31:31] When command 0 is done in I2C Master mode, this bit changes to highlevel.
                    COMMAND_DONE:  u1, 
                    
                }), @ptrFromInt(0x6000406c));
                
                /// I2C command register %s
                pub const COMD0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:13] This is the content of command 0. It consists of three parts: op_code is the command, 0: RSTART, 1: WRITE, 2: READ, 3: STOP, 4: END.Byte_num represents the number of bytes that need to be sent or received.ack_check_en, ack_exp and ack are used to control the ACK bit. See I2C cmd structure for moreInformation.
                    COMMAND:  u14, 
                    
                    /// [14:30] 
                    res0:  u0, 
                    
                    /// [31:31] When command 0 is done in I2C Master mode, this bit changes to highlevel.
                    COMMAND_DONE:  u1, 
                    
                }), @ptrFromInt(0x60004070));
                
                /// I2C command register %s
                pub const COMD0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:13] This is the content of command 0. It consists of three parts: op_code is the command, 0: RSTART, 1: WRITE, 2: READ, 3: STOP, 4: END.Byte_num represents the number of bytes that need to be sent or received.ack_check_en, ack_exp and ack are used to control the ACK bit. See I2C cmd structure for moreInformation.
                    COMMAND:  u14, 
                    
                    /// [14:30] 
                    res0:  u0, 
                    
                    /// [31:31] When command 0 is done in I2C Master mode, this bit changes to highlevel.
                    COMMAND_DONE:  u1, 
                    
                }), @ptrFromInt(0x60004074));
                
                /// SCL status time out register
                pub const SCL_ST_TIME_OUT = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:4] The threshold value of SCL_FSM state unchanged period. It should be o more than 23
                    SCL_ST_TO_I2C:  u5, 
                    
                    /// [5:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60004078));
                
                /// SCL main status time out register
                pub const SCL_MAIN_ST_TIME_OUT = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:4] The threshold value of SCL_MAIN_FSM state unchanged period.nIt should be o more than 23
                    SCL_MAIN_ST_TO_I2C:  u5, 
                    
                    /// [5:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000407c));
                
                /// Power configuration register
                pub const SCL_SP_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] When I2C master is IDLE, set this bit to send out SCL pulses. The number of pulses equals to reg_scl_rst_slv_num[4:0].
                    SCL_RST_SLV_EN:  u1, 
                    
                    /// [1:5] Configure the pulses of SCL generated in I2C master mode. Valid when reg_scl_rst_slv_en is 1.
                    SCL_RST_SLV_NUM:  u5, 
                    
                    /// [6:6] The power down enable bit for the I2C output SCL line. 1: Power down. 0: Not power down. Set reg_scl_force_out and reg_scl_pd_en to 1 to stretch SCL low.
                    SCL_PD_EN:  u1, 
                    
                    /// [7:7] The power down enable bit for the I2C output SDA line. 1: Power down. 0: Not power down. Set reg_sda_force_out and reg_sda_pd_en to 1 to stretch SDA low.
                    SDA_PD_EN:  u1, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60004080));
                
                /// Set SCL stretch of I2C slave
                pub const SCL_STRETCH_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:9] Configure the period of I2C slave stretching SCL line.
                    STRETCH_PROTECT_NUM:  u10, 
                    
                    /// [10:10] The enable bit for slave SCL stretch function. 1: Enable. 0: Disable. The SCL output line will be stretched low when reg_slave_scl_stretch_en is 1 and stretch event happens. The stretch cause can be seen in reg_stretch_cause.
                    SLAVE_SCL_STRETCH_EN:  u1, 
                    
                    /// [11:11] Set this bit to clear the I2C slave SCL stretch function.
                    SLAVE_SCL_STRETCH_CLR:  u1, 
                    
                    /// [12:12] The enable bit for slave to control ACK level function.
                    SLAVE_BYTE_ACK_CTL_EN:  u1, 
                    
                    /// [13:13] Set the ACK level when slave controlling ACK level function enables.
                    SLAVE_BYTE_ACK_LVL:  u1, 
                    
                    /// [14:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60004084));
                
                /// Version register
                pub const DATE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] This is the the version register.
                    DATE:  u32, 
                    
                }), @ptrFromInt(0x600040f8));
                
                /// I2C TXFIFO base address register
                pub const TXFIFO_START_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] This is the I2C txfifo first address.
                    TXFIFO_START_ADDR:  u32, 
                    
                }), @ptrFromInt(0x60004100));
                
                /// I2C RXFIFO base address register
                pub const RXFIFO_START_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] This is the I2C rxfifo first address.
                    RXFIFO_START_ADDR:  u32, 
                    
                }), @ptrFromInt(0x60004180));
                
            };
            
            /// I2S (Inter-IC Sound) Controller 0
            pub const I2S0 = struct {
                
                /// I2S interrupt raw register, valid in level.
                pub const INT_RAW = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] The raw interrupt status bitfor the i2s_rx_done_int interrupt
                    RX_DONE_INT_RAW:  u1, 
                    
                    /// [1:1] The raw interrupt status bitfor the i2s_tx_done_int interrupt
                    TX_DONE_INT_RAW:  u1, 
                    
                    /// [2:2] The raw interrupt status bitfor the i2s_rx_hung_int interrupt
                    RX_HUNG_INT_RAW:  u1, 
                    
                    /// [3:3] The raw interrupt status bitfor the i2s_tx_hung_int interrupt
                    TX_HUNG_INT_RAW:  u1, 
                    
                    /// [4:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000c00c));
                
                /// I2S interrupt status register.
                pub const INT_ST = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] The masked interrupt status bitfor the i2s_rx_done_int interrupt
                    RX_DONE_INT_ST:  u1, 
                    
                    /// [1:1] The masked interrupt status bitfor the i2s_tx_done_int interrupt
                    TX_DONE_INT_ST:  u1, 
                    
                    /// [2:2] The masked interrupt status bitfor the i2s_rx_hung_int interrupt
                    RX_HUNG_INT_ST:  u1, 
                    
                    /// [3:3] The masked interrupt status bitfor the i2s_tx_hung_int interrupt
                    TX_HUNG_INT_ST:  u1, 
                    
                    /// [4:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000c010));
                
                /// I2S interrupt enable register.
                pub const INT_ENA = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] The interrupt enable bitfor the i2s_rx_done_int interrupt
                    RX_DONE_INT_ENA:  u1, 
                    
                    /// [1:1] The interrupt enable bitfor the i2s_tx_done_int interrupt
                    TX_DONE_INT_ENA:  u1, 
                    
                    /// [2:2] The interrupt enable bitfor the i2s_rx_hung_int interrupt
                    RX_HUNG_INT_ENA:  u1, 
                    
                    /// [3:3] The interrupt enable bitfor the i2s_tx_hung_int interrupt
                    TX_HUNG_INT_ENA:  u1, 
                    
                    /// [4:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000c014));
                
                /// I2S interrupt clear register.
                pub const INT_CLR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Set this bit to clear the i2s_rx_done_int interrupt
                    RX_DONE_INT_CLR:  u1, 
                    
                    /// [1:1] Set this bit to clear the i2s_tx_done_int interrupt
                    TX_DONE_INT_CLR:  u1, 
                    
                    /// [2:2] Set this bit to clear the i2s_rx_hung_int interrupt
                    RX_HUNG_INT_CLR:  u1, 
                    
                    /// [3:3] Set this bit to clear the i2s_tx_hung_int interrupt
                    TX_HUNG_INT_CLR:  u1, 
                    
                    /// [4:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000c018));
                
                /// I2S RX configure register
                pub const RX_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Set this bit to reset receiver
                    RX_RESET:  u1, 
                    
                    /// [1:1] Set this bit to reset Rx AFIFO
                    RX_FIFO_RESET:  u1, 
                    
                    /// [2:2] Set this bit to start receiving data
                    RX_START:  u1, 
                    
                    /// [3:3] Set this bit to enable slave receiver mode
                    RX_SLAVE_MOD:  u1, 
                    
                    /// [4:4] 
                    res0:  u0, 
                    
                    /// [5:5] Set this bit to enable receiverin mono mode
                    RX_MONO:  u1, 
                    
                    /// [6:6] 
                    res1:  u0, 
                    
                    /// [7:7] I2S Rx byte endian, 1: low addr value to high addr. 0: low addr with low addr value.
                    RX_BIG_ENDIAN:  u1, 
                    
                    /// [8:8] Set 1 to update I2S RX registers from APB clock domain to I2S RX clock domain. This bit will be cleared by hardware after update register done.
                    RX_UPDATE:  u1, 
                    
                    /// [9:9] 1: The first channel data value is valid in I2S RX mono mode. 0: The second channel data value is valid in I2S RX mono mode.
                    RX_MONO_FST_VLD:  u1, 
                    
                    /// [10:11] I2S RX compress/decompress configuration bit. & 0 (atol): A-Law decompress, 1 (ltoa) : A-Law compress, 2 (utol) : u-Law decompress, 3 (ltou) : u-Law compress. &
                    RX_PCM_CONF:  u2, 
                    
                    /// [12:12] Set this bit to bypass Compress/Decompress module for received data.
                    RX_PCM_BYPASS:  u1, 
                    
                    /// [13:14] 0: I2S Rx only stop when reg_rx_start is cleared. 1: Stop when reg_rx_start is 0 or in_suc_eof is 1. 2:Stop I2S RX when reg_rx_start is 0 or RX FIFO is full.
                    RX_STOP_MODE:  u2, 
                    
                    /// [15:15] 1: I2S RX left alignment mode. 0: I2S RX right alignment mode.
                    RX_LEFT_ALIGN:  u1, 
                    
                    /// [16:16] 1: store 24 channel bits to 32 bits. 0:store 24 channel bits to 24 bits.
                    RX_24_FILL_EN:  u1, 
                    
                    /// [17:17] 0: WS should be 0 when receiving left channel data, and WS is 1in right channel.1: WS should be 1 when receiving left channel data, and WS is 0in right channel.
                    RX_WS_IDLE_POL:  u1, 
                    
                    /// [18:18] I2S Rx bit endian. 1:small endian, the LSB is received first. 0:big endian, the MSB is received first.
                    RX_BIT_ORDER:  u1, 
                    
                    /// [19:19] 1: Enable I2S TDM Rx mode . 0: Disable.
                    RX_TDM_EN:  u1, 
                    
                    /// [20:20] 1: Enable I2S PDM Rx mode . 0: Disable.
                    RX_PDM_EN:  u1, 
                    
                    /// [21:31] 
                    res2:  u0, 
                    
                }), @ptrFromInt(0x6000c020));
                
                /// I2S TX configure register
                pub const TX_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Set this bit to reset transmitter
                    TX_RESET:  u1, 
                    
                    /// [1:1] Set this bit to reset Tx AFIFO
                    TX_FIFO_RESET:  u1, 
                    
                    /// [2:2] Set this bit to start transmitting data
                    TX_START:  u1, 
                    
                    /// [3:3] Set this bit to enable slave transmitter mode
                    TX_SLAVE_MOD:  u1, 
                    
                    /// [4:4] 
                    res0:  u0, 
                    
                    /// [5:5] Set this bit to enable transmitter in mono mode
                    TX_MONO:  u1, 
                    
                    /// [6:6] 1: The value of Left channel data is equal to the value of right channel data in I2S TX mono mode or TDM channel select mode. 0: The invalid channel data is reg_i2s_single_data in I2S TX mono mode or TDM channel select mode.
                    TX_CHAN_EQUAL:  u1, 
                    
                    /// [7:7] I2S Tx byte endian, 1: low addr value to high addr.0: low addr with low addr value.
                    TX_BIG_ENDIAN:  u1, 
                    
                    /// [8:8] Set 1 to update I2S TX registers from APB clock domain to I2S TX clock domain. This bit will be cleared by hardware after update register done.
                    TX_UPDATE:  u1, 
                    
                    /// [9:9] 1: The first channel data value is valid in I2S TX mono mode. 0: The second channel data value is valid in I2S TX mono mode.
                    TX_MONO_FST_VLD:  u1, 
                    
                    /// [10:11] I2S TX compress/decompress configuration bit. & 0 (atol): A-Law decompress, 1 (ltoa) : A-Law compress, 2 (utol) : u-Law decompress, 3 (ltou) : u-Law compress. &
                    TX_PCM_CONF:  u2, 
                    
                    /// [12:12] Set this bit to bypassCompress/Decompress module for transmitted data.
                    TX_PCM_BYPASS:  u1, 
                    
                    /// [13:13] Set this bit to stop disable output BCK signal and WS signal when tx FIFO is emtpy
                    TX_STOP_EN:  u1, 
                    
                    /// [14:14] 
                    res1:  u0, 
                    
                    /// [15:15] 1: I2S TX left alignment mode. 0: I2S TX right alignment mode.
                    TX_LEFT_ALIGN:  u1, 
                    
                    /// [16:16] 1: Sent 32 bits in 24 channel bits mode. 0: Sent 24 bits in 24 channel bits mode
                    TX_24_FILL_EN:  u1, 
                    
                    /// [17:17] 0: WS should be 0 when sending left channel data, and WS is 1in right channel.1: WS should be 1 when sending left channel data, and WS is 0in right channel.
                    TX_WS_IDLE_POL:  u1, 
                    
                    /// [18:18] I2S Tx bit endian. 1:small endian, the LSB is sent first. 0:big endian, the MSB is sent first.
                    TX_BIT_ORDER:  u1, 
                    
                    /// [19:19] 1: Enable I2S TDM Tx mode . 0: Disable.
                    TX_TDM_EN:  u1, 
                    
                    /// [20:20] 1: Enable I2S PDM Tx mode . 0: Disable.
                    TX_PDM_EN:  u1, 
                    
                    /// [21:23] 
                    res2:  u0, 
                    
                    /// [24:26] I2S transmitter channel mode configuration bits.
                    TX_CHAN_MOD:  u3, 
                    
                    /// [27:27] Enable signal loop back mode with transmitter module and receiver module sharing the same WS and BCK signals.
                    SIG_LOOPBACK:  u1, 
                    
                    /// [28:31] 
                    res3:  u0, 
                    
                }), @ptrFromInt(0x6000c024));
                
                /// I2S RX configure register 1
                pub const RX_CONF1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:6] The width of rx_ws_out in TDM mode is (I2S_RX_TDM_WS_WIDTH[6:0] +1) * T_bck
                    RX_TDM_WS_WIDTH:  u7, 
                    
                    /// [7:12] Bit clock configuration bits in receiver mode.
                    RX_BCK_DIV_NUM:  u6, 
                    
                    /// [13:17] Set the bits to configure the valid data bit length of I2S receiver channel. 7: all the valid channel data is in 8-bit-mode. 15: all the valid channel data is in 16-bit-mode. 23: all the valid channel data is in 24-bit-mode. 31:all the valid channel data is in 32-bit-mode.
                    RX_BITS_MOD:  u5, 
                    
                    /// [18:23] I2S Rx half sample bits -1.
                    RX_HALF_SAMPLE_BITS:  u6, 
                    
                    /// [24:28] The Rx bit number for each channel minus 1in TDM mode.
                    RX_TDM_CHAN_BITS:  u5, 
                    
                    /// [29:29] Set this bit to enable receiver in Phillips standard mode
                    RX_MSB_SHIFT:  u1, 
                    
                    /// [30:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000c028));
                
                /// I2S TX configure register 1
                pub const TX_CONF1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:6] The width of tx_ws_out in TDM mode is (I2S_TX_TDM_WS_WIDTH[6:0] +1) * T_bck
                    TX_TDM_WS_WIDTH:  u7, 
                    
                    /// [7:12] Bit clock configuration bits in transmitter mode.
                    TX_BCK_DIV_NUM:  u6, 
                    
                    /// [13:17] Set the bits to configure the valid data bit length of I2S transmitter channel. 7: all the valid channel data is in 8-bit-mode. 15: all the valid channel data is in 16-bit-mode. 23: all the valid channel data is in 24-bit-mode. 31:all the valid channel data is in 32-bit-mode.
                    TX_BITS_MOD:  u5, 
                    
                    /// [18:23] I2S Tx half sample bits -1.
                    TX_HALF_SAMPLE_BITS:  u6, 
                    
                    /// [24:28] The Tx bit number for each channel minus 1in TDM mode.
                    TX_TDM_CHAN_BITS:  u5, 
                    
                    /// [29:29] Set this bit to enable transmitter in Phillips standard mode
                    TX_MSB_SHIFT:  u1, 
                    
                    /// [30:30] 1: BCK is not delayed to generate pos/neg edge in master mode. 0: BCK is delayed to generate pos/neg edge in master mode.
                    TX_BCK_NO_DLY:  u1, 
                    
                    /// [31:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000c02c));
                
                /// I2S RX clock configure register
                pub const RX_CLKM_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] Integral I2S clock divider value
                    RX_CLKM_DIV_NUM:  u8, 
                    
                    /// [8:25] 
                    res0:  u0, 
                    
                    /// [26:26] I2S Rx module clock enable signal.
                    RX_CLK_ACTIVE:  u1, 
                    
                    /// [27:28] Select I2S Rx module source clock. 0: no clock. 1: APLL. 2: CLK160. 3: I2S_MCLK_in.
                    RX_CLK_SEL:  u2, 
                    
                    /// [29:29] 0: UseI2S Tx module clock as I2S_MCLK_OUT.1: UseI2S Rx module clock as I2S_MCLK_OUT.
                    MCLK_SEL:  u1, 
                    
                    /// [30:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x6000c030));
                
                /// I2S TX clock configure register
                pub const TX_CLKM_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] Integral I2S TX clock divider value. f_I2S_CLK = f_I2S_CLK_S/(N+b/a). There will be (a-b) * n-div and b * (n+1)-div.So the average combination will be:for b <= a/2, z * [x * n-div + (n+1)-div] + y * n-div. For b > a/2, z * [n-div + x * (n+1)-div] + y * (n+1)-div.
                    TX_CLKM_DIV_NUM:  u8, 
                    
                    /// [8:25] 
                    res0:  u0, 
                    
                    /// [26:26] I2S Tx module clock enable signal.
                    TX_CLK_ACTIVE:  u1, 
                    
                    /// [27:28] Select I2S Tx module source clock. 0: XTAL clock. 1: APLL. 2: CLK160. 3: I2S_MCLK_in.
                    TX_CLK_SEL:  u2, 
                    
                    /// [29:29] Set this bit to enable clk gate
                    CLK_EN:  u1, 
                    
                    /// [30:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x6000c034));
                
                /// I2S RX module clock divider configure register
                pub const RX_CLKM_DIV_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:8] For b <= a/2, the value of I2S_RX_CLKM_DIV_Z is b. For b > a/2, the value of I2S_RX_CLKM_DIV_Z is (a-b).
                    RX_CLKM_DIV_Z:  u9, 
                    
                    /// [9:17] For b <= a/2, the value of I2S_RX_CLKM_DIV_Y is (a%b) . For b > a/2, the value of I2S_RX_CLKM_DIV_Y is (a%(a-b)).
                    RX_CLKM_DIV_Y:  u9, 
                    
                    /// [18:26] For b <= a/2, the value of I2S_RX_CLKM_DIV_X is (a/b) - 1. For b > a/2, the value of I2S_RX_CLKM_DIV_X is (a/(a-b)) - 1.
                    RX_CLKM_DIV_X:  u9, 
                    
                    /// [27:27] For b <= a/2, the value of I2S_RX_CLKM_DIV_YN1 is 0 . For b > a/2, the value of I2S_RX_CLKM_DIV_YN1 is 1.
                    RX_CLKM_DIV_YN1:  u1, 
                    
                    /// [28:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000c038));
                
                /// I2S TX module clock divider configure register
                pub const TX_CLKM_DIV_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:8] For b <= a/2, the value of I2S_TX_CLKM_DIV_Z is b. For b > a/2, the value of I2S_TX_CLKM_DIV_Z is (a-b).
                    TX_CLKM_DIV_Z:  u9, 
                    
                    /// [9:17] For b <= a/2, the value of I2S_TX_CLKM_DIV_Y is (a%b) . For b > a/2, the value of I2S_TX_CLKM_DIV_Y is (a%(a-b)).
                    TX_CLKM_DIV_Y:  u9, 
                    
                    /// [18:26] For b <= a/2, the value of I2S_TX_CLKM_DIV_X is (a/b) - 1. For b > a/2, the value of I2S_TX_CLKM_DIV_X is (a/(a-b)) - 1.
                    TX_CLKM_DIV_X:  u9, 
                    
                    /// [27:27] For b <= a/2, the value of I2S_TX_CLKM_DIV_YN1 is 0 . For b > a/2, the value of I2S_TX_CLKM_DIV_YN1 is 1.
                    TX_CLKM_DIV_YN1:  u1, 
                    
                    /// [28:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000c03c));
                
                /// I2S TX PCM2PDM configuration register
                pub const TX_PCM2PDM_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] I2S TX PDM bypass hp filter or not. The option has been removed.
                    TX_PDM_HP_BYPASS:  u1, 
                    
                    /// [1:4] I2S TX PDM OSR2 value
                    TX_PDM_SINC_OSR2:  u4, 
                    
                    /// [5:12] I2S TX PDM prescale for sigmadelta
                    TX_PDM_PRESCALE:  u8, 
                    
                    /// [13:14] I2S TX PDM sigmadelta scale shift number: 0:/2 , 1:x1 , 2:x2 , 3: x4
                    TX_PDM_HP_IN_SHIFT:  u2, 
                    
                    /// [15:16] I2S TX PDM sigmadelta scale shift number: 0:/2 , 1:x1 , 2:x2 , 3: x4
                    TX_PDM_LP_IN_SHIFT:  u2, 
                    
                    /// [17:18] I2S TX PDM sigmadelta scale shift number: 0:/2 , 1:x1 , 2:x2 , 3: x4
                    TX_PDM_SINC_IN_SHIFT:  u2, 
                    
                    /// [19:20] I2S TX PDM sigmadelta scale shift number: 0:/2 , 1:x1 , 2:x2 , 3: x4
                    TX_PDM_SIGMADELTA_IN_SHIFT:  u2, 
                    
                    /// [21:21] I2S TX PDM sigmadelta dither2 value
                    TX_PDM_SIGMADELTA_DITHER2:  u1, 
                    
                    /// [22:22] I2S TX PDM sigmadelta dither value
                    TX_PDM_SIGMADELTA_DITHER:  u1, 
                    
                    /// [23:23] I2S TX PDM dac mode enable
                    TX_PDM_DAC_2OUT_EN:  u1, 
                    
                    /// [24:24] I2S TX PDM dac 2channel enable
                    TX_PDM_DAC_MODE_EN:  u1, 
                    
                    /// [25:25] I2S TX PDM Converter enable
                    PCM2PDM_CONV_EN:  u1, 
                    
                    /// [26:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000c040));
                
                /// I2S TX PCM2PDM configuration register
                pub const TX_PCM2PDM_CONF1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:9] I2S TX PDM Fp
                    TX_PDM_FP:  u10, 
                    
                    /// [10:19] I2S TX PDM Fs
                    TX_PDM_FS:  u10, 
                    
                    /// [20:22] The fourth parameter of PDM TX IIR_HP filter stage 2 is (504 + I2S_TX_IIR_HP_MULT12_5[2:0])
                    TX_IIR_HP_MULT12_5:  u3, 
                    
                    /// [23:25] The fourth parameter of PDM TX IIR_HP filter stage 1 is (504 + I2S_TX_IIR_HP_MULT12_0[2:0])
                    TX_IIR_HP_MULT12_0:  u3, 
                    
                    /// [26:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000c044));
                
                /// I2S TX TDM mode control register
                pub const RX_TDM_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] 1: Enable the valid data input of I2S RX TDM or PDM channel 0. 0:Disable, just input 0 in this channel.
                    RX_TDM_PDM_CHAN0_EN:  u1, 
                    
                    /// [1:1] 1: Enable the valid data input of I2S RX TDM or PDM channel 1. 0:Disable, just input 0 in this channel.
                    RX_TDM_PDM_CHAN1_EN:  u1, 
                    
                    /// [2:2] 1: Enable the valid data input of I2S RX TDM or PDM channel 2. 0:Disable, just input 0 in this channel.
                    RX_TDM_PDM_CHAN2_EN:  u1, 
                    
                    /// [3:3] 1: Enable the valid data input of I2S RX TDM or PDM channel 3. 0:Disable, just input 0 in this channel.
                    RX_TDM_PDM_CHAN3_EN:  u1, 
                    
                    /// [4:4] 1: Enable the valid data input of I2S RX TDM or PDM channel 4. 0:Disable, just input 0 in this channel.
                    RX_TDM_PDM_CHAN4_EN:  u1, 
                    
                    /// [5:5] 1: Enable the valid data input of I2S RX TDM or PDM channel 5. 0:Disable, just input 0 in this channel.
                    RX_TDM_PDM_CHAN5_EN:  u1, 
                    
                    /// [6:6] 1: Enable the valid data input of I2S RX TDM or PDM channel 6. 0:Disable, just input 0 in this channel.
                    RX_TDM_PDM_CHAN6_EN:  u1, 
                    
                    /// [7:7] 1: Enable the valid data input of I2S RX TDM or PDM channel 7. 0:Disable, just input 0 in this channel.
                    RX_TDM_PDM_CHAN7_EN:  u1, 
                    
                    /// [8:8] 1: Enable the valid data input of I2S RX TDM channel 8. 0:Disable, just input 0 in this channel.
                    RX_TDM_CHAN8_EN:  u1, 
                    
                    /// [9:9] 1: Enable the valid data input of I2S RX TDM channel 9. 0:Disable, just input 0 in this channel.
                    RX_TDM_CHAN9_EN:  u1, 
                    
                    /// [10:10] 1: Enable the valid data input of I2S RX TDM channel 10. 0:Disable, just input 0 in this channel.
                    RX_TDM_CHAN10_EN:  u1, 
                    
                    /// [11:11] 1: Enable the valid data input of I2S RX TDM channel 11. 0:Disable, just input 0 in this channel.
                    RX_TDM_CHAN11_EN:  u1, 
                    
                    /// [12:12] 1: Enable the valid data input of I2S RX TDM channel 12. 0:Disable, just input 0 in this channel.
                    RX_TDM_CHAN12_EN:  u1, 
                    
                    /// [13:13] 1: Enable the valid data input of I2S RX TDM channel 13. 0:Disable, just input 0 in this channel.
                    RX_TDM_CHAN13_EN:  u1, 
                    
                    /// [14:14] 1: Enable the valid data input of I2S RX TDM channel 14. 0:Disable, just input 0 in this channel.
                    RX_TDM_CHAN14_EN:  u1, 
                    
                    /// [15:15] 1: Enable the valid data input of I2S RX TDM channel 15. 0:Disable, just input 0 in this channel.
                    RX_TDM_CHAN15_EN:  u1, 
                    
                    /// [16:19] The total channel number of I2S TX TDM mode.
                    RX_TDM_TOT_CHAN_NUM:  u4, 
                    
                    /// [20:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000c050));
                
                /// I2S TX TDM mode control register
                pub const TX_TDM_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] 1: Enable the valid data output of I2S TX TDM channel 0. 0:Disable, just output 0 in this channel.
                    TX_TDM_CHAN0_EN:  u1, 
                    
                    /// [1:1] 1: Enable the valid data output of I2S TX TDM channel 1. 0:Disable, just output 0 in this channel.
                    TX_TDM_CHAN1_EN:  u1, 
                    
                    /// [2:2] 1: Enable the valid data output of I2S TX TDM channel 2. 0:Disable, just output 0 in this channel.
                    TX_TDM_CHAN2_EN:  u1, 
                    
                    /// [3:3] 1: Enable the valid data output of I2S TX TDM channel 3. 0:Disable, just output 0 in this channel.
                    TX_TDM_CHAN3_EN:  u1, 
                    
                    /// [4:4] 1: Enable the valid data output of I2S TX TDM channel 4. 0:Disable, just output 0 in this channel.
                    TX_TDM_CHAN4_EN:  u1, 
                    
                    /// [5:5] 1: Enable the valid data output of I2S TX TDM channel 5. 0:Disable, just output 0 in this channel.
                    TX_TDM_CHAN5_EN:  u1, 
                    
                    /// [6:6] 1: Enable the valid data output of I2S TX TDM channel 6. 0:Disable, just output 0 in this channel.
                    TX_TDM_CHAN6_EN:  u1, 
                    
                    /// [7:7] 1: Enable the valid data output of I2S TX TDM channel 7. 0:Disable, just output 0 in this channel.
                    TX_TDM_CHAN7_EN:  u1, 
                    
                    /// [8:8] 1: Enable the valid data output of I2S TX TDM channel 8. 0:Disable, just output 0 in this channel.
                    TX_TDM_CHAN8_EN:  u1, 
                    
                    /// [9:9] 1: Enable the valid data output of I2S TX TDM channel 9. 0:Disable, just output 0 in this channel.
                    TX_TDM_CHAN9_EN:  u1, 
                    
                    /// [10:10] 1: Enable the valid data output of I2S TX TDM channel 10. 0:Disable, just output 0 in this channel.
                    TX_TDM_CHAN10_EN:  u1, 
                    
                    /// [11:11] 1: Enable the valid data output of I2S TX TDM channel 11. 0:Disable, just output 0 in this channel.
                    TX_TDM_CHAN11_EN:  u1, 
                    
                    /// [12:12] 1: Enable the valid data output of I2S TX TDM channel 12. 0:Disable, just output 0 in this channel.
                    TX_TDM_CHAN12_EN:  u1, 
                    
                    /// [13:13] 1: Enable the valid data output of I2S TX TDM channel 13. 0:Disable, just output 0 in this channel.
                    TX_TDM_CHAN13_EN:  u1, 
                    
                    /// [14:14] 1: Enable the valid data output of I2S TX TDM channel 14. 0:Disable, just output 0 in this channel.
                    TX_TDM_CHAN14_EN:  u1, 
                    
                    /// [15:15] 1: Enable the valid data output of I2S TX TDM channel 15. 0:Disable, just output 0 in this channel.
                    TX_TDM_CHAN15_EN:  u1, 
                    
                    /// [16:19] The total channel number of I2S TX TDM mode.
                    TX_TDM_TOT_CHAN_NUM:  u4, 
                    
                    /// [20:20] When DMA TX buffer stores the data of (REG_TX_TDM_TOT_CHAN_NUM + 1)channels, and only the data of the enabled channels is sent, then this bit should be set. Clear it when all the data stored in DMA TX buffer is for enabled channels.
                    TX_TDM_SKIP_MSK_EN:  u1, 
                    
                    /// [21:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000c054));
                
                /// I2S RX timing control register
                pub const RX_TIMING = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:1] The delay mode of I2S Rx SD input signal. 0: bypass. 1: delay by pos edge.2: delay by neg edge. 3: not used.
                    RX_SD_IN_DM:  u2, 
                    
                    /// [2:15] 
                    res0:  u0, 
                    
                    /// [16:17] The delay mode of I2S Rx WS output signal. 0: bypass. 1: delay by pos edge.2: delay by neg edge. 3: not used.
                    RX_WS_OUT_DM:  u2, 
                    
                    /// [18:19] 
                    res1:  u0, 
                    
                    /// [20:21] The delay mode of I2S Rx BCK output signal. 0: bypass. 1: delay by pos edge.2: delay by neg edge. 3: not used.
                    RX_BCK_OUT_DM:  u2, 
                    
                    /// [22:23] 
                    res2:  u0, 
                    
                    /// [24:25] The delay mode of I2S Rx WS input signal. 0: bypass. 1: delay by pos edge.2: delay by neg edge. 3: not used.
                    RX_WS_IN_DM:  u2, 
                    
                    /// [26:27] 
                    res3:  u0, 
                    
                    /// [28:29] The delay mode of I2S Rx BCK input signal. 0: bypass. 1: delay by pos edge.2: delay by neg edge. 3: not used.
                    RX_BCK_IN_DM:  u2, 
                    
                    /// [30:31] 
                    res4:  u0, 
                    
                }), @ptrFromInt(0x6000c058));
                
                /// I2S TX timing control register
                pub const TX_TIMING = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:1] The delay mode of I2S TX SD output signal. 0: bypass. 1: delay by pos edge.2: delay by neg edge. 3: not used.
                    TX_SD_OUT_DM:  u2, 
                    
                    /// [2:3] 
                    res0:  u0, 
                    
                    /// [4:5] The delay mode of I2S TX SD1 output signal. 0: bypass. 1: delay by pos edge.2: delay by neg edge. 3: not used.
                    TX_SD1_OUT_DM:  u2, 
                    
                    /// [6:15] 
                    res1:  u0, 
                    
                    /// [16:17] The delay mode of I2S TX WS output signal. 0: bypass. 1: delay by pos edge.2: delay by neg edge. 3: not used.
                    TX_WS_OUT_DM:  u2, 
                    
                    /// [18:19] 
                    res2:  u0, 
                    
                    /// [20:21] The delay mode of I2S TX BCK output signal. 0: bypass. 1: delay by pos edge.2: delay by neg edge. 3: not used.
                    TX_BCK_OUT_DM:  u2, 
                    
                    /// [22:23] 
                    res3:  u0, 
                    
                    /// [24:25] The delay mode of I2S TX WS input signal. 0: bypass. 1: delay by pos edge.2: delay by neg edge. 3: not used.
                    TX_WS_IN_DM:  u2, 
                    
                    /// [26:27] 
                    res4:  u0, 
                    
                    /// [28:29] The delay mode of I2S TX BCK input signal. 0: bypass. 1: delay by pos edge.2: delay by neg edge. 3: not used.
                    TX_BCK_IN_DM:  u2, 
                    
                    /// [30:31] 
                    res5:  u0, 
                    
                }), @ptrFromInt(0x6000c05c));
                
                /// I2S HUNG configure register.
                pub const LC_HUNG_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] the i2s_tx_hung_int interrupt or the i2s_rx_hung_int interrupt will be triggered when fifo hung counter is equal to this value
                    LC_FIFO_TIMEOUT:  u8, 
                    
                    /// [8:10] The bits are used to scale tick counter threshold. The tick counter is reset when counter value >= 88000/2^i2s_lc_fifo_timeout_shift
                    LC_FIFO_TIMEOUT_SHIFT:  u3, 
                    
                    /// [11:11] The enable bit for FIFO timeout
                    LC_FIFO_TIMEOUT_ENA:  u1, 
                    
                    /// [12:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000c060));
                
                /// I2S RX data number control register.
                pub const RXEOF_NUM = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:11] The receive data bit length is (I2S_RX_BITS_MOD[4:0] + 1) * (REG_RX_EOF_NUM[11:0] + 1) . It will trigger in_suc_eof interrupt in the configured DMA RX channel.
                    RX_EOF_NUM:  u12, 
                    
                    /// [12:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000c064));
                
                /// I2S signal data register
                pub const CONF_SIGLE_DATA = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] The configured constant channel data to be sent out.
                    SINGLE_DATA:  u32, 
                    
                }), @ptrFromInt(0x6000c068));
                
                /// I2S TX status register
                pub const STATE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] 1: i2s_tx is idle state. 0: i2s_tx is working.
                    TX_IDLE:  u1, 
                    
                    /// [1:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000c06c));
                
                /// I2S ETM configure register
                pub const ETM_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:9] I2S ETM send x words event. When sending word number of reg_etm_tx_send_word_num[9:0], i2s will trigger an etm event.
                    ETM_TX_SEND_WORD_NUM:  u10, 
                    
                    /// [10:19] I2S ETM receive x words event. When receiving word number of reg_etm_rx_receive_word_num[9:0], i2s will trigger an etm event.
                    ETM_RX_RECEIVE_WORD_NUM:  u10, 
                    
                    /// [20:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000c070));
                
                /// Version control register
                pub const DATE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:27] I2S version control register
                    DATE:  u28, 
                    
                    /// [28:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000c080));
                
            };
            
            /// Interrupt Controller (Core 0)
            pub const INTERRUPT_CORE0 = struct {
                
                /// register description
                pub const WIFI_MAC_INTR_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:4] Need add description
                    WIFI_MAC_INTR_MAP:  u5, 
                    
                    /// [5:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60010000));
                
                /// register description
                pub const WIFI_MAC_NMI_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:4] Need add description
                    WIFI_MAC_NMI_MAP:  u5, 
                    
                    /// [5:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60010004));
                
                /// register description
                pub const WIFI_PWR_INTR_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:4] Need add description
                    WIFI_PWR_INTR_MAP:  u5, 
                    
                    /// [5:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60010008));
                
                /// register description
                pub const WIFI_BB_INTR_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:4] Need add description
                    WIFI_BB_INTR_MAP:  u5, 
                    
                    /// [5:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6001000c));
                
                /// register description
                pub const BT_MAC_INTR_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:4] Need add description
                    BT_MAC_INTR_MAP:  u5, 
                    
                    /// [5:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60010010));
                
                /// register description
                pub const BT_BB_INTR_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:4] Need add description
                    BT_BB_INTR_MAP:  u5, 
                    
                    /// [5:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60010014));
                
                /// register description
                pub const BT_BB_NMI_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:4] Need add description
                    BT_BB_NMI_MAP:  u5, 
                    
                    /// [5:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60010018));
                
                /// register description
                pub const LP_TIMER_INTR_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:4] Need add description
                    LP_TIMER_INTR_MAP:  u5, 
                    
                    /// [5:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6001001c));
                
                /// register description
                pub const COEX_INTR_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:4] Need add description
                    COEX_INTR_MAP:  u5, 
                    
                    /// [5:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60010020));
                
                /// register description
                pub const BLE_TIMER_INTR_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:4] Need add description
                    BLE_TIMER_INTR_MAP:  u5, 
                    
                    /// [5:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60010024));
                
                /// register description
                pub const BLE_SEC_INTR_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:4] Need add description
                    BLE_SEC_INTR_MAP:  u5, 
                    
                    /// [5:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60010028));
                
                /// register description
                pub const I2C_MST_INTR_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:4] Need add description
                    I2C_MST_INTR_MAP:  u5, 
                    
                    /// [5:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6001002c));
                
                /// register description
                pub const ZB_MAC_INTR_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:4] Need add description
                    ZB_MAC_INTR_MAP:  u5, 
                    
                    /// [5:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60010030));
                
                /// register description
                pub const PMU_INTR_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:4] Need add description
                    PMU_INTR_MAP:  u5, 
                    
                    /// [5:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60010034));
                
                /// register description
                pub const EFUSE_INTR_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:4] Need add description
                    EFUSE_INTR_MAP:  u5, 
                    
                    /// [5:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60010038));
                
                /// register description
                pub const LP_RTC_TIMER_INTR_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:4] Need add description
                    LP_RTC_TIMER_INTR_MAP:  u5, 
                    
                    /// [5:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6001003c));
                
                /// register description
                pub const LP_UART_INTR_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:4] Need add description
                    LP_UART_INTR_MAP:  u5, 
                    
                    /// [5:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60010040));
                
                /// register description
                pub const LP_I2C_INTR_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:4] Need add description
                    LP_I2C_INTR_MAP:  u5, 
                    
                    /// [5:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60010044));
                
                /// register description
                pub const LP_WDT_INTR_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:4] Need add description
                    LP_WDT_INTR_MAP:  u5, 
                    
                    /// [5:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60010048));
                
                /// register description
                pub const LP_PERI_TIMEOUT_INTR_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:4] Need add description
                    LP_PERI_TIMEOUT_INTR_MAP:  u5, 
                    
                    /// [5:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6001004c));
                
                /// register description
                pub const LP_APM_M0_INTR_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:4] Need add description
                    LP_APM_M0_INTR_MAP:  u5, 
                    
                    /// [5:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60010050));
                
                /// register description
                pub const LP_APM_M1_INTR_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:4] Need add description
                    LP_APM_M1_INTR_MAP:  u5, 
                    
                    /// [5:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60010054));
                
                /// register description
                pub const CPU_INTR_FROM_CPU_0_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:4] Need add description
                    CPU_INTR_FROM_CPU_0_MAP:  u5, 
                    
                    /// [5:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60010058));
                
                /// register description
                pub const CPU_INTR_FROM_CPU_1_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:4] Need add description
                    CPU_INTR_FROM_CPU_1_MAP:  u5, 
                    
                    /// [5:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6001005c));
                
                /// register description
                pub const CPU_INTR_FROM_CPU_2_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:4] Need add description
                    CPU_INTR_FROM_CPU_2_MAP:  u5, 
                    
                    /// [5:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60010060));
                
                /// register description
                pub const CPU_INTR_FROM_CPU_3_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:4] Need add description
                    CPU_INTR_FROM_CPU_3_MAP:  u5, 
                    
                    /// [5:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60010064));
                
                /// register description
                pub const ASSIST_DEBUG_INTR_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:4] Need add description
                    ASSIST_DEBUG_INTR_MAP:  u5, 
                    
                    /// [5:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60010068));
                
                /// register description
                pub const TRACE_INTR_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:4] Need add description
                    TRACE_INTR_MAP:  u5, 
                    
                    /// [5:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6001006c));
                
                /// register description
                pub const CACHE_INTR_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:4] Need add description
                    CACHE_INTR_MAP:  u5, 
                    
                    /// [5:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60010070));
                
                /// register description
                pub const CPU_PERI_TIMEOUT_INTR_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:4] Need add description
                    CPU_PERI_TIMEOUT_INTR_MAP:  u5, 
                    
                    /// [5:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60010074));
                
                /// register description
                pub const GPIO_INTERRUPT_PRO_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:4] Need add description
                    GPIO_INTERRUPT_PRO_MAP:  u5, 
                    
                    /// [5:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60010078));
                
                /// register description
                pub const GPIO_INTERRUPT_PRO_NMI_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:4] Need add description
                    GPIO_INTERRUPT_PRO_NMI_MAP:  u5, 
                    
                    /// [5:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6001007c));
                
                /// register description
                pub const PAU_INTR_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:4] Need add description
                    PAU_INTR_MAP:  u5, 
                    
                    /// [5:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60010080));
                
                /// register description
                pub const HP_PERI_TIMEOUT_INTR_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:4] Need add description
                    HP_PERI_TIMEOUT_INTR_MAP:  u5, 
                    
                    /// [5:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60010084));
                
                /// register description
                pub const MODEM_PERI_TIMEOUT_INTR_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:4] Need add description
                    MODEM_PERI_TIMEOUT_INTR_MAP:  u5, 
                    
                    /// [5:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60010088));
                
                /// register description
                pub const HP_APM_M0_INTR_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:4] Need add description
                    HP_APM_M0_INTR_MAP:  u5, 
                    
                    /// [5:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6001008c));
                
                /// register description
                pub const HP_APM_M1_INTR_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:4] Need add description
                    HP_APM_M1_INTR_MAP:  u5, 
                    
                    /// [5:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60010090));
                
                /// register description
                pub const HP_APM_M2_INTR_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:4] Need add description
                    HP_APM_M2_INTR_MAP:  u5, 
                    
                    /// [5:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60010094));
                
                /// register description
                pub const HP_APM_M3_INTR_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:4] Need add description
                    HP_APM_M3_INTR_MAP:  u5, 
                    
                    /// [5:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60010098));
                
                /// register description
                pub const LP_APM0_INTR_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:4] Need add description
                    LP_APM0_INTR_MAP:  u5, 
                    
                    /// [5:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6001009c));
                
                /// register description
                pub const MSPI_INTR_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:4] Need add description
                    MSPI_INTR_MAP:  u5, 
                    
                    /// [5:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600100a0));
                
                /// register description
                pub const I2S1_INTR_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:4] Need add description
                    I2S1_INTR_MAP:  u5, 
                    
                    /// [5:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600100a4));
                
                /// register description
                pub const UHCI0_INTR_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:4] Need add description
                    UHCI0_INTR_MAP:  u5, 
                    
                    /// [5:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600100a8));
                
                /// register description
                pub const UART0_INTR_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:4] Need add description
                    UART0_INTR_MAP:  u5, 
                    
                    /// [5:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600100ac));
                
                /// register description
                pub const UART1_INTR_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:4] Need add description
                    UART1_INTR_MAP:  u5, 
                    
                    /// [5:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600100b0));
                
                /// register description
                pub const LEDC_INTR_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:4] Need add description
                    LEDC_INTR_MAP:  u5, 
                    
                    /// [5:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600100b4));
                
                /// register description
                pub const CAN0_INTR_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:4] Need add description
                    CAN0_INTR_MAP:  u5, 
                    
                    /// [5:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600100b8));
                
                /// register description
                pub const CAN1_INTR_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:4] Need add description
                    CAN1_INTR_MAP:  u5, 
                    
                    /// [5:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600100bc));
                
                /// register description
                pub const USB_INTR_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:4] Need add description
                    USB_INTR_MAP:  u5, 
                    
                    /// [5:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600100c0));
                
                /// register description
                pub const RMT_INTR_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:4] Need add description
                    RMT_INTR_MAP:  u5, 
                    
                    /// [5:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600100c4));
                
                /// register description
                pub const I2C_EXT0_INTR_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:4] Need add description
                    I2C_EXT0_INTR_MAP:  u5, 
                    
                    /// [5:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600100c8));
                
                /// register description
                pub const TG0_T0_INTR_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:4] Need add description
                    TG0_T0_INTR_MAP:  u5, 
                    
                    /// [5:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600100cc));
                
                /// register description
                pub const TG0_T1_INTR_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:4] Need add description
                    TG0_T1_INTR_MAP:  u5, 
                    
                    /// [5:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600100d0));
                
                /// register description
                pub const TG0_WDT_INTR_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:4] Need add description
                    TG0_WDT_INTR_MAP:  u5, 
                    
                    /// [5:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600100d4));
                
                /// register description
                pub const TG1_T0_INTR_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:4] Need add description
                    TG1_T0_INTR_MAP:  u5, 
                    
                    /// [5:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600100d8));
                
                /// register description
                pub const TG1_T1_INTR_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:4] Need add description
                    TG1_T1_INTR_MAP:  u5, 
                    
                    /// [5:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600100dc));
                
                /// register description
                pub const TG1_WDT_INTR_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:4] Need add description
                    TG1_WDT_INTR_MAP:  u5, 
                    
                    /// [5:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600100e0));
                
                /// register description
                pub const SYSTIMER_TARGET0_INTR_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:4] Need add description
                    SYSTIMER_TARGET0_INTR_MAP:  u5, 
                    
                    /// [5:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600100e4));
                
                /// register description
                pub const SYSTIMER_TARGET1_INTR_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:4] Need add description
                    SYSTIMER_TARGET1_INTR_MAP:  u5, 
                    
                    /// [5:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600100e8));
                
                /// register description
                pub const SYSTIMER_TARGET2_INTR_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:4] Need add description
                    SYSTIMER_TARGET2_INTR_MAP:  u5, 
                    
                    /// [5:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600100ec));
                
                /// register description
                pub const APB_ADC_INTR_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:4] Need add description
                    APB_ADC_INTR_MAP:  u5, 
                    
                    /// [5:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600100f0));
                
                /// register description
                pub const PWM_INTR_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:4] Need add description
                    PWM_INTR_MAP:  u5, 
                    
                    /// [5:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600100f4));
                
                /// register description
                pub const PCNT_INTR_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:4] Need add description
                    PCNT_INTR_MAP:  u5, 
                    
                    /// [5:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600100f8));
                
                /// register description
                pub const PARL_IO_INTR_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:4] Need add description
                    PARL_IO_INTR_MAP:  u5, 
                    
                    /// [5:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600100fc));
                
                /// register description
                pub const SLC0_INTR_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:4] Need add description
                    SLC0_INTR_MAP:  u5, 
                    
                    /// [5:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60010100));
                
                /// register description
                pub const SLC1_INTR_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:4] Need add description
                    SLC1_INTR_MAP:  u5, 
                    
                    /// [5:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60010104));
                
                /// register description
                pub const DMA_IN_CH0_INTR_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:4] Need add description
                    DMA_IN_CH0_INTR_MAP:  u5, 
                    
                    /// [5:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60010108));
                
                /// register description
                pub const DMA_IN_CH1_INTR_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:4] Need add description
                    DMA_IN_CH1_INTR_MAP:  u5, 
                    
                    /// [5:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6001010c));
                
                /// register description
                pub const DMA_IN_CH2_INTR_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:4] Need add description
                    DMA_IN_CH2_INTR_MAP:  u5, 
                    
                    /// [5:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60010110));
                
                /// register description
                pub const DMA_OUT_CH0_INTR_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:4] Need add description
                    DMA_OUT_CH0_INTR_MAP:  u5, 
                    
                    /// [5:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60010114));
                
                /// register description
                pub const DMA_OUT_CH1_INTR_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:4] Need add description
                    DMA_OUT_CH1_INTR_MAP:  u5, 
                    
                    /// [5:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60010118));
                
                /// register description
                pub const DMA_OUT_CH2_INTR_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:4] Need add description
                    DMA_OUT_CH2_INTR_MAP:  u5, 
                    
                    /// [5:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6001011c));
                
                /// register description
                pub const GPSPI2_INTR_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:4] Need add description
                    GPSPI2_INTR_MAP:  u5, 
                    
                    /// [5:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60010120));
                
                /// register description
                pub const AES_INTR_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:4] Need add description
                    AES_INTR_MAP:  u5, 
                    
                    /// [5:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60010124));
                
                /// register description
                pub const SHA_INTR_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:4] Need add description
                    SHA_INTR_MAP:  u5, 
                    
                    /// [5:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60010128));
                
                /// register description
                pub const RSA_INTR_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:4] Need add description
                    RSA_INTR_MAP:  u5, 
                    
                    /// [5:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6001012c));
                
                /// register description
                pub const ECC_INTR_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:4] Need add description
                    ECC_INTR_MAP:  u5, 
                    
                    /// [5:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60010130));
                
                /// register description
                pub const INTR_STATUS_REG_0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Need add description
                    INTR_STATUS_0:  u32, 
                    
                }), @ptrFromInt(0x60010134));
                
                /// register description
                pub const INTR_STATUS_REG_1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Need add description
                    INTR_STATUS_1:  u32, 
                    
                }), @ptrFromInt(0x60010138));
                
                /// register description
                pub const INT_STATUS_REG_2 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Need add description
                    INT_STATUS_2:  u32, 
                    
                }), @ptrFromInt(0x6001013c));
                
                /// register description
                pub const CLOCK_GATE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Need add description
                    REG_CLK_EN:  u1, 
                    
                    /// [1:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60010140));
                
                /// register description
                pub const INTERRUPT_REG_DATE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:27] Need add description
                    INTERRUPT_REG_DATE:  u28, 
                    
                    /// [28:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600107fc));
                
            };
            
            /// INTPRI Peripheral
            pub const INTPRI = struct {
                
                /// register description
                pub const CPU_INT_ENABLE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Need add description
                    CPU_INT_ENABLE:  u32, 
                    
                }), @ptrFromInt(0x600c5000));
                
                /// register description
                pub const CPU_INT_TYPE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Need add description
                    CPU_INT_TYPE:  u32, 
                    
                }), @ptrFromInt(0x600c5004));
                
                /// register description
                pub const CPU_INT_EIP_STATUS = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Need add description
                    CPU_INT_EIP_STATUS:  u32, 
                    
                }), @ptrFromInt(0x600c5008));
                
                /// register description
                pub const CPU_INT_PRI_0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:3] Need add description
                    CPU_PRI_0_MAP:  u4, 
                    
                    /// [4:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600c500c));
                
                /// register description
                pub const CPU_INT_PRI_1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:3] Need add description
                    CPU_PRI_1_MAP:  u4, 
                    
                    /// [4:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600c5010));
                
                /// register description
                pub const CPU_INT_PRI_2 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:3] Need add description
                    CPU_PRI_2_MAP:  u4, 
                    
                    /// [4:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600c5014));
                
                /// register description
                pub const CPU_INT_PRI_3 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:3] Need add description
                    CPU_PRI_3_MAP:  u4, 
                    
                    /// [4:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600c5018));
                
                /// register description
                pub const CPU_INT_PRI_4 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:3] Need add description
                    CPU_PRI_4_MAP:  u4, 
                    
                    /// [4:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600c501c));
                
                /// register description
                pub const CPU_INT_PRI_5 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:3] Need add description
                    CPU_PRI_5_MAP:  u4, 
                    
                    /// [4:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600c5020));
                
                /// register description
                pub const CPU_INT_PRI_6 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:3] Need add description
                    CPU_PRI_6_MAP:  u4, 
                    
                    /// [4:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600c5024));
                
                /// register description
                pub const CPU_INT_PRI_7 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:3] Need add description
                    CPU_PRI_7_MAP:  u4, 
                    
                    /// [4:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600c5028));
                
                /// register description
                pub const CPU_INT_PRI_8 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:3] Need add description
                    CPU_PRI_8_MAP:  u4, 
                    
                    /// [4:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600c502c));
                
                /// register description
                pub const CPU_INT_PRI_9 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:3] Need add description
                    CPU_PRI_9_MAP:  u4, 
                    
                    /// [4:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600c5030));
                
                /// register description
                pub const CPU_INT_PRI_10 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:3] Need add description
                    CPU_PRI_10_MAP:  u4, 
                    
                    /// [4:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600c5034));
                
                /// register description
                pub const CPU_INT_PRI_11 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:3] Need add description
                    CPU_PRI_11_MAP:  u4, 
                    
                    /// [4:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600c5038));
                
                /// register description
                pub const CPU_INT_PRI_12 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:3] Need add description
                    CPU_PRI_12_MAP:  u4, 
                    
                    /// [4:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600c503c));
                
                /// register description
                pub const CPU_INT_PRI_13 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:3] Need add description
                    CPU_PRI_13_MAP:  u4, 
                    
                    /// [4:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600c5040));
                
                /// register description
                pub const CPU_INT_PRI_14 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:3] Need add description
                    CPU_PRI_14_MAP:  u4, 
                    
                    /// [4:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600c5044));
                
                /// register description
                pub const CPU_INT_PRI_15 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:3] Need add description
                    CPU_PRI_15_MAP:  u4, 
                    
                    /// [4:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600c5048));
                
                /// register description
                pub const CPU_INT_PRI_16 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:3] Need add description
                    CPU_PRI_16_MAP:  u4, 
                    
                    /// [4:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600c504c));
                
                /// register description
                pub const CPU_INT_PRI_17 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:3] Need add description
                    CPU_PRI_17_MAP:  u4, 
                    
                    /// [4:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600c5050));
                
                /// register description
                pub const CPU_INT_PRI_18 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:3] Need add description
                    CPU_PRI_18_MAP:  u4, 
                    
                    /// [4:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600c5054));
                
                /// register description
                pub const CPU_INT_PRI_19 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:3] Need add description
                    CPU_PRI_19_MAP:  u4, 
                    
                    /// [4:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600c5058));
                
                /// register description
                pub const CPU_INT_PRI_20 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:3] Need add description
                    CPU_PRI_20_MAP:  u4, 
                    
                    /// [4:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600c505c));
                
                /// register description
                pub const CPU_INT_PRI_21 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:3] Need add description
                    CPU_PRI_21_MAP:  u4, 
                    
                    /// [4:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600c5060));
                
                /// register description
                pub const CPU_INT_PRI_22 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:3] Need add description
                    CPU_PRI_22_MAP:  u4, 
                    
                    /// [4:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600c5064));
                
                /// register description
                pub const CPU_INT_PRI_23 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:3] Need add description
                    CPU_PRI_23_MAP:  u4, 
                    
                    /// [4:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600c5068));
                
                /// register description
                pub const CPU_INT_PRI_24 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:3] Need add description
                    CPU_PRI_24_MAP:  u4, 
                    
                    /// [4:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600c506c));
                
                /// register description
                pub const CPU_INT_PRI_25 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:3] Need add description
                    CPU_PRI_25_MAP:  u4, 
                    
                    /// [4:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600c5070));
                
                /// register description
                pub const CPU_INT_PRI_26 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:3] Need add description
                    CPU_PRI_26_MAP:  u4, 
                    
                    /// [4:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600c5074));
                
                /// register description
                pub const CPU_INT_PRI_27 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:3] Need add description
                    CPU_PRI_27_MAP:  u4, 
                    
                    /// [4:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600c5078));
                
                /// register description
                pub const CPU_INT_PRI_28 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:3] Need add description
                    CPU_PRI_28_MAP:  u4, 
                    
                    /// [4:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600c507c));
                
                /// register description
                pub const CPU_INT_PRI_29 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:3] Need add description
                    CPU_PRI_29_MAP:  u4, 
                    
                    /// [4:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600c5080));
                
                /// register description
                pub const CPU_INT_PRI_30 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:3] Need add description
                    CPU_PRI_30_MAP:  u4, 
                    
                    /// [4:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600c5084));
                
                /// register description
                pub const CPU_INT_PRI_31 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:3] Need add description
                    CPU_PRI_31_MAP:  u4, 
                    
                    /// [4:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600c5088));
                
                /// register description
                pub const CPU_INT_THRESH = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] Need add description
                    CPU_INT_THRESH:  u8, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600c508c));
                
                /// register description
                pub const CPU_INTR_FROM_CPU_0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Need add description
                    CPU_INTR_FROM_CPU_0:  u1, 
                    
                    /// [1:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600c5090));
                
                /// register description
                pub const CPU_INTR_FROM_CPU_1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Need add description
                    CPU_INTR_FROM_CPU_1:  u1, 
                    
                    /// [1:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600c5094));
                
                /// register description
                pub const CPU_INTR_FROM_CPU_2 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Need add description
                    CPU_INTR_FROM_CPU_2:  u1, 
                    
                    /// [1:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600c5098));
                
                /// register description
                pub const CPU_INTR_FROM_CPU_3 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Need add description
                    CPU_INTR_FROM_CPU_3:  u1, 
                    
                    /// [1:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600c509c));
                
                /// register description
                pub const DATE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:27] Need add description
                    DATE:  u28, 
                    
                    /// [28:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600c50a0));
                
                /// register description
                pub const CLOCK_GATE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Need add description
                    CLK_EN:  u1, 
                    
                    /// [1:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600c50a4));
                
                /// register description
                pub const CPU_INT_CLEAR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Need add description
                    CPU_INT_CLEAR:  u32, 
                    
                }), @ptrFromInt(0x600c50a8));
                
                /// redcy eco register.
                pub const RND_ECO = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Only reserved for ECO.
                    REDCY_ENA:  u1, 
                    
                    /// [1:1] Only reserved for ECO.
                    REDCY_RESULT:  u1, 
                    
                    /// [2:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600c50ac));
                
                /// redcy eco low register.
                pub const RND_ECO_LOW = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Only reserved for ECO.
                    REDCY_LOW:  u32, 
                    
                }), @ptrFromInt(0x600c50b0));
                
                /// redcy eco high register.
                pub const RND_ECO_HIGH = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Only reserved for ECO.
                    REDCY_HIGH:  u32, 
                    
                }), @ptrFromInt(0x600c53fc));
                
            };
            
            /// Input/Output Multiplexer
            pub const IO_MUX = struct {
                
                /// Clock Output Configuration Register
                pub const PIN_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:4] If you want to output clock for I2S to CLK_OUT_out1, set this register to 0x0. CLK_OUT_out1 can be found in peripheral output signals.
                    CLK_OUT1:  u5, 
                    
                    /// [5:9] If you want to output clock for I2S to CLK_OUT_out2, set this register to 0x0. CLK_OUT_out2 can be found in peripheral output signals.
                    CLK_OUT2:  u5, 
                    
                    /// [10:14] If you want to output clock for I2S to CLK_OUT_out3, set this register to 0x0. CLK_OUT_out3 can be found in peripheral output signals.
                    CLK_OUT3:  u5, 
                    
                    /// [15:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60090000));
                
                /// IO MUX Configure Register for pad XTAL_32K_P
                pub const GPIO0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Output enable of the pad in sleep mode. 1: output enabled. 0: output disabled.
                    MCU_OE:  u1, 
                    
                    /// [1:1] Sleep mode selection of this pad. Set to 1 to put the pad in pad mode.
                    SLP_SEL:  u1, 
                    
                    /// [2:2] Pull-down enable of the pad in sleep mode. 1: internal pull-down enabled. 0: internal pull-down disabled.
                    MCU_WPD:  u1, 
                    
                    /// [3:3] Pull-up enable of the pad during sleep mode. 1: internal pull-up enabled. 0: internal pull-up disabled.
                    MCU_WPU:  u1, 
                    
                    /// [4:4] Input enable of the pad during sleep mode. 1: input enabled. 0: input disabled.
                    MCU_IE:  u1, 
                    
                    /// [5:6] Select the drive strength of the pad during sleep mode. 0: ~5 mA. 1: ~10mA. 2: ~20mA. 3: ~40mA.
                    MCU_DRV:  u2, 
                    
                    /// [7:7] Pull-down enable of the pad. 1: internal pull-down enabled. 0: internal pull-down disabled.
                    FUN_WPD:  u1, 
                    
                    /// [8:8] Pull-up enable of the pad. 1: internal pull-up enabled. 0: internal pull-up disabled.
                    FUN_WPU:  u1, 
                    
                    /// [9:9] Input enable of the pad. 1: input enabled. 0: input disabled.
                    FUN_IE:  u1, 
                    
                    /// [10:11] Select the drive strength of the pad. 0: ~5 mA. 1: ~10mA. 2: ~20mA. 3: ~40mA.
                    FUN_DRV:  u2, 
                    
                    /// [12:14] Select IO MUX function for this signal. 0: Select Function 1. 1: Select Function 2. etc.
                    MCU_SEL:  u3, 
                    
                    /// [15:15] Enable filter for pin input signals. 1: Filter enabled. 0: Filter disabled.
                    FILTER_EN:  u1, 
                    
                    /// [16:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60090004));
                
                /// IO MUX Configure Register for pad XTAL_32K_P
                pub const GPIO0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Output enable of the pad in sleep mode. 1: output enabled. 0: output disabled.
                    MCU_OE:  u1, 
                    
                    /// [1:1] Sleep mode selection of this pad. Set to 1 to put the pad in pad mode.
                    SLP_SEL:  u1, 
                    
                    /// [2:2] Pull-down enable of the pad in sleep mode. 1: internal pull-down enabled. 0: internal pull-down disabled.
                    MCU_WPD:  u1, 
                    
                    /// [3:3] Pull-up enable of the pad during sleep mode. 1: internal pull-up enabled. 0: internal pull-up disabled.
                    MCU_WPU:  u1, 
                    
                    /// [4:4] Input enable of the pad during sleep mode. 1: input enabled. 0: input disabled.
                    MCU_IE:  u1, 
                    
                    /// [5:6] Select the drive strength of the pad during sleep mode. 0: ~5 mA. 1: ~10mA. 2: ~20mA. 3: ~40mA.
                    MCU_DRV:  u2, 
                    
                    /// [7:7] Pull-down enable of the pad. 1: internal pull-down enabled. 0: internal pull-down disabled.
                    FUN_WPD:  u1, 
                    
                    /// [8:8] Pull-up enable of the pad. 1: internal pull-up enabled. 0: internal pull-up disabled.
                    FUN_WPU:  u1, 
                    
                    /// [9:9] Input enable of the pad. 1: input enabled. 0: input disabled.
                    FUN_IE:  u1, 
                    
                    /// [10:11] Select the drive strength of the pad. 0: ~5 mA. 1: ~10mA. 2: ~20mA. 3: ~40mA.
                    FUN_DRV:  u2, 
                    
                    /// [12:14] Select IO MUX function for this signal. 0: Select Function 1. 1: Select Function 2. etc.
                    MCU_SEL:  u3, 
                    
                    /// [15:15] Enable filter for pin input signals. 1: Filter enabled. 0: Filter disabled.
                    FILTER_EN:  u1, 
                    
                    /// [16:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60090008));
                
                /// IO MUX Configure Register for pad XTAL_32K_P
                pub const GPIO0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Output enable of the pad in sleep mode. 1: output enabled. 0: output disabled.
                    MCU_OE:  u1, 
                    
                    /// [1:1] Sleep mode selection of this pad. Set to 1 to put the pad in pad mode.
                    SLP_SEL:  u1, 
                    
                    /// [2:2] Pull-down enable of the pad in sleep mode. 1: internal pull-down enabled. 0: internal pull-down disabled.
                    MCU_WPD:  u1, 
                    
                    /// [3:3] Pull-up enable of the pad during sleep mode. 1: internal pull-up enabled. 0: internal pull-up disabled.
                    MCU_WPU:  u1, 
                    
                    /// [4:4] Input enable of the pad during sleep mode. 1: input enabled. 0: input disabled.
                    MCU_IE:  u1, 
                    
                    /// [5:6] Select the drive strength of the pad during sleep mode. 0: ~5 mA. 1: ~10mA. 2: ~20mA. 3: ~40mA.
                    MCU_DRV:  u2, 
                    
                    /// [7:7] Pull-down enable of the pad. 1: internal pull-down enabled. 0: internal pull-down disabled.
                    FUN_WPD:  u1, 
                    
                    /// [8:8] Pull-up enable of the pad. 1: internal pull-up enabled. 0: internal pull-up disabled.
                    FUN_WPU:  u1, 
                    
                    /// [9:9] Input enable of the pad. 1: input enabled. 0: input disabled.
                    FUN_IE:  u1, 
                    
                    /// [10:11] Select the drive strength of the pad. 0: ~5 mA. 1: ~10mA. 2: ~20mA. 3: ~40mA.
                    FUN_DRV:  u2, 
                    
                    /// [12:14] Select IO MUX function for this signal. 0: Select Function 1. 1: Select Function 2. etc.
                    MCU_SEL:  u3, 
                    
                    /// [15:15] Enable filter for pin input signals. 1: Filter enabled. 0: Filter disabled.
                    FILTER_EN:  u1, 
                    
                    /// [16:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6009000c));
                
                /// IO MUX Configure Register for pad XTAL_32K_P
                pub const GPIO0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Output enable of the pad in sleep mode. 1: output enabled. 0: output disabled.
                    MCU_OE:  u1, 
                    
                    /// [1:1] Sleep mode selection of this pad. Set to 1 to put the pad in pad mode.
                    SLP_SEL:  u1, 
                    
                    /// [2:2] Pull-down enable of the pad in sleep mode. 1: internal pull-down enabled. 0: internal pull-down disabled.
                    MCU_WPD:  u1, 
                    
                    /// [3:3] Pull-up enable of the pad during sleep mode. 1: internal pull-up enabled. 0: internal pull-up disabled.
                    MCU_WPU:  u1, 
                    
                    /// [4:4] Input enable of the pad during sleep mode. 1: input enabled. 0: input disabled.
                    MCU_IE:  u1, 
                    
                    /// [5:6] Select the drive strength of the pad during sleep mode. 0: ~5 mA. 1: ~10mA. 2: ~20mA. 3: ~40mA.
                    MCU_DRV:  u2, 
                    
                    /// [7:7] Pull-down enable of the pad. 1: internal pull-down enabled. 0: internal pull-down disabled.
                    FUN_WPD:  u1, 
                    
                    /// [8:8] Pull-up enable of the pad. 1: internal pull-up enabled. 0: internal pull-up disabled.
                    FUN_WPU:  u1, 
                    
                    /// [9:9] Input enable of the pad. 1: input enabled. 0: input disabled.
                    FUN_IE:  u1, 
                    
                    /// [10:11] Select the drive strength of the pad. 0: ~5 mA. 1: ~10mA. 2: ~20mA. 3: ~40mA.
                    FUN_DRV:  u2, 
                    
                    /// [12:14] Select IO MUX function for this signal. 0: Select Function 1. 1: Select Function 2. etc.
                    MCU_SEL:  u3, 
                    
                    /// [15:15] Enable filter for pin input signals. 1: Filter enabled. 0: Filter disabled.
                    FILTER_EN:  u1, 
                    
                    /// [16:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60090010));
                
                /// IO MUX Configure Register for pad XTAL_32K_P
                pub const GPIO0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Output enable of the pad in sleep mode. 1: output enabled. 0: output disabled.
                    MCU_OE:  u1, 
                    
                    /// [1:1] Sleep mode selection of this pad. Set to 1 to put the pad in pad mode.
                    SLP_SEL:  u1, 
                    
                    /// [2:2] Pull-down enable of the pad in sleep mode. 1: internal pull-down enabled. 0: internal pull-down disabled.
                    MCU_WPD:  u1, 
                    
                    /// [3:3] Pull-up enable of the pad during sleep mode. 1: internal pull-up enabled. 0: internal pull-up disabled.
                    MCU_WPU:  u1, 
                    
                    /// [4:4] Input enable of the pad during sleep mode. 1: input enabled. 0: input disabled.
                    MCU_IE:  u1, 
                    
                    /// [5:6] Select the drive strength of the pad during sleep mode. 0: ~5 mA. 1: ~10mA. 2: ~20mA. 3: ~40mA.
                    MCU_DRV:  u2, 
                    
                    /// [7:7] Pull-down enable of the pad. 1: internal pull-down enabled. 0: internal pull-down disabled.
                    FUN_WPD:  u1, 
                    
                    /// [8:8] Pull-up enable of the pad. 1: internal pull-up enabled. 0: internal pull-up disabled.
                    FUN_WPU:  u1, 
                    
                    /// [9:9] Input enable of the pad. 1: input enabled. 0: input disabled.
                    FUN_IE:  u1, 
                    
                    /// [10:11] Select the drive strength of the pad. 0: ~5 mA. 1: ~10mA. 2: ~20mA. 3: ~40mA.
                    FUN_DRV:  u2, 
                    
                    /// [12:14] Select IO MUX function for this signal. 0: Select Function 1. 1: Select Function 2. etc.
                    MCU_SEL:  u3, 
                    
                    /// [15:15] Enable filter for pin input signals. 1: Filter enabled. 0: Filter disabled.
                    FILTER_EN:  u1, 
                    
                    /// [16:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60090014));
                
                /// IO MUX Configure Register for pad XTAL_32K_P
                pub const GPIO0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Output enable of the pad in sleep mode. 1: output enabled. 0: output disabled.
                    MCU_OE:  u1, 
                    
                    /// [1:1] Sleep mode selection of this pad. Set to 1 to put the pad in pad mode.
                    SLP_SEL:  u1, 
                    
                    /// [2:2] Pull-down enable of the pad in sleep mode. 1: internal pull-down enabled. 0: internal pull-down disabled.
                    MCU_WPD:  u1, 
                    
                    /// [3:3] Pull-up enable of the pad during sleep mode. 1: internal pull-up enabled. 0: internal pull-up disabled.
                    MCU_WPU:  u1, 
                    
                    /// [4:4] Input enable of the pad during sleep mode. 1: input enabled. 0: input disabled.
                    MCU_IE:  u1, 
                    
                    /// [5:6] Select the drive strength of the pad during sleep mode. 0: ~5 mA. 1: ~10mA. 2: ~20mA. 3: ~40mA.
                    MCU_DRV:  u2, 
                    
                    /// [7:7] Pull-down enable of the pad. 1: internal pull-down enabled. 0: internal pull-down disabled.
                    FUN_WPD:  u1, 
                    
                    /// [8:8] Pull-up enable of the pad. 1: internal pull-up enabled. 0: internal pull-up disabled.
                    FUN_WPU:  u1, 
                    
                    /// [9:9] Input enable of the pad. 1: input enabled. 0: input disabled.
                    FUN_IE:  u1, 
                    
                    /// [10:11] Select the drive strength of the pad. 0: ~5 mA. 1: ~10mA. 2: ~20mA. 3: ~40mA.
                    FUN_DRV:  u2, 
                    
                    /// [12:14] Select IO MUX function for this signal. 0: Select Function 1. 1: Select Function 2. etc.
                    MCU_SEL:  u3, 
                    
                    /// [15:15] Enable filter for pin input signals. 1: Filter enabled. 0: Filter disabled.
                    FILTER_EN:  u1, 
                    
                    /// [16:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60090018));
                
                /// IO MUX Configure Register for pad XTAL_32K_P
                pub const GPIO0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Output enable of the pad in sleep mode. 1: output enabled. 0: output disabled.
                    MCU_OE:  u1, 
                    
                    /// [1:1] Sleep mode selection of this pad. Set to 1 to put the pad in pad mode.
                    SLP_SEL:  u1, 
                    
                    /// [2:2] Pull-down enable of the pad in sleep mode. 1: internal pull-down enabled. 0: internal pull-down disabled.
                    MCU_WPD:  u1, 
                    
                    /// [3:3] Pull-up enable of the pad during sleep mode. 1: internal pull-up enabled. 0: internal pull-up disabled.
                    MCU_WPU:  u1, 
                    
                    /// [4:4] Input enable of the pad during sleep mode. 1: input enabled. 0: input disabled.
                    MCU_IE:  u1, 
                    
                    /// [5:6] Select the drive strength of the pad during sleep mode. 0: ~5 mA. 1: ~10mA. 2: ~20mA. 3: ~40mA.
                    MCU_DRV:  u2, 
                    
                    /// [7:7] Pull-down enable of the pad. 1: internal pull-down enabled. 0: internal pull-down disabled.
                    FUN_WPD:  u1, 
                    
                    /// [8:8] Pull-up enable of the pad. 1: internal pull-up enabled. 0: internal pull-up disabled.
                    FUN_WPU:  u1, 
                    
                    /// [9:9] Input enable of the pad. 1: input enabled. 0: input disabled.
                    FUN_IE:  u1, 
                    
                    /// [10:11] Select the drive strength of the pad. 0: ~5 mA. 1: ~10mA. 2: ~20mA. 3: ~40mA.
                    FUN_DRV:  u2, 
                    
                    /// [12:14] Select IO MUX function for this signal. 0: Select Function 1. 1: Select Function 2. etc.
                    MCU_SEL:  u3, 
                    
                    /// [15:15] Enable filter for pin input signals. 1: Filter enabled. 0: Filter disabled.
                    FILTER_EN:  u1, 
                    
                    /// [16:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6009001c));
                
                /// IO MUX Configure Register for pad XTAL_32K_P
                pub const GPIO0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Output enable of the pad in sleep mode. 1: output enabled. 0: output disabled.
                    MCU_OE:  u1, 
                    
                    /// [1:1] Sleep mode selection of this pad. Set to 1 to put the pad in pad mode.
                    SLP_SEL:  u1, 
                    
                    /// [2:2] Pull-down enable of the pad in sleep mode. 1: internal pull-down enabled. 0: internal pull-down disabled.
                    MCU_WPD:  u1, 
                    
                    /// [3:3] Pull-up enable of the pad during sleep mode. 1: internal pull-up enabled. 0: internal pull-up disabled.
                    MCU_WPU:  u1, 
                    
                    /// [4:4] Input enable of the pad during sleep mode. 1: input enabled. 0: input disabled.
                    MCU_IE:  u1, 
                    
                    /// [5:6] Select the drive strength of the pad during sleep mode. 0: ~5 mA. 1: ~10mA. 2: ~20mA. 3: ~40mA.
                    MCU_DRV:  u2, 
                    
                    /// [7:7] Pull-down enable of the pad. 1: internal pull-down enabled. 0: internal pull-down disabled.
                    FUN_WPD:  u1, 
                    
                    /// [8:8] Pull-up enable of the pad. 1: internal pull-up enabled. 0: internal pull-up disabled.
                    FUN_WPU:  u1, 
                    
                    /// [9:9] Input enable of the pad. 1: input enabled. 0: input disabled.
                    FUN_IE:  u1, 
                    
                    /// [10:11] Select the drive strength of the pad. 0: ~5 mA. 1: ~10mA. 2: ~20mA. 3: ~40mA.
                    FUN_DRV:  u2, 
                    
                    /// [12:14] Select IO MUX function for this signal. 0: Select Function 1. 1: Select Function 2. etc.
                    MCU_SEL:  u3, 
                    
                    /// [15:15] Enable filter for pin input signals. 1: Filter enabled. 0: Filter disabled.
                    FILTER_EN:  u1, 
                    
                    /// [16:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60090020));
                
                /// IO MUX Configure Register for pad XTAL_32K_P
                pub const GPIO0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Output enable of the pad in sleep mode. 1: output enabled. 0: output disabled.
                    MCU_OE:  u1, 
                    
                    /// [1:1] Sleep mode selection of this pad. Set to 1 to put the pad in pad mode.
                    SLP_SEL:  u1, 
                    
                    /// [2:2] Pull-down enable of the pad in sleep mode. 1: internal pull-down enabled. 0: internal pull-down disabled.
                    MCU_WPD:  u1, 
                    
                    /// [3:3] Pull-up enable of the pad during sleep mode. 1: internal pull-up enabled. 0: internal pull-up disabled.
                    MCU_WPU:  u1, 
                    
                    /// [4:4] Input enable of the pad during sleep mode. 1: input enabled. 0: input disabled.
                    MCU_IE:  u1, 
                    
                    /// [5:6] Select the drive strength of the pad during sleep mode. 0: ~5 mA. 1: ~10mA. 2: ~20mA. 3: ~40mA.
                    MCU_DRV:  u2, 
                    
                    /// [7:7] Pull-down enable of the pad. 1: internal pull-down enabled. 0: internal pull-down disabled.
                    FUN_WPD:  u1, 
                    
                    /// [8:8] Pull-up enable of the pad. 1: internal pull-up enabled. 0: internal pull-up disabled.
                    FUN_WPU:  u1, 
                    
                    /// [9:9] Input enable of the pad. 1: input enabled. 0: input disabled.
                    FUN_IE:  u1, 
                    
                    /// [10:11] Select the drive strength of the pad. 0: ~5 mA. 1: ~10mA. 2: ~20mA. 3: ~40mA.
                    FUN_DRV:  u2, 
                    
                    /// [12:14] Select IO MUX function for this signal. 0: Select Function 1. 1: Select Function 2. etc.
                    MCU_SEL:  u3, 
                    
                    /// [15:15] Enable filter for pin input signals. 1: Filter enabled. 0: Filter disabled.
                    FILTER_EN:  u1, 
                    
                    /// [16:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60090024));
                
                /// IO MUX Configure Register for pad XTAL_32K_P
                pub const GPIO0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Output enable of the pad in sleep mode. 1: output enabled. 0: output disabled.
                    MCU_OE:  u1, 
                    
                    /// [1:1] Sleep mode selection of this pad. Set to 1 to put the pad in pad mode.
                    SLP_SEL:  u1, 
                    
                    /// [2:2] Pull-down enable of the pad in sleep mode. 1: internal pull-down enabled. 0: internal pull-down disabled.
                    MCU_WPD:  u1, 
                    
                    /// [3:3] Pull-up enable of the pad during sleep mode. 1: internal pull-up enabled. 0: internal pull-up disabled.
                    MCU_WPU:  u1, 
                    
                    /// [4:4] Input enable of the pad during sleep mode. 1: input enabled. 0: input disabled.
                    MCU_IE:  u1, 
                    
                    /// [5:6] Select the drive strength of the pad during sleep mode. 0: ~5 mA. 1: ~10mA. 2: ~20mA. 3: ~40mA.
                    MCU_DRV:  u2, 
                    
                    /// [7:7] Pull-down enable of the pad. 1: internal pull-down enabled. 0: internal pull-down disabled.
                    FUN_WPD:  u1, 
                    
                    /// [8:8] Pull-up enable of the pad. 1: internal pull-up enabled. 0: internal pull-up disabled.
                    FUN_WPU:  u1, 
                    
                    /// [9:9] Input enable of the pad. 1: input enabled. 0: input disabled.
                    FUN_IE:  u1, 
                    
                    /// [10:11] Select the drive strength of the pad. 0: ~5 mA. 1: ~10mA. 2: ~20mA. 3: ~40mA.
                    FUN_DRV:  u2, 
                    
                    /// [12:14] Select IO MUX function for this signal. 0: Select Function 1. 1: Select Function 2. etc.
                    MCU_SEL:  u3, 
                    
                    /// [15:15] Enable filter for pin input signals. 1: Filter enabled. 0: Filter disabled.
                    FILTER_EN:  u1, 
                    
                    /// [16:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60090028));
                
                /// IO MUX Configure Register for pad XTAL_32K_P
                pub const GPIO0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Output enable of the pad in sleep mode. 1: output enabled. 0: output disabled.
                    MCU_OE:  u1, 
                    
                    /// [1:1] Sleep mode selection of this pad. Set to 1 to put the pad in pad mode.
                    SLP_SEL:  u1, 
                    
                    /// [2:2] Pull-down enable of the pad in sleep mode. 1: internal pull-down enabled. 0: internal pull-down disabled.
                    MCU_WPD:  u1, 
                    
                    /// [3:3] Pull-up enable of the pad during sleep mode. 1: internal pull-up enabled. 0: internal pull-up disabled.
                    MCU_WPU:  u1, 
                    
                    /// [4:4] Input enable of the pad during sleep mode. 1: input enabled. 0: input disabled.
                    MCU_IE:  u1, 
                    
                    /// [5:6] Select the drive strength of the pad during sleep mode. 0: ~5 mA. 1: ~10mA. 2: ~20mA. 3: ~40mA.
                    MCU_DRV:  u2, 
                    
                    /// [7:7] Pull-down enable of the pad. 1: internal pull-down enabled. 0: internal pull-down disabled.
                    FUN_WPD:  u1, 
                    
                    /// [8:8] Pull-up enable of the pad. 1: internal pull-up enabled. 0: internal pull-up disabled.
                    FUN_WPU:  u1, 
                    
                    /// [9:9] Input enable of the pad. 1: input enabled. 0: input disabled.
                    FUN_IE:  u1, 
                    
                    /// [10:11] Select the drive strength of the pad. 0: ~5 mA. 1: ~10mA. 2: ~20mA. 3: ~40mA.
                    FUN_DRV:  u2, 
                    
                    /// [12:14] Select IO MUX function for this signal. 0: Select Function 1. 1: Select Function 2. etc.
                    MCU_SEL:  u3, 
                    
                    /// [15:15] Enable filter for pin input signals. 1: Filter enabled. 0: Filter disabled.
                    FILTER_EN:  u1, 
                    
                    /// [16:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6009002c));
                
                /// IO MUX Configure Register for pad XTAL_32K_P
                pub const GPIO0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Output enable of the pad in sleep mode. 1: output enabled. 0: output disabled.
                    MCU_OE:  u1, 
                    
                    /// [1:1] Sleep mode selection of this pad. Set to 1 to put the pad in pad mode.
                    SLP_SEL:  u1, 
                    
                    /// [2:2] Pull-down enable of the pad in sleep mode. 1: internal pull-down enabled. 0: internal pull-down disabled.
                    MCU_WPD:  u1, 
                    
                    /// [3:3] Pull-up enable of the pad during sleep mode. 1: internal pull-up enabled. 0: internal pull-up disabled.
                    MCU_WPU:  u1, 
                    
                    /// [4:4] Input enable of the pad during sleep mode. 1: input enabled. 0: input disabled.
                    MCU_IE:  u1, 
                    
                    /// [5:6] Select the drive strength of the pad during sleep mode. 0: ~5 mA. 1: ~10mA. 2: ~20mA. 3: ~40mA.
                    MCU_DRV:  u2, 
                    
                    /// [7:7] Pull-down enable of the pad. 1: internal pull-down enabled. 0: internal pull-down disabled.
                    FUN_WPD:  u1, 
                    
                    /// [8:8] Pull-up enable of the pad. 1: internal pull-up enabled. 0: internal pull-up disabled.
                    FUN_WPU:  u1, 
                    
                    /// [9:9] Input enable of the pad. 1: input enabled. 0: input disabled.
                    FUN_IE:  u1, 
                    
                    /// [10:11] Select the drive strength of the pad. 0: ~5 mA. 1: ~10mA. 2: ~20mA. 3: ~40mA.
                    FUN_DRV:  u2, 
                    
                    /// [12:14] Select IO MUX function for this signal. 0: Select Function 1. 1: Select Function 2. etc.
                    MCU_SEL:  u3, 
                    
                    /// [15:15] Enable filter for pin input signals. 1: Filter enabled. 0: Filter disabled.
                    FILTER_EN:  u1, 
                    
                    /// [16:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60090030));
                
                /// IO MUX Configure Register for pad XTAL_32K_P
                pub const GPIO0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Output enable of the pad in sleep mode. 1: output enabled. 0: output disabled.
                    MCU_OE:  u1, 
                    
                    /// [1:1] Sleep mode selection of this pad. Set to 1 to put the pad in pad mode.
                    SLP_SEL:  u1, 
                    
                    /// [2:2] Pull-down enable of the pad in sleep mode. 1: internal pull-down enabled. 0: internal pull-down disabled.
                    MCU_WPD:  u1, 
                    
                    /// [3:3] Pull-up enable of the pad during sleep mode. 1: internal pull-up enabled. 0: internal pull-up disabled.
                    MCU_WPU:  u1, 
                    
                    /// [4:4] Input enable of the pad during sleep mode. 1: input enabled. 0: input disabled.
                    MCU_IE:  u1, 
                    
                    /// [5:6] Select the drive strength of the pad during sleep mode. 0: ~5 mA. 1: ~10mA. 2: ~20mA. 3: ~40mA.
                    MCU_DRV:  u2, 
                    
                    /// [7:7] Pull-down enable of the pad. 1: internal pull-down enabled. 0: internal pull-down disabled.
                    FUN_WPD:  u1, 
                    
                    /// [8:8] Pull-up enable of the pad. 1: internal pull-up enabled. 0: internal pull-up disabled.
                    FUN_WPU:  u1, 
                    
                    /// [9:9] Input enable of the pad. 1: input enabled. 0: input disabled.
                    FUN_IE:  u1, 
                    
                    /// [10:11] Select the drive strength of the pad. 0: ~5 mA. 1: ~10mA. 2: ~20mA. 3: ~40mA.
                    FUN_DRV:  u2, 
                    
                    /// [12:14] Select IO MUX function for this signal. 0: Select Function 1. 1: Select Function 2. etc.
                    MCU_SEL:  u3, 
                    
                    /// [15:15] Enable filter for pin input signals. 1: Filter enabled. 0: Filter disabled.
                    FILTER_EN:  u1, 
                    
                    /// [16:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60090034));
                
                /// IO MUX Configure Register for pad XTAL_32K_P
                pub const GPIO0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Output enable of the pad in sleep mode. 1: output enabled. 0: output disabled.
                    MCU_OE:  u1, 
                    
                    /// [1:1] Sleep mode selection of this pad. Set to 1 to put the pad in pad mode.
                    SLP_SEL:  u1, 
                    
                    /// [2:2] Pull-down enable of the pad in sleep mode. 1: internal pull-down enabled. 0: internal pull-down disabled.
                    MCU_WPD:  u1, 
                    
                    /// [3:3] Pull-up enable of the pad during sleep mode. 1: internal pull-up enabled. 0: internal pull-up disabled.
                    MCU_WPU:  u1, 
                    
                    /// [4:4] Input enable of the pad during sleep mode. 1: input enabled. 0: input disabled.
                    MCU_IE:  u1, 
                    
                    /// [5:6] Select the drive strength of the pad during sleep mode. 0: ~5 mA. 1: ~10mA. 2: ~20mA. 3: ~40mA.
                    MCU_DRV:  u2, 
                    
                    /// [7:7] Pull-down enable of the pad. 1: internal pull-down enabled. 0: internal pull-down disabled.
                    FUN_WPD:  u1, 
                    
                    /// [8:8] Pull-up enable of the pad. 1: internal pull-up enabled. 0: internal pull-up disabled.
                    FUN_WPU:  u1, 
                    
                    /// [9:9] Input enable of the pad. 1: input enabled. 0: input disabled.
                    FUN_IE:  u1, 
                    
                    /// [10:11] Select the drive strength of the pad. 0: ~5 mA. 1: ~10mA. 2: ~20mA. 3: ~40mA.
                    FUN_DRV:  u2, 
                    
                    /// [12:14] Select IO MUX function for this signal. 0: Select Function 1. 1: Select Function 2. etc.
                    MCU_SEL:  u3, 
                    
                    /// [15:15] Enable filter for pin input signals. 1: Filter enabled. 0: Filter disabled.
                    FILTER_EN:  u1, 
                    
                    /// [16:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60090038));
                
                /// IO MUX Configure Register for pad XTAL_32K_P
                pub const GPIO0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Output enable of the pad in sleep mode. 1: output enabled. 0: output disabled.
                    MCU_OE:  u1, 
                    
                    /// [1:1] Sleep mode selection of this pad. Set to 1 to put the pad in pad mode.
                    SLP_SEL:  u1, 
                    
                    /// [2:2] Pull-down enable of the pad in sleep mode. 1: internal pull-down enabled. 0: internal pull-down disabled.
                    MCU_WPD:  u1, 
                    
                    /// [3:3] Pull-up enable of the pad during sleep mode. 1: internal pull-up enabled. 0: internal pull-up disabled.
                    MCU_WPU:  u1, 
                    
                    /// [4:4] Input enable of the pad during sleep mode. 1: input enabled. 0: input disabled.
                    MCU_IE:  u1, 
                    
                    /// [5:6] Select the drive strength of the pad during sleep mode. 0: ~5 mA. 1: ~10mA. 2: ~20mA. 3: ~40mA.
                    MCU_DRV:  u2, 
                    
                    /// [7:7] Pull-down enable of the pad. 1: internal pull-down enabled. 0: internal pull-down disabled.
                    FUN_WPD:  u1, 
                    
                    /// [8:8] Pull-up enable of the pad. 1: internal pull-up enabled. 0: internal pull-up disabled.
                    FUN_WPU:  u1, 
                    
                    /// [9:9] Input enable of the pad. 1: input enabled. 0: input disabled.
                    FUN_IE:  u1, 
                    
                    /// [10:11] Select the drive strength of the pad. 0: ~5 mA. 1: ~10mA. 2: ~20mA. 3: ~40mA.
                    FUN_DRV:  u2, 
                    
                    /// [12:14] Select IO MUX function for this signal. 0: Select Function 1. 1: Select Function 2. etc.
                    MCU_SEL:  u3, 
                    
                    /// [15:15] Enable filter for pin input signals. 1: Filter enabled. 0: Filter disabled.
                    FILTER_EN:  u1, 
                    
                    /// [16:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6009003c));
                
                /// IO MUX Configure Register for pad XTAL_32K_P
                pub const GPIO0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Output enable of the pad in sleep mode. 1: output enabled. 0: output disabled.
                    MCU_OE:  u1, 
                    
                    /// [1:1] Sleep mode selection of this pad. Set to 1 to put the pad in pad mode.
                    SLP_SEL:  u1, 
                    
                    /// [2:2] Pull-down enable of the pad in sleep mode. 1: internal pull-down enabled. 0: internal pull-down disabled.
                    MCU_WPD:  u1, 
                    
                    /// [3:3] Pull-up enable of the pad during sleep mode. 1: internal pull-up enabled. 0: internal pull-up disabled.
                    MCU_WPU:  u1, 
                    
                    /// [4:4] Input enable of the pad during sleep mode. 1: input enabled. 0: input disabled.
                    MCU_IE:  u1, 
                    
                    /// [5:6] Select the drive strength of the pad during sleep mode. 0: ~5 mA. 1: ~10mA. 2: ~20mA. 3: ~40mA.
                    MCU_DRV:  u2, 
                    
                    /// [7:7] Pull-down enable of the pad. 1: internal pull-down enabled. 0: internal pull-down disabled.
                    FUN_WPD:  u1, 
                    
                    /// [8:8] Pull-up enable of the pad. 1: internal pull-up enabled. 0: internal pull-up disabled.
                    FUN_WPU:  u1, 
                    
                    /// [9:9] Input enable of the pad. 1: input enabled. 0: input disabled.
                    FUN_IE:  u1, 
                    
                    /// [10:11] Select the drive strength of the pad. 0: ~5 mA. 1: ~10mA. 2: ~20mA. 3: ~40mA.
                    FUN_DRV:  u2, 
                    
                    /// [12:14] Select IO MUX function for this signal. 0: Select Function 1. 1: Select Function 2. etc.
                    MCU_SEL:  u3, 
                    
                    /// [15:15] Enable filter for pin input signals. 1: Filter enabled. 0: Filter disabled.
                    FILTER_EN:  u1, 
                    
                    /// [16:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60090040));
                
                /// IO MUX Configure Register for pad XTAL_32K_P
                pub const GPIO0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Output enable of the pad in sleep mode. 1: output enabled. 0: output disabled.
                    MCU_OE:  u1, 
                    
                    /// [1:1] Sleep mode selection of this pad. Set to 1 to put the pad in pad mode.
                    SLP_SEL:  u1, 
                    
                    /// [2:2] Pull-down enable of the pad in sleep mode. 1: internal pull-down enabled. 0: internal pull-down disabled.
                    MCU_WPD:  u1, 
                    
                    /// [3:3] Pull-up enable of the pad during sleep mode. 1: internal pull-up enabled. 0: internal pull-up disabled.
                    MCU_WPU:  u1, 
                    
                    /// [4:4] Input enable of the pad during sleep mode. 1: input enabled. 0: input disabled.
                    MCU_IE:  u1, 
                    
                    /// [5:6] Select the drive strength of the pad during sleep mode. 0: ~5 mA. 1: ~10mA. 2: ~20mA. 3: ~40mA.
                    MCU_DRV:  u2, 
                    
                    /// [7:7] Pull-down enable of the pad. 1: internal pull-down enabled. 0: internal pull-down disabled.
                    FUN_WPD:  u1, 
                    
                    /// [8:8] Pull-up enable of the pad. 1: internal pull-up enabled. 0: internal pull-up disabled.
                    FUN_WPU:  u1, 
                    
                    /// [9:9] Input enable of the pad. 1: input enabled. 0: input disabled.
                    FUN_IE:  u1, 
                    
                    /// [10:11] Select the drive strength of the pad. 0: ~5 mA. 1: ~10mA. 2: ~20mA. 3: ~40mA.
                    FUN_DRV:  u2, 
                    
                    /// [12:14] Select IO MUX function for this signal. 0: Select Function 1. 1: Select Function 2. etc.
                    MCU_SEL:  u3, 
                    
                    /// [15:15] Enable filter for pin input signals. 1: Filter enabled. 0: Filter disabled.
                    FILTER_EN:  u1, 
                    
                    /// [16:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60090044));
                
                /// IO MUX Configure Register for pad XTAL_32K_P
                pub const GPIO0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Output enable of the pad in sleep mode. 1: output enabled. 0: output disabled.
                    MCU_OE:  u1, 
                    
                    /// [1:1] Sleep mode selection of this pad. Set to 1 to put the pad in pad mode.
                    SLP_SEL:  u1, 
                    
                    /// [2:2] Pull-down enable of the pad in sleep mode. 1: internal pull-down enabled. 0: internal pull-down disabled.
                    MCU_WPD:  u1, 
                    
                    /// [3:3] Pull-up enable of the pad during sleep mode. 1: internal pull-up enabled. 0: internal pull-up disabled.
                    MCU_WPU:  u1, 
                    
                    /// [4:4] Input enable of the pad during sleep mode. 1: input enabled. 0: input disabled.
                    MCU_IE:  u1, 
                    
                    /// [5:6] Select the drive strength of the pad during sleep mode. 0: ~5 mA. 1: ~10mA. 2: ~20mA. 3: ~40mA.
                    MCU_DRV:  u2, 
                    
                    /// [7:7] Pull-down enable of the pad. 1: internal pull-down enabled. 0: internal pull-down disabled.
                    FUN_WPD:  u1, 
                    
                    /// [8:8] Pull-up enable of the pad. 1: internal pull-up enabled. 0: internal pull-up disabled.
                    FUN_WPU:  u1, 
                    
                    /// [9:9] Input enable of the pad. 1: input enabled. 0: input disabled.
                    FUN_IE:  u1, 
                    
                    /// [10:11] Select the drive strength of the pad. 0: ~5 mA. 1: ~10mA. 2: ~20mA. 3: ~40mA.
                    FUN_DRV:  u2, 
                    
                    /// [12:14] Select IO MUX function for this signal. 0: Select Function 1. 1: Select Function 2. etc.
                    MCU_SEL:  u3, 
                    
                    /// [15:15] Enable filter for pin input signals. 1: Filter enabled. 0: Filter disabled.
                    FILTER_EN:  u1, 
                    
                    /// [16:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60090048));
                
                /// IO MUX Configure Register for pad XTAL_32K_P
                pub const GPIO0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Output enable of the pad in sleep mode. 1: output enabled. 0: output disabled.
                    MCU_OE:  u1, 
                    
                    /// [1:1] Sleep mode selection of this pad. Set to 1 to put the pad in pad mode.
                    SLP_SEL:  u1, 
                    
                    /// [2:2] Pull-down enable of the pad in sleep mode. 1: internal pull-down enabled. 0: internal pull-down disabled.
                    MCU_WPD:  u1, 
                    
                    /// [3:3] Pull-up enable of the pad during sleep mode. 1: internal pull-up enabled. 0: internal pull-up disabled.
                    MCU_WPU:  u1, 
                    
                    /// [4:4] Input enable of the pad during sleep mode. 1: input enabled. 0: input disabled.
                    MCU_IE:  u1, 
                    
                    /// [5:6] Select the drive strength of the pad during sleep mode. 0: ~5 mA. 1: ~10mA. 2: ~20mA. 3: ~40mA.
                    MCU_DRV:  u2, 
                    
                    /// [7:7] Pull-down enable of the pad. 1: internal pull-down enabled. 0: internal pull-down disabled.
                    FUN_WPD:  u1, 
                    
                    /// [8:8] Pull-up enable of the pad. 1: internal pull-up enabled. 0: internal pull-up disabled.
                    FUN_WPU:  u1, 
                    
                    /// [9:9] Input enable of the pad. 1: input enabled. 0: input disabled.
                    FUN_IE:  u1, 
                    
                    /// [10:11] Select the drive strength of the pad. 0: ~5 mA. 1: ~10mA. 2: ~20mA. 3: ~40mA.
                    FUN_DRV:  u2, 
                    
                    /// [12:14] Select IO MUX function for this signal. 0: Select Function 1. 1: Select Function 2. etc.
                    MCU_SEL:  u3, 
                    
                    /// [15:15] Enable filter for pin input signals. 1: Filter enabled. 0: Filter disabled.
                    FILTER_EN:  u1, 
                    
                    /// [16:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6009004c));
                
                /// IO MUX Configure Register for pad XTAL_32K_P
                pub const GPIO0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Output enable of the pad in sleep mode. 1: output enabled. 0: output disabled.
                    MCU_OE:  u1, 
                    
                    /// [1:1] Sleep mode selection of this pad. Set to 1 to put the pad in pad mode.
                    SLP_SEL:  u1, 
                    
                    /// [2:2] Pull-down enable of the pad in sleep mode. 1: internal pull-down enabled. 0: internal pull-down disabled.
                    MCU_WPD:  u1, 
                    
                    /// [3:3] Pull-up enable of the pad during sleep mode. 1: internal pull-up enabled. 0: internal pull-up disabled.
                    MCU_WPU:  u1, 
                    
                    /// [4:4] Input enable of the pad during sleep mode. 1: input enabled. 0: input disabled.
                    MCU_IE:  u1, 
                    
                    /// [5:6] Select the drive strength of the pad during sleep mode. 0: ~5 mA. 1: ~10mA. 2: ~20mA. 3: ~40mA.
                    MCU_DRV:  u2, 
                    
                    /// [7:7] Pull-down enable of the pad. 1: internal pull-down enabled. 0: internal pull-down disabled.
                    FUN_WPD:  u1, 
                    
                    /// [8:8] Pull-up enable of the pad. 1: internal pull-up enabled. 0: internal pull-up disabled.
                    FUN_WPU:  u1, 
                    
                    /// [9:9] Input enable of the pad. 1: input enabled. 0: input disabled.
                    FUN_IE:  u1, 
                    
                    /// [10:11] Select the drive strength of the pad. 0: ~5 mA. 1: ~10mA. 2: ~20mA. 3: ~40mA.
                    FUN_DRV:  u2, 
                    
                    /// [12:14] Select IO MUX function for this signal. 0: Select Function 1. 1: Select Function 2. etc.
                    MCU_SEL:  u3, 
                    
                    /// [15:15] Enable filter for pin input signals. 1: Filter enabled. 0: Filter disabled.
                    FILTER_EN:  u1, 
                    
                    /// [16:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60090050));
                
                /// IO MUX Configure Register for pad XTAL_32K_P
                pub const GPIO0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Output enable of the pad in sleep mode. 1: output enabled. 0: output disabled.
                    MCU_OE:  u1, 
                    
                    /// [1:1] Sleep mode selection of this pad. Set to 1 to put the pad in pad mode.
                    SLP_SEL:  u1, 
                    
                    /// [2:2] Pull-down enable of the pad in sleep mode. 1: internal pull-down enabled. 0: internal pull-down disabled.
                    MCU_WPD:  u1, 
                    
                    /// [3:3] Pull-up enable of the pad during sleep mode. 1: internal pull-up enabled. 0: internal pull-up disabled.
                    MCU_WPU:  u1, 
                    
                    /// [4:4] Input enable of the pad during sleep mode. 1: input enabled. 0: input disabled.
                    MCU_IE:  u1, 
                    
                    /// [5:6] Select the drive strength of the pad during sleep mode. 0: ~5 mA. 1: ~10mA. 2: ~20mA. 3: ~40mA.
                    MCU_DRV:  u2, 
                    
                    /// [7:7] Pull-down enable of the pad. 1: internal pull-down enabled. 0: internal pull-down disabled.
                    FUN_WPD:  u1, 
                    
                    /// [8:8] Pull-up enable of the pad. 1: internal pull-up enabled. 0: internal pull-up disabled.
                    FUN_WPU:  u1, 
                    
                    /// [9:9] Input enable of the pad. 1: input enabled. 0: input disabled.
                    FUN_IE:  u1, 
                    
                    /// [10:11] Select the drive strength of the pad. 0: ~5 mA. 1: ~10mA. 2: ~20mA. 3: ~40mA.
                    FUN_DRV:  u2, 
                    
                    /// [12:14] Select IO MUX function for this signal. 0: Select Function 1. 1: Select Function 2. etc.
                    MCU_SEL:  u3, 
                    
                    /// [15:15] Enable filter for pin input signals. 1: Filter enabled. 0: Filter disabled.
                    FILTER_EN:  u1, 
                    
                    /// [16:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60090054));
                
                /// IO MUX Configure Register for pad XTAL_32K_P
                pub const GPIO0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Output enable of the pad in sleep mode. 1: output enabled. 0: output disabled.
                    MCU_OE:  u1, 
                    
                    /// [1:1] Sleep mode selection of this pad. Set to 1 to put the pad in pad mode.
                    SLP_SEL:  u1, 
                    
                    /// [2:2] Pull-down enable of the pad in sleep mode. 1: internal pull-down enabled. 0: internal pull-down disabled.
                    MCU_WPD:  u1, 
                    
                    /// [3:3] Pull-up enable of the pad during sleep mode. 1: internal pull-up enabled. 0: internal pull-up disabled.
                    MCU_WPU:  u1, 
                    
                    /// [4:4] Input enable of the pad during sleep mode. 1: input enabled. 0: input disabled.
                    MCU_IE:  u1, 
                    
                    /// [5:6] Select the drive strength of the pad during sleep mode. 0: ~5 mA. 1: ~10mA. 2: ~20mA. 3: ~40mA.
                    MCU_DRV:  u2, 
                    
                    /// [7:7] Pull-down enable of the pad. 1: internal pull-down enabled. 0: internal pull-down disabled.
                    FUN_WPD:  u1, 
                    
                    /// [8:8] Pull-up enable of the pad. 1: internal pull-up enabled. 0: internal pull-up disabled.
                    FUN_WPU:  u1, 
                    
                    /// [9:9] Input enable of the pad. 1: input enabled. 0: input disabled.
                    FUN_IE:  u1, 
                    
                    /// [10:11] Select the drive strength of the pad. 0: ~5 mA. 1: ~10mA. 2: ~20mA. 3: ~40mA.
                    FUN_DRV:  u2, 
                    
                    /// [12:14] Select IO MUX function for this signal. 0: Select Function 1. 1: Select Function 2. etc.
                    MCU_SEL:  u3, 
                    
                    /// [15:15] Enable filter for pin input signals. 1: Filter enabled. 0: Filter disabled.
                    FILTER_EN:  u1, 
                    
                    /// [16:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60090058));
                
                /// IO MUX Configure Register for pad XTAL_32K_P
                pub const GPIO0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Output enable of the pad in sleep mode. 1: output enabled. 0: output disabled.
                    MCU_OE:  u1, 
                    
                    /// [1:1] Sleep mode selection of this pad. Set to 1 to put the pad in pad mode.
                    SLP_SEL:  u1, 
                    
                    /// [2:2] Pull-down enable of the pad in sleep mode. 1: internal pull-down enabled. 0: internal pull-down disabled.
                    MCU_WPD:  u1, 
                    
                    /// [3:3] Pull-up enable of the pad during sleep mode. 1: internal pull-up enabled. 0: internal pull-up disabled.
                    MCU_WPU:  u1, 
                    
                    /// [4:4] Input enable of the pad during sleep mode. 1: input enabled. 0: input disabled.
                    MCU_IE:  u1, 
                    
                    /// [5:6] Select the drive strength of the pad during sleep mode. 0: ~5 mA. 1: ~10mA. 2: ~20mA. 3: ~40mA.
                    MCU_DRV:  u2, 
                    
                    /// [7:7] Pull-down enable of the pad. 1: internal pull-down enabled. 0: internal pull-down disabled.
                    FUN_WPD:  u1, 
                    
                    /// [8:8] Pull-up enable of the pad. 1: internal pull-up enabled. 0: internal pull-up disabled.
                    FUN_WPU:  u1, 
                    
                    /// [9:9] Input enable of the pad. 1: input enabled. 0: input disabled.
                    FUN_IE:  u1, 
                    
                    /// [10:11] Select the drive strength of the pad. 0: ~5 mA. 1: ~10mA. 2: ~20mA. 3: ~40mA.
                    FUN_DRV:  u2, 
                    
                    /// [12:14] Select IO MUX function for this signal. 0: Select Function 1. 1: Select Function 2. etc.
                    MCU_SEL:  u3, 
                    
                    /// [15:15] Enable filter for pin input signals. 1: Filter enabled. 0: Filter disabled.
                    FILTER_EN:  u1, 
                    
                    /// [16:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6009005c));
                
                /// IO MUX Configure Register for pad XTAL_32K_P
                pub const GPIO0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Output enable of the pad in sleep mode. 1: output enabled. 0: output disabled.
                    MCU_OE:  u1, 
                    
                    /// [1:1] Sleep mode selection of this pad. Set to 1 to put the pad in pad mode.
                    SLP_SEL:  u1, 
                    
                    /// [2:2] Pull-down enable of the pad in sleep mode. 1: internal pull-down enabled. 0: internal pull-down disabled.
                    MCU_WPD:  u1, 
                    
                    /// [3:3] Pull-up enable of the pad during sleep mode. 1: internal pull-up enabled. 0: internal pull-up disabled.
                    MCU_WPU:  u1, 
                    
                    /// [4:4] Input enable of the pad during sleep mode. 1: input enabled. 0: input disabled.
                    MCU_IE:  u1, 
                    
                    /// [5:6] Select the drive strength of the pad during sleep mode. 0: ~5 mA. 1: ~10mA. 2: ~20mA. 3: ~40mA.
                    MCU_DRV:  u2, 
                    
                    /// [7:7] Pull-down enable of the pad. 1: internal pull-down enabled. 0: internal pull-down disabled.
                    FUN_WPD:  u1, 
                    
                    /// [8:8] Pull-up enable of the pad. 1: internal pull-up enabled. 0: internal pull-up disabled.
                    FUN_WPU:  u1, 
                    
                    /// [9:9] Input enable of the pad. 1: input enabled. 0: input disabled.
                    FUN_IE:  u1, 
                    
                    /// [10:11] Select the drive strength of the pad. 0: ~5 mA. 1: ~10mA. 2: ~20mA. 3: ~40mA.
                    FUN_DRV:  u2, 
                    
                    /// [12:14] Select IO MUX function for this signal. 0: Select Function 1. 1: Select Function 2. etc.
                    MCU_SEL:  u3, 
                    
                    /// [15:15] Enable filter for pin input signals. 1: Filter enabled. 0: Filter disabled.
                    FILTER_EN:  u1, 
                    
                    /// [16:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60090060));
                
                /// IO MUX Configure Register for pad XTAL_32K_P
                pub const GPIO0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Output enable of the pad in sleep mode. 1: output enabled. 0: output disabled.
                    MCU_OE:  u1, 
                    
                    /// [1:1] Sleep mode selection of this pad. Set to 1 to put the pad in pad mode.
                    SLP_SEL:  u1, 
                    
                    /// [2:2] Pull-down enable of the pad in sleep mode. 1: internal pull-down enabled. 0: internal pull-down disabled.
                    MCU_WPD:  u1, 
                    
                    /// [3:3] Pull-up enable of the pad during sleep mode. 1: internal pull-up enabled. 0: internal pull-up disabled.
                    MCU_WPU:  u1, 
                    
                    /// [4:4] Input enable of the pad during sleep mode. 1: input enabled. 0: input disabled.
                    MCU_IE:  u1, 
                    
                    /// [5:6] Select the drive strength of the pad during sleep mode. 0: ~5 mA. 1: ~10mA. 2: ~20mA. 3: ~40mA.
                    MCU_DRV:  u2, 
                    
                    /// [7:7] Pull-down enable of the pad. 1: internal pull-down enabled. 0: internal pull-down disabled.
                    FUN_WPD:  u1, 
                    
                    /// [8:8] Pull-up enable of the pad. 1: internal pull-up enabled. 0: internal pull-up disabled.
                    FUN_WPU:  u1, 
                    
                    /// [9:9] Input enable of the pad. 1: input enabled. 0: input disabled.
                    FUN_IE:  u1, 
                    
                    /// [10:11] Select the drive strength of the pad. 0: ~5 mA. 1: ~10mA. 2: ~20mA. 3: ~40mA.
                    FUN_DRV:  u2, 
                    
                    /// [12:14] Select IO MUX function for this signal. 0: Select Function 1. 1: Select Function 2. etc.
                    MCU_SEL:  u3, 
                    
                    /// [15:15] Enable filter for pin input signals. 1: Filter enabled. 0: Filter disabled.
                    FILTER_EN:  u1, 
                    
                    /// [16:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60090064));
                
                /// IO MUX Configure Register for pad XTAL_32K_P
                pub const GPIO0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Output enable of the pad in sleep mode. 1: output enabled. 0: output disabled.
                    MCU_OE:  u1, 
                    
                    /// [1:1] Sleep mode selection of this pad. Set to 1 to put the pad in pad mode.
                    SLP_SEL:  u1, 
                    
                    /// [2:2] Pull-down enable of the pad in sleep mode. 1: internal pull-down enabled. 0: internal pull-down disabled.
                    MCU_WPD:  u1, 
                    
                    /// [3:3] Pull-up enable of the pad during sleep mode. 1: internal pull-up enabled. 0: internal pull-up disabled.
                    MCU_WPU:  u1, 
                    
                    /// [4:4] Input enable of the pad during sleep mode. 1: input enabled. 0: input disabled.
                    MCU_IE:  u1, 
                    
                    /// [5:6] Select the drive strength of the pad during sleep mode. 0: ~5 mA. 1: ~10mA. 2: ~20mA. 3: ~40mA.
                    MCU_DRV:  u2, 
                    
                    /// [7:7] Pull-down enable of the pad. 1: internal pull-down enabled. 0: internal pull-down disabled.
                    FUN_WPD:  u1, 
                    
                    /// [8:8] Pull-up enable of the pad. 1: internal pull-up enabled. 0: internal pull-up disabled.
                    FUN_WPU:  u1, 
                    
                    /// [9:9] Input enable of the pad. 1: input enabled. 0: input disabled.
                    FUN_IE:  u1, 
                    
                    /// [10:11] Select the drive strength of the pad. 0: ~5 mA. 1: ~10mA. 2: ~20mA. 3: ~40mA.
                    FUN_DRV:  u2, 
                    
                    /// [12:14] Select IO MUX function for this signal. 0: Select Function 1. 1: Select Function 2. etc.
                    MCU_SEL:  u3, 
                    
                    /// [15:15] Enable filter for pin input signals. 1: Filter enabled. 0: Filter disabled.
                    FILTER_EN:  u1, 
                    
                    /// [16:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60090068));
                
                /// IO MUX Configure Register for pad XTAL_32K_P
                pub const GPIO0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Output enable of the pad in sleep mode. 1: output enabled. 0: output disabled.
                    MCU_OE:  u1, 
                    
                    /// [1:1] Sleep mode selection of this pad. Set to 1 to put the pad in pad mode.
                    SLP_SEL:  u1, 
                    
                    /// [2:2] Pull-down enable of the pad in sleep mode. 1: internal pull-down enabled. 0: internal pull-down disabled.
                    MCU_WPD:  u1, 
                    
                    /// [3:3] Pull-up enable of the pad during sleep mode. 1: internal pull-up enabled. 0: internal pull-up disabled.
                    MCU_WPU:  u1, 
                    
                    /// [4:4] Input enable of the pad during sleep mode. 1: input enabled. 0: input disabled.
                    MCU_IE:  u1, 
                    
                    /// [5:6] Select the drive strength of the pad during sleep mode. 0: ~5 mA. 1: ~10mA. 2: ~20mA. 3: ~40mA.
                    MCU_DRV:  u2, 
                    
                    /// [7:7] Pull-down enable of the pad. 1: internal pull-down enabled. 0: internal pull-down disabled.
                    FUN_WPD:  u1, 
                    
                    /// [8:8] Pull-up enable of the pad. 1: internal pull-up enabled. 0: internal pull-up disabled.
                    FUN_WPU:  u1, 
                    
                    /// [9:9] Input enable of the pad. 1: input enabled. 0: input disabled.
                    FUN_IE:  u1, 
                    
                    /// [10:11] Select the drive strength of the pad. 0: ~5 mA. 1: ~10mA. 2: ~20mA. 3: ~40mA.
                    FUN_DRV:  u2, 
                    
                    /// [12:14] Select IO MUX function for this signal. 0: Select Function 1. 1: Select Function 2. etc.
                    MCU_SEL:  u3, 
                    
                    /// [15:15] Enable filter for pin input signals. 1: Filter enabled. 0: Filter disabled.
                    FILTER_EN:  u1, 
                    
                    /// [16:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6009006c));
                
                /// IO MUX Configure Register for pad XTAL_32K_P
                pub const GPIO0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Output enable of the pad in sleep mode. 1: output enabled. 0: output disabled.
                    MCU_OE:  u1, 
                    
                    /// [1:1] Sleep mode selection of this pad. Set to 1 to put the pad in pad mode.
                    SLP_SEL:  u1, 
                    
                    /// [2:2] Pull-down enable of the pad in sleep mode. 1: internal pull-down enabled. 0: internal pull-down disabled.
                    MCU_WPD:  u1, 
                    
                    /// [3:3] Pull-up enable of the pad during sleep mode. 1: internal pull-up enabled. 0: internal pull-up disabled.
                    MCU_WPU:  u1, 
                    
                    /// [4:4] Input enable of the pad during sleep mode. 1: input enabled. 0: input disabled.
                    MCU_IE:  u1, 
                    
                    /// [5:6] Select the drive strength of the pad during sleep mode. 0: ~5 mA. 1: ~10mA. 2: ~20mA. 3: ~40mA.
                    MCU_DRV:  u2, 
                    
                    /// [7:7] Pull-down enable of the pad. 1: internal pull-down enabled. 0: internal pull-down disabled.
                    FUN_WPD:  u1, 
                    
                    /// [8:8] Pull-up enable of the pad. 1: internal pull-up enabled. 0: internal pull-up disabled.
                    FUN_WPU:  u1, 
                    
                    /// [9:9] Input enable of the pad. 1: input enabled. 0: input disabled.
                    FUN_IE:  u1, 
                    
                    /// [10:11] Select the drive strength of the pad. 0: ~5 mA. 1: ~10mA. 2: ~20mA. 3: ~40mA.
                    FUN_DRV:  u2, 
                    
                    /// [12:14] Select IO MUX function for this signal. 0: Select Function 1. 1: Select Function 2. etc.
                    MCU_SEL:  u3, 
                    
                    /// [15:15] Enable filter for pin input signals. 1: Filter enabled. 0: Filter disabled.
                    FILTER_EN:  u1, 
                    
                    /// [16:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60090070));
                
                /// IO MUX Configure Register for pad XTAL_32K_P
                pub const GPIO0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Output enable of the pad in sleep mode. 1: output enabled. 0: output disabled.
                    MCU_OE:  u1, 
                    
                    /// [1:1] Sleep mode selection of this pad. Set to 1 to put the pad in pad mode.
                    SLP_SEL:  u1, 
                    
                    /// [2:2] Pull-down enable of the pad in sleep mode. 1: internal pull-down enabled. 0: internal pull-down disabled.
                    MCU_WPD:  u1, 
                    
                    /// [3:3] Pull-up enable of the pad during sleep mode. 1: internal pull-up enabled. 0: internal pull-up disabled.
                    MCU_WPU:  u1, 
                    
                    /// [4:4] Input enable of the pad during sleep mode. 1: input enabled. 0: input disabled.
                    MCU_IE:  u1, 
                    
                    /// [5:6] Select the drive strength of the pad during sleep mode. 0: ~5 mA. 1: ~10mA. 2: ~20mA. 3: ~40mA.
                    MCU_DRV:  u2, 
                    
                    /// [7:7] Pull-down enable of the pad. 1: internal pull-down enabled. 0: internal pull-down disabled.
                    FUN_WPD:  u1, 
                    
                    /// [8:8] Pull-up enable of the pad. 1: internal pull-up enabled. 0: internal pull-up disabled.
                    FUN_WPU:  u1, 
                    
                    /// [9:9] Input enable of the pad. 1: input enabled. 0: input disabled.
                    FUN_IE:  u1, 
                    
                    /// [10:11] Select the drive strength of the pad. 0: ~5 mA. 1: ~10mA. 2: ~20mA. 3: ~40mA.
                    FUN_DRV:  u2, 
                    
                    /// [12:14] Select IO MUX function for this signal. 0: Select Function 1. 1: Select Function 2. etc.
                    MCU_SEL:  u3, 
                    
                    /// [15:15] Enable filter for pin input signals. 1: Filter enabled. 0: Filter disabled.
                    FILTER_EN:  u1, 
                    
                    /// [16:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60090074));
                
                /// IO MUX Configure Register for pad XTAL_32K_P
                pub const GPIO0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Output enable of the pad in sleep mode. 1: output enabled. 0: output disabled.
                    MCU_OE:  u1, 
                    
                    /// [1:1] Sleep mode selection of this pad. Set to 1 to put the pad in pad mode.
                    SLP_SEL:  u1, 
                    
                    /// [2:2] Pull-down enable of the pad in sleep mode. 1: internal pull-down enabled. 0: internal pull-down disabled.
                    MCU_WPD:  u1, 
                    
                    /// [3:3] Pull-up enable of the pad during sleep mode. 1: internal pull-up enabled. 0: internal pull-up disabled.
                    MCU_WPU:  u1, 
                    
                    /// [4:4] Input enable of the pad during sleep mode. 1: input enabled. 0: input disabled.
                    MCU_IE:  u1, 
                    
                    /// [5:6] Select the drive strength of the pad during sleep mode. 0: ~5 mA. 1: ~10mA. 2: ~20mA. 3: ~40mA.
                    MCU_DRV:  u2, 
                    
                    /// [7:7] Pull-down enable of the pad. 1: internal pull-down enabled. 0: internal pull-down disabled.
                    FUN_WPD:  u1, 
                    
                    /// [8:8] Pull-up enable of the pad. 1: internal pull-up enabled. 0: internal pull-up disabled.
                    FUN_WPU:  u1, 
                    
                    /// [9:9] Input enable of the pad. 1: input enabled. 0: input disabled.
                    FUN_IE:  u1, 
                    
                    /// [10:11] Select the drive strength of the pad. 0: ~5 mA. 1: ~10mA. 2: ~20mA. 3: ~40mA.
                    FUN_DRV:  u2, 
                    
                    /// [12:14] Select IO MUX function for this signal. 0: Select Function 1. 1: Select Function 2. etc.
                    MCU_SEL:  u3, 
                    
                    /// [15:15] Enable filter for pin input signals. 1: Filter enabled. 0: Filter disabled.
                    FILTER_EN:  u1, 
                    
                    /// [16:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60090078));
                
                /// IO MUX Configure Register for pad XTAL_32K_P
                pub const GPIO0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Output enable of the pad in sleep mode. 1: output enabled. 0: output disabled.
                    MCU_OE:  u1, 
                    
                    /// [1:1] Sleep mode selection of this pad. Set to 1 to put the pad in pad mode.
                    SLP_SEL:  u1, 
                    
                    /// [2:2] Pull-down enable of the pad in sleep mode. 1: internal pull-down enabled. 0: internal pull-down disabled.
                    MCU_WPD:  u1, 
                    
                    /// [3:3] Pull-up enable of the pad during sleep mode. 1: internal pull-up enabled. 0: internal pull-up disabled.
                    MCU_WPU:  u1, 
                    
                    /// [4:4] Input enable of the pad during sleep mode. 1: input enabled. 0: input disabled.
                    MCU_IE:  u1, 
                    
                    /// [5:6] Select the drive strength of the pad during sleep mode. 0: ~5 mA. 1: ~10mA. 2: ~20mA. 3: ~40mA.
                    MCU_DRV:  u2, 
                    
                    /// [7:7] Pull-down enable of the pad. 1: internal pull-down enabled. 0: internal pull-down disabled.
                    FUN_WPD:  u1, 
                    
                    /// [8:8] Pull-up enable of the pad. 1: internal pull-up enabled. 0: internal pull-up disabled.
                    FUN_WPU:  u1, 
                    
                    /// [9:9] Input enable of the pad. 1: input enabled. 0: input disabled.
                    FUN_IE:  u1, 
                    
                    /// [10:11] Select the drive strength of the pad. 0: ~5 mA. 1: ~10mA. 2: ~20mA. 3: ~40mA.
                    FUN_DRV:  u2, 
                    
                    /// [12:14] Select IO MUX function for this signal. 0: Select Function 1. 1: Select Function 2. etc.
                    MCU_SEL:  u3, 
                    
                    /// [15:15] Enable filter for pin input signals. 1: Filter enabled. 0: Filter disabled.
                    FILTER_EN:  u1, 
                    
                    /// [16:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6009007c));
                
                /// GPIO MATRIX Configure Register for modem diag
                pub const MODEM_DIAG_EN = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] bit i to enable modem_diag[i] into gpio matrix. 1:enable modem_diag[i] into gpio matrix. 0:enable other signals into gpio matrix
                    MODEM_DIAG_EN:  u32, 
                    
                }), @ptrFromInt(0x600900bc));
                
                /// IO MUX Version Control Register
                pub const DATE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:27] Version control register
                    REG_DATE:  u28, 
                    
                    /// [28:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600900fc));
                
            };
            
            /// LED Control PWM (Pulse Width Modulation)
            pub const LEDC = struct {
                
                /// Configuration register 0 for channel %s
                pub const CH0_CONF0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:1] This field is used to select one of timers for channel %s.0: select timer0, 1: select timer1, 2: select timer2, 3: select timer3
                    TIMER_SEL:  u2, 
                    
                    /// [2:2] Set this bit to enable signal output on channel %s.
                    SIG_OUT_EN:  u1, 
                    
                    /// [3:3] This bit is used to control the output value when channel %s is inactive (when LEDC_SIG_OUT_EN_CH%s is 0).
                    IDLE_LV:  u1, 
                    
                    /// [4:4] This bit is used to update LEDC_HPOINT_CH%s, LEDC_DUTY_START_CH%s, LEDC_SIG_OUT_EN_CH%s, LEDC_TIMER_SEL_CH%s, LEDC_DUTY_NUM_CH%s, LEDC_DUTY_CYCLE_CH%s, LEDC_DUTY_SCALE_CH%s, LEDC_DUTY_INC_CH%s, and LEDC_OVF_CNT_EN_CH%s fields for channel %s, and will be automatically cleared by hardware.
                    PARA_UP:  u1, 
                    
                    /// [5:14] This register is used to configure the maximum times of overflow minus 1.The LEDC_OVF_CNT_CH%s_INT interrupt will be triggered when channel %s overflows for (LEDC_OVF_NUM_CH%s + 1) times.
                    OVF_NUM:  u10, 
                    
                    /// [15:15] This bit is used to enable the ovf_cnt of channel %s.
                    OVF_CNT_EN:  u1, 
                    
                    /// [16:16] Set this bit to reset the ovf_cnt of channel %s.
                    OVF_CNT_RESET:  u1, 
                    
                    /// [17:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60007000));
                
                /// Configuration register 0 for channel %s
                pub const CH0_CONF0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:1] This field is used to select one of timers for channel %s.0: select timer0, 1: select timer1, 2: select timer2, 3: select timer3
                    TIMER_SEL:  u2, 
                    
                    /// [2:2] Set this bit to enable signal output on channel %s.
                    SIG_OUT_EN:  u1, 
                    
                    /// [3:3] This bit is used to control the output value when channel %s is inactive (when LEDC_SIG_OUT_EN_CH%s is 0).
                    IDLE_LV:  u1, 
                    
                    /// [4:4] This bit is used to update LEDC_HPOINT_CH%s, LEDC_DUTY_START_CH%s, LEDC_SIG_OUT_EN_CH%s, LEDC_TIMER_SEL_CH%s, LEDC_DUTY_NUM_CH%s, LEDC_DUTY_CYCLE_CH%s, LEDC_DUTY_SCALE_CH%s, LEDC_DUTY_INC_CH%s, and LEDC_OVF_CNT_EN_CH%s fields for channel %s, and will be automatically cleared by hardware.
                    PARA_UP:  u1, 
                    
                    /// [5:14] This register is used to configure the maximum times of overflow minus 1.The LEDC_OVF_CNT_CH%s_INT interrupt will be triggered when channel %s overflows for (LEDC_OVF_NUM_CH%s + 1) times.
                    OVF_NUM:  u10, 
                    
                    /// [15:15] This bit is used to enable the ovf_cnt of channel %s.
                    OVF_CNT_EN:  u1, 
                    
                    /// [16:16] Set this bit to reset the ovf_cnt of channel %s.
                    OVF_CNT_RESET:  u1, 
                    
                    /// [17:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60007004));
                
                /// Configuration register 0 for channel %s
                pub const CH0_CONF0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:1] This field is used to select one of timers for channel %s.0: select timer0, 1: select timer1, 2: select timer2, 3: select timer3
                    TIMER_SEL:  u2, 
                    
                    /// [2:2] Set this bit to enable signal output on channel %s.
                    SIG_OUT_EN:  u1, 
                    
                    /// [3:3] This bit is used to control the output value when channel %s is inactive (when LEDC_SIG_OUT_EN_CH%s is 0).
                    IDLE_LV:  u1, 
                    
                    /// [4:4] This bit is used to update LEDC_HPOINT_CH%s, LEDC_DUTY_START_CH%s, LEDC_SIG_OUT_EN_CH%s, LEDC_TIMER_SEL_CH%s, LEDC_DUTY_NUM_CH%s, LEDC_DUTY_CYCLE_CH%s, LEDC_DUTY_SCALE_CH%s, LEDC_DUTY_INC_CH%s, and LEDC_OVF_CNT_EN_CH%s fields for channel %s, and will be automatically cleared by hardware.
                    PARA_UP:  u1, 
                    
                    /// [5:14] This register is used to configure the maximum times of overflow minus 1.The LEDC_OVF_CNT_CH%s_INT interrupt will be triggered when channel %s overflows for (LEDC_OVF_NUM_CH%s + 1) times.
                    OVF_NUM:  u10, 
                    
                    /// [15:15] This bit is used to enable the ovf_cnt of channel %s.
                    OVF_CNT_EN:  u1, 
                    
                    /// [16:16] Set this bit to reset the ovf_cnt of channel %s.
                    OVF_CNT_RESET:  u1, 
                    
                    /// [17:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60007008));
                
                /// Configuration register 0 for channel %s
                pub const CH0_CONF0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:1] This field is used to select one of timers for channel %s.0: select timer0, 1: select timer1, 2: select timer2, 3: select timer3
                    TIMER_SEL:  u2, 
                    
                    /// [2:2] Set this bit to enable signal output on channel %s.
                    SIG_OUT_EN:  u1, 
                    
                    /// [3:3] This bit is used to control the output value when channel %s is inactive (when LEDC_SIG_OUT_EN_CH%s is 0).
                    IDLE_LV:  u1, 
                    
                    /// [4:4] This bit is used to update LEDC_HPOINT_CH%s, LEDC_DUTY_START_CH%s, LEDC_SIG_OUT_EN_CH%s, LEDC_TIMER_SEL_CH%s, LEDC_DUTY_NUM_CH%s, LEDC_DUTY_CYCLE_CH%s, LEDC_DUTY_SCALE_CH%s, LEDC_DUTY_INC_CH%s, and LEDC_OVF_CNT_EN_CH%s fields for channel %s, and will be automatically cleared by hardware.
                    PARA_UP:  u1, 
                    
                    /// [5:14] This register is used to configure the maximum times of overflow minus 1.The LEDC_OVF_CNT_CH%s_INT interrupt will be triggered when channel %s overflows for (LEDC_OVF_NUM_CH%s + 1) times.
                    OVF_NUM:  u10, 
                    
                    /// [15:15] This bit is used to enable the ovf_cnt of channel %s.
                    OVF_CNT_EN:  u1, 
                    
                    /// [16:16] Set this bit to reset the ovf_cnt of channel %s.
                    OVF_CNT_RESET:  u1, 
                    
                    /// [17:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000700c));
                
                /// Configuration register 0 for channel %s
                pub const CH0_CONF0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:1] This field is used to select one of timers for channel %s.0: select timer0, 1: select timer1, 2: select timer2, 3: select timer3
                    TIMER_SEL:  u2, 
                    
                    /// [2:2] Set this bit to enable signal output on channel %s.
                    SIG_OUT_EN:  u1, 
                    
                    /// [3:3] This bit is used to control the output value when channel %s is inactive (when LEDC_SIG_OUT_EN_CH%s is 0).
                    IDLE_LV:  u1, 
                    
                    /// [4:4] This bit is used to update LEDC_HPOINT_CH%s, LEDC_DUTY_START_CH%s, LEDC_SIG_OUT_EN_CH%s, LEDC_TIMER_SEL_CH%s, LEDC_DUTY_NUM_CH%s, LEDC_DUTY_CYCLE_CH%s, LEDC_DUTY_SCALE_CH%s, LEDC_DUTY_INC_CH%s, and LEDC_OVF_CNT_EN_CH%s fields for channel %s, and will be automatically cleared by hardware.
                    PARA_UP:  u1, 
                    
                    /// [5:14] This register is used to configure the maximum times of overflow minus 1.The LEDC_OVF_CNT_CH%s_INT interrupt will be triggered when channel %s overflows for (LEDC_OVF_NUM_CH%s + 1) times.
                    OVF_NUM:  u10, 
                    
                    /// [15:15] This bit is used to enable the ovf_cnt of channel %s.
                    OVF_CNT_EN:  u1, 
                    
                    /// [16:16] Set this bit to reset the ovf_cnt of channel %s.
                    OVF_CNT_RESET:  u1, 
                    
                    /// [17:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60007010));
                
                /// Configuration register 0 for channel %s
                pub const CH0_CONF0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:1] This field is used to select one of timers for channel %s.0: select timer0, 1: select timer1, 2: select timer2, 3: select timer3
                    TIMER_SEL:  u2, 
                    
                    /// [2:2] Set this bit to enable signal output on channel %s.
                    SIG_OUT_EN:  u1, 
                    
                    /// [3:3] This bit is used to control the output value when channel %s is inactive (when LEDC_SIG_OUT_EN_CH%s is 0).
                    IDLE_LV:  u1, 
                    
                    /// [4:4] This bit is used to update LEDC_HPOINT_CH%s, LEDC_DUTY_START_CH%s, LEDC_SIG_OUT_EN_CH%s, LEDC_TIMER_SEL_CH%s, LEDC_DUTY_NUM_CH%s, LEDC_DUTY_CYCLE_CH%s, LEDC_DUTY_SCALE_CH%s, LEDC_DUTY_INC_CH%s, and LEDC_OVF_CNT_EN_CH%s fields for channel %s, and will be automatically cleared by hardware.
                    PARA_UP:  u1, 
                    
                    /// [5:14] This register is used to configure the maximum times of overflow minus 1.The LEDC_OVF_CNT_CH%s_INT interrupt will be triggered when channel %s overflows for (LEDC_OVF_NUM_CH%s + 1) times.
                    OVF_NUM:  u10, 
                    
                    /// [15:15] This bit is used to enable the ovf_cnt of channel %s.
                    OVF_CNT_EN:  u1, 
                    
                    /// [16:16] Set this bit to reset the ovf_cnt of channel %s.
                    OVF_CNT_RESET:  u1, 
                    
                    /// [17:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60007014));
                
                /// High point register for channel %s
                pub const CH0_HPOINT = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:19] The output value changes to high when the selected timers has reached the value specified by this register.
                    HPOINT:  u20, 
                    
                    /// [20:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60007004));
                
                /// High point register for channel %s
                pub const CH0_HPOINT = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:19] The output value changes to high when the selected timers has reached the value specified by this register.
                    HPOINT:  u20, 
                    
                    /// [20:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60007008));
                
                /// High point register for channel %s
                pub const CH0_HPOINT = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:19] The output value changes to high when the selected timers has reached the value specified by this register.
                    HPOINT:  u20, 
                    
                    /// [20:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000700c));
                
                /// High point register for channel %s
                pub const CH0_HPOINT = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:19] The output value changes to high when the selected timers has reached the value specified by this register.
                    HPOINT:  u20, 
                    
                    /// [20:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60007010));
                
                /// High point register for channel %s
                pub const CH0_HPOINT = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:19] The output value changes to high when the selected timers has reached the value specified by this register.
                    HPOINT:  u20, 
                    
                    /// [20:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60007014));
                
                /// High point register for channel %s
                pub const CH0_HPOINT = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:19] The output value changes to high when the selected timers has reached the value specified by this register.
                    HPOINT:  u20, 
                    
                    /// [20:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60007018));
                
                /// Initial duty cycle for channel %s
                pub const CH0_DUTY = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:24] This register is used to change the output duty by controlling the Lpoint.The output value turns to low when the selected timers has reached the Lpoint.
                    DUTY:  u25, 
                    
                    /// [25:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60007008));
                
                /// Initial duty cycle for channel %s
                pub const CH0_DUTY = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:24] This register is used to change the output duty by controlling the Lpoint.The output value turns to low when the selected timers has reached the Lpoint.
                    DUTY:  u25, 
                    
                    /// [25:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000700c));
                
                /// Initial duty cycle for channel %s
                pub const CH0_DUTY = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:24] This register is used to change the output duty by controlling the Lpoint.The output value turns to low when the selected timers has reached the Lpoint.
                    DUTY:  u25, 
                    
                    /// [25:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60007010));
                
                /// Initial duty cycle for channel %s
                pub const CH0_DUTY = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:24] This register is used to change the output duty by controlling the Lpoint.The output value turns to low when the selected timers has reached the Lpoint.
                    DUTY:  u25, 
                    
                    /// [25:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60007014));
                
                /// Initial duty cycle for channel %s
                pub const CH0_DUTY = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:24] This register is used to change the output duty by controlling the Lpoint.The output value turns to low when the selected timers has reached the Lpoint.
                    DUTY:  u25, 
                    
                    /// [25:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60007018));
                
                /// Initial duty cycle for channel %s
                pub const CH0_DUTY = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:24] This register is used to change the output duty by controlling the Lpoint.The output value turns to low when the selected timers has reached the Lpoint.
                    DUTY:  u25, 
                    
                    /// [25:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000701c));
                
                /// Configuration register 1 for channel %s
                pub const CH0_CONF1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:30] 
                    res0:  u0, 
                    
                    /// [31:31] Other configured fields in LEDC_CH%s_CONF1_REG will start to take effect when this bit is set to 1.
                    DUTY_START:  u1, 
                    
                }), @ptrFromInt(0x6000700c));
                
                /// Configuration register 1 for channel %s
                pub const CH0_CONF1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:30] 
                    res0:  u0, 
                    
                    /// [31:31] Other configured fields in LEDC_CH%s_CONF1_REG will start to take effect when this bit is set to 1.
                    DUTY_START:  u1, 
                    
                }), @ptrFromInt(0x60007010));
                
                /// Configuration register 1 for channel %s
                pub const CH0_CONF1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:30] 
                    res0:  u0, 
                    
                    /// [31:31] Other configured fields in LEDC_CH%s_CONF1_REG will start to take effect when this bit is set to 1.
                    DUTY_START:  u1, 
                    
                }), @ptrFromInt(0x60007014));
                
                /// Configuration register 1 for channel %s
                pub const CH0_CONF1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:30] 
                    res0:  u0, 
                    
                    /// [31:31] Other configured fields in LEDC_CH%s_CONF1_REG will start to take effect when this bit is set to 1.
                    DUTY_START:  u1, 
                    
                }), @ptrFromInt(0x60007018));
                
                /// Configuration register 1 for channel %s
                pub const CH0_CONF1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:30] 
                    res0:  u0, 
                    
                    /// [31:31] Other configured fields in LEDC_CH%s_CONF1_REG will start to take effect when this bit is set to 1.
                    DUTY_START:  u1, 
                    
                }), @ptrFromInt(0x6000701c));
                
                /// Configuration register 1 for channel %s
                pub const CH0_CONF1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:30] 
                    res0:  u0, 
                    
                    /// [31:31] Other configured fields in LEDC_CH%s_CONF1_REG will start to take effect when this bit is set to 1.
                    DUTY_START:  u1, 
                    
                }), @ptrFromInt(0x60007020));
                
                /// Current duty cycle for channel %s
                pub const CH0_DUTY_R = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:24] This register stores the current duty of output signal on channel %s.
                    DUTY_CH_R:  u25, 
                    
                    /// [25:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60007010));
                
                /// Current duty cycle for channel %s
                pub const CH0_DUTY_R = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:24] This register stores the current duty of output signal on channel %s.
                    DUTY_CH_R:  u25, 
                    
                    /// [25:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60007014));
                
                /// Current duty cycle for channel %s
                pub const CH0_DUTY_R = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:24] This register stores the current duty of output signal on channel %s.
                    DUTY_CH_R:  u25, 
                    
                    /// [25:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60007018));
                
                /// Current duty cycle for channel %s
                pub const CH0_DUTY_R = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:24] This register stores the current duty of output signal on channel %s.
                    DUTY_CH_R:  u25, 
                    
                    /// [25:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000701c));
                
                /// Current duty cycle for channel %s
                pub const CH0_DUTY_R = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:24] This register stores the current duty of output signal on channel %s.
                    DUTY_CH_R:  u25, 
                    
                    /// [25:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60007020));
                
                /// Current duty cycle for channel %s
                pub const CH0_DUTY_R = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:24] This register stores the current duty of output signal on channel %s.
                    DUTY_CH_R:  u25, 
                    
                    /// [25:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60007024));
                
                /// Timer %s configuration
                pub const TIMER0_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:4] This register is used to control the range of the counter in timer %s.
                    DUTY_RES:  u5, 
                    
                    /// [5:22] This register is used to configure the divisor for the divider in timer %s.The least significant eight bits represent the fractional part.
                    CLK_DIV:  u18, 
                    
                    /// [23:23] This bit is used to suspend the counter in timer %s.
                    PAUSE:  u1, 
                    
                    /// [24:24] This bit is used to reset timer %s. The counter will show 0 after reset.
                    RST:  u1, 
                    
                    /// [25:25] This bit is used to select clock for timer %s. When this bit is set to 1 LEDC_APB_CLK_SEL[1:0] should be 1, otherwise the timer clock may be not accurate.1'h0: SLOW_CLK 1'h1: REF_TICK
                    TICK_SEL:  u1, 
                    
                    /// [26:26] Set this bit to update LEDC_CLK_DIV_TIMER%s and LEDC_TIMER%s_DUTY_RES.
                    PARA_UP:  u1, 
                    
                    /// [27:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600070a0));
                
                /// Timer %s configuration
                pub const TIMER0_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:4] This register is used to control the range of the counter in timer %s.
                    DUTY_RES:  u5, 
                    
                    /// [5:22] This register is used to configure the divisor for the divider in timer %s.The least significant eight bits represent the fractional part.
                    CLK_DIV:  u18, 
                    
                    /// [23:23] This bit is used to suspend the counter in timer %s.
                    PAUSE:  u1, 
                    
                    /// [24:24] This bit is used to reset timer %s. The counter will show 0 after reset.
                    RST:  u1, 
                    
                    /// [25:25] This bit is used to select clock for timer %s. When this bit is set to 1 LEDC_APB_CLK_SEL[1:0] should be 1, otherwise the timer clock may be not accurate.1'h0: SLOW_CLK 1'h1: REF_TICK
                    TICK_SEL:  u1, 
                    
                    /// [26:26] Set this bit to update LEDC_CLK_DIV_TIMER%s and LEDC_TIMER%s_DUTY_RES.
                    PARA_UP:  u1, 
                    
                    /// [27:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600070a4));
                
                /// Timer %s configuration
                pub const TIMER0_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:4] This register is used to control the range of the counter in timer %s.
                    DUTY_RES:  u5, 
                    
                    /// [5:22] This register is used to configure the divisor for the divider in timer %s.The least significant eight bits represent the fractional part.
                    CLK_DIV:  u18, 
                    
                    /// [23:23] This bit is used to suspend the counter in timer %s.
                    PAUSE:  u1, 
                    
                    /// [24:24] This bit is used to reset timer %s. The counter will show 0 after reset.
                    RST:  u1, 
                    
                    /// [25:25] This bit is used to select clock for timer %s. When this bit is set to 1 LEDC_APB_CLK_SEL[1:0] should be 1, otherwise the timer clock may be not accurate.1'h0: SLOW_CLK 1'h1: REF_TICK
                    TICK_SEL:  u1, 
                    
                    /// [26:26] Set this bit to update LEDC_CLK_DIV_TIMER%s and LEDC_TIMER%s_DUTY_RES.
                    PARA_UP:  u1, 
                    
                    /// [27:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600070a8));
                
                /// Timer %s configuration
                pub const TIMER0_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:4] This register is used to control the range of the counter in timer %s.
                    DUTY_RES:  u5, 
                    
                    /// [5:22] This register is used to configure the divisor for the divider in timer %s.The least significant eight bits represent the fractional part.
                    CLK_DIV:  u18, 
                    
                    /// [23:23] This bit is used to suspend the counter in timer %s.
                    PAUSE:  u1, 
                    
                    /// [24:24] This bit is used to reset timer %s. The counter will show 0 after reset.
                    RST:  u1, 
                    
                    /// [25:25] This bit is used to select clock for timer %s. When this bit is set to 1 LEDC_APB_CLK_SEL[1:0] should be 1, otherwise the timer clock may be not accurate.1'h0: SLOW_CLK 1'h1: REF_TICK
                    TICK_SEL:  u1, 
                    
                    /// [26:26] Set this bit to update LEDC_CLK_DIV_TIMER%s and LEDC_TIMER%s_DUTY_RES.
                    PARA_UP:  u1, 
                    
                    /// [27:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600070ac));
                
                /// Timer %s current counter value
                pub const TIMER0_VALUE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:19] This register stores the current counter value of timer %s.
                    TIMER_CNT:  u20, 
                    
                    /// [20:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600070a4));
                
                /// Timer %s current counter value
                pub const TIMER0_VALUE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:19] This register stores the current counter value of timer %s.
                    TIMER_CNT:  u20, 
                    
                    /// [20:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600070a8));
                
                /// Timer %s current counter value
                pub const TIMER0_VALUE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:19] This register stores the current counter value of timer %s.
                    TIMER_CNT:  u20, 
                    
                    /// [20:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600070ac));
                
                /// Timer %s current counter value
                pub const TIMER0_VALUE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:19] This register stores the current counter value of timer %s.
                    TIMER_CNT:  u20, 
                    
                    /// [20:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600070b0));
                
                /// Raw interrupt status
                pub const INT_RAW = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Triggered when the timer0 has reached its maximum counter value.
                    TIMER0_OVF_INT_RAW:  u1, 
                    
                    /// [1:1] Triggered when the timer1 has reached its maximum counter value.
                    TIMER1_OVF_INT_RAW:  u1, 
                    
                    /// [2:2] Triggered when the timer2 has reached its maximum counter value.
                    TIMER2_OVF_INT_RAW:  u1, 
                    
                    /// [3:3] Triggered when the timer3 has reached its maximum counter value.
                    TIMER3_OVF_INT_RAW:  u1, 
                    
                    /// [4:4] Interrupt raw bit for channel 0. Triggered when the gradual change of duty has finished.
                    DUTY_CHNG_END_CH0_INT_RAW:  u1, 
                    
                    /// [5:5] Interrupt raw bit for channel 1. Triggered when the gradual change of duty has finished.
                    DUTY_CHNG_END_CH1_INT_RAW:  u1, 
                    
                    /// [6:6] Interrupt raw bit for channel 2. Triggered when the gradual change of duty has finished.
                    DUTY_CHNG_END_CH2_INT_RAW:  u1, 
                    
                    /// [7:7] Interrupt raw bit for channel 3. Triggered when the gradual change of duty has finished.
                    DUTY_CHNG_END_CH3_INT_RAW:  u1, 
                    
                    /// [8:8] Interrupt raw bit for channel 4. Triggered when the gradual change of duty has finished.
                    DUTY_CHNG_END_CH4_INT_RAW:  u1, 
                    
                    /// [9:9] Interrupt raw bit for channel 5. Triggered when the gradual change of duty has finished.
                    DUTY_CHNG_END_CH5_INT_RAW:  u1, 
                    
                    /// [10:11] 
                    res0:  u0, 
                    
                    /// [12:12] Interrupt raw bit for channel 0. Triggered when the ovf_cnt has reached the value specified by LEDC_OVF_NUM_CH0.
                    OVF_CNT_CH0_INT_RAW:  u1, 
                    
                    /// [13:13] Interrupt raw bit for channel 1. Triggered when the ovf_cnt has reached the value specified by LEDC_OVF_NUM_CH1.
                    OVF_CNT_CH1_INT_RAW:  u1, 
                    
                    /// [14:14] Interrupt raw bit for channel 2. Triggered when the ovf_cnt has reached the value specified by LEDC_OVF_NUM_CH2.
                    OVF_CNT_CH2_INT_RAW:  u1, 
                    
                    /// [15:15] Interrupt raw bit for channel 3. Triggered when the ovf_cnt has reached the value specified by LEDC_OVF_NUM_CH3.
                    OVF_CNT_CH3_INT_RAW:  u1, 
                    
                    /// [16:16] Interrupt raw bit for channel 4. Triggered when the ovf_cnt has reached the value specified by LEDC_OVF_NUM_CH4.
                    OVF_CNT_CH4_INT_RAW:  u1, 
                    
                    /// [17:17] Interrupt raw bit for channel 5. Triggered when the ovf_cnt has reached the value specified by LEDC_OVF_NUM_CH5.
                    OVF_CNT_CH5_INT_RAW:  u1, 
                    
                    /// [18:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x600070c0));
                
                /// Masked interrupt status
                pub const INT_ST = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] This is the masked interrupt status bit for the LEDC_TIMER0_OVF_INT interrupt when LEDC_TIMER0_OVF_INT_ENA is set to 1.
                    TIMER0_OVF_INT_ST:  u1, 
                    
                    /// [1:1] This is the masked interrupt status bit for the LEDC_TIMER1_OVF_INT interrupt when LEDC_TIMER1_OVF_INT_ENA is set to 1.
                    TIMER1_OVF_INT_ST:  u1, 
                    
                    /// [2:2] This is the masked interrupt status bit for the LEDC_TIMER2_OVF_INT interrupt when LEDC_TIMER2_OVF_INT_ENA is set to 1.
                    TIMER2_OVF_INT_ST:  u1, 
                    
                    /// [3:3] This is the masked interrupt status bit for the LEDC_TIMER3_OVF_INT interrupt when LEDC_TIMER3_OVF_INT_ENA is set to 1.
                    TIMER3_OVF_INT_ST:  u1, 
                    
                    /// [4:4] This is the masked interrupt status bit for the LEDC_DUTY_CHNG_END_CH0_INT interrupt when LEDC_DUTY_CHNG_END_CH0_INT_ENA is set to 1.
                    DUTY_CHNG_END_CH0_INT_ST:  u1, 
                    
                    /// [5:5] This is the masked interrupt status bit for the LEDC_DUTY_CHNG_END_CH1_INT interrupt when LEDC_DUTY_CHNG_END_CH1_INT_ENA is set to 1.
                    DUTY_CHNG_END_CH1_INT_ST:  u1, 
                    
                    /// [6:6] This is the masked interrupt status bit for the LEDC_DUTY_CHNG_END_CH2_INT interrupt when LEDC_DUTY_CHNG_END_CH2_INT_ENA is set to 1.
                    DUTY_CHNG_END_CH2_INT_ST:  u1, 
                    
                    /// [7:7] This is the masked interrupt status bit for the LEDC_DUTY_CHNG_END_CH3_INT interrupt when LEDC_DUTY_CHNG_END_CH3_INT_ENA is set to 1.
                    DUTY_CHNG_END_CH3_INT_ST:  u1, 
                    
                    /// [8:8] This is the masked interrupt status bit for the LEDC_DUTY_CHNG_END_CH4_INT interrupt when LEDC_DUTY_CHNG_END_CH4_INT_ENA is set to 1.
                    DUTY_CHNG_END_CH4_INT_ST:  u1, 
                    
                    /// [9:9] This is the masked interrupt status bit for the LEDC_DUTY_CHNG_END_CH5_INT interrupt when LEDC_DUTY_CHNG_END_CH5_INT_ENA is set to 1.
                    DUTY_CHNG_END_CH5_INT_ST:  u1, 
                    
                    /// [10:11] 
                    res0:  u0, 
                    
                    /// [12:12] This is the masked interrupt status bit for the LEDC_OVF_CNT_CH0_INT interrupt when LEDC_OVF_CNT_CH0_INT_ENA is set to 1.
                    OVF_CNT_CH0_INT_ST:  u1, 
                    
                    /// [13:13] This is the masked interrupt status bit for the LEDC_OVF_CNT_CH1_INT interrupt when LEDC_OVF_CNT_CH1_INT_ENA is set to 1.
                    OVF_CNT_CH1_INT_ST:  u1, 
                    
                    /// [14:14] This is the masked interrupt status bit for the LEDC_OVF_CNT_CH2_INT interrupt when LEDC_OVF_CNT_CH2_INT_ENA is set to 1.
                    OVF_CNT_CH2_INT_ST:  u1, 
                    
                    /// [15:15] This is the masked interrupt status bit for the LEDC_OVF_CNT_CH3_INT interrupt when LEDC_OVF_CNT_CH3_INT_ENA is set to 1.
                    OVF_CNT_CH3_INT_ST:  u1, 
                    
                    /// [16:16] This is the masked interrupt status bit for the LEDC_OVF_CNT_CH4_INT interrupt when LEDC_OVF_CNT_CH4_INT_ENA is set to 1.
                    OVF_CNT_CH4_INT_ST:  u1, 
                    
                    /// [17:17] This is the masked interrupt status bit for the LEDC_OVF_CNT_CH5_INT interrupt when LEDC_OVF_CNT_CH5_INT_ENA is set to 1.
                    OVF_CNT_CH5_INT_ST:  u1, 
                    
                    /// [18:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x600070c4));
                
                /// Interrupt enable bits
                pub const INT_ENA = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] The interrupt enable bit for the LEDC_TIMER0_OVF_INT interrupt.
                    TIMER0_OVF_INT_ENA:  u1, 
                    
                    /// [1:1] The interrupt enable bit for the LEDC_TIMER1_OVF_INT interrupt.
                    TIMER1_OVF_INT_ENA:  u1, 
                    
                    /// [2:2] The interrupt enable bit for the LEDC_TIMER2_OVF_INT interrupt.
                    TIMER2_OVF_INT_ENA:  u1, 
                    
                    /// [3:3] The interrupt enable bit for the LEDC_TIMER3_OVF_INT interrupt.
                    TIMER3_OVF_INT_ENA:  u1, 
                    
                    /// [4:4] The interrupt enable bit for the LEDC_DUTY_CHNG_END_CH0_INT interrupt.
                    DUTY_CHNG_END_CH0_INT_ENA:  u1, 
                    
                    /// [5:5] The interrupt enable bit for the LEDC_DUTY_CHNG_END_CH1_INT interrupt.
                    DUTY_CHNG_END_CH1_INT_ENA:  u1, 
                    
                    /// [6:6] The interrupt enable bit for the LEDC_DUTY_CHNG_END_CH2_INT interrupt.
                    DUTY_CHNG_END_CH2_INT_ENA:  u1, 
                    
                    /// [7:7] The interrupt enable bit for the LEDC_DUTY_CHNG_END_CH3_INT interrupt.
                    DUTY_CHNG_END_CH3_INT_ENA:  u1, 
                    
                    /// [8:8] The interrupt enable bit for the LEDC_DUTY_CHNG_END_CH4_INT interrupt.
                    DUTY_CHNG_END_CH4_INT_ENA:  u1, 
                    
                    /// [9:9] The interrupt enable bit for the LEDC_DUTY_CHNG_END_CH5_INT interrupt.
                    DUTY_CHNG_END_CH5_INT_ENA:  u1, 
                    
                    /// [10:11] 
                    res0:  u0, 
                    
                    /// [12:12] The interrupt enable bit for the LEDC_OVF_CNT_CH0_INT interrupt.
                    OVF_CNT_CH0_INT_ENA:  u1, 
                    
                    /// [13:13] The interrupt enable bit for the LEDC_OVF_CNT_CH1_INT interrupt.
                    OVF_CNT_CH1_INT_ENA:  u1, 
                    
                    /// [14:14] The interrupt enable bit for the LEDC_OVF_CNT_CH2_INT interrupt.
                    OVF_CNT_CH2_INT_ENA:  u1, 
                    
                    /// [15:15] The interrupt enable bit for the LEDC_OVF_CNT_CH3_INT interrupt.
                    OVF_CNT_CH3_INT_ENA:  u1, 
                    
                    /// [16:16] The interrupt enable bit for the LEDC_OVF_CNT_CH4_INT interrupt.
                    OVF_CNT_CH4_INT_ENA:  u1, 
                    
                    /// [17:17] The interrupt enable bit for the LEDC_OVF_CNT_CH5_INT interrupt.
                    OVF_CNT_CH5_INT_ENA:  u1, 
                    
                    /// [18:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x600070c8));
                
                /// Interrupt clear bits
                pub const INT_CLR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Set this bit to clear the LEDC_TIMER0_OVF_INT interrupt.
                    TIMER0_OVF_INT_CLR:  u1, 
                    
                    /// [1:1] Set this bit to clear the LEDC_TIMER1_OVF_INT interrupt.
                    TIMER1_OVF_INT_CLR:  u1, 
                    
                    /// [2:2] Set this bit to clear the LEDC_TIMER2_OVF_INT interrupt.
                    TIMER2_OVF_INT_CLR:  u1, 
                    
                    /// [3:3] Set this bit to clear the LEDC_TIMER3_OVF_INT interrupt.
                    TIMER3_OVF_INT_CLR:  u1, 
                    
                    /// [4:4] Set this bit to clear the LEDC_DUTY_CHNG_END_CH0_INT interrupt.
                    DUTY_CHNG_END_CH0_INT_CLR:  u1, 
                    
                    /// [5:5] Set this bit to clear the LEDC_DUTY_CHNG_END_CH1_INT interrupt.
                    DUTY_CHNG_END_CH1_INT_CLR:  u1, 
                    
                    /// [6:6] Set this bit to clear the LEDC_DUTY_CHNG_END_CH2_INT interrupt.
                    DUTY_CHNG_END_CH2_INT_CLR:  u1, 
                    
                    /// [7:7] Set this bit to clear the LEDC_DUTY_CHNG_END_CH3_INT interrupt.
                    DUTY_CHNG_END_CH3_INT_CLR:  u1, 
                    
                    /// [8:8] Set this bit to clear the LEDC_DUTY_CHNG_END_CH4_INT interrupt.
                    DUTY_CHNG_END_CH4_INT_CLR:  u1, 
                    
                    /// [9:9] Set this bit to clear the LEDC_DUTY_CHNG_END_CH5_INT interrupt.
                    DUTY_CHNG_END_CH5_INT_CLR:  u1, 
                    
                    /// [10:11] 
                    res0:  u0, 
                    
                    /// [12:12] Set this bit to clear the LEDC_OVF_CNT_CH0_INT interrupt.
                    OVF_CNT_CH0_INT_CLR:  u1, 
                    
                    /// [13:13] Set this bit to clear the LEDC_OVF_CNT_CH1_INT interrupt.
                    OVF_CNT_CH1_INT_CLR:  u1, 
                    
                    /// [14:14] Set this bit to clear the LEDC_OVF_CNT_CH2_INT interrupt.
                    OVF_CNT_CH2_INT_CLR:  u1, 
                    
                    /// [15:15] Set this bit to clear the LEDC_OVF_CNT_CH3_INT interrupt.
                    OVF_CNT_CH3_INT_CLR:  u1, 
                    
                    /// [16:16] Set this bit to clear the LEDC_OVF_CNT_CH4_INT interrupt.
                    OVF_CNT_CH4_INT_CLR:  u1, 
                    
                    /// [17:17] Set this bit to clear the LEDC_OVF_CNT_CH5_INT interrupt.
                    OVF_CNT_CH5_INT_CLR:  u1, 
                    
                    /// [18:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x600070cc));
                
                /// Ledc ch%s gamma ram write register.
                pub const CH0_GAMMA_WR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Ledc ch%s gamma duty inc of current ram write address.This register is used to increase or decrease the duty of output signal on channel %s. 1: Increase0: Decrease.
                    CH_GAMMA_DUTY_INC:  u1, 
                    
                    /// [1:10] Ledc ch%s gamma duty cycle of current ram write address.The duty will change every LEDC_CH%s_GAMMA_DUTY_CYCLE on channel %s.
                    CH_GAMMA_DUTY_CYCLE:  u10, 
                    
                    /// [11:20] Ledc ch%s gamma scale of current ram write address.This register is used to configure the changing step scale of duty on channel %s.
                    CH_GAMMA_SCALE:  u10, 
                    
                    /// [21:30] Ledc ch%s gamma duty num of current ram write address.This register is used to control the number of times the duty cycle will be changed.
                    CH_GAMMA_DUTY_NUM:  u10, 
                    
                    /// [31:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60007100));
                
                /// Ledc ch%s gamma ram write register.
                pub const CH0_GAMMA_WR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Ledc ch%s gamma duty inc of current ram write address.This register is used to increase or decrease the duty of output signal on channel %s. 1: Increase0: Decrease.
                    CH_GAMMA_DUTY_INC:  u1, 
                    
                    /// [1:10] Ledc ch%s gamma duty cycle of current ram write address.The duty will change every LEDC_CH%s_GAMMA_DUTY_CYCLE on channel %s.
                    CH_GAMMA_DUTY_CYCLE:  u10, 
                    
                    /// [11:20] Ledc ch%s gamma scale of current ram write address.This register is used to configure the changing step scale of duty on channel %s.
                    CH_GAMMA_SCALE:  u10, 
                    
                    /// [21:30] Ledc ch%s gamma duty num of current ram write address.This register is used to control the number of times the duty cycle will be changed.
                    CH_GAMMA_DUTY_NUM:  u10, 
                    
                    /// [31:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60007104));
                
                /// Ledc ch%s gamma ram write register.
                pub const CH0_GAMMA_WR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Ledc ch%s gamma duty inc of current ram write address.This register is used to increase or decrease the duty of output signal on channel %s. 1: Increase0: Decrease.
                    CH_GAMMA_DUTY_INC:  u1, 
                    
                    /// [1:10] Ledc ch%s gamma duty cycle of current ram write address.The duty will change every LEDC_CH%s_GAMMA_DUTY_CYCLE on channel %s.
                    CH_GAMMA_DUTY_CYCLE:  u10, 
                    
                    /// [11:20] Ledc ch%s gamma scale of current ram write address.This register is used to configure the changing step scale of duty on channel %s.
                    CH_GAMMA_SCALE:  u10, 
                    
                    /// [21:30] Ledc ch%s gamma duty num of current ram write address.This register is used to control the number of times the duty cycle will be changed.
                    CH_GAMMA_DUTY_NUM:  u10, 
                    
                    /// [31:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60007108));
                
                /// Ledc ch%s gamma ram write register.
                pub const CH0_GAMMA_WR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Ledc ch%s gamma duty inc of current ram write address.This register is used to increase or decrease the duty of output signal on channel %s. 1: Increase0: Decrease.
                    CH_GAMMA_DUTY_INC:  u1, 
                    
                    /// [1:10] Ledc ch%s gamma duty cycle of current ram write address.The duty will change every LEDC_CH%s_GAMMA_DUTY_CYCLE on channel %s.
                    CH_GAMMA_DUTY_CYCLE:  u10, 
                    
                    /// [11:20] Ledc ch%s gamma scale of current ram write address.This register is used to configure the changing step scale of duty on channel %s.
                    CH_GAMMA_SCALE:  u10, 
                    
                    /// [21:30] Ledc ch%s gamma duty num of current ram write address.This register is used to control the number of times the duty cycle will be changed.
                    CH_GAMMA_DUTY_NUM:  u10, 
                    
                    /// [31:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000710c));
                
                /// Ledc ch%s gamma ram write register.
                pub const CH0_GAMMA_WR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Ledc ch%s gamma duty inc of current ram write address.This register is used to increase or decrease the duty of output signal on channel %s. 1: Increase0: Decrease.
                    CH_GAMMA_DUTY_INC:  u1, 
                    
                    /// [1:10] Ledc ch%s gamma duty cycle of current ram write address.The duty will change every LEDC_CH%s_GAMMA_DUTY_CYCLE on channel %s.
                    CH_GAMMA_DUTY_CYCLE:  u10, 
                    
                    /// [11:20] Ledc ch%s gamma scale of current ram write address.This register is used to configure the changing step scale of duty on channel %s.
                    CH_GAMMA_SCALE:  u10, 
                    
                    /// [21:30] Ledc ch%s gamma duty num of current ram write address.This register is used to control the number of times the duty cycle will be changed.
                    CH_GAMMA_DUTY_NUM:  u10, 
                    
                    /// [31:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60007110));
                
                /// Ledc ch%s gamma ram write register.
                pub const CH0_GAMMA_WR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Ledc ch%s gamma duty inc of current ram write address.This register is used to increase or decrease the duty of output signal on channel %s. 1: Increase0: Decrease.
                    CH_GAMMA_DUTY_INC:  u1, 
                    
                    /// [1:10] Ledc ch%s gamma duty cycle of current ram write address.The duty will change every LEDC_CH%s_GAMMA_DUTY_CYCLE on channel %s.
                    CH_GAMMA_DUTY_CYCLE:  u10, 
                    
                    /// [11:20] Ledc ch%s gamma scale of current ram write address.This register is used to configure the changing step scale of duty on channel %s.
                    CH_GAMMA_SCALE:  u10, 
                    
                    /// [21:30] Ledc ch%s gamma duty num of current ram write address.This register is used to control the number of times the duty cycle will be changed.
                    CH_GAMMA_DUTY_NUM:  u10, 
                    
                    /// [31:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60007114));
                
                /// Ledc ch%s gamma ram write address register.
                pub const CH0_GAMMA_WR_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:3] Ledc ch%s gamma ram write address.
                    CH_GAMMA_WR_ADDR:  u4, 
                    
                    /// [4:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60007104));
                
                /// Ledc ch%s gamma ram write address register.
                pub const CH0_GAMMA_WR_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:3] Ledc ch%s gamma ram write address.
                    CH_GAMMA_WR_ADDR:  u4, 
                    
                    /// [4:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60007108));
                
                /// Ledc ch%s gamma ram write address register.
                pub const CH0_GAMMA_WR_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:3] Ledc ch%s gamma ram write address.
                    CH_GAMMA_WR_ADDR:  u4, 
                    
                    /// [4:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000710c));
                
                /// Ledc ch%s gamma ram write address register.
                pub const CH0_GAMMA_WR_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:3] Ledc ch%s gamma ram write address.
                    CH_GAMMA_WR_ADDR:  u4, 
                    
                    /// [4:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60007110));
                
                /// Ledc ch%s gamma ram write address register.
                pub const CH0_GAMMA_WR_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:3] Ledc ch%s gamma ram write address.
                    CH_GAMMA_WR_ADDR:  u4, 
                    
                    /// [4:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60007114));
                
                /// Ledc ch%s gamma ram write address register.
                pub const CH0_GAMMA_WR_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:3] Ledc ch%s gamma ram write address.
                    CH_GAMMA_WR_ADDR:  u4, 
                    
                    /// [4:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60007118));
                
                /// Ledc ch%s gamma ram read address register.
                pub const CH0_GAMMA_RD_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:3] Ledc ch%s gamma ram read address.
                    CH_GAMMA_RD_ADDR:  u4, 
                    
                    /// [4:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60007108));
                
                /// Ledc ch%s gamma ram read address register.
                pub const CH0_GAMMA_RD_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:3] Ledc ch%s gamma ram read address.
                    CH_GAMMA_RD_ADDR:  u4, 
                    
                    /// [4:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000710c));
                
                /// Ledc ch%s gamma ram read address register.
                pub const CH0_GAMMA_RD_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:3] Ledc ch%s gamma ram read address.
                    CH_GAMMA_RD_ADDR:  u4, 
                    
                    /// [4:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60007110));
                
                /// Ledc ch%s gamma ram read address register.
                pub const CH0_GAMMA_RD_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:3] Ledc ch%s gamma ram read address.
                    CH_GAMMA_RD_ADDR:  u4, 
                    
                    /// [4:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60007114));
                
                /// Ledc ch%s gamma ram read address register.
                pub const CH0_GAMMA_RD_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:3] Ledc ch%s gamma ram read address.
                    CH_GAMMA_RD_ADDR:  u4, 
                    
                    /// [4:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60007118));
                
                /// Ledc ch%s gamma ram read address register.
                pub const CH0_GAMMA_RD_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:3] Ledc ch%s gamma ram read address.
                    CH_GAMMA_RD_ADDR:  u4, 
                    
                    /// [4:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000711c));
                
                /// Ledc ch%s gamma ram read data register.
                pub const CH0_GAMMA_RD_DATA = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:30] Ledc ch%s gamma ram read data.
                    CH_GAMMA_RD_DATA:  u31, 
                    
                    /// [31:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000710c));
                
                /// Ledc ch%s gamma ram read data register.
                pub const CH0_GAMMA_RD_DATA = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:30] Ledc ch%s gamma ram read data.
                    CH_GAMMA_RD_DATA:  u31, 
                    
                    /// [31:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60007110));
                
                /// Ledc ch%s gamma ram read data register.
                pub const CH0_GAMMA_RD_DATA = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:30] Ledc ch%s gamma ram read data.
                    CH_GAMMA_RD_DATA:  u31, 
                    
                    /// [31:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60007114));
                
                /// Ledc ch%s gamma ram read data register.
                pub const CH0_GAMMA_RD_DATA = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:30] Ledc ch%s gamma ram read data.
                    CH_GAMMA_RD_DATA:  u31, 
                    
                    /// [31:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60007118));
                
                /// Ledc ch%s gamma ram read data register.
                pub const CH0_GAMMA_RD_DATA = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:30] Ledc ch%s gamma ram read data.
                    CH_GAMMA_RD_DATA:  u31, 
                    
                    /// [31:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000711c));
                
                /// Ledc ch%s gamma ram read data register.
                pub const CH0_GAMMA_RD_DATA = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:30] Ledc ch%s gamma ram read data.
                    CH_GAMMA_RD_DATA:  u31, 
                    
                    /// [31:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60007120));
                
                /// Ledc ch%s gamma config register.
                pub const CH0_GAMMA_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:4] Ledc ch%s gamma entry num.
                    CH_GAMMA_ENTRY_NUM:  u5, 
                    
                    /// [5:5] Ledc ch%s gamma pause, write 1 to pause.
                    CH_GAMMA_PAUSE:  u1, 
                    
                    /// [6:6] Ledc ch%s gamma resume, write 1 to resume.
                    CH_GAMMA_RESUME:  u1, 
                    
                    /// [7:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60007180));
                
                /// Ledc ch%s gamma config register.
                pub const CH0_GAMMA_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:4] Ledc ch%s gamma entry num.
                    CH_GAMMA_ENTRY_NUM:  u5, 
                    
                    /// [5:5] Ledc ch%s gamma pause, write 1 to pause.
                    CH_GAMMA_PAUSE:  u1, 
                    
                    /// [6:6] Ledc ch%s gamma resume, write 1 to resume.
                    CH_GAMMA_RESUME:  u1, 
                    
                    /// [7:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60007184));
                
                /// Ledc ch%s gamma config register.
                pub const CH0_GAMMA_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:4] Ledc ch%s gamma entry num.
                    CH_GAMMA_ENTRY_NUM:  u5, 
                    
                    /// [5:5] Ledc ch%s gamma pause, write 1 to pause.
                    CH_GAMMA_PAUSE:  u1, 
                    
                    /// [6:6] Ledc ch%s gamma resume, write 1 to resume.
                    CH_GAMMA_RESUME:  u1, 
                    
                    /// [7:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60007188));
                
                /// Ledc ch%s gamma config register.
                pub const CH0_GAMMA_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:4] Ledc ch%s gamma entry num.
                    CH_GAMMA_ENTRY_NUM:  u5, 
                    
                    /// [5:5] Ledc ch%s gamma pause, write 1 to pause.
                    CH_GAMMA_PAUSE:  u1, 
                    
                    /// [6:6] Ledc ch%s gamma resume, write 1 to resume.
                    CH_GAMMA_RESUME:  u1, 
                    
                    /// [7:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000718c));
                
                /// Ledc ch%s gamma config register.
                pub const CH0_GAMMA_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:4] Ledc ch%s gamma entry num.
                    CH_GAMMA_ENTRY_NUM:  u5, 
                    
                    /// [5:5] Ledc ch%s gamma pause, write 1 to pause.
                    CH_GAMMA_PAUSE:  u1, 
                    
                    /// [6:6] Ledc ch%s gamma resume, write 1 to resume.
                    CH_GAMMA_RESUME:  u1, 
                    
                    /// [7:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60007190));
                
                /// Ledc ch%s gamma config register.
                pub const CH0_GAMMA_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:4] Ledc ch%s gamma entry num.
                    CH_GAMMA_ENTRY_NUM:  u5, 
                    
                    /// [5:5] Ledc ch%s gamma pause, write 1 to pause.
                    CH_GAMMA_PAUSE:  u1, 
                    
                    /// [6:6] Ledc ch%s gamma resume, write 1 to resume.
                    CH_GAMMA_RESUME:  u1, 
                    
                    /// [7:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60007194));
                
                /// Ledc event task enable bit register0.
                pub const EVT_TASK_EN0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Ledc ch0 duty change end event enable register, write 1 to enable this event.
                    EVT_DUTY_CHNG_END_CH0_EN:  u1, 
                    
                    /// [1:1] Ledc ch1 duty change end event enable register, write 1 to enable this event.
                    EVT_DUTY_CHNG_END_CH1_EN:  u1, 
                    
                    /// [2:2] Ledc ch2 duty change end event enable register, write 1 to enable this event.
                    EVT_DUTY_CHNG_END_CH2_EN:  u1, 
                    
                    /// [3:3] Ledc ch3 duty change end event enable register, write 1 to enable this event.
                    EVT_DUTY_CHNG_END_CH3_EN:  u1, 
                    
                    /// [4:4] Ledc ch4 duty change end event enable register, write 1 to enable this event.
                    EVT_DUTY_CHNG_END_CH4_EN:  u1, 
                    
                    /// [5:5] Ledc ch5 duty change end event enable register, write 1 to enable this event.
                    EVT_DUTY_CHNG_END_CH5_EN:  u1, 
                    
                    /// [6:7] 
                    res0:  u0, 
                    
                    /// [8:8] Ledc ch0 overflow count pulse event enable register, write 1 to enable this event.
                    EVT_OVF_CNT_PLS_CH0_EN:  u1, 
                    
                    /// [9:9] Ledc ch1 overflow count pulse event enable register, write 1 to enable this event.
                    EVT_OVF_CNT_PLS_CH1_EN:  u1, 
                    
                    /// [10:10] Ledc ch2 overflow count pulse event enable register, write 1 to enable this event.
                    EVT_OVF_CNT_PLS_CH2_EN:  u1, 
                    
                    /// [11:11] Ledc ch3 overflow count pulse event enable register, write 1 to enable this event.
                    EVT_OVF_CNT_PLS_CH3_EN:  u1, 
                    
                    /// [12:12] Ledc ch4 overflow count pulse event enable register, write 1 to enable this event.
                    EVT_OVF_CNT_PLS_CH4_EN:  u1, 
                    
                    /// [13:13] Ledc ch5 overflow count pulse event enable register, write 1 to enable this event.
                    EVT_OVF_CNT_PLS_CH5_EN:  u1, 
                    
                    /// [14:15] 
                    res1:  u0, 
                    
                    /// [16:16] Ledc timer0 overflow event enable register, write 1 to enable this event.
                    EVT_TIME_OVF_TIMER0_EN:  u1, 
                    
                    /// [17:17] Ledc timer1 overflow event enable register, write 1 to enable this event.
                    EVT_TIME_OVF_TIMER1_EN:  u1, 
                    
                    /// [18:18] Ledc timer2 overflow event enable register, write 1 to enable this event.
                    EVT_TIME_OVF_TIMER2_EN:  u1, 
                    
                    /// [19:19] Ledc timer3 overflow event enable register, write 1 to enable this event.
                    EVT_TIME_OVF_TIMER3_EN:  u1, 
                    
                    /// [20:20] Ledc timer0 compare event enable register, write 1 to enable this event.
                    EVT_TIME0_CMP_EN:  u1, 
                    
                    /// [21:21] Ledc timer1 compare event enable register, write 1 to enable this event.
                    EVT_TIME1_CMP_EN:  u1, 
                    
                    /// [22:22] Ledc timer2 compare event enable register, write 1 to enable this event.
                    EVT_TIME2_CMP_EN:  u1, 
                    
                    /// [23:23] Ledc timer3 compare event enable register, write 1 to enable this event.
                    EVT_TIME3_CMP_EN:  u1, 
                    
                    /// [24:24] Ledc ch0 duty scale update task enable register, write 1 to enable this task.
                    TASK_DUTY_SCALE_UPDATE_CH0_EN:  u1, 
                    
                    /// [25:25] Ledc ch1 duty scale update task enable register, write 1 to enable this task.
                    TASK_DUTY_SCALE_UPDATE_CH1_EN:  u1, 
                    
                    /// [26:26] Ledc ch2 duty scale update task enable register, write 1 to enable this task.
                    TASK_DUTY_SCALE_UPDATE_CH2_EN:  u1, 
                    
                    /// [27:27] Ledc ch3 duty scale update task enable register, write 1 to enable this task.
                    TASK_DUTY_SCALE_UPDATE_CH3_EN:  u1, 
                    
                    /// [28:28] Ledc ch4 duty scale update task enable register, write 1 to enable this task.
                    TASK_DUTY_SCALE_UPDATE_CH4_EN:  u1, 
                    
                    /// [29:29] Ledc ch5 duty scale update task enable register, write 1 to enable this task.
                    TASK_DUTY_SCALE_UPDATE_CH5_EN:  u1, 
                    
                    /// [30:31] 
                    res2:  u0, 
                    
                }), @ptrFromInt(0x600071a0));
                
                /// Ledc event task enable bit register1.
                pub const EVT_TASK_EN1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Ledc timer0 res update task enable register, write 1 to enable this task.
                    TASK_TIMER0_RES_UPDATE_EN:  u1, 
                    
                    /// [1:1] Ledc timer1 res update task enable register, write 1 to enable this task.
                    TASK_TIMER1_RES_UPDATE_EN:  u1, 
                    
                    /// [2:2] Ledc timer2 res update task enable register, write 1 to enable this task.
                    TASK_TIMER2_RES_UPDATE_EN:  u1, 
                    
                    /// [3:3] Ledc timer3 res update task enable register, write 1 to enable this task.
                    TASK_TIMER3_RES_UPDATE_EN:  u1, 
                    
                    /// [4:4] Ledc timer0 capture task enable register, write 1 to enable this task.
                    TASK_TIMER0_CAP_EN:  u1, 
                    
                    /// [5:5] Ledc timer1 capture task enable register, write 1 to enable this task.
                    TASK_TIMER1_CAP_EN:  u1, 
                    
                    /// [6:6] Ledc timer2 capture task enable register, write 1 to enable this task.
                    TASK_TIMER2_CAP_EN:  u1, 
                    
                    /// [7:7] Ledc timer3 capture task enable register, write 1 to enable this task.
                    TASK_TIMER3_CAP_EN:  u1, 
                    
                    /// [8:8] Ledc ch0 signal out disable task enable register, write 1 to enable this task.
                    TASK_SIG_OUT_DIS_CH0_EN:  u1, 
                    
                    /// [9:9] Ledc ch1 signal out disable task enable register, write 1 to enable this task.
                    TASK_SIG_OUT_DIS_CH1_EN:  u1, 
                    
                    /// [10:10] Ledc ch2 signal out disable task enable register, write 1 to enable this task.
                    TASK_SIG_OUT_DIS_CH2_EN:  u1, 
                    
                    /// [11:11] Ledc ch3 signal out disable task enable register, write 1 to enable this task.
                    TASK_SIG_OUT_DIS_CH3_EN:  u1, 
                    
                    /// [12:12] Ledc ch4 signal out disable task enable register, write 1 to enable this task.
                    TASK_SIG_OUT_DIS_CH4_EN:  u1, 
                    
                    /// [13:13] Ledc ch5 signal out disable task enable register, write 1 to enable this task.
                    TASK_SIG_OUT_DIS_CH5_EN:  u1, 
                    
                    /// [14:15] 
                    res0:  u0, 
                    
                    /// [16:16] Ledc ch0 overflow count reset task enable register, write 1 to enable this task.
                    TASK_OVF_CNT_RST_CH0_EN:  u1, 
                    
                    /// [17:17] Ledc ch1 overflow count reset task enable register, write 1 to enable this task.
                    TASK_OVF_CNT_RST_CH1_EN:  u1, 
                    
                    /// [18:18] Ledc ch2 overflow count reset task enable register, write 1 to enable this task.
                    TASK_OVF_CNT_RST_CH2_EN:  u1, 
                    
                    /// [19:19] Ledc ch3 overflow count reset task enable register, write 1 to enable this task.
                    TASK_OVF_CNT_RST_CH3_EN:  u1, 
                    
                    /// [20:20] Ledc ch4 overflow count reset task enable register, write 1 to enable this task.
                    TASK_OVF_CNT_RST_CH4_EN:  u1, 
                    
                    /// [21:21] Ledc ch5 overflow count reset task enable register, write 1 to enable this task.
                    TASK_OVF_CNT_RST_CH5_EN:  u1, 
                    
                    /// [22:23] 
                    res1:  u0, 
                    
                    /// [24:24] Ledc timer0 reset task enable register, write 1 to enable this task.
                    TASK_TIMER0_RST_EN:  u1, 
                    
                    /// [25:25] Ledc timer1 reset task enable register, write 1 to enable this task.
                    TASK_TIMER1_RST_EN:  u1, 
                    
                    /// [26:26] Ledc timer2 reset task enable register, write 1 to enable this task.
                    TASK_TIMER2_RST_EN:  u1, 
                    
                    /// [27:27] Ledc timer3 reset task enable register, write 1 to enable this task.
                    TASK_TIMER3_RST_EN:  u1, 
                    
                    /// [28:28] Ledc timer0 pause resume task enable register, write 1 to enable this task.
                    TASK_TIMER0_PAUSE_RESUME_EN:  u1, 
                    
                    /// [29:29] Ledc timer1 pause resume task enable register, write 1 to enable this task.
                    TASK_TIMER1_PAUSE_RESUME_EN:  u1, 
                    
                    /// [30:30] Ledc timer2 pause resume task enable register, write 1 to enable this task.
                    TASK_TIMER2_PAUSE_RESUME_EN:  u1, 
                    
                    /// [31:31] Ledc timer3 pause resume task enable register, write 1 to enable this task.
                    TASK_TIMER3_PAUSE_RESUME_EN:  u1, 
                    
                }), @ptrFromInt(0x600071a4));
                
                /// Ledc event task enable bit register2.
                pub const EVT_TASK_EN2 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Ledc ch0 gamma restart task enable register, write 1 to enable this task.
                    TASK_GAMMA_RESTART_CH0_EN:  u1, 
                    
                    /// [1:1] Ledc ch1 gamma restart task enable register, write 1 to enable this task.
                    TASK_GAMMA_RESTART_CH1_EN:  u1, 
                    
                    /// [2:2] Ledc ch2 gamma restart task enable register, write 1 to enable this task.
                    TASK_GAMMA_RESTART_CH2_EN:  u1, 
                    
                    /// [3:3] Ledc ch3 gamma restart task enable register, write 1 to enable this task.
                    TASK_GAMMA_RESTART_CH3_EN:  u1, 
                    
                    /// [4:4] Ledc ch4 gamma restart task enable register, write 1 to enable this task.
                    TASK_GAMMA_RESTART_CH4_EN:  u1, 
                    
                    /// [5:5] Ledc ch5 gamma restart task enable register, write 1 to enable this task.
                    TASK_GAMMA_RESTART_CH5_EN:  u1, 
                    
                    /// [6:7] 
                    res0:  u0, 
                    
                    /// [8:8] Ledc ch0 gamma pause task enable register, write 1 to enable this task.
                    TASK_GAMMA_PAUSE_CH0_EN:  u1, 
                    
                    /// [9:9] Ledc ch1 gamma pause task enable register, write 1 to enable this task.
                    TASK_GAMMA_PAUSE_CH1_EN:  u1, 
                    
                    /// [10:10] Ledc ch2 gamma pause task enable register, write 1 to enable this task.
                    TASK_GAMMA_PAUSE_CH2_EN:  u1, 
                    
                    /// [11:11] Ledc ch3 gamma pause task enable register, write 1 to enable this task.
                    TASK_GAMMA_PAUSE_CH3_EN:  u1, 
                    
                    /// [12:12] Ledc ch4 gamma pause task enable register, write 1 to enable this task.
                    TASK_GAMMA_PAUSE_CH4_EN:  u1, 
                    
                    /// [13:13] Ledc ch5 gamma pause task enable register, write 1 to enable this task.
                    TASK_GAMMA_PAUSE_CH5_EN:  u1, 
                    
                    /// [14:15] 
                    res1:  u0, 
                    
                    /// [16:16] Ledc ch0 gamma resume task enable register, write 1 to enable this task.
                    TASK_GAMMA_RESUME_CH0_EN:  u1, 
                    
                    /// [17:17] Ledc ch1 gamma resume task enable register, write 1 to enable this task.
                    TASK_GAMMA_RESUME_CH1_EN:  u1, 
                    
                    /// [18:18] Ledc ch2 gamma resume task enable register, write 1 to enable this task.
                    TASK_GAMMA_RESUME_CH2_EN:  u1, 
                    
                    /// [19:19] Ledc ch3 gamma resume task enable register, write 1 to enable this task.
                    TASK_GAMMA_RESUME_CH3_EN:  u1, 
                    
                    /// [20:20] Ledc ch4 gamma resume task enable register, write 1 to enable this task.
                    TASK_GAMMA_RESUME_CH4_EN:  u1, 
                    
                    /// [21:21] Ledc ch5 gamma resume task enable register, write 1 to enable this task.
                    TASK_GAMMA_RESUME_CH5_EN:  u1, 
                    
                    /// [22:31] 
                    res2:  u0, 
                    
                }), @ptrFromInt(0x600071a8));
                
                /// Ledc timer%s compare value register.
                pub const TIMER0_CMP = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:19] This register stores ledc timer%s compare value.
                    TIMER_CMP:  u20, 
                    
                    /// [20:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600071b0));
                
                /// Ledc timer%s compare value register.
                pub const TIMER0_CMP = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:19] This register stores ledc timer%s compare value.
                    TIMER_CMP:  u20, 
                    
                    /// [20:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600071b4));
                
                /// Ledc timer%s compare value register.
                pub const TIMER0_CMP = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:19] This register stores ledc timer%s compare value.
                    TIMER_CMP:  u20, 
                    
                    /// [20:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600071b8));
                
                /// Ledc timer%s compare value register.
                pub const TIMER0_CMP = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:19] This register stores ledc timer%s compare value.
                    TIMER_CMP:  u20, 
                    
                    /// [20:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600071bc));
                
                /// Ledc timer%s count value capture register.
                pub const TIMER0_CNT_CAP = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:19] This register stores ledc timer%s count value.
                    TIMER_CNT_CAP:  u20, 
                    
                    /// [20:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600071c0));
                
                /// Ledc timer%s count value capture register.
                pub const TIMER0_CNT_CAP = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:19] This register stores ledc timer%s count value.
                    TIMER_CNT_CAP:  u20, 
                    
                    /// [20:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600071c4));
                
                /// Ledc timer%s count value capture register.
                pub const TIMER0_CNT_CAP = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:19] This register stores ledc timer%s count value.
                    TIMER_CNT_CAP:  u20, 
                    
                    /// [20:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600071c8));
                
                /// Ledc timer%s count value capture register.
                pub const TIMER0_CNT_CAP = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:19] This register stores ledc timer%s count value.
                    TIMER_CNT_CAP:  u20, 
                    
                    /// [20:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600071cc));
                
                /// Global ledc configuration register
                pub const CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:1] This bit is used to select clock source for the 4 timers .2'd1: APB_CLK 2'd2: RTC8M_CLK 2'd3: XTAL_CLK
                    APB_CLK_SEL:  u2, 
                    
                    /// [2:2] This bit is used to control clock.1'b1: Force clock on for gamma ram. 1'h0: Support clock only when application writes or read gamma ram.
                    GAMMA_RAM_CLK_EN_CH0:  u1, 
                    
                    /// [3:3] This bit is used to control clock.1'b1: Force clock on for gamma ram. 1'h0: Support clock only when application writes or read gamma ram.
                    GAMMA_RAM_CLK_EN_CH1:  u1, 
                    
                    /// [4:4] This bit is used to control clock.1'b1: Force clock on for gamma ram. 1'h0: Support clock only when application writes or read gamma ram.
                    GAMMA_RAM_CLK_EN_CH2:  u1, 
                    
                    /// [5:5] This bit is used to control clock.1'b1: Force clock on for gamma ram. 1'h0: Support clock only when application writes or read gamma ram.
                    GAMMA_RAM_CLK_EN_CH3:  u1, 
                    
                    /// [6:6] This bit is used to control clock.1'b1: Force clock on for gamma ram. 1'h0: Support clock only when application writes or read gamma ram.
                    GAMMA_RAM_CLK_EN_CH4:  u1, 
                    
                    /// [7:7] This bit is used to control clock.1'b1: Force clock on for gamma ram. 1'h0: Support clock only when application writes or read gamma ram.
                    GAMMA_RAM_CLK_EN_CH5:  u1, 
                    
                    /// [8:30] 
                    res0:  u0, 
                    
                    /// [31:31] This bit is used to control clock.1'b1: Force clock on for register. 1'h0: Support clock only when application writes registers.
                    CLK_EN:  u1, 
                    
                }), @ptrFromInt(0x600071f0));
                
                /// Version control register
                pub const DATE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:27] This is the version control register.
                    LEDC_DATE:  u28, 
                    
                    /// [28:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600071fc));
                
            };
            
            /// LP_PERI Peripheral
            pub const LP_PERI = struct {
                
                /// need_des
                pub const CLK_EN = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:22] 
                    res0:  u0, 
                    
                    /// [23:23] need_des
                    LP_TOUCH_CK_EN:  u1, 
                    
                    /// [24:24] need_des
                    RNG_CK_EN:  u1, 
                    
                    /// [25:25] need_des
                    OTP_DBG_CK_EN:  u1, 
                    
                    /// [26:26] need_des
                    LP_UART_CK_EN:  u1, 
                    
                    /// [27:27] need_des
                    LP_IO_CK_EN:  u1, 
                    
                    /// [28:28] need_des
                    LP_EXT_I2C_CK_EN:  u1, 
                    
                    /// [29:29] need_des
                    LP_ANA_I2C_CK_EN:  u1, 
                    
                    /// [30:30] need_des
                    EFUSE_CK_EN:  u1, 
                    
                    /// [31:31] need_des
                    LP_CPU_CK_EN:  u1, 
                    
                }), @ptrFromInt(0x600b2800));
                
                /// need_des
                pub const RESET_EN = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:22] 
                    res0:  u0, 
                    
                    /// [23:23] need_des
                    BUS_RESET_EN:  u1, 
                    
                    /// [24:24] need_des
                    LP_TOUCH_RESET_EN:  u1, 
                    
                    /// [25:25] need_des
                    OTP_DBG_RESET_EN:  u1, 
                    
                    /// [26:26] need_des
                    LP_UART_RESET_EN:  u1, 
                    
                    /// [27:27] need_des
                    LP_IO_RESET_EN:  u1, 
                    
                    /// [28:28] need_des
                    LP_EXT_I2C_RESET_EN:  u1, 
                    
                    /// [29:29] need_des
                    LP_ANA_I2C_RESET_EN:  u1, 
                    
                    /// [30:30] need_des
                    EFUSE_RESET_EN:  u1, 
                    
                    /// [31:31] need_des
                    LP_CPU_RESET_EN:  u1, 
                    
                }), @ptrFromInt(0x600b2804));
                
                /// need_des
                pub const RNG_DATA = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] need_des
                    RND_DATA:  u32, 
                    
                }), @ptrFromInt(0x600b2808));
                
                /// need_des
                pub const CPU = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:30] 
                    res0:  u0, 
                    
                    /// [31:31] need_des
                    LPCORE_DBGM_UNAVALIABLE:  u1, 
                    
                }), @ptrFromInt(0x600b280c));
                
                /// need_des
                pub const BUS_TIMEOUT = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:13] 
                    res0:  u0, 
                    
                    /// [14:29] need_des
                    LP_PERI_TIMEOUT_THRES:  u16, 
                    
                    /// [30:30] need_des
                    LP_PERI_TIMEOUT_INT_CLEAR:  u1, 
                    
                    /// [31:31] need_des
                    LP_PERI_TIMEOUT_PROTECT_EN:  u1, 
                    
                }), @ptrFromInt(0x600b2810));
                
                /// need_des
                pub const BUS_TIMEOUT_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] need_des
                    LP_PERI_TIMEOUT_ADDR:  u32, 
                    
                }), @ptrFromInt(0x600b2814));
                
                /// need_des
                pub const BUS_TIMEOUT_UID = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:6] need_des
                    LP_PERI_TIMEOUT_UID:  u7, 
                    
                    /// [7:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600b2818));
                
                /// need_des
                pub const MEM_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] need_des
                    UART_WAKEUP_FLAG_CLR:  u1, 
                    
                    /// [1:1] need_des
                    UART_WAKEUP_FLAG:  u1, 
                    
                    /// [2:28] 
                    res0:  u0, 
                    
                    /// [29:29] need_des
                    UART_WAKEUP_EN:  u1, 
                    
                    /// [30:30] need_des
                    UART_MEM_FORCE_PD:  u1, 
                    
                    /// [31:31] need_des
                    UART_MEM_FORCE_PU:  u1, 
                    
                }), @ptrFromInt(0x600b281c));
                
                /// need_des
                pub const INTERRUPT_SOURCE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] BIT5~BIT0: pmu_lp_int, modem_lp_int, lp_timer_lp_int, lp_uart_int, lp_i2c_int, lp_io_int
                    LP_INTERRUPT_SOURCE:  u6, 
                    
                    /// [6:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600b2820));
                
                /// need_des
                pub const DATE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:30] need_des
                    LPPERI_DATE:  u31, 
                    
                    /// [31:31] need_des
                    CLK_EN:  u1, 
                    
                }), @ptrFromInt(0x600b2bfc));
                
            };
            
            /// LP_ANA Peripheral
            pub const LP_ANA = struct {
                
                /// need_des
                pub const BOD_MODE0_CNTL = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] 
                    res0:  u0, 
                    
                    /// [6:6] need_des
                    BOD_MODE0_CLOSE_FLASH_ENA:  u1, 
                    
                    /// [7:7] need_des
                    BOD_MODE0_PD_RF_ENA:  u1, 
                    
                    /// [8:17] need_des
                    BOD_MODE0_INTR_WAIT:  u10, 
                    
                    /// [18:27] need_des
                    BOD_MODE0_RESET_WAIT:  u10, 
                    
                    /// [28:28] need_des
                    BOD_MODE0_CNT_CLR:  u1, 
                    
                    /// [29:29] need_des
                    BOD_MODE0_INTR_ENA:  u1, 
                    
                    /// [30:30] need_des
                    BOD_MODE0_RESET_SEL:  u1, 
                    
                    /// [31:31] need_des
                    BOD_MODE0_RESET_ENA:  u1, 
                    
                }), @ptrFromInt(0x600b2c00));
                
                /// need_des
                pub const BOD_MODE1_CNTL = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:30] 
                    res0:  u0, 
                    
                    /// [31:31] need_des
                    BOD_MODE1_RESET_ENA:  u1, 
                    
                }), @ptrFromInt(0x600b2c04));
                
                /// need_des
                pub const CK_GLITCH_CNTL = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:30] 
                    res0:  u0, 
                    
                    /// [31:31] need_des
                    CK_GLITCH_RESET_ENA:  u1, 
                    
                }), @ptrFromInt(0x600b2c08));
                
                /// need_des
                pub const FIB_ENABLE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] need_des
                    ANA_FIB_ENA:  u32, 
                    
                }), @ptrFromInt(0x600b2c0c));
                
                /// need_des
                pub const INT_RAW = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:30] 
                    res0:  u0, 
                    
                    /// [31:31] need_des
                    BOD_MODE0_INT_RAW:  u1, 
                    
                }), @ptrFromInt(0x600b2c10));
                
                /// need_des
                pub const INT_ST = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:30] 
                    res0:  u0, 
                    
                    /// [31:31] need_des
                    BOD_MODE0_INT_ST:  u1, 
                    
                }), @ptrFromInt(0x600b2c14));
                
                /// need_des
                pub const INT_ENA = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:30] 
                    res0:  u0, 
                    
                    /// [31:31] need_des
                    BOD_MODE0_INT_ENA:  u1, 
                    
                }), @ptrFromInt(0x600b2c18));
                
                /// need_des
                pub const INT_CLR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:30] 
                    res0:  u0, 
                    
                    /// [31:31] need_des
                    BOD_MODE0_INT_CLR:  u1, 
                    
                }), @ptrFromInt(0x600b2c1c));
                
                /// need_des
                pub const LP_INT_RAW = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:30] 
                    res0:  u0, 
                    
                    /// [31:31] need_des
                    BOD_MODE0_LP_INT_RAW:  u1, 
                    
                }), @ptrFromInt(0x600b2c20));
                
                /// need_des
                pub const LP_INT_ST = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:30] 
                    res0:  u0, 
                    
                    /// [31:31] need_des
                    BOD_MODE0_LP_INT_ST:  u1, 
                    
                }), @ptrFromInt(0x600b2c24));
                
                /// need_des
                pub const LP_INT_ENA = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:30] 
                    res0:  u0, 
                    
                    /// [31:31] need_des
                    BOD_MODE0_LP_INT_ENA:  u1, 
                    
                }), @ptrFromInt(0x600b2c28));
                
                /// need_des
                pub const LP_INT_CLR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:30] 
                    res0:  u0, 
                    
                    /// [31:31] need_des
                    BOD_MODE0_LP_INT_CLR:  u1, 
                    
                }), @ptrFromInt(0x600b2c2c));
                
                /// need_des
                pub const DATE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:30] need_des
                    LP_ANA_DATE:  u31, 
                    
                    /// [31:31] need_des
                    CLK_EN:  u1, 
                    
                }), @ptrFromInt(0x600b2ffc));
                
            };
            
            /// LP_AON Peripheral
            pub const LP_AON = struct {
                
                /// need_des
                pub const STORE0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] need_des
                    LP_AON_STORE0:  u32, 
                    
                }), @ptrFromInt(0x600b1000));
                
                /// need_des
                pub const STORE1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] need_des
                    LP_AON_STORE1:  u32, 
                    
                }), @ptrFromInt(0x600b1004));
                
                /// need_des
                pub const STORE2 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] need_des
                    LP_AON_STORE2:  u32, 
                    
                }), @ptrFromInt(0x600b1008));
                
                /// need_des
                pub const STORE3 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] need_des
                    LP_AON_STORE3:  u32, 
                    
                }), @ptrFromInt(0x600b100c));
                
                /// need_des
                pub const STORE4 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] need_des
                    LP_AON_STORE4:  u32, 
                    
                }), @ptrFromInt(0x600b1010));
                
                /// need_des
                pub const STORE5 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] need_des
                    LP_AON_STORE5:  u32, 
                    
                }), @ptrFromInt(0x600b1014));
                
                /// need_des
                pub const STORE6 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] need_des
                    LP_AON_STORE6:  u32, 
                    
                }), @ptrFromInt(0x600b1018));
                
                /// need_des
                pub const STORE7 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] need_des
                    LP_AON_STORE7:  u32, 
                    
                }), @ptrFromInt(0x600b101c));
                
                /// need_des
                pub const STORE8 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] need_des
                    LP_AON_STORE8:  u32, 
                    
                }), @ptrFromInt(0x600b1020));
                
                /// need_des
                pub const STORE9 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] need_des
                    LP_AON_STORE9:  u32, 
                    
                }), @ptrFromInt(0x600b1024));
                
                /// need_des
                pub const GPIO_MUX = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] need_des
                    SEL:  u8, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600b1028));
                
                /// need_des
                pub const GPIO_HOLD0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] need_des
                    GPIO_HOLD0:  u32, 
                    
                }), @ptrFromInt(0x600b102c));
                
                /// need_des
                pub const GPIO_HOLD1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] need_des
                    GPIO_HOLD1:  u32, 
                    
                }), @ptrFromInt(0x600b1030));
                
                /// need_des
                pub const SYS_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:29] 
                    res0:  u0, 
                    
                    /// [30:30] need_des
                    FORCE_DOWNLOAD_BOOT:  u1, 
                    
                    /// [31:31] need_des
                    HPSYS_SW_RESET:  u1, 
                    
                }), @ptrFromInt(0x600b1034));
                
                /// need_des
                pub const CPUCORE0_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] need_des
                    CPU_CORE0_SW_STALL:  u8, 
                    
                    /// [8:27] 
                    res0:  u0, 
                    
                    /// [28:28] need_des
                    CPU_CORE0_SW_RESET:  u1, 
                    
                    /// [29:29] need_des
                    CPU_CORE0_OCD_HALT_ON_RESET:  u1, 
                    
                    /// [30:30] need_des
                    CPU_CORE0_STAT_VECTOR_SEL:  u1, 
                    
                    /// [31:31] need_des
                    CPU_CORE0_DRESET_MASK:  u1, 
                    
                }), @ptrFromInt(0x600b1038));
                
                /// need_des
                pub const IO_MUX = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:30] 
                    res0:  u0, 
                    
                    /// [31:31] need_des
                    RESET_DISABLE:  u1, 
                    
                }), @ptrFromInt(0x600b103c));
                
                /// need_des
                pub const EXT_WAKEUP_CNTL = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] need_des
                    EXT_WAKEUP_STATUS:  u8, 
                    
                    /// [8:13] 
                    res0:  u0, 
                    
                    /// [14:14] need_des
                    EXT_WAKEUP_STATUS_CLR:  u1, 
                    
                    /// [15:22] need_des
                    EXT_WAKEUP_SEL:  u8, 
                    
                    /// [23:30] need_des
                    EXT_WAKEUP_LV:  u8, 
                    
                    /// [31:31] need_des
                    EXT_WAKEUP_FILTER:  u1, 
                    
                }), @ptrFromInt(0x600b1040));
                
                /// need_des
                pub const USB = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:30] 
                    res0:  u0, 
                    
                    /// [31:31] need_des
                    RESET_DISABLE:  u1, 
                    
                }), @ptrFromInt(0x600b1044));
                
                /// need_des
                pub const LPBUS = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:15] 
                    res0:  u0, 
                    
                    /// [16:18] This field controls fast memory WPULSE parameter.
                    FAST_MEM_WPULSE:  u3, 
                    
                    /// [19:21] This field controls fast memory WA parameter.
                    FAST_MEM_WA:  u3, 
                    
                    /// [22:23] This field controls fast memory RA parameter.
                    FAST_MEM_RA:  u2, 
                    
                    /// [24:27] 
                    res1:  u0, 
                    
                    /// [28:28] need_des
                    FAST_MEM_MUX_FSM_IDLE:  u1, 
                    
                    /// [29:29] need_des
                    FAST_MEM_MUX_SEL_STATUS:  u1, 
                    
                    /// [30:30] need_des
                    FAST_MEM_MUX_SEL_UPDATE:  u1, 
                    
                    /// [31:31] need_des
                    FAST_MEM_MUX_SEL:  u1, 
                    
                }), @ptrFromInt(0x600b1048));
                
                /// need_des
                pub const SDIO_ACTIVE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:21] 
                    res0:  u0, 
                    
                    /// [22:31] need_des
                    SDIO_ACT_DNUM:  u10, 
                    
                }), @ptrFromInt(0x600b104c));
                
                /// need_des
                pub const LPCORE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] need_des
                    ETM_WAKEUP_FLAG_CLR:  u1, 
                    
                    /// [1:1] need_des
                    ETM_WAKEUP_FLAG:  u1, 
                    
                    /// [2:30] 
                    res0:  u0, 
                    
                    /// [31:31] need_des
                    DISABLE:  u1, 
                    
                }), @ptrFromInt(0x600b1050));
                
                /// need_des
                pub const SAR_CCT = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:28] 
                    res0:  u0, 
                    
                    /// [29:31] need_des
                    SAR2_PWDET_CCT:  u3, 
                    
                }), @ptrFromInt(0x600b1054));
                
                /// need_des
                pub const DATE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:30] need_des
                    DATE:  u31, 
                    
                    /// [31:31] need_des
                    CLK_EN:  u1, 
                    
                }), @ptrFromInt(0x600b13fc));
                
            };
            
            /// Low-power Access Permission Management Controller
            pub const LP_APM = struct {
                
                /// Region filter enable register
                pub const REGION_FILTER_EN = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:3] Region filter enable
                    REGION_FILTER_EN:  u4, 
                    
                    /// [4:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600b3800));
                
                /// Region address register
                pub const REGION0_ADDR_START = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Start address of region0
                    REGION0_ADDR_START:  u32, 
                    
                }), @ptrFromInt(0x600b3804));
                
                /// Region address register
                pub const REGION0_ADDR_END = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] End address of region0
                    REGION0_ADDR_END:  u32, 
                    
                }), @ptrFromInt(0x600b3808));
                
                /// Region access authority attribute register
                pub const REGION0_PMS_ATTR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Region execute authority in REE_MODE0
                    REGION0_R0_PMS_X:  u1, 
                    
                    /// [1:1] Region write authority in REE_MODE0
                    REGION0_R0_PMS_W:  u1, 
                    
                    /// [2:2] Region read authority in REE_MODE0
                    REGION0_R0_PMS_R:  u1, 
                    
                    /// [3:3] 
                    res0:  u0, 
                    
                    /// [4:4] Region execute authority in REE_MODE1
                    REGION0_R1_PMS_X:  u1, 
                    
                    /// [5:5] Region write authority in REE_MODE1
                    REGION0_R1_PMS_W:  u1, 
                    
                    /// [6:6] Region read authority in REE_MODE1
                    REGION0_R1_PMS_R:  u1, 
                    
                    /// [7:7] 
                    res1:  u0, 
                    
                    /// [8:8] Region execute authority in REE_MODE2
                    REGION0_R2_PMS_X:  u1, 
                    
                    /// [9:9] Region write authority in REE_MODE2
                    REGION0_R2_PMS_W:  u1, 
                    
                    /// [10:10] Region read authority in REE_MODE2
                    REGION0_R2_PMS_R:  u1, 
                    
                    /// [11:31] 
                    res2:  u0, 
                    
                }), @ptrFromInt(0x600b380c));
                
                /// Region address register
                pub const REGION1_ADDR_START = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Start address of region1
                    REGION1_ADDR_START:  u32, 
                    
                }), @ptrFromInt(0x600b3810));
                
                /// Region address register
                pub const REGION1_ADDR_END = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] End address of region1
                    REGION1_ADDR_END:  u32, 
                    
                }), @ptrFromInt(0x600b3814));
                
                /// Region access authority attribute register
                pub const REGION1_PMS_ATTR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Region execute authority in REE_MODE0
                    REGION1_R0_PMS_X:  u1, 
                    
                    /// [1:1] Region write authority in REE_MODE0
                    REGION1_R0_PMS_W:  u1, 
                    
                    /// [2:2] Region read authority in REE_MODE0
                    REGION1_R0_PMS_R:  u1, 
                    
                    /// [3:3] 
                    res0:  u0, 
                    
                    /// [4:4] Region execute authority in REE_MODE1
                    REGION1_R1_PMS_X:  u1, 
                    
                    /// [5:5] Region write authority in REE_MODE1
                    REGION1_R1_PMS_W:  u1, 
                    
                    /// [6:6] Region read authority in REE_MODE1
                    REGION1_R1_PMS_R:  u1, 
                    
                    /// [7:7] 
                    res1:  u0, 
                    
                    /// [8:8] Region execute authority in REE_MODE2
                    REGION1_R2_PMS_X:  u1, 
                    
                    /// [9:9] Region write authority in REE_MODE2
                    REGION1_R2_PMS_W:  u1, 
                    
                    /// [10:10] Region read authority in REE_MODE2
                    REGION1_R2_PMS_R:  u1, 
                    
                    /// [11:31] 
                    res2:  u0, 
                    
                }), @ptrFromInt(0x600b3818));
                
                /// Region address register
                pub const REGION2_ADDR_START = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Start address of region2
                    REGION2_ADDR_START:  u32, 
                    
                }), @ptrFromInt(0x600b381c));
                
                /// Region address register
                pub const REGION2_ADDR_END = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] End address of region2
                    REGION2_ADDR_END:  u32, 
                    
                }), @ptrFromInt(0x600b3820));
                
                /// Region access authority attribute register
                pub const REGION2_PMS_ATTR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Region execute authority in REE_MODE0
                    REGION2_R0_PMS_X:  u1, 
                    
                    /// [1:1] Region write authority in REE_MODE0
                    REGION2_R0_PMS_W:  u1, 
                    
                    /// [2:2] Region read authority in REE_MODE0
                    REGION2_R0_PMS_R:  u1, 
                    
                    /// [3:3] 
                    res0:  u0, 
                    
                    /// [4:4] Region execute authority in REE_MODE1
                    REGION2_R1_PMS_X:  u1, 
                    
                    /// [5:5] Region write authority in REE_MODE1
                    REGION2_R1_PMS_W:  u1, 
                    
                    /// [6:6] Region read authority in REE_MODE1
                    REGION2_R1_PMS_R:  u1, 
                    
                    /// [7:7] 
                    res1:  u0, 
                    
                    /// [8:8] Region execute authority in REE_MODE2
                    REGION2_R2_PMS_X:  u1, 
                    
                    /// [9:9] Region write authority in REE_MODE2
                    REGION2_R2_PMS_W:  u1, 
                    
                    /// [10:10] Region read authority in REE_MODE2
                    REGION2_R2_PMS_R:  u1, 
                    
                    /// [11:31] 
                    res2:  u0, 
                    
                }), @ptrFromInt(0x600b3824));
                
                /// Region address register
                pub const REGION3_ADDR_START = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Start address of region3
                    REGION3_ADDR_START:  u32, 
                    
                }), @ptrFromInt(0x600b3828));
                
                /// Region address register
                pub const REGION3_ADDR_END = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] End address of region3
                    REGION3_ADDR_END:  u32, 
                    
                }), @ptrFromInt(0x600b382c));
                
                /// Region access authority attribute register
                pub const REGION3_PMS_ATTR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Region execute authority in REE_MODE0
                    REGION3_R0_PMS_X:  u1, 
                    
                    /// [1:1] Region write authority in REE_MODE0
                    REGION3_R0_PMS_W:  u1, 
                    
                    /// [2:2] Region read authority in REE_MODE0
                    REGION3_R0_PMS_R:  u1, 
                    
                    /// [3:3] 
                    res0:  u0, 
                    
                    /// [4:4] Region execute authority in REE_MODE1
                    REGION3_R1_PMS_X:  u1, 
                    
                    /// [5:5] Region write authority in REE_MODE1
                    REGION3_R1_PMS_W:  u1, 
                    
                    /// [6:6] Region read authority in REE_MODE1
                    REGION3_R1_PMS_R:  u1, 
                    
                    /// [7:7] 
                    res1:  u0, 
                    
                    /// [8:8] Region execute authority in REE_MODE2
                    REGION3_R2_PMS_X:  u1, 
                    
                    /// [9:9] Region write authority in REE_MODE2
                    REGION3_R2_PMS_W:  u1, 
                    
                    /// [10:10] Region read authority in REE_MODE2
                    REGION3_R2_PMS_R:  u1, 
                    
                    /// [11:31] 
                    res2:  u0, 
                    
                }), @ptrFromInt(0x600b3830));
                
                /// PMS function control register
                pub const FUNC_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] PMS M0 function enable
                    M0_PMS_FUNC_EN:  u1, 
                    
                    /// [1:1] PMS M1 function enable
                    M1_PMS_FUNC_EN:  u1, 
                    
                    /// [2:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600b38c4));
                
                /// M0 status register
                pub const M0_STATUS = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:1] Exception status
                    M0_EXCEPTION_STATUS:  u2, 
                    
                    /// [2:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600b38c8));
                
                /// M0 status clear register
                pub const M0_STATUS_CLR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Clear exception status
                    M0_REGION_STATUS_CLR:  u1, 
                    
                    /// [1:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600b38cc));
                
                /// M0 exception_info0 register
                pub const M0_EXCEPTION_INFO0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:3] Exception region
                    M0_EXCEPTION_REGION:  u4, 
                    
                    /// [4:15] 
                    res0:  u0, 
                    
                    /// [16:17] Exception mode
                    M0_EXCEPTION_MODE:  u2, 
                    
                    /// [18:22] Exception id information
                    M0_EXCEPTION_ID:  u5, 
                    
                    /// [23:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x600b38d0));
                
                /// M0 exception_info1 register
                pub const M0_EXCEPTION_INFO1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Exception addr
                    M0_EXCEPTION_ADDR:  u32, 
                    
                }), @ptrFromInt(0x600b38d4));
                
                /// M1 status register
                pub const M1_STATUS = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:1] Exception status
                    M1_EXCEPTION_STATUS:  u2, 
                    
                    /// [2:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600b38d8));
                
                /// M1 status clear register
                pub const M1_STATUS_CLR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Clear exception status
                    M1_REGION_STATUS_CLR:  u1, 
                    
                    /// [1:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600b38dc));
                
                /// M1 exception_info0 register
                pub const M1_EXCEPTION_INFO0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:3] Exception region
                    M1_EXCEPTION_REGION:  u4, 
                    
                    /// [4:15] 
                    res0:  u0, 
                    
                    /// [16:17] Exception mode
                    M1_EXCEPTION_MODE:  u2, 
                    
                    /// [18:22] Exception id information
                    M1_EXCEPTION_ID:  u5, 
                    
                    /// [23:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x600b38e0));
                
                /// M1 exception_info1 register
                pub const M1_EXCEPTION_INFO1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Exception addr
                    M1_EXCEPTION_ADDR:  u32, 
                    
                }), @ptrFromInt(0x600b38e4));
                
                /// APM interrupt enable register
                pub const INT_EN = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] APM M0 interrupt enable
                    M0_APM_INT_EN:  u1, 
                    
                    /// [1:1] APM M1 interrupt enable
                    M1_APM_INT_EN:  u1, 
                    
                    /// [2:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600b38e8));
                
                /// clock gating register
                pub const CLOCK_GATE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] reg_clk_en
                    CLK_EN:  u1, 
                    
                    /// [1:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600b38ec));
                
                /// Version register
                pub const DATE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:27] reg_date
                    DATE:  u28, 
                    
                    /// [28:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600b38fc));
                
            };
            
            /// LP_APM0 Peripheral
            pub const LP_APM0 = struct {
                
                /// Region filter enable register
                pub const REGION_FILTER_EN = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:3] Region filter enable
                    REGION_FILTER_EN:  u4, 
                    
                    /// [4:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60099800));
                
                /// Region address register
                pub const REGION0_ADDR_START = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Start address of region0
                    REGION0_ADDR_START:  u32, 
                    
                }), @ptrFromInt(0x60099804));
                
                /// Region address register
                pub const REGION0_ADDR_END = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] End address of region0
                    REGION0_ADDR_END:  u32, 
                    
                }), @ptrFromInt(0x60099808));
                
                /// Region access authority attribute register
                pub const REGION0_PMS_ATTR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Region execute authority in REE_MODE0
                    REGION0_R0_PMS_X:  u1, 
                    
                    /// [1:1] Region write authority in REE_MODE0
                    REGION0_R0_PMS_W:  u1, 
                    
                    /// [2:2] Region read authority in REE_MODE0
                    REGION0_R0_PMS_R:  u1, 
                    
                    /// [3:3] 
                    res0:  u0, 
                    
                    /// [4:4] Region execute authority in REE_MODE1
                    REGION0_R1_PMS_X:  u1, 
                    
                    /// [5:5] Region write authority in REE_MODE1
                    REGION0_R1_PMS_W:  u1, 
                    
                    /// [6:6] Region read authority in REE_MODE1
                    REGION0_R1_PMS_R:  u1, 
                    
                    /// [7:7] 
                    res1:  u0, 
                    
                    /// [8:8] Region execute authority in REE_MODE2
                    REGION0_R2_PMS_X:  u1, 
                    
                    /// [9:9] Region write authority in REE_MODE2
                    REGION0_R2_PMS_W:  u1, 
                    
                    /// [10:10] Region read authority in REE_MODE2
                    REGION0_R2_PMS_R:  u1, 
                    
                    /// [11:31] 
                    res2:  u0, 
                    
                }), @ptrFromInt(0x6009980c));
                
                /// Region address register
                pub const REGION1_ADDR_START = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Start address of region1
                    REGION1_ADDR_START:  u32, 
                    
                }), @ptrFromInt(0x60099810));
                
                /// Region address register
                pub const REGION1_ADDR_END = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] End address of region1
                    REGION1_ADDR_END:  u32, 
                    
                }), @ptrFromInt(0x60099814));
                
                /// Region access authority attribute register
                pub const REGION1_PMS_ATTR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Region execute authority in REE_MODE0
                    REGION1_R0_PMS_X:  u1, 
                    
                    /// [1:1] Region write authority in REE_MODE0
                    REGION1_R0_PMS_W:  u1, 
                    
                    /// [2:2] Region read authority in REE_MODE0
                    REGION1_R0_PMS_R:  u1, 
                    
                    /// [3:3] 
                    res0:  u0, 
                    
                    /// [4:4] Region execute authority in REE_MODE1
                    REGION1_R1_PMS_X:  u1, 
                    
                    /// [5:5] Region write authority in REE_MODE1
                    REGION1_R1_PMS_W:  u1, 
                    
                    /// [6:6] Region read authority in REE_MODE1
                    REGION1_R1_PMS_R:  u1, 
                    
                    /// [7:7] 
                    res1:  u0, 
                    
                    /// [8:8] Region execute authority in REE_MODE2
                    REGION1_R2_PMS_X:  u1, 
                    
                    /// [9:9] Region write authority in REE_MODE2
                    REGION1_R2_PMS_W:  u1, 
                    
                    /// [10:10] Region read authority in REE_MODE2
                    REGION1_R2_PMS_R:  u1, 
                    
                    /// [11:31] 
                    res2:  u0, 
                    
                }), @ptrFromInt(0x60099818));
                
                /// Region address register
                pub const REGION2_ADDR_START = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Start address of region2
                    REGION2_ADDR_START:  u32, 
                    
                }), @ptrFromInt(0x6009981c));
                
                /// Region address register
                pub const REGION2_ADDR_END = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] End address of region2
                    REGION2_ADDR_END:  u32, 
                    
                }), @ptrFromInt(0x60099820));
                
                /// Region access authority attribute register
                pub const REGION2_PMS_ATTR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Region execute authority in REE_MODE0
                    REGION2_R0_PMS_X:  u1, 
                    
                    /// [1:1] Region write authority in REE_MODE0
                    REGION2_R0_PMS_W:  u1, 
                    
                    /// [2:2] Region read authority in REE_MODE0
                    REGION2_R0_PMS_R:  u1, 
                    
                    /// [3:3] 
                    res0:  u0, 
                    
                    /// [4:4] Region execute authority in REE_MODE1
                    REGION2_R1_PMS_X:  u1, 
                    
                    /// [5:5] Region write authority in REE_MODE1
                    REGION2_R1_PMS_W:  u1, 
                    
                    /// [6:6] Region read authority in REE_MODE1
                    REGION2_R1_PMS_R:  u1, 
                    
                    /// [7:7] 
                    res1:  u0, 
                    
                    /// [8:8] Region execute authority in REE_MODE2
                    REGION2_R2_PMS_X:  u1, 
                    
                    /// [9:9] Region write authority in REE_MODE2
                    REGION2_R2_PMS_W:  u1, 
                    
                    /// [10:10] Region read authority in REE_MODE2
                    REGION2_R2_PMS_R:  u1, 
                    
                    /// [11:31] 
                    res2:  u0, 
                    
                }), @ptrFromInt(0x60099824));
                
                /// Region address register
                pub const REGION3_ADDR_START = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Start address of region3
                    REGION3_ADDR_START:  u32, 
                    
                }), @ptrFromInt(0x60099828));
                
                /// Region address register
                pub const REGION3_ADDR_END = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] End address of region3
                    REGION3_ADDR_END:  u32, 
                    
                }), @ptrFromInt(0x6009982c));
                
                /// Region access authority attribute register
                pub const REGION3_PMS_ATTR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Region execute authority in REE_MODE0
                    REGION3_R0_PMS_X:  u1, 
                    
                    /// [1:1] Region write authority in REE_MODE0
                    REGION3_R0_PMS_W:  u1, 
                    
                    /// [2:2] Region read authority in REE_MODE0
                    REGION3_R0_PMS_R:  u1, 
                    
                    /// [3:3] 
                    res0:  u0, 
                    
                    /// [4:4] Region execute authority in REE_MODE1
                    REGION3_R1_PMS_X:  u1, 
                    
                    /// [5:5] Region write authority in REE_MODE1
                    REGION3_R1_PMS_W:  u1, 
                    
                    /// [6:6] Region read authority in REE_MODE1
                    REGION3_R1_PMS_R:  u1, 
                    
                    /// [7:7] 
                    res1:  u0, 
                    
                    /// [8:8] Region execute authority in REE_MODE2
                    REGION3_R2_PMS_X:  u1, 
                    
                    /// [9:9] Region write authority in REE_MODE2
                    REGION3_R2_PMS_W:  u1, 
                    
                    /// [10:10] Region read authority in REE_MODE2
                    REGION3_R2_PMS_R:  u1, 
                    
                    /// [11:31] 
                    res2:  u0, 
                    
                }), @ptrFromInt(0x60099830));
                
                /// PMS function control register
                pub const FUNC_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] PMS M0 function enable
                    M0_PMS_FUNC_EN:  u1, 
                    
                    /// [1:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600998c4));
                
                /// M0 status register
                pub const M0_STATUS = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:1] Exception status
                    M0_EXCEPTION_STATUS:  u2, 
                    
                    /// [2:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600998c8));
                
                /// M0 status clear register
                pub const M0_STATUS_CLR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Clear exception status
                    M0_REGION_STATUS_CLR:  u1, 
                    
                    /// [1:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600998cc));
                
                /// M0 exception_info0 register
                pub const M0_EXCEPTION_INFO0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:3] Exception region
                    M0_EXCEPTION_REGION:  u4, 
                    
                    /// [4:15] 
                    res0:  u0, 
                    
                    /// [16:17] Exception mode
                    M0_EXCEPTION_MODE:  u2, 
                    
                    /// [18:22] Exception id information
                    M0_EXCEPTION_ID:  u5, 
                    
                    /// [23:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x600998d0));
                
                /// M0 exception_info1 register
                pub const M0_EXCEPTION_INFO1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Exception addr
                    M0_EXCEPTION_ADDR:  u32, 
                    
                }), @ptrFromInt(0x600998d4));
                
                /// APM interrupt enable register
                pub const INT_EN = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] APM M0 interrupt enable
                    M0_APM_INT_EN:  u1, 
                    
                    /// [1:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600998d8));
                
                /// clock gating register
                pub const CLOCK_GATE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] reg_clk_en
                    CLK_EN:  u1, 
                    
                    /// [1:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600998dc));
                
                /// Version register
                pub const DATE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:27] reg_date
                    DATE:  u28, 
                    
                    /// [28:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60099ffc));
                
            };
            
            /// LP_CLKRST Peripheral
            pub const LP_CLKRST = struct {
                
                /// need_des
                pub const LP_CLK_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:1] need_des
                    SLOW_CLK_SEL:  u2, 
                    
                    /// [2:2] need_des
                    FAST_CLK_SEL:  u1, 
                    
                    /// [3:10] need_des
                    LP_PERI_DIV_NUM:  u8, 
                    
                    /// [11:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600b0400));
                
                /// need_des
                pub const LP_CLK_PO_EN = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] need_des
                    AON_SLOW_OEN:  u1, 
                    
                    /// [1:1] need_des
                    AON_FAST_OEN:  u1, 
                    
                    /// [2:2] need_des
                    SOSC_OEN:  u1, 
                    
                    /// [3:3] need_des
                    FOSC_OEN:  u1, 
                    
                    /// [4:4] need_des
                    OSC32K_OEN:  u1, 
                    
                    /// [5:5] need_des
                    XTAL32K_OEN:  u1, 
                    
                    /// [6:6] need_des
                    CORE_EFUSE_OEN:  u1, 
                    
                    /// [7:7] need_des
                    SLOW_OEN:  u1, 
                    
                    /// [8:8] need_des
                    FAST_OEN:  u1, 
                    
                    /// [9:9] need_des
                    RNG_OEN:  u1, 
                    
                    /// [10:10] need_des
                    LPBUS_OEN:  u1, 
                    
                    /// [11:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600b0404));
                
                /// need_des
                pub const LP_CLK_EN = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:30] 
                    res0:  u0, 
                    
                    /// [31:31] need_des
                    FAST_ORI_GATE:  u1, 
                    
                }), @ptrFromInt(0x600b0408));
                
                /// need_des
                pub const LP_RST_EN = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:27] 
                    res0:  u0, 
                    
                    /// [28:28] need_des
                    AON_EFUSE_CORE_RESET_EN:  u1, 
                    
                    /// [29:29] need_des
                    LP_TIMER_RESET_EN:  u1, 
                    
                    /// [30:30] need_des
                    WDT_RESET_EN:  u1, 
                    
                    /// [31:31] need_des
                    ANA_PERI_RESET_EN:  u1, 
                    
                }), @ptrFromInt(0x600b040c));
                
                /// need_des
                pub const RESET_CAUSE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:4] need_des
                    RESET_CAUSE:  u5, 
                    
                    /// [5:5] need_des
                    CORE0_RESET_FLAG:  u1, 
                    
                    /// [6:28] 
                    res0:  u0, 
                    
                    /// [29:29] need_des
                    CORE0_RESET_CAUSE_CLR:  u1, 
                    
                    /// [30:30] need_des
                    CORE0_RESET_FLAG_SET:  u1, 
                    
                    /// [31:31] need_des
                    CORE0_RESET_FLAG_CLR:  u1, 
                    
                }), @ptrFromInt(0x600b0410));
                
                /// need_des
                pub const CPU_RESET = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:21] 
                    res0:  u0, 
                    
                    /// [22:24] need_des
                    RTC_WDT_CPU_RESET_LENGTH:  u3, 
                    
                    /// [25:25] need_des
                    RTC_WDT_CPU_RESET_EN:  u1, 
                    
                    /// [26:30] need_des
                    CPU_STALL_WAIT:  u5, 
                    
                    /// [31:31] need_des
                    CPU_STALL_EN:  u1, 
                    
                }), @ptrFromInt(0x600b0414));
                
                /// need_des
                pub const FOSC_CNTL = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:21] 
                    res0:  u0, 
                    
                    /// [22:31] need_des
                    FOSC_DFREQ:  u10, 
                    
                }), @ptrFromInt(0x600b0418));
                
                /// need_des
                pub const RC32K_CNTL = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:21] 
                    res0:  u0, 
                    
                    /// [22:31] need_des
                    RC32K_DFREQ:  u10, 
                    
                }), @ptrFromInt(0x600b041c));
                
                /// need_des
                pub const CLK_TO_HP = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:27] 
                    res0:  u0, 
                    
                    /// [28:28] need_des
                    ICG_HP_XTAL32K:  u1, 
                    
                    /// [29:29] need_des
                    ICG_HP_SOSC:  u1, 
                    
                    /// [30:30] need_des
                    ICG_HP_OSC32K:  u1, 
                    
                    /// [31:31] need_des
                    ICG_HP_FOSC:  u1, 
                    
                }), @ptrFromInt(0x600b0420));
                
                /// need_des
                pub const LPMEM_FORCE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:30] 
                    res0:  u0, 
                    
                    /// [31:31] need_des
                    LPMEM_CLK_FORCE_ON:  u1, 
                    
                }), @ptrFromInt(0x600b0424));
                
                /// need_des
                pub const LPPERI = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:29] 
                    res0:  u0, 
                    
                    /// [30:30] need_des
                    LP_I2C_CLK_SEL:  u1, 
                    
                    /// [31:31] need_des
                    LP_UART_CLK_SEL:  u1, 
                    
                }), @ptrFromInt(0x600b0428));
                
                /// need_des
                pub const XTAL32K = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:21] 
                    res0:  u0, 
                    
                    /// [22:24] need_des
                    DRES_XTAL32K:  u3, 
                    
                    /// [25:27] need_des
                    DGM_XTAL32K:  u3, 
                    
                    /// [28:28] need_des
                    DBUF_XTAL32K:  u1, 
                    
                    /// [29:31] need_des
                    DAC_XTAL32K:  u3, 
                    
                }), @ptrFromInt(0x600b042c));
                
                /// need_des
                pub const DATE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:30] need_des
                    CLKRST_DATE:  u31, 
                    
                    /// [31:31] need_des
                    CLK_EN:  u1, 
                    
                }), @ptrFromInt(0x600b07fc));
                
            };
            
            /// Low-power I2C (Inter-Integrated Circuit) Controller 0
            pub const LP_I2C0 = struct {
                
                /// Configures the low level width of the SCLClock
                pub const I2C_SCL_LOW_PERIOD = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:8] This register is used to configure for how long SCL remains low in master mode, in I2C module clock cycles.
                    I2C_SCL_LOW_PERIOD:  u9, 
                    
                    /// [9:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600b1800));
                
                /// Transmission setting
                pub const I2C_CTR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] 1: direct output, 0: open drain output.
                    I2C_SDA_FORCE_OUT:  u1, 
                    
                    /// [1:1] 1: direct output, 0: open drain output.
                    I2C_SCL_FORCE_OUT:  u1, 
                    
                    /// [2:2] This register is used to select the sample mode.1: sample SDA data on the SCL low level.0: sample SDA data on the SCL high level.
                    I2C_SAMPLE_SCL_LEVEL:  u1, 
                    
                    /// [3:3] This register is used to configure the ACK value that need to sent by master when the rx_fifo_cnt has reached the threshold.
                    I2C_RX_FULL_ACK_LEVEL:  u1, 
                    
                    /// [4:4] 
                    res0:  u0, 
                    
                    /// [5:5] Set this bit to start sending the data in txfifo.
                    I2C_TRANS_START:  u1, 
                    
                    /// [6:6] This bit is used to control the sending mode for data needing to be sent. 1: send data from the least significant bit,0: send data from the most significant bit.
                    I2C_TX_LSB_FIRST:  u1, 
                    
                    /// [7:7] This bit is used to control the storage mode for received data.1: receive data from the least significant bit,0: receive data from the most significant bit.
                    I2C_RX_LSB_FIRST:  u1, 
                    
                    /// [8:8] Reserved
                    I2C_CLK_EN:  u1, 
                    
                    /// [9:9] This is the enable bit for arbitration_lost.
                    I2C_ARBITRATION_EN:  u1, 
                    
                    /// [10:10] This register is used to reset the scl FMS.
                    I2C_FSM_RST:  u1, 
                    
                    /// [11:11] synchronization bit
                    I2C_CONF_UPGATE:  u1, 
                    
                    /// [12:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x600b1804));
                
                /// Describe I2C work status.
                pub const I2C_SR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] The received ACK value in master mode or slave mode. 0: ACK, 1: NACK.
                    I2C_RESP_REC:  u1, 
                    
                    /// [1:2] 
                    res0:  u0, 
                    
                    /// [3:3] When the I2C controller loses control of SCL line, this register changes to 1.
                    I2C_ARB_LOST:  u1, 
                    
                    /// [4:4] 1: the I2C bus is busy transferring data, 0: the I2C bus is in idle state.
                    I2C_BUS_BUSY:  u1, 
                    
                    /// [5:7] 
                    res1:  u0, 
                    
                    /// [8:12] This field represents the amount of data needed to be sent.
                    I2C_RXFIFO_CNT:  u5, 
                    
                    /// [13:17] 
                    res2:  u0, 
                    
                    /// [18:22] This field stores the amount of received data in RAM.
                    I2C_TXFIFO_CNT:  u5, 
                    
                    /// [23:23] 
                    res3:  u0, 
                    
                    /// [24:26] This field indicates the states of the I2C module state machine. 0: Idle, 1: Address shift, 2: ACK address, 3: Rx data, 4: Tx data, 5: Send ACK, 6: Wait ACK
                    I2C_SCL_MAIN_STATE_LAST:  u3, 
                    
                    /// [27:27] 
                    res4:  u0, 
                    
                    /// [28:30] This field indicates the states of the state machine used to produce SCL.0: Idle, 1: Start, 2: Negative edge, 3: Low, 4: Positive edge, 5: High, 6: Stop
                    I2C_SCL_STATE_LAST:  u3, 
                    
                    /// [31:31] 
                    res5:  u0, 
                    
                }), @ptrFromInt(0x600b1808));
                
                /// Setting time out control for receiving data.
                pub const I2C_TO = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:4] This register is used to configure the timeout for receiving a data bit in APBclock cycles.
                    I2C_TIME_OUT_VALUE:  u5, 
                    
                    /// [5:5] This is the enable bit for time out control.
                    I2C_TIME_OUT_EN:  u1, 
                    
                    /// [6:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600b180c));
                
                /// FIFO status register.
                pub const I2C_FIFO_ST = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:3] This is the offset address of the APB reading from rxfifo
                    I2C_RXFIFO_RADDR:  u4, 
                    
                    /// [4:4] 
                    res0:  u0, 
                    
                    /// [5:8] This is the offset address of i2c module receiving data and writing to rxfifo.
                    I2C_RXFIFO_WADDR:  u4, 
                    
                    /// [9:9] 
                    res1:  u0, 
                    
                    /// [10:13] This is the offset address of i2c module reading from txfifo.
                    I2C_TXFIFO_RADDR:  u4, 
                    
                    /// [14:14] 
                    res2:  u0, 
                    
                    /// [15:18] This is the offset address of APB bus writing to txfifo.
                    I2C_TXFIFO_WADDR:  u4, 
                    
                    /// [19:31] 
                    res3:  u0, 
                    
                }), @ptrFromInt(0x600b1814));
                
                /// FIFO configuration register.
                pub const FIFO_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:3] The water mark threshold of rx FIFO in nonfifo access mode. When reg_reg_fifo_prt_en is 1 and rx FIFO counter is bigger than reg_rxfifo_wm_thrhd[3:0], reg_rxfifo_wm_int_raw bit will be valid.
                    RXFIFO_WM_THRHD:  u4, 
                    
                    /// [4:4] 
                    res0:  u0, 
                    
                    /// [5:8] The water mark threshold of tx FIFO in nonfifo access mode. When reg_reg_fifo_prt_en is 1 and tx FIFO counter is smaller than reg_txfifo_wm_thrhd[3:0], reg_txfifo_wm_int_raw bit will be valid.
                    TXFIFO_WM_THRHD:  u4, 
                    
                    /// [9:9] 
                    res1:  u0, 
                    
                    /// [10:10] Set this bit to enable APB nonfifo access.
                    NONFIFO_EN:  u1, 
                    
                    /// [11:11] 
                    res2:  u0, 
                    
                    /// [12:12] Set this bit to reset rx-fifo.
                    RX_FIFO_RST:  u1, 
                    
                    /// [13:13] Set this bit to reset tx-fifo.
                    TX_FIFO_RST:  u1, 
                    
                    /// [14:14] The control enable bit of FIFO pointer in non-fifo access mode. This bit controls the valid bits and the interrupts of tx/rx_fifo overflow, underflow, full and empty.
                    FIFO_PRT_EN:  u1, 
                    
                    /// [15:31] 
                    res3:  u0, 
                    
                }), @ptrFromInt(0x600b1818));
                
                /// Rx FIFO read data.
                pub const I2C_DATA = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] The value of rx FIFO read data.
                    I2C_FIFO_RDATA:  u8, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600b181c));
                
                /// Raw interrupt status
                pub const I2C_INT_RAW = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] The raw interrupt bit for I2C_RXFIFO_WM_INT interrupt.
                    I2C_RXFIFO_WM_INT_RAW:  u1, 
                    
                    /// [1:1] The raw interrupt bit for I2C_TXFIFO_WM_INT interrupt.
                    I2C_TXFIFO_WM_INT_RAW:  u1, 
                    
                    /// [2:2] The raw interrupt bit for I2C_RXFIFO_OVF_INT interrupt.
                    I2C_RXFIFO_OVF_INT_RAW:  u1, 
                    
                    /// [3:3] The raw interrupt bit for the I2C_END_DETECT_INT interrupt.
                    I2C_END_DETECT_INT_RAW:  u1, 
                    
                    /// [4:4] The raw interrupt bit for the I2C_END_DETECT_INT interrupt.
                    I2C_BYTE_TRANS_DONE_INT_RAW:  u1, 
                    
                    /// [5:5] The raw interrupt bit for the I2C_ARBITRATION_LOST_INT interrupt.
                    I2C_ARBITRATION_LOST_INT_RAW:  u1, 
                    
                    /// [6:6] The raw interrupt bit for I2C_TRANS_COMPLETE_INT interrupt.
                    I2C_MST_TXFIFO_UDF_INT_RAW:  u1, 
                    
                    /// [7:7] The raw interrupt bit for the I2C_TRANS_COMPLETE_INT interrupt.
                    I2C_TRANS_COMPLETE_INT_RAW:  u1, 
                    
                    /// [8:8] The raw interrupt bit for the I2C_TIME_OUT_INT interrupt.
                    I2C_TIME_OUT_INT_RAW:  u1, 
                    
                    /// [9:9] The raw interrupt bit for the I2C_TRANS_START_INT interrupt.
                    I2C_TRANS_START_INT_RAW:  u1, 
                    
                    /// [10:10] The raw interrupt bit for I2C_SLAVE_STRETCH_INT interrupt.
                    I2C_NACK_INT_RAW:  u1, 
                    
                    /// [11:11] The raw interrupt bit for I2C_TXFIFO_OVF_INT interrupt.
                    I2C_TXFIFO_OVF_INT_RAW:  u1, 
                    
                    /// [12:12] The raw interrupt bit for I2C_RXFIFO_UDF_INTinterrupt.
                    I2C_RXFIFO_UDF_INT_RAW:  u1, 
                    
                    /// [13:13] The raw interrupt bit for I2C_SCL_ST_TO_INT interrupt.
                    I2C_SCL_ST_TO_INT_RAW:  u1, 
                    
                    /// [14:14] The raw interrupt bit for I2C_SCL_MAIN_ST_TO_INT interrupt.
                    I2C_SCL_MAIN_ST_TO_INT_RAW:  u1, 
                    
                    /// [15:15] The raw interrupt bit for I2C_DET_START_INT interrupt.
                    I2C_DET_START_INT_RAW:  u1, 
                    
                    /// [16:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600b1820));
                
                /// Interrupt clear bits
                pub const I2C_INT_CLR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Set this bit to clear I2C_RXFIFO_WM_INT interrupt.
                    I2C_RXFIFO_WM_INT_CLR:  u1, 
                    
                    /// [1:1] Set this bit to clear I2C_TXFIFO_WM_INT interrupt.
                    I2C_TXFIFO_WM_INT_CLR:  u1, 
                    
                    /// [2:2] Set this bit to clear I2C_RXFIFO_OVF_INT interrupt.
                    I2C_RXFIFO_OVF_INT_CLR:  u1, 
                    
                    /// [3:3] Set this bit to clear the I2C_END_DETECT_INT interrupt.
                    I2C_END_DETECT_INT_CLR:  u1, 
                    
                    /// [4:4] Set this bit to clear the I2C_END_DETECT_INT interrupt.
                    I2C_BYTE_TRANS_DONE_INT_CLR:  u1, 
                    
                    /// [5:5] Set this bit to clear the I2C_ARBITRATION_LOST_INT interrupt.
                    I2C_ARBITRATION_LOST_INT_CLR:  u1, 
                    
                    /// [6:6] Set this bit to clear I2C_TRANS_COMPLETE_INT interrupt.
                    I2C_MST_TXFIFO_UDF_INT_CLR:  u1, 
                    
                    /// [7:7] Set this bit to clear the I2C_TRANS_COMPLETE_INT interrupt.
                    I2C_TRANS_COMPLETE_INT_CLR:  u1, 
                    
                    /// [8:8] Set this bit to clear the I2C_TIME_OUT_INT interrupt.
                    I2C_TIME_OUT_INT_CLR:  u1, 
                    
                    /// [9:9] Set this bit to clear the I2C_TRANS_START_INT interrupt.
                    I2C_TRANS_START_INT_CLR:  u1, 
                    
                    /// [10:10] Set this bit to clear I2C_SLAVE_STRETCH_INT interrupt.
                    I2C_NACK_INT_CLR:  u1, 
                    
                    /// [11:11] Set this bit to clear I2C_TXFIFO_OVF_INT interrupt.
                    I2C_TXFIFO_OVF_INT_CLR:  u1, 
                    
                    /// [12:12] Set this bit to clear I2C_RXFIFO_UDF_INTinterrupt.
                    I2C_RXFIFO_UDF_INT_CLR:  u1, 
                    
                    /// [13:13] Set this bit to clear I2C_SCL_ST_TO_INT interrupt.
                    I2C_SCL_ST_TO_INT_CLR:  u1, 
                    
                    /// [14:14] Set this bit to clear I2C_SCL_MAIN_ST_TO_INT interrupt.
                    I2C_SCL_MAIN_ST_TO_INT_CLR:  u1, 
                    
                    /// [15:15] Set this bit to clear I2C_DET_START_INT interrupt.
                    I2C_DET_START_INT_CLR:  u1, 
                    
                    /// [16:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600b1824));
                
                /// Interrupt enable bits
                pub const I2C_INT_ENA = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] The interrupt enable bit for I2C_RXFIFO_WM_INT interrupt.
                    I2C_RXFIFO_WM_INT_ENA:  u1, 
                    
                    /// [1:1] The interrupt enable bit for I2C_TXFIFO_WM_INT interrupt.
                    I2C_TXFIFO_WM_INT_ENA:  u1, 
                    
                    /// [2:2] The interrupt enable bit for I2C_RXFIFO_OVF_INT interrupt.
                    I2C_RXFIFO_OVF_INT_ENA:  u1, 
                    
                    /// [3:3] The interrupt enable bit for the I2C_END_DETECT_INT interrupt.
                    I2C_END_DETECT_INT_ENA:  u1, 
                    
                    /// [4:4] The interrupt enable bit for the I2C_END_DETECT_INT interrupt.
                    I2C_BYTE_TRANS_DONE_INT_ENA:  u1, 
                    
                    /// [5:5] The interrupt enable bit for the I2C_ARBITRATION_LOST_INT interrupt.
                    I2C_ARBITRATION_LOST_INT_ENA:  u1, 
                    
                    /// [6:6] The interrupt enable bit for I2C_TRANS_COMPLETE_INT interrupt.
                    I2C_MST_TXFIFO_UDF_INT_ENA:  u1, 
                    
                    /// [7:7] The interrupt enable bit for the I2C_TRANS_COMPLETE_INT interrupt.
                    I2C_TRANS_COMPLETE_INT_ENA:  u1, 
                    
                    /// [8:8] The interrupt enable bit for the I2C_TIME_OUT_INT interrupt.
                    I2C_TIME_OUT_INT_ENA:  u1, 
                    
                    /// [9:9] The interrupt enable bit for the I2C_TRANS_START_INT interrupt.
                    I2C_TRANS_START_INT_ENA:  u1, 
                    
                    /// [10:10] The interrupt enable bit for I2C_SLAVE_STRETCH_INT interrupt.
                    I2C_NACK_INT_ENA:  u1, 
                    
                    /// [11:11] The interrupt enable bit for I2C_TXFIFO_OVF_INT interrupt.
                    I2C_TXFIFO_OVF_INT_ENA:  u1, 
                    
                    /// [12:12] The interrupt enable bit for I2C_RXFIFO_UDF_INTinterrupt.
                    I2C_RXFIFO_UDF_INT_ENA:  u1, 
                    
                    /// [13:13] The interrupt enable bit for I2C_SCL_ST_TO_INT interrupt.
                    I2C_SCL_ST_TO_INT_ENA:  u1, 
                    
                    /// [14:14] The interrupt enable bit for I2C_SCL_MAIN_ST_TO_INT interrupt.
                    I2C_SCL_MAIN_ST_TO_INT_ENA:  u1, 
                    
                    /// [15:15] The interrupt enable bit for I2C_DET_START_INT interrupt.
                    I2C_DET_START_INT_ENA:  u1, 
                    
                    /// [16:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600b1828));
                
                /// Status of captured I2C communication events
                pub const I2C_INT_STATUS = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] The masked interrupt status bit for I2C_RXFIFO_WM_INT interrupt.
                    I2C_RXFIFO_WM_INT_ST:  u1, 
                    
                    /// [1:1] The masked interrupt status bit for I2C_TXFIFO_WM_INT interrupt.
                    I2C_TXFIFO_WM_INT_ST:  u1, 
                    
                    /// [2:2] The masked interrupt status bit for I2C_RXFIFO_OVF_INT interrupt.
                    I2C_RXFIFO_OVF_INT_ST:  u1, 
                    
                    /// [3:3] The masked interrupt status bit for the I2C_END_DETECT_INT interrupt.
                    I2C_END_DETECT_INT_ST:  u1, 
                    
                    /// [4:4] The masked interrupt status bit for the I2C_END_DETECT_INT interrupt.
                    I2C_BYTE_TRANS_DONE_INT_ST:  u1, 
                    
                    /// [5:5] The masked interrupt status bit for the I2C_ARBITRATION_LOST_INT interrupt.
                    I2C_ARBITRATION_LOST_INT_ST:  u1, 
                    
                    /// [6:6] The masked interrupt status bit for I2C_TRANS_COMPLETE_INT interrupt.
                    I2C_MST_TXFIFO_UDF_INT_ST:  u1, 
                    
                    /// [7:7] The masked interrupt status bit for the I2C_TRANS_COMPLETE_INT interrupt.
                    I2C_TRANS_COMPLETE_INT_ST:  u1, 
                    
                    /// [8:8] The masked interrupt status bit for the I2C_TIME_OUT_INT interrupt.
                    I2C_TIME_OUT_INT_ST:  u1, 
                    
                    /// [9:9] The masked interrupt status bit for the I2C_TRANS_START_INT interrupt.
                    I2C_TRANS_START_INT_ST:  u1, 
                    
                    /// [10:10] The masked interrupt status bit for I2C_SLAVE_STRETCH_INT interrupt.
                    I2C_NACK_INT_ST:  u1, 
                    
                    /// [11:11] The masked interrupt status bit for I2C_TXFIFO_OVF_INT interrupt.
                    I2C_TXFIFO_OVF_INT_ST:  u1, 
                    
                    /// [12:12] The masked interrupt status bit for I2C_RXFIFO_UDF_INTinterrupt.
                    I2C_RXFIFO_UDF_INT_ST:  u1, 
                    
                    /// [13:13] The masked interrupt status bit for I2C_SCL_ST_TO_INT interrupt.
                    I2C_SCL_ST_TO_INT_ST:  u1, 
                    
                    /// [14:14] The masked interrupt status bit for I2C_SCL_MAIN_ST_TO_INT interrupt.
                    I2C_SCL_MAIN_ST_TO_INT_ST:  u1, 
                    
                    /// [15:15] The masked interrupt status bit for I2C_DET_START_INT interrupt.
                    I2C_DET_START_INT_ST:  u1, 
                    
                    /// [16:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600b182c));
                
                /// Configures the hold time after a negative SCL edge.
                pub const I2C_SDA_HOLD = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:8] This register is used to configure the time to hold the data after the negativeedge of SCL, in I2C module clock cycles.
                    TIME:  u9, 
                    
                    /// [9:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600b1830));
                
                /// Configures the sample time after a positive SCL edge.
                pub const I2C_SDA_SAMPLE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:8] This register is used to configure for how long SDA is sampled, in I2C module clock cycles.
                    TIME:  u9, 
                    
                    /// [9:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600b1834));
                
                /// Configures the high level width of SCL
                pub const I2C_SCL_HIGH_PERIOD = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:8] This register is used to configure for how long SCL setup to high level and remains high in master mode, in I2C module clock cycles.
                    I2C_SCL_HIGH_PERIOD:  u9, 
                    
                    /// [9:15] This register is used to configure for the SCL_FSM's waiting period for SCL high level in master mode, in I2C module clock cycles.
                    I2C_SCL_WAIT_HIGH_PERIOD:  u7, 
                    
                    /// [16:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600b1838));
                
                /// Configures the delay between the SDA and SCL negative edge for a start condition
                pub const I2C_SCL_START_HOLD = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:8] This register is used to configure the time between the negative edgeof SDA and the negative edge of SCL for a START condition, in I2C module clock cycles.
                    TIME:  u9, 
                    
                    /// [9:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600b1840));
                
                /// Configures the delay between the positiveedge of SCL and the negative edge of SDA
                pub const I2C_SCL_RSTART_SETUP = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:8] This register is used to configure the time between the positiveedge of SCL and the negative edge of SDA for a RESTART condition, in I2C module clock cycles.
                    TIME:  u9, 
                    
                    /// [9:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600b1844));
                
                /// Configures the delay after the SCL clockedge for a stop condition
                pub const I2C_SCL_STOP_HOLD = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:8] This register is used to configure the delay after the STOP condition,in I2C module clock cycles.
                    TIME:  u9, 
                    
                    /// [9:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600b1848));
                
                /// Configures the delay between the SDA andSCL positive edge for a stop condition
                pub const I2C_SCL_STOP_SETUP = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:8] This register is used to configure the time between the positive edgeof SCL and the positive edge of SDA, in I2C module clock cycles.
                    TIME:  u9, 
                    
                    /// [9:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600b184c));
                
                /// SCL and SDA filter configuration register
                pub const I2C_FILTER_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:3] When a pulse on the SCL input has smaller width than this register valuein I2C module clock cycles, the I2C controller will ignore that pulse.
                    I2C_SCL_FILTER_THRES:  u4, 
                    
                    /// [4:7] When a pulse on the SDA input has smaller width than this register valuein I2C module clock cycles, the I2C controller will ignore that pulse.
                    I2C_SDA_FILTER_THRES:  u4, 
                    
                    /// [8:8] This is the filter enable bit for SCL.
                    I2C_SCL_FILTER_EN:  u1, 
                    
                    /// [9:9] This is the filter enable bit for SDA.
                    I2C_SDA_FILTER_EN:  u1, 
                    
                    /// [10:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600b1850));
                
                /// I2C CLK configuration register
                pub const I2C_CLK_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] the integral part of the fractional divisor for i2c module
                    I2C_SCLK_DIV_NUM:  u8, 
                    
                    /// [8:13] the numerator of the fractional part of the fractional divisor for i2c module
                    I2C_SCLK_DIV_A:  u6, 
                    
                    /// [14:19] the denominator of the fractional part of the fractional divisor for i2c module
                    I2C_SCLK_DIV_B:  u6, 
                    
                    /// [20:20] The clock selection for i2c module:0-XTAL,1-CLK_8MHz.
                    I2C_SCLK_SEL:  u1, 
                    
                    /// [21:21] The clock switch for i2c module
                    I2C_SCLK_ACTIVE:  u1, 
                    
                    /// [22:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600b1854));
                
                /// I2C command register 0
                pub const I2C_COMD0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:13] This is the content of command 0. It consists of three parts: op_code is the command, 0: RSTART, 1: WRITE, 2: READ, 3: STOP, 4: END.Byte_num represents the number of bytes that need to be sent or received.ack_check_en, ack_exp and ack are used to control the ACK bit. See I2C cmd structure for moreInformation.
                    I2C_COMMAND0:  u14, 
                    
                    /// [14:30] 
                    res0:  u0, 
                    
                    /// [31:31] When command 0 is done in I2C Master mode, this bit changes to highlevel.
                    I2C_COMMAND0_DONE:  u1, 
                    
                }), @ptrFromInt(0x600b1858));
                
                /// I2C command register 1
                pub const I2C_COMD1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:13] This is the content of command 1. It consists of three parts: op_code is the command, 0: RSTART, 1: WRITE, 2: READ, 3: STOP, 4: END.Byte_num represents the number of bytes that need to be sent or received.ack_check_en, ack_exp and ack are used to control the ACK bit. See I2C cmd structure for moreInformation.
                    I2C_COMMAND1:  u14, 
                    
                    /// [14:30] 
                    res0:  u0, 
                    
                    /// [31:31] When command 1 is done in I2C Master mode, this bit changes to highlevel.
                    I2C_COMMAND1_DONE:  u1, 
                    
                }), @ptrFromInt(0x600b185c));
                
                /// I2C command register 2
                pub const I2C_COMD2 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:13] This is the content of command 2. It consists of three parts: op_code is the command, 0: RSTART, 1: WRITE, 2: READ, 3: STOP, 4: END.Byte_num represents the number of bytes that need to be sent or received.ack_check_en, ack_exp and ack are used to control the ACK bit. See I2C cmd structure for moreInformation.
                    I2C_COMMAND2:  u14, 
                    
                    /// [14:30] 
                    res0:  u0, 
                    
                    /// [31:31] When command 2 is done in I2C Master mode, this bit changes to highLevel.
                    I2C_COMMAND2_DONE:  u1, 
                    
                }), @ptrFromInt(0x600b1860));
                
                /// I2C command register 3
                pub const I2C_COMD3 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:13] This is the content of command 3. It consists of three parts: op_code is the command, 0: RSTART, 1: WRITE, 2: READ, 3: STOP, 4: END.Byte_num represents the number of bytes that need to be sent or received.ack_check_en, ack_exp and ack are used to control the ACK bit. See I2C cmd structure for moreInformation.
                    I2C_COMMAND3:  u14, 
                    
                    /// [14:30] 
                    res0:  u0, 
                    
                    /// [31:31] When command 3 is done in I2C Master mode, this bit changes to highlevel.
                    I2C_COMMAND3_DONE:  u1, 
                    
                }), @ptrFromInt(0x600b1864));
                
                /// I2C command register 4
                pub const I2C_COMD4 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:13] This is the content of command 4. It consists of three parts: op_code is the command, 0: RSTART, 1: WRITE, 2: READ, 3: STOP, 4: END.Byte_num represents the number of bytes that need to be sent or received.ack_check_en, ack_exp and ack are used to control the ACK bit. See I2C cmd structure for moreInformation.
                    I2C_COMMAND4:  u14, 
                    
                    /// [14:30] 
                    res0:  u0, 
                    
                    /// [31:31] When command 4 is done in I2C Master mode, this bit changes to highlevel.
                    I2C_COMMAND4_DONE:  u1, 
                    
                }), @ptrFromInt(0x600b1868));
                
                /// I2C command register 5
                pub const I2C_COMD5 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:13] This is the content of command 5. It consists of three parts:op_code is the command, 0: RSTART, 1: WRITE, 2: READ, 3: STOP, 4: END.Byte_num represents the number of bytes that need to be sent or received.ack_check_en, ack_exp and ack are used to control the ACK bit. See I2C cmd structure for moreInformation.
                    I2C_COMMAND5:  u14, 
                    
                    /// [14:30] 
                    res0:  u0, 
                    
                    /// [31:31] When command 5 is done in I2C Master mode, this bit changes to high level.
                    I2C_COMMAND5_DONE:  u1, 
                    
                }), @ptrFromInt(0x600b186c));
                
                /// I2C command register 6
                pub const I2C_COMD6 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:13] This is the content of command 6. It consists of three parts: op_code is the command, 0: RSTART, 1: WRITE, 2: READ, 3: STOP, 4: END.Byte_num represents the number of bytes that need to be sent or received.ack_check_en, ack_exp and ack are used to control the ACK bit. See I2C cmd structure for moreInformation.
                    I2C_COMMAND6:  u14, 
                    
                    /// [14:30] 
                    res0:  u0, 
                    
                    /// [31:31] When command 6 is done in I2C Master mode, this bit changes to high level.
                    I2C_COMMAND6_DONE:  u1, 
                    
                }), @ptrFromInt(0x600b1870));
                
                /// I2C command register 7
                pub const I2C_COMD7 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:13] This is the content of command 7. It consists of three parts: op_code is the command, 0: RSTART, 1: WRITE, 2: READ, 3: STOP, 4: END.Byte_num represents the number of bytes that need to be sent or received.ack_check_en, ack_exp and ack are used to control the ACK bit. See I2C cmd structure for moreInformation.
                    I2C_COMMAND7:  u14, 
                    
                    /// [14:30] 
                    res0:  u0, 
                    
                    /// [31:31] When command 7 is done in I2C Master mode, this bit changes to high level.
                    I2C_COMMAND7_DONE:  u1, 
                    
                }), @ptrFromInt(0x600b1874));
                
                /// SCL status time out register
                pub const I2C_SCL_ST_TIME_OUT = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:4] The threshold value of SCL_FSM state unchanged period. It should be o more than 23
                    I2C_SCL_ST_TO_I2C:  u5, 
                    
                    /// [5:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600b1878));
                
                /// SCL main status time out register
                pub const I2C_SCL_MAIN_ST_TIME_OUT = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:4] The threshold value of SCL_MAIN_FSM state unchanged period.nIt should be o more than 23
                    I2C_SCL_MAIN_ST_TO_I2C:  u5, 
                    
                    /// [5:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600b187c));
                
                /// Power configuration register
                pub const I2C_SCL_SP_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] When I2C master is IDLE, set this bit to send out SCL pulses. The number of pulses equals to reg_scl_rst_slv_num[4:0].
                    I2C_SCL_RST_SLV_EN:  u1, 
                    
                    /// [1:5] Configure the pulses of SCL generated in I2C master mode. Valid when reg_scl_rst_slv_en is 1.
                    I2C_SCL_RST_SLV_NUM:  u5, 
                    
                    /// [6:6] The power down enable bit for the I2C output SCL line. 1: Power down. 0: Not power down. Set reg_scl_force_out and reg_scl_pd_en to 1 to stretch SCL low.
                    I2C_SCL_PD_EN:  u1, 
                    
                    /// [7:7] The power down enable bit for the I2C output SDA line. 1: Power down. 0: Not power down. Set reg_sda_force_out and reg_sda_pd_en to 1 to stretch SDA low.
                    I2C_SDA_PD_EN:  u1, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600b1880));
                
                /// Version register
                pub const I2C_DATE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] This is the the version register.
                    I2C_DATE:  u32, 
                    
                }), @ptrFromInt(0x600b18f8));
                
                /// I2C TXFIFO base address register
                pub const I2C_TXFIFO_START_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] This is the I2C txfifo first address.
                    I2C_TXFIFO_START_ADDR:  u32, 
                    
                }), @ptrFromInt(0x600b1900));
                
                /// I2C RXFIFO base address register
                pub const I2C_RXFIFO_START_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] This is the I2C rxfifo first address.
                    I2C_RXFIFO_START_ADDR:  u32, 
                    
                }), @ptrFromInt(0x600b1980));
                
            };
            
            /// LP_I2C_ANA_MST Peripheral
            pub const LP_I2C_ANA_MST = struct {
                
                /// need_des
                pub const I2C0_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:24] need_des
                    LP_I2C_ANA_MAST_I2C0_CTRL:  u25, 
                    
                    /// [25:25] need_des
                    LP_I2C_ANA_MAST_I2C0_BUSY:  u1, 
                    
                    /// [26:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600b2400));
                
                /// need_des
                pub const I2C0_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:23] need_des
                    LP_I2C_ANA_MAST_I2C0_CONF:  u24, 
                    
                    /// [24:31] reserved
                    LP_I2C_ANA_MAST_I2C0_STATUS:  u8, 
                    
                }), @ptrFromInt(0x600b2404));
                
                /// need_des
                pub const I2C0_DATA = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] need_des
                    LP_I2C_ANA_MAST_I2C0_RDATA:  u8, 
                    
                    /// [8:10] need_des
                    LP_I2C_ANA_MAST_I2C0_CLK_SEL:  u3, 
                    
                    /// [11:11] needdes
                    LP_I2C_ANA_MAST_I2C_MST_SEL:  u1, 
                    
                    /// [12:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600b2408));
                
                /// need_des
                pub const ANA_CONF1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:23] need_des
                    LP_I2C_ANA_MAST_ANA_CONF1:  u24, 
                    
                    /// [24:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600b240c));
                
                /// need_des
                pub const NOUSE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] need_des
                    LP_I2C_ANA_MAST_I2C_MST_NOUSE:  u32, 
                    
                }), @ptrFromInt(0x600b2410));
                
                /// need_des
                pub const DEVICE_EN = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:11] need_des
                    LP_I2C_ANA_MAST_I2C_DEVICE_EN:  u12, 
                    
                    /// [12:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600b2414));
                
                /// need_des
                pub const DATE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:27] need_des
                    LP_I2C_ANA_MAST_I2C_MAT_DATE:  u28, 
                    
                    /// [28:28] need_des
                    LP_I2C_ANA_MAST_I2C_MAT_CLK_EN:  u1, 
                    
                    /// [29:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600b27fc));
                
            };
            
            /// LP_IO Peripheral
            pub const LP_IO = struct {
                
                /// need des
                pub const OUT_DATA = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] set lp gpio output data
                    LP_GPIO_OUT_DATA:  u8, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600b2000));
                
                /// need des
                pub const OUT_DATA_W1TS = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] set one time output data
                    LP_GPIO_OUT_DATA_W1TS:  u8, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600b2004));
                
                /// need des
                pub const OUT_DATA_W1TC = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] clear one time output data
                    LP_GPIO_OUT_DATA_W1TC:  u8, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600b2008));
                
                /// need des
                pub const OUT_ENABLE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] set lp gpio output data
                    LP_GPIO_ENABLE:  u8, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600b200c));
                
                /// need des
                pub const OUT_ENABLE_W1TS = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] set one time output data
                    LP_GPIO_ENABLE_W1TS:  u8, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600b2010));
                
                /// need des
                pub const OUT_ENABLE_W1TC = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] clear one time output data
                    LP_GPIO_ENABLE_W1TC:  u8, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600b2014));
                
                /// need des
                pub const STATUS = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] set lp gpio output data
                    LP_GPIO_STATUS_INTERRUPT:  u8, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600b2018));
                
                /// need des
                pub const STATUS_W1TS = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] set one time output data
                    LP_GPIO_STATUS_W1TS:  u8, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600b201c));
                
                /// need des
                pub const STATUS_W1TC = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] clear one time output data
                    LP_GPIO_STATUS_W1TC:  u8, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600b2020));
                
                /// need des
                pub const IN = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] need des
                    LP_GPIO_IN_DATA_NEXT:  u8, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600b2024));
                
                /// need des
                pub const PIN0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:1] need des
                    LP_GPIO0_SYNC_BYPASS:  u2, 
                    
                    /// [2:2] need des
                    LP_GPIO0_PAD_DRIVER:  u1, 
                    
                    /// [3:3] need des
                    LP_GPIO0_EDGE_WAKEUP_CLR:  u1, 
                    
                    /// [4:6] 
                    res0:  u0, 
                    
                    /// [7:9] need des
                    LP_GPIO0_INT_TYPE:  u3, 
                    
                    /// [10:10] need des
                    LP_GPIO0_WAKEUP_ENABLE:  u1, 
                    
                    /// [11:11] need des
                    LP_GPIO0_FILTER_EN:  u1, 
                    
                    /// [12:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x600b2028));
                
                /// need des
                pub const PIN1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:1] need des
                    LP_GPIO1_SYNC_BYPASS:  u2, 
                    
                    /// [2:2] need des
                    LP_GPIO1_PAD_DRIVER:  u1, 
                    
                    /// [3:3] need des
                    LP_GPIO1_EDGE_WAKEUP_CLR:  u1, 
                    
                    /// [4:6] 
                    res0:  u0, 
                    
                    /// [7:9] need des
                    LP_GPIO1_INT_TYPE:  u3, 
                    
                    /// [10:10] need des
                    LP_GPIO1_WAKEUP_ENABLE:  u1, 
                    
                    /// [11:11] need des
                    LP_GPIO1_FILTER_EN:  u1, 
                    
                    /// [12:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x600b202c));
                
                /// need des
                pub const PIN2 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:1] need des
                    LP_GPIO2_SYNC_BYPASS:  u2, 
                    
                    /// [2:2] need des
                    LP_GPIO2_PAD_DRIVER:  u1, 
                    
                    /// [3:3] need des
                    LP_GPIO2_EDGE_WAKEUP_CLR:  u1, 
                    
                    /// [4:6] 
                    res0:  u0, 
                    
                    /// [7:9] need des
                    LP_GPIO2_INT_TYPE:  u3, 
                    
                    /// [10:10] need des
                    LP_GPIO2_WAKEUP_ENABLE:  u1, 
                    
                    /// [11:11] need des
                    LP_GPIO2_FILTER_EN:  u1, 
                    
                    /// [12:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x600b2030));
                
                /// need des
                pub const PIN3 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:1] need des
                    LP_GPIO3_SYNC_BYPASS:  u2, 
                    
                    /// [2:2] need des
                    LP_GPIO3_PAD_DRIVER:  u1, 
                    
                    /// [3:3] need des
                    LP_GPIO3_EDGE_WAKEUP_CLR:  u1, 
                    
                    /// [4:6] 
                    res0:  u0, 
                    
                    /// [7:9] need des
                    LP_GPIO3_INT_TYPE:  u3, 
                    
                    /// [10:10] need des
                    LP_GPIO3_WAKEUP_ENABLE:  u1, 
                    
                    /// [11:11] need des
                    LP_GPIO3_FILTER_EN:  u1, 
                    
                    /// [12:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x600b2034));
                
                /// need des
                pub const PIN4 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:1] need des
                    LP_GPIO4_SYNC_BYPASS:  u2, 
                    
                    /// [2:2] need des
                    LP_GPIO4_PAD_DRIVER:  u1, 
                    
                    /// [3:3] need des
                    LP_GPIO4_EDGE_WAKEUP_CLR:  u1, 
                    
                    /// [4:6] 
                    res0:  u0, 
                    
                    /// [7:9] need des
                    LP_GPIO4_INT_TYPE:  u3, 
                    
                    /// [10:10] need des
                    LP_GPIO4_WAKEUP_ENABLE:  u1, 
                    
                    /// [11:11] need des
                    LP_GPIO4_FILTER_EN:  u1, 
                    
                    /// [12:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x600b2038));
                
                /// need des
                pub const PIN5 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:1] need des
                    LP_GPIO5_SYNC_BYPASS:  u2, 
                    
                    /// [2:2] need des
                    LP_GPIO5_PAD_DRIVER:  u1, 
                    
                    /// [3:3] need des
                    LP_GPIO5_EDGE_WAKEUP_CLR:  u1, 
                    
                    /// [4:6] 
                    res0:  u0, 
                    
                    /// [7:9] need des
                    LP_GPIO5_INT_TYPE:  u3, 
                    
                    /// [10:10] need des
                    LP_GPIO5_WAKEUP_ENABLE:  u1, 
                    
                    /// [11:11] need des
                    LP_GPIO5_FILTER_EN:  u1, 
                    
                    /// [12:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x600b203c));
                
                /// need des
                pub const PIN6 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:1] need des
                    LP_GPIO6_SYNC_BYPASS:  u2, 
                    
                    /// [2:2] need des
                    LP_GPIO6_PAD_DRIVER:  u1, 
                    
                    /// [3:3] need des
                    LP_GPIO6_EDGE_WAKEUP_CLR:  u1, 
                    
                    /// [4:6] 
                    res0:  u0, 
                    
                    /// [7:9] need des
                    LP_GPIO6_INT_TYPE:  u3, 
                    
                    /// [10:10] need des
                    LP_GPIO6_WAKEUP_ENABLE:  u1, 
                    
                    /// [11:11] need des
                    LP_GPIO6_FILTER_EN:  u1, 
                    
                    /// [12:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x600b2040));
                
                /// need des
                pub const PIN7 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:1] need des
                    LP_GPIO7_SYNC_BYPASS:  u2, 
                    
                    /// [2:2] need des
                    LP_GPIO7_PAD_DRIVER:  u1, 
                    
                    /// [3:3] need des
                    LP_GPIO7_EDGE_WAKEUP_CLR:  u1, 
                    
                    /// [4:6] 
                    res0:  u0, 
                    
                    /// [7:9] need des
                    LP_GPIO7_INT_TYPE:  u3, 
                    
                    /// [10:10] need des
                    LP_GPIO7_WAKEUP_ENABLE:  u1, 
                    
                    /// [11:11] need des
                    LP_GPIO7_FILTER_EN:  u1, 
                    
                    /// [12:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x600b2044));
                
                /// need des
                pub const GPIO0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] need des
                    LP_GPIO0_MCU_OE:  u1, 
                    
                    /// [1:1] need des
                    LP_GPIO0_SLP_SEL:  u1, 
                    
                    /// [2:2] need des
                    LP_GPIO0_MCU_WPD:  u1, 
                    
                    /// [3:3] need des
                    LP_GPIO0_MCU_WPU:  u1, 
                    
                    /// [4:4] need des
                    LP_GPIO0_MCU_IE:  u1, 
                    
                    /// [5:6] need des
                    LP_GPIO0_MCU_DRV:  u2, 
                    
                    /// [7:7] need des
                    LP_GPIO0_FUN_WPD:  u1, 
                    
                    /// [8:8] need des
                    LP_GPIO0_FUN_WPU:  u1, 
                    
                    /// [9:9] need des
                    LP_GPIO0_FUN_IE:  u1, 
                    
                    /// [10:11] need des
                    LP_GPIO0_FUN_DRV:  u2, 
                    
                    /// [12:14] need des
                    LP_GPIO0_MCU_SEL:  u3, 
                    
                    /// [15:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600b2048));
                
                /// need des
                pub const GPIO1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] need des
                    LP_GPIO1_MCU_OE:  u1, 
                    
                    /// [1:1] need des
                    LP_GPIO1_SLP_SEL:  u1, 
                    
                    /// [2:2] need des
                    LP_GPIO1_MCU_WPD:  u1, 
                    
                    /// [3:3] need des
                    LP_GPIO1_MCU_WPU:  u1, 
                    
                    /// [4:4] need des
                    LP_GPIO1_MCU_IE:  u1, 
                    
                    /// [5:6] need des
                    LP_GPIO1_MCU_DRV:  u2, 
                    
                    /// [7:7] need des
                    LP_GPIO1_FUN_WPD:  u1, 
                    
                    /// [8:8] need des
                    LP_GPIO1_FUN_WPU:  u1, 
                    
                    /// [9:9] need des
                    LP_GPIO1_FUN_IE:  u1, 
                    
                    /// [10:11] need des
                    LP_GPIO1_FUN_DRV:  u2, 
                    
                    /// [12:14] need des
                    LP_GPIO1_MCU_SEL:  u3, 
                    
                    /// [15:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600b204c));
                
                /// need des
                pub const GPIO2 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] need des
                    LP_GPIO2_MCU_OE:  u1, 
                    
                    /// [1:1] need des
                    LP_GPIO2_SLP_SEL:  u1, 
                    
                    /// [2:2] need des
                    LP_GPIO2_MCU_WPD:  u1, 
                    
                    /// [3:3] need des
                    LP_GPIO2_MCU_WPU:  u1, 
                    
                    /// [4:4] need des
                    LP_GPIO2_MCU_IE:  u1, 
                    
                    /// [5:6] need des
                    LP_GPIO2_MCU_DRV:  u2, 
                    
                    /// [7:7] need des
                    LP_GPIO2_FUN_WPD:  u1, 
                    
                    /// [8:8] need des
                    LP_GPIO2_FUN_WPU:  u1, 
                    
                    /// [9:9] need des
                    LP_GPIO2_FUN_IE:  u1, 
                    
                    /// [10:11] need des
                    LP_GPIO2_FUN_DRV:  u2, 
                    
                    /// [12:14] need des
                    LP_GPIO2_MCU_SEL:  u3, 
                    
                    /// [15:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600b2050));
                
                /// need des
                pub const GPIO3 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] need des
                    LP_GPIO3_MCU_OE:  u1, 
                    
                    /// [1:1] need des
                    LP_GPIO3_SLP_SEL:  u1, 
                    
                    /// [2:2] need des
                    LP_GPIO3_MCU_WPD:  u1, 
                    
                    /// [3:3] need des
                    LP_GPIO3_MCU_WPU:  u1, 
                    
                    /// [4:4] need des
                    LP_GPIO3_MCU_IE:  u1, 
                    
                    /// [5:6] need des
                    LP_GPIO3_MCU_DRV:  u2, 
                    
                    /// [7:7] need des
                    LP_GPIO3_FUN_WPD:  u1, 
                    
                    /// [8:8] need des
                    LP_GPIO3_FUN_WPU:  u1, 
                    
                    /// [9:9] need des
                    LP_GPIO3_FUN_IE:  u1, 
                    
                    /// [10:11] need des
                    LP_GPIO3_FUN_DRV:  u2, 
                    
                    /// [12:14] need des
                    LP_GPIO3_MCU_SEL:  u3, 
                    
                    /// [15:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600b2054));
                
                /// need des
                pub const GPIO4 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] need des
                    LP_GPIO4_MCU_OE:  u1, 
                    
                    /// [1:1] need des
                    LP_GPIO4_SLP_SEL:  u1, 
                    
                    /// [2:2] need des
                    LP_GPIO4_MCU_WPD:  u1, 
                    
                    /// [3:3] need des
                    LP_GPIO4_MCU_WPU:  u1, 
                    
                    /// [4:4] need des
                    LP_GPIO4_MCU_IE:  u1, 
                    
                    /// [5:6] need des
                    LP_GPIO4_MCU_DRV:  u2, 
                    
                    /// [7:7] need des
                    LP_GPIO4_FUN_WPD:  u1, 
                    
                    /// [8:8] need des
                    LP_GPIO4_FUN_WPU:  u1, 
                    
                    /// [9:9] need des
                    LP_GPIO4_FUN_IE:  u1, 
                    
                    /// [10:11] need des
                    LP_GPIO4_FUN_DRV:  u2, 
                    
                    /// [12:14] need des
                    LP_GPIO4_MCU_SEL:  u3, 
                    
                    /// [15:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600b2058));
                
                /// need des
                pub const GPIO5 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] need des
                    LP_GPIO5_MCU_OE:  u1, 
                    
                    /// [1:1] need des
                    LP_GPIO5_SLP_SEL:  u1, 
                    
                    /// [2:2] need des
                    LP_GPIO5_MCU_WPD:  u1, 
                    
                    /// [3:3] need des
                    LP_GPIO5_MCU_WPU:  u1, 
                    
                    /// [4:4] need des
                    LP_GPIO5_MCU_IE:  u1, 
                    
                    /// [5:6] need des
                    LP_GPIO5_MCU_DRV:  u2, 
                    
                    /// [7:7] need des
                    LP_GPIO5_FUN_WPD:  u1, 
                    
                    /// [8:8] need des
                    LP_GPIO5_FUN_WPU:  u1, 
                    
                    /// [9:9] need des
                    LP_GPIO5_FUN_IE:  u1, 
                    
                    /// [10:11] need des
                    LP_GPIO5_FUN_DRV:  u2, 
                    
                    /// [12:14] need des
                    LP_GPIO5_MCU_SEL:  u3, 
                    
                    /// [15:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600b205c));
                
                /// need des
                pub const GPIO6 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] need des
                    LP_GPIO6_MCU_OE:  u1, 
                    
                    /// [1:1] need des
                    LP_GPIO6_SLP_SEL:  u1, 
                    
                    /// [2:2] need des
                    LP_GPIO6_MCU_WPD:  u1, 
                    
                    /// [3:3] need des
                    LP_GPIO6_MCU_WPU:  u1, 
                    
                    /// [4:4] need des
                    LP_GPIO6_MCU_IE:  u1, 
                    
                    /// [5:6] need des
                    LP_GPIO6_MCU_DRV:  u2, 
                    
                    /// [7:7] need des
                    LP_GPIO6_FUN_WPD:  u1, 
                    
                    /// [8:8] need des
                    LP_GPIO6_FUN_WPU:  u1, 
                    
                    /// [9:9] need des
                    LP_GPIO6_FUN_IE:  u1, 
                    
                    /// [10:11] need des
                    LP_GPIO6_FUN_DRV:  u2, 
                    
                    /// [12:14] need des
                    LP_GPIO6_MCU_SEL:  u3, 
                    
                    /// [15:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600b2060));
                
                /// need des
                pub const GPIO7 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] need des
                    LP_GPIO7_MCU_OE:  u1, 
                    
                    /// [1:1] need des
                    LP_GPIO7_SLP_SEL:  u1, 
                    
                    /// [2:2] need des
                    LP_GPIO7_MCU_WPD:  u1, 
                    
                    /// [3:3] need des
                    LP_GPIO7_MCU_WPU:  u1, 
                    
                    /// [4:4] need des
                    LP_GPIO7_MCU_IE:  u1, 
                    
                    /// [5:6] need des
                    LP_GPIO7_MCU_DRV:  u2, 
                    
                    /// [7:7] need des
                    LP_GPIO7_FUN_WPD:  u1, 
                    
                    /// [8:8] need des
                    LP_GPIO7_FUN_WPU:  u1, 
                    
                    /// [9:9] need des
                    LP_GPIO7_FUN_IE:  u1, 
                    
                    /// [10:11] need des
                    LP_GPIO7_FUN_DRV:  u2, 
                    
                    /// [12:14] need des
                    LP_GPIO7_MCU_SEL:  u3, 
                    
                    /// [15:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600b2064));
                
                /// need des
                pub const STATUS_INTERRUPT = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] need des
                    LP_GPIO_STATUS_INTERRUPT_NEXT:  u8, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600b2068));
                
                /// need des
                pub const DEBUG_SEL0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:6] need des
                    LP_DEBUG_SEL0:  u7, 
                    
                    /// [7:13] need des
                    LP_DEBUG_SEL1:  u7, 
                    
                    /// [14:20] need des
                    LP_DEBUG_SEL2:  u7, 
                    
                    /// [21:27] need des
                    LP_DEBUG_SEL3:  u7, 
                    
                    /// [28:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600b206c));
                
                /// need des
                pub const DEBUG_SEL1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:6] need des
                    LP_DEBUG_SEL4:  u7, 
                    
                    /// [7:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600b2070));
                
                /// need des
                pub const LPI2C = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:29] 
                    res0:  u0, 
                    
                    /// [30:30] need des
                    LP_I2C_SDA_IE:  u1, 
                    
                    /// [31:31] need des
                    LP_I2C_SCL_IE:  u1, 
                    
                }), @ptrFromInt(0x600b2074));
                
                /// need des
                pub const DATE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:30] need des
                    LP_IO_DATE:  u31, 
                    
                    /// [31:31] need des
                    CLK_EN:  u1, 
                    
                }), @ptrFromInt(0x600b23fc));
                
            };
            
            /// Low-power Trusted Execution Environment
            pub const LP_TEE = struct {
                
                /// Tee mode control register
                pub const M0_MODE_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:1] M0 security level mode: 2'd3: ree_mode2. 2'd2: ree_mode1. 2'd1: ree_mode0. 2'd0: tee_mode
                    M0_MODE:  u2, 
                    
                    /// [2:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600b3400));
                
                /// Clock gating register
                pub const CLOCK_GATE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] reg_clk_en
                    CLK_EN:  u1, 
                    
                    /// [1:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600b3404));
                
                /// need_des
                pub const FORCE_ACC_HP = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] need_des
                    LP_AON_FORCE_ACC_HPMEM_EN:  u1, 
                    
                    /// [1:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600b3490));
                
                /// Version register
                pub const DATE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:27] reg_tee_date
                    DATE:  u28, 
                    
                    /// [28:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600b34fc));
                
            };
            
            /// Low-power Timer
            pub const LP_TIMER = struct {
                
                /// need_des
                pub const TAR0_LOW = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] need_des
                    MAIN_TIMER_TAR_LOW0:  u32, 
                    
                }), @ptrFromInt(0x600b0c00));
                
                /// need_des
                pub const TAR0_HIGH = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:15] need_des
                    MAIN_TIMER_TAR_HIGH0:  u16, 
                    
                    /// [16:30] 
                    res0:  u0, 
                    
                    /// [31:31] need_des
                    MAIN_TIMER_TAR_EN0:  u1, 
                    
                }), @ptrFromInt(0x600b0c04));
                
                /// need_des
                pub const TAR1_LOW = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] need_des
                    MAIN_TIMER_TAR_LOW1:  u32, 
                    
                }), @ptrFromInt(0x600b0c08));
                
                /// need_des
                pub const TAR1_HIGH = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:15] need_des
                    MAIN_TIMER_TAR_HIGH1:  u16, 
                    
                    /// [16:30] 
                    res0:  u0, 
                    
                    /// [31:31] need_des
                    MAIN_TIMER_TAR_EN1:  u1, 
                    
                }), @ptrFromInt(0x600b0c0c));
                
                /// need_des
                pub const UPDATE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:27] 
                    res0:  u0, 
                    
                    /// [28:28] need_des
                    MAIN_TIMER_UPDATE:  u1, 
                    
                    /// [29:29] need_des
                    MAIN_TIMER_XTAL_OFF:  u1, 
                    
                    /// [30:30] need_des
                    MAIN_TIMER_SYS_STALL:  u1, 
                    
                    /// [31:31] need_des
                    MAIN_TIMER_SYS_RST:  u1, 
                    
                }), @ptrFromInt(0x600b0c10));
                
                /// need_des
                pub const MAIN_BUF0_LOW = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] need_des
                    MAIN_TIMER_BUF0_LOW:  u32, 
                    
                }), @ptrFromInt(0x600b0c14));
                
                /// need_des
                pub const MAIN_BUF0_HIGH = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:15] need_des
                    MAIN_TIMER_BUF0_HIGH:  u16, 
                    
                    /// [16:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600b0c18));
                
                /// need_des
                pub const MAIN_BUF1_LOW = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] need_des
                    MAIN_TIMER_BUF1_LOW:  u32, 
                    
                }), @ptrFromInt(0x600b0c1c));
                
                /// need_des
                pub const MAIN_BUF1_HIGH = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:15] need_des
                    MAIN_TIMER_BUF1_HIGH:  u16, 
                    
                    /// [16:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600b0c20));
                
                /// need_des
                pub const MAIN_OVERFLOW = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:30] 
                    res0:  u0, 
                    
                    /// [31:31] need_des
                    MAIN_TIMER_ALARM_LOAD:  u1, 
                    
                }), @ptrFromInt(0x600b0c24));
                
                /// need_des
                pub const INT_RAW = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:29] 
                    res0:  u0, 
                    
                    /// [30:30] need_des
                    OVERFLOW_RAW:  u1, 
                    
                    /// [31:31] need_des
                    SOC_WAKEUP_INT_RAW:  u1, 
                    
                }), @ptrFromInt(0x600b0c28));
                
                /// need_des
                pub const INT_ST = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:29] 
                    res0:  u0, 
                    
                    /// [30:30] need_des
                    OVERFLOW_ST:  u1, 
                    
                    /// [31:31] need_des
                    SOC_WAKEUP_INT_ST:  u1, 
                    
                }), @ptrFromInt(0x600b0c2c));
                
                /// need_des
                pub const INT_ENA = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:29] 
                    res0:  u0, 
                    
                    /// [30:30] need_des
                    OVERFLOW_ENA:  u1, 
                    
                    /// [31:31] need_des
                    SOC_WAKEUP_INT_ENA:  u1, 
                    
                }), @ptrFromInt(0x600b0c30));
                
                /// need_des
                pub const INT_CLR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:29] 
                    res0:  u0, 
                    
                    /// [30:30] need_des
                    OVERFLOW_CLR:  u1, 
                    
                    /// [31:31] need_des
                    SOC_WAKEUP_INT_CLR:  u1, 
                    
                }), @ptrFromInt(0x600b0c34));
                
                /// need_des
                pub const LP_INT_RAW = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:29] 
                    res0:  u0, 
                    
                    /// [30:30] need_des
                    MAIN_TIMER_OVERFLOW_LP_INT_RAW:  u1, 
                    
                    /// [31:31] need_des
                    MAIN_TIMER_LP_INT_RAW:  u1, 
                    
                }), @ptrFromInt(0x600b0c38));
                
                /// need_des
                pub const LP_INT_ST = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:29] 
                    res0:  u0, 
                    
                    /// [30:30] need_des
                    MAIN_TIMER_OVERFLOW_LP_INT_ST:  u1, 
                    
                    /// [31:31] need_des
                    MAIN_TIMER_LP_INT_ST:  u1, 
                    
                }), @ptrFromInt(0x600b0c3c));
                
                /// need_des
                pub const LP_INT_ENA = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:29] 
                    res0:  u0, 
                    
                    /// [30:30] need_des
                    MAIN_TIMER_OVERFLOW_LP_INT_ENA:  u1, 
                    
                    /// [31:31] need_des
                    MAIN_TIMER_LP_INT_ENA:  u1, 
                    
                }), @ptrFromInt(0x600b0c40));
                
                /// need_des
                pub const LP_INT_CLR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:29] 
                    res0:  u0, 
                    
                    /// [30:30] need_des
                    MAIN_TIMER_OVERFLOW_LP_INT_CLR:  u1, 
                    
                    /// [31:31] need_des
                    MAIN_TIMER_LP_INT_CLR:  u1, 
                    
                }), @ptrFromInt(0x600b0c44));
                
                /// need_des
                pub const DATE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:30] need_des
                    DATE:  u31, 
                    
                    /// [31:31] need_des
                    CLK_EN:  u1, 
                    
                }), @ptrFromInt(0x600b0ffc));
                
            };
            
            /// Low-power UART (Universal Asynchronous Receiver-Transmitter) Controller
            pub const LP_UART = struct {
                
                /// FIFO data register
                pub const FIFO = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] UART 0 accesses FIFO via this register.
                    RXFIFO_RD_BYTE:  u8, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600b1400));
                
                /// Raw interrupt status
                pub const INT_RAW = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] This interrupt raw bit turns to high level when receiver receives more data than what rxfifo_full_thrhd specifies.
                    RXFIFO_FULL_INT_RAW:  u1, 
                    
                    /// [1:1] This interrupt raw bit turns to high level when the amount of data in Tx-FIFO is less than what txfifo_empty_thrhd specifies .
                    TXFIFO_EMPTY_INT_RAW:  u1, 
                    
                    /// [2:2] This interrupt raw bit turns to high level when receiver detects a parity error in the data.
                    PARITY_ERR_INT_RAW:  u1, 
                    
                    /// [3:3] This interrupt raw bit turns to high level when receiver detects a data frame error .
                    FRM_ERR_INT_RAW:  u1, 
                    
                    /// [4:4] This interrupt raw bit turns to high level when receiver receives more data than the FIFO can store.
                    RXFIFO_OVF_INT_RAW:  u1, 
                    
                    /// [5:5] This interrupt raw bit turns to high level when receiver detects the edge change of DSRn signal.
                    DSR_CHG_INT_RAW:  u1, 
                    
                    /// [6:6] This interrupt raw bit turns to high level when receiver detects the edge change of CTSn signal.
                    CTS_CHG_INT_RAW:  u1, 
                    
                    /// [7:7] This interrupt raw bit turns to high level when receiver detects a 0 after the stop bit.
                    BRK_DET_INT_RAW:  u1, 
                    
                    /// [8:8] This interrupt raw bit turns to high level when receiver takes more time than rx_tout_thrhd to receive a byte.
                    RXFIFO_TOUT_INT_RAW:  u1, 
                    
                    /// [9:9] This interrupt raw bit turns to high level when receiver recevies Xon char when uart_sw_flow_con_en is set to 1.
                    SW_XON_INT_RAW:  u1, 
                    
                    /// [10:10] This interrupt raw bit turns to high level when receiver receives Xoff char when uart_sw_flow_con_en is set to 1.
                    SW_XOFF_INT_RAW:  u1, 
                    
                    /// [11:11] This interrupt raw bit turns to high level when receiver detects a glitch in the middle of a start bit.
                    GLITCH_DET_INT_RAW:  u1, 
                    
                    /// [12:12] This interrupt raw bit turns to high level when transmitter completessendingNULL characters after all data in Tx-FIFO are sent.
                    TX_BRK_DONE_INT_RAW:  u1, 
                    
                    /// [13:13] This interrupt raw bit turns to high level when transmitter has kept the shortest duration after sending thelast data.
                    TX_BRK_IDLE_DONE_INT_RAW:  u1, 
                    
                    /// [14:14] This interrupt raw bit turns to high level when transmitter has send out all data in FIFO.
                    TX_DONE_INT_RAW:  u1, 
                    
                    /// [15:17] 
                    res0:  u0, 
                    
                    /// [18:18] This interrupt raw bit turns to high level when receiver detects the configured at_cmd char.
                    AT_CMD_CHAR_DET_INT_RAW:  u1, 
                    
                    /// [19:19] This interrupt raw bit turns to high level when input rxd edge changes more times than what reg_active_threshold specifies in light sleeping mode.
                    WAKEUP_INT_RAW:  u1, 
                    
                    /// [20:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x600b1404));
                
                /// Masked interrupt status
                pub const INT_ST = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] This is the status bit for rxfifo_full_int_raw when rxfifo_full_int_ena is set to 1.
                    RXFIFO_FULL_INT_ST:  u1, 
                    
                    /// [1:1] This is the status bit fortxfifo_empty_int_rawwhen txfifo_empty_int_ena is set to 1.
                    TXFIFO_EMPTY_INT_ST:  u1, 
                    
                    /// [2:2] This is the status bit for parity_err_int_raw when parity_err_int_ena is set to 1.
                    PARITY_ERR_INT_ST:  u1, 
                    
                    /// [3:3] This is the status bit for frm_err_int_raw when frm_err_int_ena is set to 1.
                    FRM_ERR_INT_ST:  u1, 
                    
                    /// [4:4] This is the status bit for rxfifo_ovf_int_raw when rxfifo_ovf_int_ena is set to 1.
                    RXFIFO_OVF_INT_ST:  u1, 
                    
                    /// [5:5] This is the status bit for dsr_chg_int_raw when dsr_chg_int_ena is set to 1.
                    DSR_CHG_INT_ST:  u1, 
                    
                    /// [6:6] This is the status bit for cts_chg_int_raw when cts_chg_int_ena is set to 1.
                    CTS_CHG_INT_ST:  u1, 
                    
                    /// [7:7] This is the status bit for brk_det_int_raw when brk_det_int_ena is set to 1.
                    BRK_DET_INT_ST:  u1, 
                    
                    /// [8:8] This is the status bit for rxfifo_tout_int_raw when rxfifo_tout_int_ena is set to 1.
                    RXFIFO_TOUT_INT_ST:  u1, 
                    
                    /// [9:9] This is the status bit for sw_xon_int_raw when sw_xon_int_ena is set to 1.
                    SW_XON_INT_ST:  u1, 
                    
                    /// [10:10] This is the status bit for sw_xoff_int_raw when sw_xoff_int_ena is set to 1.
                    SW_XOFF_INT_ST:  u1, 
                    
                    /// [11:11] This is the status bit for glitch_det_int_raw when glitch_det_int_ena is set to 1.
                    GLITCH_DET_INT_ST:  u1, 
                    
                    /// [12:12] This is the status bit for tx_brk_done_int_raw when tx_brk_done_int_ena is set to 1.
                    TX_BRK_DONE_INT_ST:  u1, 
                    
                    /// [13:13] This is the stauts bit for tx_brk_idle_done_int_raw when tx_brk_idle_done_int_ena is set to 1.
                    TX_BRK_IDLE_DONE_INT_ST:  u1, 
                    
                    /// [14:14] This is the status bit for tx_done_int_raw when tx_done_int_ena is set to 1.
                    TX_DONE_INT_ST:  u1, 
                    
                    /// [15:17] 
                    res0:  u0, 
                    
                    /// [18:18] This is the status bit for at_cmd_det_int_raw when at_cmd_char_det_int_ena is set to 1.
                    AT_CMD_CHAR_DET_INT_ST:  u1, 
                    
                    /// [19:19] This is the status bit for uart_wakeup_int_raw when uart_wakeup_int_ena is set to 1.
                    WAKEUP_INT_ST:  u1, 
                    
                    /// [20:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x600b1408));
                
                /// Interrupt enable bits
                pub const INT_ENA = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] This is the enable bit for rxfifo_full_int_st register.
                    RXFIFO_FULL_INT_ENA:  u1, 
                    
                    /// [1:1] This is the enable bit for txfifo_empty_int_st register.
                    TXFIFO_EMPTY_INT_ENA:  u1, 
                    
                    /// [2:2] This is the enable bit for parity_err_int_st register.
                    PARITY_ERR_INT_ENA:  u1, 
                    
                    /// [3:3] This is the enable bit for frm_err_int_st register.
                    FRM_ERR_INT_ENA:  u1, 
                    
                    /// [4:4] This is the enable bit for rxfifo_ovf_int_st register.
                    RXFIFO_OVF_INT_ENA:  u1, 
                    
                    /// [5:5] This is the enable bit for dsr_chg_int_st register.
                    DSR_CHG_INT_ENA:  u1, 
                    
                    /// [6:6] This is the enable bit for cts_chg_int_st register.
                    CTS_CHG_INT_ENA:  u1, 
                    
                    /// [7:7] This is the enable bit for brk_det_int_st register.
                    BRK_DET_INT_ENA:  u1, 
                    
                    /// [8:8] This is the enable bit for rxfifo_tout_int_st register.
                    RXFIFO_TOUT_INT_ENA:  u1, 
                    
                    /// [9:9] This is the enable bit for sw_xon_int_st register.
                    SW_XON_INT_ENA:  u1, 
                    
                    /// [10:10] This is the enable bit for sw_xoff_int_st register.
                    SW_XOFF_INT_ENA:  u1, 
                    
                    /// [11:11] This is the enable bit for glitch_det_int_st register.
                    GLITCH_DET_INT_ENA:  u1, 
                    
                    /// [12:12] This is the enable bit for tx_brk_done_int_st register.
                    TX_BRK_DONE_INT_ENA:  u1, 
                    
                    /// [13:13] This is the enable bit for tx_brk_idle_done_int_st register.
                    TX_BRK_IDLE_DONE_INT_ENA:  u1, 
                    
                    /// [14:14] This is the enable bit for tx_done_int_st register.
                    TX_DONE_INT_ENA:  u1, 
                    
                    /// [15:17] 
                    res0:  u0, 
                    
                    /// [18:18] This is the enable bit for at_cmd_char_det_int_st register.
                    AT_CMD_CHAR_DET_INT_ENA:  u1, 
                    
                    /// [19:19] This is the enable bit for uart_wakeup_int_st register.
                    WAKEUP_INT_ENA:  u1, 
                    
                    /// [20:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x600b140c));
                
                /// Interrupt clear bits
                pub const INT_CLR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Set this bit to clear the rxfifo_full_int_raw interrupt.
                    RXFIFO_FULL_INT_CLR:  u1, 
                    
                    /// [1:1] Set this bit to clear txfifo_empty_int_raw interrupt.
                    TXFIFO_EMPTY_INT_CLR:  u1, 
                    
                    /// [2:2] Set this bit to clear parity_err_int_raw interrupt.
                    PARITY_ERR_INT_CLR:  u1, 
                    
                    /// [3:3] Set this bit to clear frm_err_int_raw interrupt.
                    FRM_ERR_INT_CLR:  u1, 
                    
                    /// [4:4] Set this bit to clear rxfifo_ovf_int_raw interrupt.
                    RXFIFO_OVF_INT_CLR:  u1, 
                    
                    /// [5:5] Set this bit to clear the dsr_chg_int_raw interrupt.
                    DSR_CHG_INT_CLR:  u1, 
                    
                    /// [6:6] Set this bit to clear the cts_chg_int_raw interrupt.
                    CTS_CHG_INT_CLR:  u1, 
                    
                    /// [7:7] Set this bit to clear the brk_det_int_raw interrupt.
                    BRK_DET_INT_CLR:  u1, 
                    
                    /// [8:8] Set this bit to clear the rxfifo_tout_int_raw interrupt.
                    RXFIFO_TOUT_INT_CLR:  u1, 
                    
                    /// [9:9] Set this bit to clear the sw_xon_int_raw interrupt.
                    SW_XON_INT_CLR:  u1, 
                    
                    /// [10:10] Set this bit to clear the sw_xoff_int_raw interrupt.
                    SW_XOFF_INT_CLR:  u1, 
                    
                    /// [11:11] Set this bit to clear the glitch_det_int_raw interrupt.
                    GLITCH_DET_INT_CLR:  u1, 
                    
                    /// [12:12] Set this bit to clear the tx_brk_done_int_raw interrupt..
                    TX_BRK_DONE_INT_CLR:  u1, 
                    
                    /// [13:13] Set this bit to clear the tx_brk_idle_done_int_raw interrupt.
                    TX_BRK_IDLE_DONE_INT_CLR:  u1, 
                    
                    /// [14:14] Set this bit to clear the tx_done_int_raw interrupt.
                    TX_DONE_INT_CLR:  u1, 
                    
                    /// [15:17] 
                    res0:  u0, 
                    
                    /// [18:18] Set this bit to clear the at_cmd_char_det_int_raw interrupt.
                    AT_CMD_CHAR_DET_INT_CLR:  u1, 
                    
                    /// [19:19] Set this bit to clear the uart_wakeup_int_raw interrupt.
                    WAKEUP_INT_CLR:  u1, 
                    
                    /// [20:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x600b1410));
                
                /// Clock divider configuration
                pub const CLKDIV = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:11] The integral part of the frequency divider factor.
                    CLKDIV:  u12, 
                    
                    /// [12:19] 
                    res0:  u0, 
                    
                    /// [20:23] The decimal part of the frequency divider factor.
                    FRAG:  u4, 
                    
                    /// [24:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x600b1414));
                
                /// Rx Filter configuration
                pub const RX_FILT = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] when input pulse width is lower than this value the pulse is ignored.
                    GLITCH_FILT:  u8, 
                    
                    /// [8:8] Set this bit to enable Rx signal filter.
                    GLITCH_FILT_EN:  u1, 
                    
                    /// [9:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600b1418));
                
                /// UART status register
                pub const STATUS = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:2] 
                    res0:  u0, 
                    
                    /// [3:7] Stores the byte number of valid data in Rx-FIFO.
                    RXFIFO_CNT:  u5, 
                    
                    /// [8:12] 
                    res1:  u0, 
                    
                    /// [13:13] The register represent the level value of the internal uart dsr signal.
                    DSRN:  u1, 
                    
                    /// [14:14] This register represent the level value of the internal uart cts signal.
                    CTSN:  u1, 
                    
                    /// [15:15] This register represent thelevel value of the internal uart rxd signal.
                    RXD:  u1, 
                    
                    /// [16:18] 
                    res2:  u0, 
                    
                    /// [19:23] Stores the byte number of data in Tx-FIFO.
                    TXFIFO_CNT:  u5, 
                    
                    /// [24:28] 
                    res3:  u0, 
                    
                    /// [29:29] This bit represents the level of the internal uart dtr signal.
                    DTRN:  u1, 
                    
                    /// [30:30] This bit represents the level of the internal uart rts signal.
                    RTSN:  u1, 
                    
                    /// [31:31] This bit represents thelevel of the internal uart txd signal.
                    TXD:  u1, 
                    
                }), @ptrFromInt(0x600b141c));
                
                /// Configuration register 0
                pub const CONF0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] This register is used to configure the parity check mode.
                    PARITY:  u1, 
                    
                    /// [1:1] Set this bit to enable uart parity check.
                    PARITY_EN:  u1, 
                    
                    /// [2:3] This register is used to set the length of data.
                    BIT_NUM:  u2, 
                    
                    /// [4:5] This register is used to set the length ofstop bit.
                    STOP_BIT_NUM:  u2, 
                    
                    /// [6:6] Set this bit to enbale transmitter tosend NULL when the process of sending data is done.
                    TXD_BRK:  u1, 
                    
                    /// [7:11] 
                    res0:  u0, 
                    
                    /// [12:12] Set this bit to enable uart loopback test mode.
                    LOOPBACK:  u1, 
                    
                    /// [13:13] Set this bit to enable flow control function for transmitter.
                    TX_FLOW_EN:  u1, 
                    
                    /// [14:14] 
                    res1:  u0, 
                    
                    /// [15:15] Set this bit to inverse the level value of uart rxd signal.
                    RXD_INV:  u1, 
                    
                    /// [16:16] Set this bit to inverse the level value of uart txd signal.
                    TXD_INV:  u1, 
                    
                    /// [17:17] Disable UART Rx data overflow detect.
                    DIS_RX_DAT_OVF:  u1, 
                    
                    /// [18:18] 1'h1: Receiver stops storing data into FIFO when data is wrong. 1'h0: Receiver stores the data even if thereceived data is wrong.
                    ERR_WR_MASK:  u1, 
                    
                    /// [19:19] 
                    res2:  u0, 
                    
                    /// [20:20] UART memory clock gate enable signal.
                    MEM_CLK_EN:  u1, 
                    
                    /// [21:21] This register is used to configure the software rts signal which is used in software flow control.
                    SW_RTS:  u1, 
                    
                    /// [22:22] Set this bit to reset the uart receive-FIFO.
                    RXFIFO_RST:  u1, 
                    
                    /// [23:23] Set this bit to reset the uart transmit-FIFO.
                    TXFIFO_RST:  u1, 
                    
                    /// [24:31] 
                    res3:  u0, 
                    
                }), @ptrFromInt(0x600b1420));
                
                /// Configuration register 1
                pub const CONF1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:2] 
                    res0:  u0, 
                    
                    /// [3:7] It will produce rxfifo_full_int interrupt when receiver receives more data than this register value.
                    RXFIFO_FULL_THRHD:  u5, 
                    
                    /// [8:10] 
                    res1:  u0, 
                    
                    /// [11:15] It will produce txfifo_empty_int interrupt when the data amount in Tx-FIFO is less than this register value.
                    TXFIFO_EMPTY_THRHD:  u5, 
                    
                    /// [16:16] Set this bit to inverse the level value of uart cts signal.
                    CTS_INV:  u1, 
                    
                    /// [17:17] Set this bit to inverse the level value of uart dsr signal.
                    DSR_INV:  u1, 
                    
                    /// [18:18] Set this bit to inverse the level value of uart rts signal.
                    RTS_INV:  u1, 
                    
                    /// [19:19] Set this bit to inverse the level value of uart dtr signal.
                    DTR_INV:  u1, 
                    
                    /// [20:20] This register is used to configure the software dtr signal which is used in software flow control.
                    SW_DTR:  u1, 
                    
                    /// [21:21] 1'h1: Force clock on for register. 1'h0: Support clock only when application writes registers.
                    CLK_EN:  u1, 
                    
                    /// [22:31] 
                    res2:  u0, 
                    
                }), @ptrFromInt(0x600b1424));
                
                /// Hardware flow-control configuration
                pub const HWFC_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:2] 
                    res0:  u0, 
                    
                    /// [3:7] This register is used to configure the maximum amount of data that can be receivedwhen hardware flow control works.
                    RX_FLOW_THRHD:  u5, 
                    
                    /// [8:8] This is the flow enable bit for UART receiver.
                    RX_FLOW_EN:  u1, 
                    
                    /// [9:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x600b142c));
                
                /// UART sleep configure register 0
                pub const SLEEP_CONF0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] This register restores the specified wake up char1 to wake up
                    WK_CHAR1:  u8, 
                    
                    /// [8:15] This register restores the specified wake up char2 to wake up
                    WK_CHAR2:  u8, 
                    
                    /// [16:23] This register restores the specified wake up char3 to wake up
                    WK_CHAR3:  u8, 
                    
                    /// [24:31] This register restores the specified wake up char4 to wake up
                    WK_CHAR4:  u8, 
                    
                }), @ptrFromInt(0x600b1430));
                
                /// UART sleep configure register 1
                pub const SLEEP_CONF1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] This register restores the specified char0 to wake up
                    WK_CHAR0:  u8, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600b1434));
                
                /// UART sleep configure register 2
                pub const SLEEP_CONF2 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:9] The uart is activated from light sleeping mode when the input rxd edge changes more times than this register value.
                    ACTIVE_THRESHOLD:  u10, 
                    
                    /// [10:12] 
                    res0:  u0, 
                    
                    /// [13:17] In wake up mode 1 this field is used to set the received data number threshold to wake up chip.
                    RX_WAKE_UP_THRHD:  u5, 
                    
                    /// [18:20] This register is used to select number of wake up char.
                    WK_CHAR_NUM:  u3, 
                    
                    /// [21:25] This register is used to maskwake up char.
                    WK_CHAR_MASK:  u5, 
                    
                    /// [26:27] This register is used to select wake up mode. 0: RXD toggling to wake up. 1: received data number larger than
                    WK_MODE_SEL:  u2, 
                    
                    /// [28:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x600b1438));
                
                /// Software flow-control character configuration
                pub const SWFC_CONF0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] This register stores the Xon flow control char.
                    XON_CHAR:  u8, 
                    
                    /// [8:15] This register stores the Xoff flow control char.
                    XOFF_CHAR:  u8, 
                    
                    /// [16:16] In software flow control mode, UART Tx is disabled once UART Rx receives XOFF. In this status, UART Tx can not transmit XOFF even the received data number is larger than UART_XOFF_THRESHOLD. Set this bit to enable UART Tx can transmit XON/XOFF when UART Tx is disabled.
                    XON_XOFF_STILL_SEND:  u1, 
                    
                    /// [17:17] Set this bit to enable software flow control. It is used with register sw_xon or sw_xoff.
                    SW_FLOW_CON_EN:  u1, 
                    
                    /// [18:18] Set this bit to remove flow control char from the received data.
                    XONOFF_DEL:  u1, 
                    
                    /// [19:19] Set this bit to enable the transmitter to go on sending data.
                    FORCE_XON:  u1, 
                    
                    /// [20:20] Set this bit to stop thetransmitter from sending data.
                    FORCE_XOFF:  u1, 
                    
                    /// [21:21] Set this bit to send Xon char. It is cleared by hardware automatically.
                    SEND_XON:  u1, 
                    
                    /// [22:22] Set this bit to send Xoff char. It is cleared by hardware automatically.
                    SEND_XOFF:  u1, 
                    
                    /// [23:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600b143c));
                
                /// Software flow-control character configuration
                pub const SWFC_CONF1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:2] 
                    res0:  u0, 
                    
                    /// [3:7] When the data amount in Rx-FIFO is less than this register value with uart_sw_flow_con_en set to 1it will send a Xon char.
                    XON_THRESHOLD:  u5, 
                    
                    /// [8:10] 
                    res1:  u0, 
                    
                    /// [11:15] When the data amount in Rx-FIFO is more than this register value with uart_sw_flow_con_en set to 1it will send a Xoff char.
                    XOFF_THRESHOLD:  u5, 
                    
                    /// [16:31] 
                    res2:  u0, 
                    
                }), @ptrFromInt(0x600b1440));
                
                /// Tx Break character configuration
                pub const TXBRK_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] This register is used to configure the number of 0 to be sent after the process of sending data is done. It is active when txd_brk is set to 1.
                    TX_BRK_NUM:  u8, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600b1444));
                
                /// Frame-end idle configuration
                pub const IDLE_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:9] It will produce frame end signal when receiver takes more time to receive one byte data than this register value.
                    RX_IDLE_THRHD:  u10, 
                    
                    /// [10:19] This register is used to configure the duration time between transfers.
                    TX_IDLE_NUM:  u10, 
                    
                    /// [20:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600b1448));
                
                /// RS485 mode configuration
                pub const RS485_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] 
                    res0:  u0, 
                    
                    /// [1:1] Set this bit to delay the stop bit by 1 bit.
                    DL0_EN:  u1, 
                    
                    /// [2:2] Set this bit to delay the stop bit by 1 bit.
                    DL1_EN:  u1, 
                    
                    /// [3:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x600b144c));
                
                /// Pre-sequence timing configuration
                pub const AT_CMD_PRECNT = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:15] This register is used to configure the idle duration time before the first at_cmd is received by receiver.
                    PRE_IDLE_NUM:  u16, 
                    
                    /// [16:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600b1450));
                
                /// Post-sequence timing configuration
                pub const AT_CMD_POSTCNT = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:15] This register is used to configure the duration time between the last at_cmd and the next data.
                    POST_IDLE_NUM:  u16, 
                    
                    /// [16:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600b1454));
                
                /// Timeout configuration
                pub const AT_CMD_GAPTOUT = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:15] This register is used to configure the duration time between the at_cmd chars.
                    RX_GAP_TOUT:  u16, 
                    
                    /// [16:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600b1458));
                
                /// AT escape sequence detection configuration
                pub const AT_CMD_CHAR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] This register is used to configure the content of at_cmd char.
                    AT_CMD_CHAR:  u8, 
                    
                    /// [8:15] This register is used to configure the num of continuous at_cmd chars received by receiver.
                    CHAR_NUM:  u8, 
                    
                    /// [16:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600b145c));
                
                /// UART memory power configuration
                pub const MEM_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:24] 
                    res0:  u0, 
                    
                    /// [25:25] Set this bit to force power down UART memory.
                    MEM_FORCE_PD:  u1, 
                    
                    /// [26:26] Set this bit to force power up UART memory.
                    MEM_FORCE_PU:  u1, 
                    
                    /// [27:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x600b1460));
                
                /// UART threshold and allocation configuration
                pub const TOUT_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] This is the enble bit for uart receiver's timeout function.
                    RX_TOUT_EN:  u1, 
                    
                    /// [1:1] Set this bit to stop accumulating idle_cnt when hardware flow control works.
                    RX_TOUT_FLOW_DIS:  u1, 
                    
                    /// [2:11] This register is used to configure the threshold time that receiver takes to receive one byte. The rxfifo_tout_int interrupt will be trigger when the receiver takes more time to receive one byte with rx_tout_en set to 1.
                    RX_TOUT_THRHD:  u10, 
                    
                    /// [12:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600b1464));
                
                /// Tx-SRAM write and read offset address.
                pub const MEM_TX_STATUS = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:2] 
                    res0:  u0, 
                    
                    /// [3:7] This register stores the offset write address in Tx-SRAM.
                    TX_SRAM_WADDR:  u5, 
                    
                    /// [8:11] 
                    res1:  u0, 
                    
                    /// [12:16] This register stores the offset read address in Tx-SRAM.
                    TX_SRAM_RADDR:  u5, 
                    
                    /// [17:31] 
                    res2:  u0, 
                    
                }), @ptrFromInt(0x600b1468));
                
                /// Rx-SRAM write and read offset address.
                pub const MEM_RX_STATUS = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:2] 
                    res0:  u0, 
                    
                    /// [3:7] This register stores the offset read address in RX-SRAM.
                    RX_SRAM_RADDR:  u5, 
                    
                    /// [8:11] 
                    res1:  u0, 
                    
                    /// [12:16] This register stores the offset write address in Rx-SRAM.
                    RX_SRAM_WADDR:  u5, 
                    
                    /// [17:31] 
                    res2:  u0, 
                    
                }), @ptrFromInt(0x600b146c));
                
                /// UART transmit and receive status.
                pub const FSM_STATUS = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:3] This is the status register of receiver.
                    ST_URX_OUT:  u4, 
                    
                    /// [4:7] This is the status register of transmitter.
                    ST_UTX_OUT:  u4, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600b1470));
                
                /// UART core clock configuration
                pub const CLK_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] Thedenominator of the frequency divider factor.
                    SCLK_DIV_B:  u6, 
                    
                    /// [6:11] The numerator of the frequency divider factor.
                    SCLK_DIV_A:  u6, 
                    
                    /// [12:19] The integral part of the frequency divider factor.
                    SCLK_DIV_NUM:  u8, 
                    
                    /// [20:21] UART clock source select. 1: 80Mhz.2: 8Mhz.3: XTAL.
                    SCLK_SEL:  u2, 
                    
                    /// [22:22] Set this bit to enable UART Tx/Rx clock.
                    SCLK_EN:  u1, 
                    
                    /// [23:23] Write 1 then write 0 to this bit to reset UART Tx/Rx.
                    RST_CORE:  u1, 
                    
                    /// [24:24] Set this bit to enable UART Tx clock.
                    TX_SCLK_EN:  u1, 
                    
                    /// [25:25] Set this bit to enable UART Rx clock.
                    RX_SCLK_EN:  u1, 
                    
                    /// [26:26] Write 1 then write 0 to this bit to reset UART Tx.
                    TX_RST_CORE:  u1, 
                    
                    /// [27:27] Write 1 then write 0 to this bit to reset UART Rx.
                    RX_RST_CORE:  u1, 
                    
                    /// [28:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600b1488));
                
                /// UART Version register
                pub const DATE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] This is the version register.
                    DATE:  u32, 
                    
                }), @ptrFromInt(0x600b148c));
                
                /// UART AFIFO Status
                pub const AFIFO_STATUS = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Full signal of APB TX AFIFO.
                    TX_AFIFO_FULL:  u1, 
                    
                    /// [1:1] Empty signal of APB TX AFIFO.
                    TX_AFIFO_EMPTY:  u1, 
                    
                    /// [2:2] Full signal of APB RX AFIFO.
                    RX_AFIFO_FULL:  u1, 
                    
                    /// [3:3] Empty signal of APB RX AFIFO.
                    RX_AFIFO_EMPTY:  u1, 
                    
                    /// [4:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600b1490));
                
                /// UART Registers Configuration Update register
                pub const REG_UPDATE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Software write 1 would synchronize registers into UART Core clock domain and would be cleared by hardware after synchronization is done.
                    REG_UPDATE:  u1, 
                    
                    /// [1:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600b1498));
                
                /// UART ID register
                pub const ID = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] This register is used to configure the uart_id.
                    ID:  u32, 
                    
                }), @ptrFromInt(0x600b149c));
                
            };
            
            /// Low-power Watchdog Timer
            pub const LP_WDT = struct {
                
                /// need_des
                pub const WDTCONFIG0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] need_des
                    WDT_CHIP_RESET_WIDTH:  u8, 
                    
                    /// [8:8] need_des
                    WDT_CHIP_RESET_EN:  u1, 
                    
                    /// [9:9] need_des
                    WDT_PAUSE_IN_SLP:  u1, 
                    
                    /// [10:10] need_des
                    WDT_APPCPU_RESET_EN:  u1, 
                    
                    /// [11:11] need_des
                    WDT_PROCPU_RESET_EN:  u1, 
                    
                    /// [12:12] need_des
                    WDT_FLASHBOOT_MOD_EN:  u1, 
                    
                    /// [13:15] need_des
                    WDT_SYS_RESET_LENGTH:  u3, 
                    
                    /// [16:18] need_des
                    WDT_CPU_RESET_LENGTH:  u3, 
                    
                    /// [19:21] need_des
                    WDT_STG3:  u3, 
                    
                    /// [22:24] need_des
                    WDT_STG2:  u3, 
                    
                    /// [25:27] need_des
                    WDT_STG1:  u3, 
                    
                    /// [28:30] need_des
                    WDT_STG0:  u3, 
                    
                    /// [31:31] need_des
                    WDT_EN:  u1, 
                    
                }), @ptrFromInt(0x600b1c00));
                
                /// need_des
                pub const CONFIG1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] need_des
                    WDT_STG0_HOLD:  u32, 
                    
                }), @ptrFromInt(0x600b1c04));
                
                /// need_des
                pub const CONFIG2 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] need_des
                    WDT_STG1_HOLD:  u32, 
                    
                }), @ptrFromInt(0x600b1c08));
                
                /// need_des
                pub const CONFIG3 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] need_des
                    WDT_STG2_HOLD:  u32, 
                    
                }), @ptrFromInt(0x600b1c0c));
                
                /// need_des
                pub const CONFIG4 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] need_des
                    WDT_STG3_HOLD:  u32, 
                    
                }), @ptrFromInt(0x600b1c10));
                
                /// need_des
                pub const WDTFEED = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:30] 
                    res0:  u0, 
                    
                    /// [31:31] need_des
                    RTC_WDT_FEED:  u1, 
                    
                }), @ptrFromInt(0x600b1c14));
                
                /// need_des
                pub const WDTWPROTECT = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] need_des
                    WDT_WKEY:  u32, 
                    
                }), @ptrFromInt(0x600b1c18));
                
                /// need_des
                pub const SWD_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] need_des
                    SWD_RESET_FLAG:  u1, 
                    
                    /// [1:17] 
                    res0:  u0, 
                    
                    /// [18:18] need_des
                    SWD_AUTO_FEED_EN:  u1, 
                    
                    /// [19:19] need_des
                    SWD_RST_FLAG_CLR:  u1, 
                    
                    /// [20:29] need_des
                    SWD_SIGNAL_WIDTH:  u10, 
                    
                    /// [30:30] need_des
                    SWD_DISABLE:  u1, 
                    
                    /// [31:31] need_des
                    SWD_FEED:  u1, 
                    
                }), @ptrFromInt(0x600b1c1c));
                
                /// need_des
                pub const SWD_WPROTECT = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] need_des
                    SWD_WKEY:  u32, 
                    
                }), @ptrFromInt(0x600b1c20));
                
                /// need_des
                pub const INT_RAW = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:29] 
                    res0:  u0, 
                    
                    /// [30:30] need_des
                    SUPER_WDT_INT_RAW:  u1, 
                    
                    /// [31:31] need_des
                    LP_WDT_INT_RAW:  u1, 
                    
                }), @ptrFromInt(0x600b1c24));
                
                /// need_des
                pub const INT_ST_RTC = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:29] 
                    res0:  u0, 
                    
                    /// [30:30] need_des
                    SUPER_WDT_INT_ST:  u1, 
                    
                    /// [31:31] need_des
                    WDT_INT_ST:  u1, 
                    
                }), @ptrFromInt(0x600b1c28));
                
                /// need_des
                pub const INT_ENA_RTC = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:29] 
                    res0:  u0, 
                    
                    /// [30:30] need_des
                    SUPER_WDT_INT_ENA:  u1, 
                    
                    /// [31:31] need_des
                    WDT_INT_ENA:  u1, 
                    
                }), @ptrFromInt(0x600b1c2c));
                
                /// need_des
                pub const INT_CLR_RTC = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:29] 
                    res0:  u0, 
                    
                    /// [30:30] need_des
                    SUPER_WDT_INT_CLR:  u1, 
                    
                    /// [31:31] need_des
                    WDT_INT_CLR:  u1, 
                    
                }), @ptrFromInt(0x600b1c30));
                
                /// need_des
                pub const DATE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:30] need_des
                    LP_WDT_DATE:  u31, 
                    
                    /// [31:31] need_des
                    CLK_EN:  u1, 
                    
                }), @ptrFromInt(0x600b1ffc));
                
            };
            
            /// Motor Control Pulse-Width Modulation 0
            pub const MCPWM0 = struct {
                
                /// PWM clock prescaler register.
                pub const CLK_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] Period of PWM_clk = 6.25ns * (PWM_CLK_PRESCALE + 1)
                    CLK_PRESCALE:  u8, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60014000));
                
                /// PWM timer0 period and update method configuration register.
                pub const TIMER0_CFG0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] period of PT0_clk = Period of PWM_clk * (PWM_TIMER0_PRESCALE + 1)
                    TIMER0_PRESCALE:  u8, 
                    
                    /// [8:23] period shadow register of PWM timer0
                    TIMER0_PERIOD:  u16, 
                    
                    /// [24:25] Update method for active register of PWM timer0 period, 0: immediate, 1: TEZ, 2: sync, 3: TEZ | sync. TEZ here and below means timer equal zero event
                    TIMER0_PERIOD_UPMETHOD:  u2, 
                    
                    /// [26:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60014004));
                
                /// PWM timer0 working mode and start/stop control configuration register.
                pub const TIMER0_CFG1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:2] PWM timer0 start and stop control. 0: if PWM timer0 starts, then stops at TEZ, 1: if timer0 starts, then stops at TEP, 2: PWM timer0 starts and runs on, 3: timer0 starts and stops at the next TEZ, 4: timer0 starts and stops at the next TEP. TEP here and below means the event that happens when the timer equals to period
                    TIMER0_START:  u3, 
                    
                    /// [3:4] PWM timer0 working mode, 0: freeze, 1: increase mode, 2: decrease mode, 3: up-down mode
                    TIMER0_MOD:  u2, 
                    
                    /// [5:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60014008));
                
                /// PWM timer0 sync function configuration register.
                pub const TIMER0_SYNC = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] When set, timer reloading with phase on sync input event is enabled.
                    TIMER0_SYNCI_EN:  u1, 
                    
                    /// [1:1] Toggling this bit will trigger a software sync.
                    SW:  u1, 
                    
                    /// [2:3] PWM timer0 sync_out selection, 0: sync_in, 1: TEZ, 2: TEP, and sync out will always generate when toggling the reg_timer0_sync_sw bit
                    TIMER0_SYNCO_SEL:  u2, 
                    
                    /// [4:19] phase for timer reload on sync event
                    TIMER0_PHASE:  u16, 
                    
                    /// [20:20] Configure the PWM timer0's direction when timer0 mode is up-down mode: 0-increase,1-decrease
                    TIMER0_PHASE_DIRECTION:  u1, 
                    
                    /// [21:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6001400c));
                
                /// PWM timer0 status register.
                pub const TIMER0_STATUS = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:15] current PWM timer0 counter value
                    TIMER0_VALUE:  u16, 
                    
                    /// [16:16] current PWM timer0 counter direction, 0: increment 1: decrement
                    TIMER0_DIRECTION:  u1, 
                    
                    /// [17:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60014010));
                
                /// PWM timer1 period and update method configuration register.
                pub const TIMER1_CFG0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] period of PT0_clk = Period of PWM_clk * (PWM_timer1_PRESCALE + 1)
                    TIMER1_PRESCALE:  u8, 
                    
                    /// [8:23] period shadow register of PWM timer1
                    TIMER1_PERIOD:  u16, 
                    
                    /// [24:25] Update method for active register of PWM timer1 period, 0: immediate, 1: TEZ, 2: sync, 3: TEZ | sync. TEZ here and below means timer equal zero event
                    TIMER1_PERIOD_UPMETHOD:  u2, 
                    
                    /// [26:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60014014));
                
                /// PWM timer1 working mode and start/stop control configuration register.
                pub const TIMER1_CFG1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:2] PWM timer1 start and stop control. 0: if PWM timer1 starts, then stops at TEZ, 1: if timer1 starts, then stops at TEP, 2: PWM timer1 starts and runs on, 3: timer1 starts and stops at the next TEZ, 4: timer1 starts and stops at the next TEP. TEP here and below means the event that happens when the timer equals to period
                    TIMER1_START:  u3, 
                    
                    /// [3:4] PWM timer1 working mode, 0: freeze, 1: increase mode, 2: decrease mode, 3: up-down mode
                    TIMER1_MOD:  u2, 
                    
                    /// [5:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60014018));
                
                /// PWM timer1 sync function configuration register.
                pub const TIMER1_SYNC = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] When set, timer reloading with phase on sync input event is enabled.
                    TIMER1_SYNCI_EN:  u1, 
                    
                    /// [1:1] Toggling this bit will trigger a software sync.
                    SW:  u1, 
                    
                    /// [2:3] PWM timer1 sync_out selection, 0: sync_in, 1: TEZ, 2: TEP, and sync out will always generate when toggling the reg_timer1_sync_sw bit
                    TIMER1_SYNCO_SEL:  u2, 
                    
                    /// [4:19] phase for timer reload on sync event
                    TIMER1_PHASE:  u16, 
                    
                    /// [20:20] Configure the PWM timer1's direction when timer1 mode is up-down mode: 0-increase,1-decrease
                    TIMER1_PHASE_DIRECTION:  u1, 
                    
                    /// [21:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6001401c));
                
                /// PWM timer1 status register.
                pub const TIMER1_STATUS = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:15] current PWM timer1 counter value
                    TIMER1_VALUE:  u16, 
                    
                    /// [16:16] current PWM timer1 counter direction, 0: increment 1: decrement
                    TIMER1_DIRECTION:  u1, 
                    
                    /// [17:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60014020));
                
                /// PWM timer2 period and update method configuration register.
                pub const TIMER2_CFG0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] period of PT0_clk = Period of PWM_clk * (PWM_timer2_PRESCALE + 1)
                    TIMER2_PRESCALE:  u8, 
                    
                    /// [8:23] period shadow register of PWM timer2
                    TIMER2_PERIOD:  u16, 
                    
                    /// [24:25] Update method for active register of PWM timer2 period, 0: immediate, 1: TEZ, 2: sync, 3: TEZ | sync. TEZ here and below means timer equal zero event
                    TIMER2_PERIOD_UPMETHOD:  u2, 
                    
                    /// [26:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60014024));
                
                /// PWM timer2 working mode and start/stop control configuration register.
                pub const TIMER2_CFG1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:2] PWM timer2 start and stop control. 0: if PWM timer2 starts, then stops at TEZ, 1: if timer2 starts, then stops at TEP, 2: PWM timer2 starts and runs on, 3: timer2 starts and stops at the next TEZ, 4: timer2 starts and stops at the next TEP. TEP here and below means the event that happens when the timer equals to period
                    TIMER2_START:  u3, 
                    
                    /// [3:4] PWM timer2 working mode, 0: freeze, 1: increase mode, 2: decrease mode, 3: up-down mode
                    TIMER2_MOD:  u2, 
                    
                    /// [5:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60014028));
                
                /// PWM timer2 sync function configuration register.
                pub const TIMER2_SYNC = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] When set, timer reloading with phase on sync input event is enabled.
                    TIMER2_SYNCI_EN:  u1, 
                    
                    /// [1:1] Toggling this bit will trigger a software sync.
                    SW:  u1, 
                    
                    /// [2:3] PWM timer2 sync_out selection, 0: sync_in, 1: TEZ, 2: TEP, and sync out will always generate when toggling the reg_timer0_sync_sw bit
                    TIMER2_SYNCO_SEL:  u2, 
                    
                    /// [4:19] phase for timer reload on sync event
                    TIMER2_PHASE:  u16, 
                    
                    /// [20:20] Configure the PWM timer2's direction when timer2 mode is up-down mode: 0-increase,1-decrease
                    TIMER2_PHASE_DIRECTION:  u1, 
                    
                    /// [21:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6001402c));
                
                /// PWM timer2 status register.
                pub const TIMER2_STATUS = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:15] current PWM timer2 counter value
                    TIMER2_VALUE:  u16, 
                    
                    /// [16:16] current PWM timer2 counter direction, 0: increment 1: decrement
                    TIMER2_DIRECTION:  u1, 
                    
                    /// [17:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60014030));
                
                /// Synchronization input selection for three PWM timers.
                pub const TIMER_SYNCI_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:2] select sync input for PWM timer0, 1: PWM timer0 sync_out, 2: PWM timer1 sync_out, 3: PWM timer2 sync_out, 4: SYNC0 from GPIO matrix, 5: SYNC1 from GPIO matrix, 6: SYNC2 from GPIO matrix, other values: no sync input selected
                    TIMER0_SYNCISEL:  u3, 
                    
                    /// [3:5] select sync input for PWM timer1, 1: PWM timer0 sync_out, 2: PWM timer1 sync_out, 3: PWM timer2 sync_out, 4: SYNC0 from GPIO matrix, 5: SYNC1 from GPIO matrix, 6: SYNC2 from GPIO matrix, other values: no sync input selected
                    TIMER1_SYNCISEL:  u3, 
                    
                    /// [6:8] select sync input for PWM timer2, 1: PWM timer0 sync_out, 2: PWM timer1 sync_out, 3: PWM timer2 sync_out, 4: SYNC0 from GPIO matrix, 5: SYNC1 from GPIO matrix, 6: SYNC2 from GPIO matrix, other values: no sync input selected
                    TIMER2_SYNCISEL:  u3, 
                    
                    /// [9:9] invert SYNC0 from GPIO matrix
                    EXTERNAL_SYNCI0_INVERT:  u1, 
                    
                    /// [10:10] invert SYNC1 from GPIO matrix
                    EXTERNAL_SYNCI1_INVERT:  u1, 
                    
                    /// [11:11] invert SYNC2 from GPIO matrix
                    EXTERNAL_SYNCI2_INVERT:  u1, 
                    
                    /// [12:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60014034));
                
                /// Select specific timer for PWM operators.
                pub const OPERATOR_TIMERSEL = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:1] Select which PWM timer's is the timing reference for PWM operator0, 0: timer0, 1: timer1, 2: timer2
                    OPERATOR0_TIMERSEL:  u2, 
                    
                    /// [2:3] Select which PWM timer's is the timing reference for PWM operator1, 0: timer0, 1: timer1, 2: timer2
                    OPERATOR1_TIMERSEL:  u2, 
                    
                    /// [4:5] Select which PWM timer's is the timing reference for PWM operator2, 0: timer0, 1: timer1, 2: timer2
                    OPERATOR2_TIMERSEL:  u2, 
                    
                    /// [6:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60014038));
                
                /// Transfer status and update method for time stamp registers A and B
                pub const GEN0_STMP_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:3] Update method for PWM generator 0 time stamp A's active register. When all bits are set to 0: immediately, when bit0 is set to 1: TEZ, when bit1 is set to 1: TEP,when bit2 is set to 1: sync, when bit3 is set to 1: disable the update.
                    CMPR0_A_UPMETHOD:  u4, 
                    
                    /// [4:7] Update method for PWM generator 0 time stamp B's active register. When all bits are set to 0: immediately, when bit0 is set to 1: TEZ, when bit1 is set to 1: TEP,when bit2 is set to 1: sync, when bit3 is set to 1: disable the update.
                    CMPR0_B_UPMETHOD:  u4, 
                    
                    /// [8:8] Set and reset by hardware. If set, PWM generator 0 time stamp A's shadow reg is filled and waiting to be transferred to A's active reg. If cleared, A's active reg has been updated with shadow register latest value
                    CMPR0_A_SHDW_FULL:  u1, 
                    
                    /// [9:9] Set and reset by hardware. If set, PWM generator 0 time stamp B's shadow reg is filled and waiting to be transferred to B's active reg. If cleared, B's active reg has been updated with shadow register latest value
                    CMPR0_B_SHDW_FULL:  u1, 
                    
                    /// [10:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6001403c));
                
                /// Shadow register for register A.
                pub const GEN0_TSTMP_A = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:15] PWM generator 0 time stamp A's shadow register
                    CMPR0_A:  u16, 
                    
                    /// [16:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60014040));
                
                /// Shadow register for register B.
                pub const GEN0_TSTMP_B = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:15] PWM generator 0 time stamp B's shadow register
                    CMPR0_B:  u16, 
                    
                    /// [16:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60014044));
                
                /// Fault event T0 and T1 handling
                pub const GEN0_CFG0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:3] Update method for PWM generator 0's active register of configuration. When all bits are set to 0: immediately, when bit0 is set to 1: TEZ, when bit1 is set to 1:TEP,when bit2 is set to 1:sync,when bit3 is set to 1:disable the update
                    GEN0_CFG_UPMETHOD:  u4, 
                    
                    /// [4:6] Source selection for PWM generator 0 event_t0, take effect immediately, 0: fault_event0, 1: fault_event1, 2: fault_event2, 3: sync_taken, 4: none
                    GEN0_T0_SEL:  u3, 
                    
                    /// [7:9] Source selection for PWM generator 0 event_t1, take effect immediately, 0: fault_event0, 1: fault_event1, 2: fault_event2, 3: sync_taken, 4: none
                    GEN0_T1_SEL:  u3, 
                    
                    /// [10:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60014048));
                
                /// Permissives to force PWM0A and PWM0B outputs by software
                pub const GEN0_FORCE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] Updating method for continuous software force of PWM generator0. When all bits are set to 0: immediately, when bit0 is set to 1: TEZ,,when bit1 is set to 1: TEP, when bit2 is set to 1: TEA, when bit3 is set to 1: TEB, when bit4 is set to 1: sync, when bit5 is set to 1: disable update. (TEA/B here and below means an event generated when the timer's value equals to that of register A/B.)
                    GEN0_CNTUFORCE_UPMETHOD:  u6, 
                    
                    /// [6:7] Continuous software force mode for PWM0A. 0: disabled, 1: low, 2: high, 3: disabled
                    GEN0_A_CNTUFORCE_MODE:  u2, 
                    
                    /// [8:9] Continuous software force mode for PWM0B. 0: disabled, 1: low, 2: high, 3: disabled
                    GEN0_B_CNTUFORCE_MODE:  u2, 
                    
                    /// [10:10] Trigger of non-continuous immediate software-force event for PWM0A, a toggle will trigger a force event.
                    GEN0_A_NCIFORCE:  u1, 
                    
                    /// [11:12] non-continuous immediate software force mode for PWM0A, 0: disabled, 1: low, 2: high, 3: disabled
                    GEN0_A_NCIFORCE_MODE:  u2, 
                    
                    /// [13:13] Trigger of non-continuous immediate software-force event for PWM0B, a toggle will trigger a force event.
                    GEN0_B_NCIFORCE:  u1, 
                    
                    /// [14:15] non-continuous immediate software force mode for PWM0B, 0: disabled, 1: low, 2: high, 3: disabled
                    GEN0_B_NCIFORCE_MODE:  u2, 
                    
                    /// [16:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6001404c));
                
                /// Actions triggered by events on PWM0A
                pub const GEN0_A = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:1] Action on PWM0A triggered by event TEZ when timer increasing
                    UTEZ:  u2, 
                    
                    /// [2:3] Action on PWM0A triggered by event TEP when timer increasing
                    UTEP:  u2, 
                    
                    /// [4:5] Action on PWM0A triggered by event TEA when timer increasing
                    UTEA:  u2, 
                    
                    /// [6:7] Action on PWM0A triggered by event TEB when timer increasing
                    UTEB:  u2, 
                    
                    /// [8:9] Action on PWM0A triggered by event_t0 when timer increasing
                    UT0:  u2, 
                    
                    /// [10:11] Action on PWM0A triggered by event_t1 when timer increasing
                    UT1:  u2, 
                    
                    /// [12:13] Action on PWM0A triggered by event TEZ when timer decreasing
                    DTEZ:  u2, 
                    
                    /// [14:15] Action on PWM0A triggered by event TEP when timer decreasing
                    DTEP:  u2, 
                    
                    /// [16:17] Action on PWM0A triggered by event TEA when timer decreasing
                    DTEA:  u2, 
                    
                    /// [18:19] Action on PWM0A triggered by event TEB when timer decreasing
                    DTEB:  u2, 
                    
                    /// [20:21] Action on PWM0A triggered by event_t0 when timer decreasing
                    DT0:  u2, 
                    
                    /// [22:23] Action on PWM0A triggered by event_t1 when timer decreasing. 0: no change, 1: low, 2: high, 3: toggle
                    DT1:  u2, 
                    
                    /// [24:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60014050));
                
                /// Actions triggered by events on PWM0B
                pub const GEN0_B = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:1] Action on PWM0B triggered by event TEZ when timer increasing
                    UTEZ:  u2, 
                    
                    /// [2:3] Action on PWM0B triggered by event TEP when timer increasing
                    UTEP:  u2, 
                    
                    /// [4:5] Action on PWM0B triggered by event TEA when timer increasing
                    UTEA:  u2, 
                    
                    /// [6:7] Action on PWM0B triggered by event TEB when timer increasing
                    UTEB:  u2, 
                    
                    /// [8:9] Action on PWM0B triggered by event_t0 when timer increasing
                    UT0:  u2, 
                    
                    /// [10:11] Action on PWM0B triggered by event_t1 when timer increasing
                    UT1:  u2, 
                    
                    /// [12:13] Action on PWM0B triggered by event TEZ when timer decreasing
                    DTEZ:  u2, 
                    
                    /// [14:15] Action on PWM0B triggered by event TEP when timer decreasing
                    DTEP:  u2, 
                    
                    /// [16:17] Action on PWM0B triggered by event TEA when timer decreasing
                    DTEA:  u2, 
                    
                    /// [18:19] Action on PWM0B triggered by event TEB when timer decreasing
                    DTEB:  u2, 
                    
                    /// [20:21] Action on PWM0B triggered by event_t0 when timer decreasing
                    DT0:  u2, 
                    
                    /// [22:23] Action on PWM0B triggered by event_t1 when timer decreasing. 0: no change, 1: low, 2: high, 3: toggle
                    DT1:  u2, 
                    
                    /// [24:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60014054));
                
                /// dead time type selection and configuration
                pub const DT0_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:3] Update method for FED (rising edge delay) active register. 0: immediate, when bit0 is set to 1: tez, when bit1 is set to 1:tep,when bit2 is set to 1: sync, when bit3 is set to 1: disable the update
                    DB0_FED_UPMETHOD:  u4, 
                    
                    /// [4:7] Update method for RED (rising edge delay) active register. 0: immediate, when bit0 is set to 1: tez, when bit1 is set to 1:tep,when bit2 is set to 1: sync, when bit3 is set to 1: disable the update
                    DB0_RED_UPMETHOD:  u4, 
                    
                    /// [8:8] S8 in table, dual-edge B mode, 0: fed/red take effect on different path separately, 1: fed/red take effect on B path, A out is in bypass or dulpB mode
                    DB0_DEB_MODE:  u1, 
                    
                    /// [9:9] S6 in table
                    DB0_A_OUTSWAP:  u1, 
                    
                    /// [10:10] S7 in table
                    DB0_B_OUTSWAP:  u1, 
                    
                    /// [11:11] S4 in table
                    DB0_RED_INSEL:  u1, 
                    
                    /// [12:12] S5 in table
                    DB0_FED_INSEL:  u1, 
                    
                    /// [13:13] S2 in table
                    DB0_RED_OUTINVERT:  u1, 
                    
                    /// [14:14] S3 in table
                    DB0_FED_OUTINVERT:  u1, 
                    
                    /// [15:15] S1 in table
                    DB0_A_OUTBYPASS:  u1, 
                    
                    /// [16:16] S0 in table
                    DB0_B_OUTBYPASS:  u1, 
                    
                    /// [17:17] Dead time generator 0 clock selection. 0: PWM_clk, 1: PT_clk
                    DB0_CLK_SEL:  u1, 
                    
                    /// [18:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60014058));
                
                /// Shadow register for falling edge delay (FED).
                pub const DT0_FED_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:15] Shadow register for FED
                    DB0_FED:  u16, 
                    
                    /// [16:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6001405c));
                
                /// Shadow register for rising edge delay (RED).
                pub const DT0_RED_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:15] Shadow register for RED
                    DB0_RED:  u16, 
                    
                    /// [16:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60014060));
                
                /// Carrier enable and configuratoin
                pub const CARRIER0_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] When set, carrier0 function is enabled. When cleared, carrier0 is bypassed
                    CHOPPER0_EN:  u1, 
                    
                    /// [1:4] PWM carrier0 clock (PC_clk) prescale value. Period of PC_clk = period of PWM_clk * (PWM_CARRIER0_PRESCALE + 1)
                    CHOPPER0_PRESCALE:  u4, 
                    
                    /// [5:7] carrier duty selection. Duty = PWM_CARRIER0_DUTY / 8
                    CHOPPER0_DUTY:  u3, 
                    
                    /// [8:11] width of the first pulse in number of periods of the carrier
                    CHOPPER0_OSHTWTH:  u4, 
                    
                    /// [12:12] when set, invert the output of PWM0A and PWM0B for this submodule
                    CHOPPER0_OUT_INVERT:  u1, 
                    
                    /// [13:13] when set, invert the input of PWM0A and PWM0B for this submodule
                    CHOPPER0_IN_INVERT:  u1, 
                    
                    /// [14:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60014064));
                
                /// Actions on PWM0A and PWM0B trip events
                pub const FH0_CFG0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Enable register for software force cycle-by-cycle mode action. 0: disable, 1: enable
                    TZ0_SW_CBC:  u1, 
                    
                    /// [1:1] event_f2 will trigger cycle-by-cycle mode action. 0: disable, 1: enable
                    TZ0_F2_CBC:  u1, 
                    
                    /// [2:2] event_f1 will trigger cycle-by-cycle mode action. 0: disable, 1: enable
                    TZ0_F1_CBC:  u1, 
                    
                    /// [3:3] event_f0 will trigger cycle-by-cycle mode action. 0: disable, 1: enable
                    TZ0_F0_CBC:  u1, 
                    
                    /// [4:4] Enable register for software force one-shot mode action. 0: disable, 1: enable
                    TZ0_SW_OST:  u1, 
                    
                    /// [5:5] event_f2 will trigger one-shot mode action. 0: disable, 1: enable
                    TZ0_F2_OST:  u1, 
                    
                    /// [6:6] event_f1 will trigger one-shot mode action. 0: disable, 1: enable
                    TZ0_F1_OST:  u1, 
                    
                    /// [7:7] event_f0 will trigger one-shot mode action. 0: disable, 1: enable
                    TZ0_F0_OST:  u1, 
                    
                    /// [8:9] Cycle-by-cycle mode action on PWM0A when fault event occurs and timer is decreasing. 0: do nothing, 1: force low, 2: force high, 3: toggle
                    TZ0_A_CBC_D:  u2, 
                    
                    /// [10:11] Cycle-by-cycle mode action on PWM0A when fault event occurs and timer is increasing. 0: do nothing, 1: force low, 2: force high, 3: toggle
                    TZ0_A_CBC_U:  u2, 
                    
                    /// [12:13] One-shot mode action on PWM0A when fault event occurs and timer is decreasing. 0: do nothing, 1: force low, 2: force high, 3: toggle
                    TZ0_A_OST_D:  u2, 
                    
                    /// [14:15] One-shot mode action on PWM0A when fault event occurs and timer is increasing. 0: do nothing, 1: force low, 2: force high, 3: toggle
                    TZ0_A_OST_U:  u2, 
                    
                    /// [16:17] Cycle-by-cycle mode action on PWM0B when fault event occurs and timer is decreasing. 0: do nothing, 1: force low, 2: force high, 3: toggle
                    TZ0_B_CBC_D:  u2, 
                    
                    /// [18:19] Cycle-by-cycle mode action on PWM0B when fault event occurs and timer is increasing. 0: do nothing,1: force low, 2: force high, 3: toggle
                    TZ0_B_CBC_U:  u2, 
                    
                    /// [20:21] One-shot mode action on PWM0B when fault event occurs and timer is decreasing. 0: do nothing, 1: force low, 2: force high, 3: toggle
                    TZ0_B_OST_D:  u2, 
                    
                    /// [22:23] One-shot mode action on PWM0B when fault event occurs and timer is increasing. 0: do nothing, 1: force low, 2: force high, 3: toggle
                    TZ0_B_OST_U:  u2, 
                    
                    /// [24:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60014068));
                
                /// Software triggers for fault handler actions
                pub const FH0_CFG1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] a rising edge will clear on going one-shot mode action
                    TZ0_CLR_OST:  u1, 
                    
                    /// [1:2] cycle-by-cycle mode action refresh moment selection. When bit0 is set to 1: TEZ, when bit1 is set to 1:TEP
                    TZ0_CBCPULSE:  u2, 
                    
                    /// [3:3] a toggle trigger a cycle-by-cycle mode action
                    TZ0_FORCE_CBC:  u1, 
                    
                    /// [4:4] a toggle (software negate its value) triggers a one-shot mode action
                    TZ0_FORCE_OST:  u1, 
                    
                    /// [5:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6001406c));
                
                /// Status of fault events.
                pub const FH0_STATUS = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Set and reset by hardware. If set, a cycle-by-cycle mode action is on going
                    TZ0_CBC_ON:  u1, 
                    
                    /// [1:1] Set and reset by hardware. If set, an one-shot mode action is on going
                    TZ0_OST_ON:  u1, 
                    
                    /// [2:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60014070));
                
                /// Transfer status and update method for time stamp registers A and B
                pub const GEN1_STMP_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:3] Update method for PWM generator 1 time stamp A's active register. When all bits are set to 0: immediately, when bit0 is set to 1: TEZ, when bit1 is set to 1: TEP,when bit2 is set to 1: sync, when bit3 is set to 1: disable the update.
                    CMPR1_A_UPMETHOD:  u4, 
                    
                    /// [4:7] Update method for PWM generator 1 time stamp B's active register. When all bits are set to 0: immediately, when bit0 is set to 1: TEZ, when bit1 is set to 1: TEP,when bit2 is set to 1: sync, when bit3 is set to 1: disable the update.
                    CMPR1_B_UPMETHOD:  u4, 
                    
                    /// [8:8] Set and reset by hardware. If set, PWM generator 1 time stamp A's shadow reg is filled and waiting to be transferred to A's active reg. If cleared, A's active reg has been updated with shadow register latest value
                    CMPR1_A_SHDW_FULL:  u1, 
                    
                    /// [9:9] Set and reset by hardware. If set, PWM generator 1 time stamp B's shadow reg is filled and waiting to be transferred to B's active reg. If cleared, B's active reg has been updated with shadow register latest value
                    CMPR1_B_SHDW_FULL:  u1, 
                    
                    /// [10:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60014074));
                
                /// Shadow register for register A.
                pub const GEN1_TSTMP_A = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:15] PWM generator 1 time stamp A's shadow register
                    CMPR1_A:  u16, 
                    
                    /// [16:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60014078));
                
                /// Shadow register for register B.
                pub const GEN1_TSTMP_B = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:15] PWM generator 1 time stamp B's shadow register
                    CMPR1_B:  u16, 
                    
                    /// [16:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6001407c));
                
                /// Fault event T0 and T1 handling
                pub const GEN1_CFG0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:3] Update method for PWM generator 1's active register of configuration. When all bits are set to 0: immediately, when bit0 is set to 1: TEZ, when bit1 is set to 1:sync;when bit3 is set to 1:disable the update.
                    GEN1_CFG_UPMETHOD:  u4, 
                    
                    /// [4:6] Source selection for PWM generator 1 event_t0, take effect immediately, 0: fault_event0, 1: fault_event1, 2: fault_event2, 3: sync_taken, 4: none
                    GEN1_T0_SEL:  u3, 
                    
                    /// [7:9] Source selection for PWM generator 1 event_t1, take effect immediately, 0: fault_event0, 1: fault_event1, 2: fault_event2, 3: sync_taken, 4: none
                    GEN1_T1_SEL:  u3, 
                    
                    /// [10:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60014080));
                
                /// Permissives to force PWM1A and PWM1B outputs by software
                pub const GEN1_FORCE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] Updating method for continuous software force of PWM generator 1. When all bits are set to 0: immediately, when bit0 is set to 1: TEZ,,when bit1 is set to 1: TEP, when bit2 is set to 1: TEA, when bit3 is set to 1: TEB, when bit4 is set to 1: sync, when bit5 is set to 1: disable update. (TEA/B here and below means an event generated when the timer's value equals to that of register A/B.)
                    GEN1_CNTUFORCE_UPMETHOD:  u6, 
                    
                    /// [6:7] Continuous software force mode for PWM1A. 0: disabled, 1: low, 2: high, 3: disabled
                    GEN1_A_CNTUFORCE_MODE:  u2, 
                    
                    /// [8:9] Continuous software force mode for PWM1B. 0: disabled, 1: low, 2: high, 3: disabled
                    GEN1_B_CNTUFORCE_MODE:  u2, 
                    
                    /// [10:10] Trigger of non-continuous immediate software-force event for PWM1A, a toggle will trigger a force event.
                    GEN1_A_NCIFORCE:  u1, 
                    
                    /// [11:12] non-continuous immediate software force mode for PWM1A, 0: disabled, 1: low, 2: high, 3: disabled
                    GEN1_A_NCIFORCE_MODE:  u2, 
                    
                    /// [13:13] Trigger of non-continuous immediate software-force event for PWM1B, a toggle will trigger a force event.
                    GEN1_B_NCIFORCE:  u1, 
                    
                    /// [14:15] non-continuous immediate software force mode for PWM1B, 0: disabled, 1: low, 2: high, 3: disabled
                    GEN1_B_NCIFORCE_MODE:  u2, 
                    
                    /// [16:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60014084));
                
                /// Actions triggered by events on PWM1A
                pub const GEN1_A = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:1] Action on PWM1A triggered by event TEZ when timer increasing
                    UTEZ:  u2, 
                    
                    /// [2:3] Action on PWM1A triggered by event TEP when timer increasing
                    UTEP:  u2, 
                    
                    /// [4:5] Action on PWM1A triggered by event TEA when timer increasing
                    UTEA:  u2, 
                    
                    /// [6:7] Action on PWM1A triggered by event TEB when timer increasing
                    UTEB:  u2, 
                    
                    /// [8:9] Action on PWM1A triggered by event_t0 when timer increasing
                    UT0:  u2, 
                    
                    /// [10:11] Action on PWM1A triggered by event_t1 when timer increasing
                    UT1:  u2, 
                    
                    /// [12:13] Action on PWM1A triggered by event TEZ when timer decreasing
                    DTEZ:  u2, 
                    
                    /// [14:15] Action on PWM1A triggered by event TEP when timer decreasing
                    DTEP:  u2, 
                    
                    /// [16:17] Action on PWM1A triggered by event TEA when timer decreasing
                    DTEA:  u2, 
                    
                    /// [18:19] Action on PWM1A triggered by event TEB when timer decreasing
                    DTEB:  u2, 
                    
                    /// [20:21] Action on PWM1A triggered by event_t0 when timer decreasing
                    DT0:  u2, 
                    
                    /// [22:23] Action on PWM1A triggered by event_t1 when timer decreasing. 0: no change, 1: low, 2: high, 3: toggle
                    DT1:  u2, 
                    
                    /// [24:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60014088));
                
                /// Actions triggered by events on PWM1B
                pub const GEN1_B = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:1] Action on PWM1B triggered by event TEZ when timer increasing
                    UTEZ:  u2, 
                    
                    /// [2:3] Action on PWM1B triggered by event TEP when timer increasing
                    UTEP:  u2, 
                    
                    /// [4:5] Action on PWM1B triggered by event TEA when timer increasing
                    UTEA:  u2, 
                    
                    /// [6:7] Action on PWM1B triggered by event TEB when timer increasing
                    UTEB:  u2, 
                    
                    /// [8:9] Action on PWM1B triggered by event_t0 when timer increasing
                    UT0:  u2, 
                    
                    /// [10:11] Action on PWM1B triggered by event_t1 when timer increasing
                    UT1:  u2, 
                    
                    /// [12:13] Action on PWM1B triggered by event TEZ when timer decreasing
                    DTEZ:  u2, 
                    
                    /// [14:15] Action on PWM1B triggered by event TEP when timer decreasing
                    DTEP:  u2, 
                    
                    /// [16:17] Action on PWM1B triggered by event TEA when timer decreasing
                    DTEA:  u2, 
                    
                    /// [18:19] Action on PWM1B triggered by event TEB when timer decreasing
                    DTEB:  u2, 
                    
                    /// [20:21] Action on PWM1B triggered by event_t0 when timer decreasing
                    DT0:  u2, 
                    
                    /// [22:23] Action on PWM1B triggered by event_t1 when timer decreasing. 0: no change, 1: low, 2: high, 3: toggle
                    DT1:  u2, 
                    
                    /// [24:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6001408c));
                
                /// dead time type selection and configuration
                pub const DT1_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:3] Update method for FED (falling edge delay) active register. 0: immediate, when bit0 is set to 1: tez, when bit1 is set to 1:tep,when bit2 is set to 1: sync, when bit3 is set to 1: disable the update
                    DB1_FED_UPMETHOD:  u4, 
                    
                    /// [4:7] Update method for RED (rising edge delay) active register. 0: immediate,when bit0 is set to 1: tez, when bit1 is set to 1:tep,when bit2 is set to 1: sync, when bit3 is set to 1: disable the update
                    DB1_RED_UPMETHOD:  u4, 
                    
                    /// [8:8] S8 in table, dual-edge B mode, 0: fed/red take effect on different path separately, 1: fed/red take effect on B path, A out is in bypass or dulpB mode
                    DB1_DEB_MODE:  u1, 
                    
                    /// [9:9] S6 in table
                    DB1_A_OUTSWAP:  u1, 
                    
                    /// [10:10] S7 in table
                    DB1_B_OUTSWAP:  u1, 
                    
                    /// [11:11] S4 in table
                    DB1_RED_INSEL:  u1, 
                    
                    /// [12:12] S5 in table
                    DB1_FED_INSEL:  u1, 
                    
                    /// [13:13] S2 in table
                    DB1_RED_OUTINVERT:  u1, 
                    
                    /// [14:14] S3 in table
                    DB1_FED_OUTINVERT:  u1, 
                    
                    /// [15:15] S1 in table
                    DB1_A_OUTBYPASS:  u1, 
                    
                    /// [16:16] S0 in table
                    DB1_B_OUTBYPASS:  u1, 
                    
                    /// [17:17] Dead time generator 1 clock selection. 0: PWM_clk, 1: PT_clk
                    DB1_CLK_SEL:  u1, 
                    
                    /// [18:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60014090));
                
                /// Shadow register for falling edge delay (FED).
                pub const DT1_FED_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:15] Shadow register for FED
                    DB1_FED:  u16, 
                    
                    /// [16:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60014094));
                
                /// Shadow register for rising edge delay (RED).
                pub const DT1_RED_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:15] Shadow register for RED
                    DB1_RED:  u16, 
                    
                    /// [16:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60014098));
                
                /// Carrier enable and configuratoin
                pub const CARRIER1_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] When set, carrier1 function is enabled. When cleared, carrier1 is bypassed
                    CHOPPER1_EN:  u1, 
                    
                    /// [1:4] PWM carrier1 clock (PC_clk) prescale value. Period of PC_clk = period of PWM_clk * (PWM_CARRIER0_PRESCALE + 1)
                    CHOPPER1_PRESCALE:  u4, 
                    
                    /// [5:7] carrier duty selection. Duty = PWM_CARRIER0_DUTY / 8
                    CHOPPER1_DUTY:  u3, 
                    
                    /// [8:11] width of the first pulse in number of periods of the carrier
                    CHOPPER1_OSHTWTH:  u4, 
                    
                    /// [12:12] when set, invert the output of PWM1A and PWM1B for this submodule
                    CHOPPER1_OUT_INVERT:  u1, 
                    
                    /// [13:13] when set, invert the input of PWM1A and PWM1B for this submodule
                    CHOPPER1_IN_INVERT:  u1, 
                    
                    /// [14:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6001409c));
                
                /// Actions on PWM1A and PWM1B trip events
                pub const FH1_CFG0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Enable register for software force cycle-by-cycle mode action. 0: disable, 1: enable
                    TZ1_SW_CBC:  u1, 
                    
                    /// [1:1] event_f2 will trigger cycle-by-cycle mode action. 0: disable, 1: enable
                    TZ1_F2_CBC:  u1, 
                    
                    /// [2:2] event_f1 will trigger cycle-by-cycle mode action. 0: disable, 1: enable
                    TZ1_F1_CBC:  u1, 
                    
                    /// [3:3] event_f0 will trigger cycle-by-cycle mode action. 0: disable, 1: enable
                    TZ1_F0_CBC:  u1, 
                    
                    /// [4:4] Enable register for software force one-shot mode action. 0: disable, 1: enable
                    TZ1_SW_OST:  u1, 
                    
                    /// [5:5] event_f2 will trigger one-shot mode action. 0: disable, 1: enable
                    TZ1_F2_OST:  u1, 
                    
                    /// [6:6] event_f1 will trigger one-shot mode action. 0: disable, 1: enable
                    TZ1_F1_OST:  u1, 
                    
                    /// [7:7] event_f0 will trigger one-shot mode action. 0: disable, 1: enable
                    TZ1_F0_OST:  u1, 
                    
                    /// [8:9] Cycle-by-cycle mode action on PWM1A when fault event occurs and timer is decreasing. 0: do nothing, 1: force low, 2: force high, 3: toggle
                    TZ1_A_CBC_D:  u2, 
                    
                    /// [10:11] Cycle-by-cycle mode action on PWM1A when fault event occurs and timer is increasing. 0: do nothing, 1: force low, 2: force high, 3: toggle
                    TZ1_A_CBC_U:  u2, 
                    
                    /// [12:13] One-shot mode action on PWM1A when fault event occurs and timer is decreasing. 0: do nothing,1: force low, 2: force high, 3: toggle
                    TZ1_A_OST_D:  u2, 
                    
                    /// [14:15] One-shot mode action on PWM1A when fault event occurs and timer is increasing. 0: do nothing, 1: force low, 2: force high, 3: toggle
                    TZ1_A_OST_U:  u2, 
                    
                    /// [16:17] Cycle-by-cycle mode action on PWM1B when fault event occurs and timer is decreasing. 0: do nothing, 1: force low, 2: force high, 3: toggle
                    TZ1_B_CBC_D:  u2, 
                    
                    /// [18:19] Cycle-by-cycle mode action on PWM1B when fault event occurs and timer is increasing. 0: do nothing, 1: force low, 2: force high, 3: toggle
                    TZ1_B_CBC_U:  u2, 
                    
                    /// [20:21] One-shot mode action on PWM1B when fault event occurs and timer is decreasing. 0: do nothing, 1: force low, 2: force high, 3: toggle
                    TZ1_B_OST_D:  u2, 
                    
                    /// [22:23] One-shot mode action on PWM1B when fault event occurs and timer is increasing. 0: do nothing, 1: force low, 2: force high, 3: toggle
                    TZ1_B_OST_U:  u2, 
                    
                    /// [24:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600140a0));
                
                /// Software triggers for fault handler actions
                pub const FH1_CFG1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] a rising edge will clear on going one-shot mode action
                    TZ1_CLR_OST:  u1, 
                    
                    /// [1:2] cycle-by-cycle mode action refresh moment selection. When bit0 is set to 1: TEZ, when bit1 is set to 1:TEP
                    TZ1_CBCPULSE:  u2, 
                    
                    /// [3:3] a toggle trigger a cycle-by-cycle mode action
                    TZ1_FORCE_CBC:  u1, 
                    
                    /// [4:4] a toggle (software negate its value) triggers a one-shot mode action
                    TZ1_FORCE_OST:  u1, 
                    
                    /// [5:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600140a4));
                
                /// Status of fault events.
                pub const FH1_STATUS = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Set and reset by hardware. If set, a cycle-by-cycle mode action is on going
                    TZ1_CBC_ON:  u1, 
                    
                    /// [1:1] Set and reset by hardware. If set, an one-shot mode action is on going
                    TZ1_OST_ON:  u1, 
                    
                    /// [2:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600140a8));
                
                /// Transfer status and update method for time stamp registers A and B
                pub const GEN2_STMP_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:3] Update method for PWM generator 2 time stamp A's active register. When all bits are set to 0: immediately, when bit0 is set to 1: TEZ, when bit1 is set to 1: TEP,when bit2 is set to 1: sync, when bit3 is set to 1: disable the update.
                    CMPR2_A_UPMETHOD:  u4, 
                    
                    /// [4:7] Update method for PWM generator 2 time stamp B's active register. When all bits are set to 0: immediately, when bit0 is set to 1: TEZ, when bit1 is set to 1: TEP,when bit2 is set to 1: sync, when bit3 is set to 1: disable the update.
                    CMPR2_B_UPMETHOD:  u4, 
                    
                    /// [8:8] Set and reset by hardware. If set, PWM generator 2 time stamp A's shadow reg is filled and waiting to be transferred to A's active reg. If cleared, A's active reg has been updated with shadow register latest value
                    CMPR2_A_SHDW_FULL:  u1, 
                    
                    /// [9:9] Set and reset by hardware. If set, PWM generator 2 time stamp B's shadow reg is filled and waiting to be transferred to B's active reg. If cleared, B's active reg has been updated with shadow register latest value
                    CMPR2_B_SHDW_FULL:  u1, 
                    
                    /// [10:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600140ac));
                
                /// Shadow register for register A.
                pub const GEN2_TSTMP_A = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:15] PWM generator 2 time stamp A's shadow register
                    CMPR2_A:  u16, 
                    
                    /// [16:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600140b0));
                
                /// Shadow register for register B.
                pub const GEN2_TSTMP_B = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:15] PWM generator 2 time stamp B's shadow register
                    CMPR2_B:  u16, 
                    
                    /// [16:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600140b4));
                
                /// Fault event T0 and T1 handling
                pub const GEN2_CFG0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:3] Update method for PWM generator 2's active register of configuration. 0: immediately, when bit0 is set to 1: TEZ, when bit1 is set to 1:sync;when bit3 is set to 1:disable the update.
                    GEN2_CFG_UPMETHOD:  u4, 
                    
                    /// [4:6] Source selection for PWM generator 2 event_t0, take effect immediately, 0: fault_event0, 1: fault_event1, 2: fault_event2, 3: sync_taken, 4: none
                    GEN2_T0_SEL:  u3, 
                    
                    /// [7:9] Source selection for PWM generator 2 event_t1, take effect immediately, 0: fault_event0, 1: fault_event1, 2: fault_event2, 3: sync_taken, 4: none
                    GEN2_T1_SEL:  u3, 
                    
                    /// [10:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600140b8));
                
                /// Permissives to force PWM2A and PWM2B outputs by software
                pub const GEN2_FORCE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] Updating method for continuous software force of PWM generator 2. When all bits are set to 0: immediately, when bit0 is set to 1: TEZ,when bit1 is set to 1: TEP, when bit2 is set to 1: TEA, when bit3 is set to 1: TEB, when bit4 is set to 1: sync, when bit5 is set to 1: disable update. (TEA/B here and below means an event generated when the timer's value equals to that of register A/B.)
                    GEN2_CNTUFORCE_UPMETHOD:  u6, 
                    
                    /// [6:7] Continuous software force mode for PWM2A. 0: disabled, 1: low, 2: high, 3: disabled
                    GEN2_A_CNTUFORCE_MODE:  u2, 
                    
                    /// [8:9] Continuous software force mode for PWM2B. 0: disabled, 1: low, 2: high, 3: disabled
                    GEN2_B_CNTUFORCE_MODE:  u2, 
                    
                    /// [10:10] Trigger of non-continuous immediate software-force event for PWM2A, a toggle will trigger a force event.
                    GEN2_A_NCIFORCE:  u1, 
                    
                    /// [11:12] non-continuous immediate software force mode for PWM2A, 0: disabled, 1: low, 2: high, 3: disabled
                    GEN2_A_NCIFORCE_MODE:  u2, 
                    
                    /// [13:13] Trigger of non-continuous immediate software-force event for PWM2B, a toggle will trigger a force event.
                    GEN2_B_NCIFORCE:  u1, 
                    
                    /// [14:15] non-continuous immediate software force mode for PWM2B, 0: disabled, 1: low, 2: high, 3: disabled
                    GEN2_B_NCIFORCE_MODE:  u2, 
                    
                    /// [16:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600140bc));
                
                /// Actions triggered by events on PWM2A
                pub const GEN2_A = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:1] Action on PWM2A triggered by event TEZ when timer increasing
                    UTEZ:  u2, 
                    
                    /// [2:3] Action on PWM2A triggered by event TEP when timer increasing
                    UTEP:  u2, 
                    
                    /// [4:5] Action on PWM2A triggered by event TEA when timer increasing
                    UTEA:  u2, 
                    
                    /// [6:7] Action on PWM2A triggered by event TEB when timer increasing
                    UTEB:  u2, 
                    
                    /// [8:9] Action on PWM2A triggered by event_t0 when timer increasing
                    UT0:  u2, 
                    
                    /// [10:11] Action on PWM2A triggered by event_t1 when timer increasing
                    UT1:  u2, 
                    
                    /// [12:13] Action on PWM2A triggered by event TEZ when timer decreasing
                    DTEZ:  u2, 
                    
                    /// [14:15] Action on PWM2A triggered by event TEP when timer decreasing
                    DTEP:  u2, 
                    
                    /// [16:17] Action on PWM2A triggered by event TEA when timer decreasing
                    DTEA:  u2, 
                    
                    /// [18:19] Action on PWM2A triggered by event TEB when timer decreasing
                    DTEB:  u2, 
                    
                    /// [20:21] Action on PWM2A triggered by event_t0 when timer decreasing
                    DT0:  u2, 
                    
                    /// [22:23] Action on PWM2A triggered by event_t1 when timer decreasing. 0: no change, 1: low, 2: high, 3: toggle
                    DT1:  u2, 
                    
                    /// [24:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600140c0));
                
                /// Actions triggered by events on PWM2B
                pub const GEN2_B = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:1] Action on PWM2B triggered by event TEZ when timer increasing
                    UTEZ:  u2, 
                    
                    /// [2:3] Action on PWM2B triggered by event TEP when timer increasing
                    UTEP:  u2, 
                    
                    /// [4:5] Action on PWM2B triggered by event TEA when timer increasing
                    UTEA:  u2, 
                    
                    /// [6:7] Action on PWM2B triggered by event TEB when timer increasing
                    UTEB:  u2, 
                    
                    /// [8:9] Action on PWM2B triggered by event_t0 when timer increasing
                    UT0:  u2, 
                    
                    /// [10:11] Action on PWM2B triggered by event_t1 when timer increasing
                    UT1:  u2, 
                    
                    /// [12:13] Action on PWM2B triggered by event TEZ when timer decreasing
                    DTEZ:  u2, 
                    
                    /// [14:15] Action on PWM2B triggered by event TEP when timer decreasing
                    DTEP:  u2, 
                    
                    /// [16:17] Action on PWM2B triggered by event TEA when timer decreasing
                    DTEA:  u2, 
                    
                    /// [18:19] Action on PWM2B triggered by event TEB when timer decreasing
                    DTEB:  u2, 
                    
                    /// [20:21] Action on PWM2B triggered by event_t0 when timer decreasing
                    DT0:  u2, 
                    
                    /// [22:23] Action on PWM2B triggered by event_t1 when timer decreasing. 0: no change, 1: low, 2: high, 3: toggle
                    DT1:  u2, 
                    
                    /// [24:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600140c4));
                
                /// dead time type selection and configuration
                pub const DT2_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:3] Update method for FED (falling edge delay) active register.0: immediate,when bit0 is set to 1: tez, when bit1 is set to 1:tep,when bit2 is set to 1: sync, when bit3 is set to 1: disable the update
                    DB2_FED_UPMETHOD:  u4, 
                    
                    /// [4:7] Update method for RED (rising edge delay) active register.0: immediate,when bit0 is set to 1: tez, when bit1 is set to 1:tep,when bit2 is set to 1: sync, when bit3 is set to 1: disable the update
                    DB2_RED_UPMETHOD:  u4, 
                    
                    /// [8:8] S8 in table, dual-edge B mode, 0: fed/red take effect on different path separately, 1: fed/red take effect on B path, A out is in bypass or dulpB mode
                    DB2_DEB_MODE:  u1, 
                    
                    /// [9:9] S6 in table
                    DB2_A_OUTSWAP:  u1, 
                    
                    /// [10:10] S7 in table
                    DB2_B_OUTSWAP:  u1, 
                    
                    /// [11:11] S4 in table
                    DB2_RED_INSEL:  u1, 
                    
                    /// [12:12] S5 in table
                    DB2_FED_INSEL:  u1, 
                    
                    /// [13:13] S2 in table
                    DB2_RED_OUTINVERT:  u1, 
                    
                    /// [14:14] S3 in table
                    DB2_FED_OUTINVERT:  u1, 
                    
                    /// [15:15] S1 in table
                    DB2_A_OUTBYPASS:  u1, 
                    
                    /// [16:16] S0 in table
                    DB2_B_OUTBYPASS:  u1, 
                    
                    /// [17:17] Dead time generator 2 clock selection. 0: PWM_clk, 1: PT_clk
                    DB2_CLK_SEL:  u1, 
                    
                    /// [18:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600140c8));
                
                /// Shadow register for falling edge delay (FED).
                pub const DT2_FED_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:15] Shadow register for FED
                    DB2_FED:  u16, 
                    
                    /// [16:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600140cc));
                
                /// Shadow register for rising edge delay (RED).
                pub const DT2_RED_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:15] Shadow register for RED
                    DB2_RED:  u16, 
                    
                    /// [16:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600140d0));
                
                /// Carrier enable and configuratoin
                pub const CARRIER2_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] When set, carrier2 function is enabled. When cleared, carrier2 is bypassed
                    CHOPPER2_EN:  u1, 
                    
                    /// [1:4] PWM carrier2 clock (PC_clk) prescale value. Period of PC_clk = period of PWM_clk * (PWM_CARRIER0_PRESCALE + 1)
                    CHOPPER2_PRESCALE:  u4, 
                    
                    /// [5:7] carrier duty selection. Duty = PWM_CARRIER0_DUTY / 8
                    CHOPPER2_DUTY:  u3, 
                    
                    /// [8:11] width of the first pulse in number of periods of the carrier
                    CHOPPER2_OSHTWTH:  u4, 
                    
                    /// [12:12] when set, invert the output of PWM2A and PWM2B for this submodule
                    CHOPPER2_OUT_INVERT:  u1, 
                    
                    /// [13:13] when set, invert the input of PWM2A and PWM2B for this submodule
                    CHOPPER2_IN_INVERT:  u1, 
                    
                    /// [14:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600140d4));
                
                /// Actions on PWM2A and PWM2B trip events
                pub const FH2_CFG0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Enable register for software force cycle-by-cycle mode action. 0: disable, 1: enable
                    TZ2_SW_CBC:  u1, 
                    
                    /// [1:1] event_f2 will trigger cycle-by-cycle mode action. 0: disable, 1: enable
                    TZ2_F2_CBC:  u1, 
                    
                    /// [2:2] event_f1 will trigger cycle-by-cycle mode action. 0: disable, 1: enable
                    TZ2_F1_CBC:  u1, 
                    
                    /// [3:3] event_f0 will trigger cycle-by-cycle mode action. 0: disable, 1: enable
                    TZ2_F0_CBC:  u1, 
                    
                    /// [4:4] Enable register for software force one-shot mode action. 0: disable, 1: enable
                    TZ2_SW_OST:  u1, 
                    
                    /// [5:5] event_f2 will trigger one-shot mode action. 0: disable, 1: enable
                    TZ2_F2_OST:  u1, 
                    
                    /// [6:6] event_f1 will trigger one-shot mode action. 0: disable, 1: enable
                    TZ2_F1_OST:  u1, 
                    
                    /// [7:7] event_f0 will trigger one-shot mode action. 0: disable, 1: enable
                    TZ2_F0_OST:  u1, 
                    
                    /// [8:9] Cycle-by-cycle mode action on PWM2A when fault event occurs and timer is decreasing. 0: do nothing, 1: force low, 2: force high, 3: toggle
                    TZ2_A_CBC_D:  u2, 
                    
                    /// [10:11] Cycle-by-cycle mode action on PWM2A when fault event occurs and timer is increasing. 0: do nothing, 1: force low, 2: force high, 3: toggle
                    TZ2_A_CBC_U:  u2, 
                    
                    /// [12:13] One-shot mode action on PWM2A when fault event occurs and timer is decreasing. 0: do nothing, 1: force low, 2: force high, 3: toggle
                    TZ2_A_OST_D:  u2, 
                    
                    /// [14:15] One-shot mode action on PWM2A when fault event occurs and timer is increasing. 0: do nothing, 1: force low, 2: force high, 3: toggle
                    TZ2_A_OST_U:  u2, 
                    
                    /// [16:17] Cycle-by-cycle mode action on PWM2B when fault event occurs and timer is decreasing. 0: do nothing, 1: force low, 2: force high, 3: toggle
                    TZ2_B_CBC_D:  u2, 
                    
                    /// [18:19] Cycle-by-cycle mode action on PWM2B when fault event occurs and timer is increasing. 0: do nothing, 1: force low, 2: force high, 3: toggle
                    TZ2_B_CBC_U:  u2, 
                    
                    /// [20:21] One-shot mode action on PWM2B when fault event occurs and timer is decreasing. 0: do nothing, 1: force low, 2: force high, 3: toggle
                    TZ2_B_OST_D:  u2, 
                    
                    /// [22:23] One-shot mode action on PWM2B when fault event occurs and timer is increasing. 0: do nothing, 1: force low, 2: force high, 3: toggle
                    TZ2_B_OST_U:  u2, 
                    
                    /// [24:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600140d8));
                
                /// Software triggers for fault handler actions
                pub const FH2_CFG1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] a rising edge will clear on going one-shot mode action
                    TZ2_CLR_OST:  u1, 
                    
                    /// [1:2] cycle-by-cycle mode action refresh moment selection. When bit0 is set to 1: TEZ, when bit1 is set to 1:TEP
                    TZ2_CBCPULSE:  u2, 
                    
                    /// [3:3] a toggle trigger a cycle-by-cycle mode action
                    TZ2_FORCE_CBC:  u1, 
                    
                    /// [4:4] a toggle (software negate its value) triggers a one-shot mode action
                    TZ2_FORCE_OST:  u1, 
                    
                    /// [5:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600140dc));
                
                /// Status of fault events.
                pub const FH2_STATUS = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Set and reset by hardware. If set, a cycle-by-cycle mode action is on going
                    TZ2_CBC_ON:  u1, 
                    
                    /// [1:1] Set and reset by hardware. If set, an one-shot mode action is on going
                    TZ2_OST_ON:  u1, 
                    
                    /// [2:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600140e0));
                
                /// Fault detection configuration and status
                pub const FAULT_DETECT = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] When set, event_f0 generation is enabled
                    F0_EN:  u1, 
                    
                    /// [1:1] When set, event_f1 generation is enabled
                    F1_EN:  u1, 
                    
                    /// [2:2] When set, event_f2 generation is enabled
                    F2_EN:  u1, 
                    
                    /// [3:3] Set event_f0 trigger polarity on FAULT2 source from GPIO matrix. 0: level low, 1: level high
                    F0_POLE:  u1, 
                    
                    /// [4:4] Set event_f1 trigger polarity on FAULT2 source from GPIO matrix. 0: level low, 1: level high
                    F1_POLE:  u1, 
                    
                    /// [5:5] Set event_f2 trigger polarity on FAULT2 source from GPIO matrix. 0: level low, 1: level high
                    F2_POLE:  u1, 
                    
                    /// [6:6] Set and reset by hardware. If set, event_f0 is on going
                    EVENT_F0:  u1, 
                    
                    /// [7:7] Set and reset by hardware. If set, event_f1 is on going
                    EVENT_F1:  u1, 
                    
                    /// [8:8] Set and reset by hardware. If set, event_f2 is on going
                    EVENT_F2:  u1, 
                    
                    /// [9:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600140e4));
                
                /// Configure capture timer
                pub const CAP_TIMER_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] When set, capture timer incrementing under APB_clk is enabled.
                    CAP_TIMER_EN:  u1, 
                    
                    /// [1:1] When set, capture timer sync is enabled.
                    CAP_SYNCI_EN:  u1, 
                    
                    /// [2:4] capture module sync input selection. 0: none, 1: timer0 sync_out, 2: timer1 sync_out, 3: timer2 sync_out, 4: SYNC0 from GPIO matrix, 5: SYNC1 from GPIO matrix, 6: SYNC2 from GPIO matrix
                    CAP_SYNCI_SEL:  u3, 
                    
                    /// [5:5] When reg_cap_synci_en is 1,write 1 will trigger a capture timer sync, capture timer is loaded with value in phase register.
                    CAP_SYNC_SW:  u1, 
                    
                    /// [6:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600140e8));
                
                /// Phase for capture timer sync
                pub const CAP_TIMER_PHASE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Phase value for capture timer sync operation.
                    CAP_PHASE:  u32, 
                    
                }), @ptrFromInt(0x600140ec));
                
                /// Capture channel 0 configuration and enable
                pub const CAP_CH0_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] When set, capture on channel 0 is enabled
                    CAP0_EN:  u1, 
                    
                    /// [1:2] Edge of capture on channel 0 after prescaling. When bit0 is set to 1: enable capture on the negative edge, When bit1 is set to 1: enable capture on the positive edge.
                    CAP0_MODE:  u2, 
                    
                    /// [3:10] Value of prescaling on possitive edge of CAP0. Prescale value = PWM_CAP0_PRESCALE + 1
                    CAP0_PRESCALE:  u8, 
                    
                    /// [11:11] when set, CAP0 form GPIO matrix is inverted before prescale
                    CAP0_IN_INVERT:  u1, 
                    
                    /// [12:12] Write 1 will trigger a software forced capture on channel 0
                    CAP0_SW:  u1, 
                    
                    /// [13:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600140f0));
                
                /// Capture channel 1 configuration and enable
                pub const CAP_CH1_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] When set, capture on channel 2 is enabled
                    CAP1_EN:  u1, 
                    
                    /// [1:2] Edge of capture on channel 1 after prescaling. When bit0 is set to 1: enable capture on the negative edge, When bit1 is set to 1: enable capture on the positive edge.
                    CAP1_MODE:  u2, 
                    
                    /// [3:10] Value of prescaling on possitive edge of CAP1. Prescale value = PWM_CAP1_PRESCALE + 1
                    CAP1_PRESCALE:  u8, 
                    
                    /// [11:11] when set, CAP1 form GPIO matrix is inverted before prescale
                    CAP1_IN_INVERT:  u1, 
                    
                    /// [12:12] Write 1 will trigger a software forced capture on channel 1
                    CAP1_SW:  u1, 
                    
                    /// [13:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600140f4));
                
                /// Capture channel 2 configuration and enable
                pub const CAP_CH2_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] When set, capture on channel 2 is enabled
                    CAP2_EN:  u1, 
                    
                    /// [1:2] Edge of capture on channel 2 after prescaling. When bit0 is set to 1: enable capture on the negative edge, When bit1 is set to 1: enable capture on the positive edge.
                    CAP2_MODE:  u2, 
                    
                    /// [3:10] Value of prescaling on possitive edge of CAP2. Prescale value = PWM_CAP2_PRESCALE + 1
                    CAP2_PRESCALE:  u8, 
                    
                    /// [11:11] when set, CAP2 form GPIO matrix is inverted before prescale
                    CAP2_IN_INVERT:  u1, 
                    
                    /// [12:12] Write 1 will trigger a software forced capture on channel 2
                    CAP2_SW:  u1, 
                    
                    /// [13:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600140f8));
                
                /// ch0 capture value status register
                pub const CAP_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Value of last capture on channel 0
                    CAP0_VALUE:  u32, 
                    
                }), @ptrFromInt(0x600140fc));
                
                /// ch1 capture value status register
                pub const CAP_CH1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Value of last capture on channel 1
                    CAP1_VALUE:  u32, 
                    
                }), @ptrFromInt(0x60014100));
                
                /// ch2 capture value status register
                pub const CAP_CH2 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Value of last capture on channel 2
                    CAP2_VALUE:  u32, 
                    
                }), @ptrFromInt(0x60014104));
                
                /// Edge of last capture trigger
                pub const CAP_STATUS = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Edge of last capture trigger on channel 0, 0: posedge, 1: negedge
                    CAP0_EDGE:  u1, 
                    
                    /// [1:1] Edge of last capture trigger on channel 1, 0: posedge, 1: negedge
                    CAP1_EDGE:  u1, 
                    
                    /// [2:2] Edge of last capture trigger on channel 2, 0: posedge, 1: negedge
                    CAP2_EDGE:  u1, 
                    
                    /// [3:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60014108));
                
                /// Enable update.
                pub const UPDATE_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] The global enable of update of all active registers in MCPWM module
                    GLOBAL_UP_EN:  u1, 
                    
                    /// [1:1] a toggle (software invert its value) will trigger a forced update of all active registers in MCPWM module
                    GLOBAL_FORCE_UP:  u1, 
                    
                    /// [2:2] When set and PWM_GLOBAL_UP_EN is set, update of active registers in PWM operator 0 are enabled
                    OP0_UP_EN:  u1, 
                    
                    /// [3:3] a toggle (software invert its value) will trigger a forced update of active registers in PWM operator 0
                    OP0_FORCE_UP:  u1, 
                    
                    /// [4:4] When set and PWM_GLOBAL_UP_EN is set, update of active registers in PWM operator 1 are enabled
                    OP1_UP_EN:  u1, 
                    
                    /// [5:5] a toggle (software invert its value) will trigger a forced update of active registers in PWM operator 1
                    OP1_FORCE_UP:  u1, 
                    
                    /// [6:6] When set and PWM_GLOBAL_UP_EN is set, update of active registers in PWM operator 2 are enabled
                    OP2_UP_EN:  u1, 
                    
                    /// [7:7] a toggle (software invert its value) will trigger a forced update of active registers in PWM operator 2
                    OP2_FORCE_UP:  u1, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6001410c));
                
                /// Interrupt enable bits
                pub const INT_ENA = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] The enable bit for the interrupt triggered when the timer 0 stops.
                    TIMER0_STOP_INT_ENA:  u1, 
                    
                    /// [1:1] The enable bit for the interrupt triggered when the timer 1 stops.
                    TIMER1_STOP_INT_ENA:  u1, 
                    
                    /// [2:2] The enable bit for the interrupt triggered when the timer 2 stops.
                    TIMER2_STOP_INT_ENA:  u1, 
                    
                    /// [3:3] The enable bit for the interrupt triggered by a PWM timer 0 TEZ event.
                    TIMER0_TEZ_INT_ENA:  u1, 
                    
                    /// [4:4] The enable bit for the interrupt triggered by a PWM timer 1 TEZ event.
                    TIMER1_TEZ_INT_ENA:  u1, 
                    
                    /// [5:5] The enable bit for the interrupt triggered by a PWM timer 2 TEZ event.
                    TIMER2_TEZ_INT_ENA:  u1, 
                    
                    /// [6:6] The enable bit for the interrupt triggered by a PWM timer 0 TEP event.
                    TIMER0_TEP_INT_ENA:  u1, 
                    
                    /// [7:7] The enable bit for the interrupt triggered by a PWM timer 1 TEP event.
                    TIMER1_TEP_INT_ENA:  u1, 
                    
                    /// [8:8] The enable bit for the interrupt triggered by a PWM timer 2 TEP event.
                    TIMER2_TEP_INT_ENA:  u1, 
                    
                    /// [9:9] The enable bit for the interrupt triggered when event_f0 starts.
                    FAULT0_INT_ENA:  u1, 
                    
                    /// [10:10] The enable bit for the interrupt triggered when event_f1 starts.
                    FAULT1_INT_ENA:  u1, 
                    
                    /// [11:11] The enable bit for the interrupt triggered when event_f2 starts.
                    FAULT2_INT_ENA:  u1, 
                    
                    /// [12:12] The enable bit for the interrupt triggered when event_f0 ends.
                    FAULT0_CLR_INT_ENA:  u1, 
                    
                    /// [13:13] The enable bit for the interrupt triggered when event_f1 ends.
                    FAULT1_CLR_INT_ENA:  u1, 
                    
                    /// [14:14] The enable bit for the interrupt triggered when event_f2 ends.
                    FAULT2_CLR_INT_ENA:  u1, 
                    
                    /// [15:15] The enable bit for the interrupt triggered by a PWM operator 0 TEA event
                    CMPR0_TEA_INT_ENA:  u1, 
                    
                    /// [16:16] The enable bit for the interrupt triggered by a PWM operator 1 TEA event
                    CMPR1_TEA_INT_ENA:  u1, 
                    
                    /// [17:17] The enable bit for the interrupt triggered by a PWM operator 2 TEA event
                    CMPR2_TEA_INT_ENA:  u1, 
                    
                    /// [18:18] The enable bit for the interrupt triggered by a PWM operator 0 TEB event
                    CMPR0_TEB_INT_ENA:  u1, 
                    
                    /// [19:19] The enable bit for the interrupt triggered by a PWM operator 1 TEB event
                    CMPR1_TEB_INT_ENA:  u1, 
                    
                    /// [20:20] The enable bit for the interrupt triggered by a PWM operator 2 TEB event
                    CMPR2_TEB_INT_ENA:  u1, 
                    
                    /// [21:21] The enable bit for the interrupt triggered by a cycle-by-cycle mode action on PWM0.
                    TZ0_CBC_INT_ENA:  u1, 
                    
                    /// [22:22] The enable bit for the interrupt triggered by a cycle-by-cycle mode action on PWM1.
                    TZ1_CBC_INT_ENA:  u1, 
                    
                    /// [23:23] The enable bit for the interrupt triggered by a cycle-by-cycle mode action on PWM2.
                    TZ2_CBC_INT_ENA:  u1, 
                    
                    /// [24:24] The enable bit for the interrupt triggered by a one-shot mode action on PWM0.
                    TZ0_OST_INT_ENA:  u1, 
                    
                    /// [25:25] The enable bit for the interrupt triggered by a one-shot mode action on PWM1.
                    TZ1_OST_INT_ENA:  u1, 
                    
                    /// [26:26] The enable bit for the interrupt triggered by a one-shot mode action on PWM2.
                    TZ2_OST_INT_ENA:  u1, 
                    
                    /// [27:27] The enable bit for the interrupt triggered by capture on channel 0.
                    CAP0_INT_ENA:  u1, 
                    
                    /// [28:28] The enable bit for the interrupt triggered by capture on channel 1.
                    CAP1_INT_ENA:  u1, 
                    
                    /// [29:29] The enable bit for the interrupt triggered by capture on channel 2.
                    CAP2_INT_ENA:  u1, 
                    
                    /// [30:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60014110));
                
                /// Raw interrupt status
                pub const INT_RAW = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] The raw status bit for the interrupt triggered when the timer 0 stops.
                    TIMER0_STOP_INT_RAW:  u1, 
                    
                    /// [1:1] The raw status bit for the interrupt triggered when the timer 1 stops.
                    TIMER1_STOP_INT_RAW:  u1, 
                    
                    /// [2:2] The raw status bit for the interrupt triggered when the timer 2 stops.
                    TIMER2_STOP_INT_RAW:  u1, 
                    
                    /// [3:3] The raw status bit for the interrupt triggered by a PWM timer 0 TEZ event.
                    TIMER0_TEZ_INT_RAW:  u1, 
                    
                    /// [4:4] The raw status bit for the interrupt triggered by a PWM timer 1 TEZ event.
                    TIMER1_TEZ_INT_RAW:  u1, 
                    
                    /// [5:5] The raw status bit for the interrupt triggered by a PWM timer 2 TEZ event.
                    TIMER2_TEZ_INT_RAW:  u1, 
                    
                    /// [6:6] The raw status bit for the interrupt triggered by a PWM timer 0 TEP event.
                    TIMER0_TEP_INT_RAW:  u1, 
                    
                    /// [7:7] The raw status bit for the interrupt triggered by a PWM timer 1 TEP event.
                    TIMER1_TEP_INT_RAW:  u1, 
                    
                    /// [8:8] The raw status bit for the interrupt triggered by a PWM timer 2 TEP event.
                    TIMER2_TEP_INT_RAW:  u1, 
                    
                    /// [9:9] The raw status bit for the interrupt triggered when event_f0 starts.
                    FAULT0_INT_RAW:  u1, 
                    
                    /// [10:10] The raw status bit for the interrupt triggered when event_f1 starts.
                    FAULT1_INT_RAW:  u1, 
                    
                    /// [11:11] The raw status bit for the interrupt triggered when event_f2 starts.
                    FAULT2_INT_RAW:  u1, 
                    
                    /// [12:12] The raw status bit for the interrupt triggered when event_f0 ends.
                    FAULT0_CLR_INT_RAW:  u1, 
                    
                    /// [13:13] The raw status bit for the interrupt triggered when event_f1 ends.
                    FAULT1_CLR_INT_RAW:  u1, 
                    
                    /// [14:14] The raw status bit for the interrupt triggered when event_f2 ends.
                    FAULT2_CLR_INT_RAW:  u1, 
                    
                    /// [15:15] The raw status bit for the interrupt triggered by a PWM operator 0 TEA event
                    CMPR0_TEA_INT_RAW:  u1, 
                    
                    /// [16:16] The raw status bit for the interrupt triggered by a PWM operator 1 TEA event
                    CMPR1_TEA_INT_RAW:  u1, 
                    
                    /// [17:17] The raw status bit for the interrupt triggered by a PWM operator 2 TEA event
                    CMPR2_TEA_INT_RAW:  u1, 
                    
                    /// [18:18] The raw status bit for the interrupt triggered by a PWM operator 0 TEB event
                    CMPR0_TEB_INT_RAW:  u1, 
                    
                    /// [19:19] The raw status bit for the interrupt triggered by a PWM operator 1 TEB event
                    CMPR1_TEB_INT_RAW:  u1, 
                    
                    /// [20:20] The raw status bit for the interrupt triggered by a PWM operator 2 TEB event
                    CMPR2_TEB_INT_RAW:  u1, 
                    
                    /// [21:21] The raw status bit for the interrupt triggered by a cycle-by-cycle mode action on PWM0.
                    TZ0_CBC_INT_RAW:  u1, 
                    
                    /// [22:22] The raw status bit for the interrupt triggered by a cycle-by-cycle mode action on PWM1.
                    TZ1_CBC_INT_RAW:  u1, 
                    
                    /// [23:23] The raw status bit for the interrupt triggered by a cycle-by-cycle mode action on PWM2.
                    TZ2_CBC_INT_RAW:  u1, 
                    
                    /// [24:24] The raw status bit for the interrupt triggered by a one-shot mode action on PWM0.
                    TZ0_OST_INT_RAW:  u1, 
                    
                    /// [25:25] The raw status bit for the interrupt triggered by a one-shot mode action on PWM1.
                    TZ1_OST_INT_RAW:  u1, 
                    
                    /// [26:26] The raw status bit for the interrupt triggered by a one-shot mode action on PWM2.
                    TZ2_OST_INT_RAW:  u1, 
                    
                    /// [27:27] The raw status bit for the interrupt triggered by capture on channel 0.
                    CAP0_INT_RAW:  u1, 
                    
                    /// [28:28] The raw status bit for the interrupt triggered by capture on channel 1.
                    CAP1_INT_RAW:  u1, 
                    
                    /// [29:29] The raw status bit for the interrupt triggered by capture on channel 2.
                    CAP2_INT_RAW:  u1, 
                    
                    /// [30:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60014114));
                
                /// Masked interrupt status
                pub const INT_ST = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] The masked status bit for the interrupt triggered when the timer 0 stops.
                    TIMER0_STOP_INT_ST:  u1, 
                    
                    /// [1:1] The masked status bit for the interrupt triggered when the timer 1 stops.
                    TIMER1_STOP_INT_ST:  u1, 
                    
                    /// [2:2] The masked status bit for the interrupt triggered when the timer 2 stops.
                    TIMER2_STOP_INT_ST:  u1, 
                    
                    /// [3:3] The masked status bit for the interrupt triggered by a PWM timer 0 TEZ event.
                    TIMER0_TEZ_INT_ST:  u1, 
                    
                    /// [4:4] The masked status bit for the interrupt triggered by a PWM timer 1 TEZ event.
                    TIMER1_TEZ_INT_ST:  u1, 
                    
                    /// [5:5] The masked status bit for the interrupt triggered by a PWM timer 2 TEZ event.
                    TIMER2_TEZ_INT_ST:  u1, 
                    
                    /// [6:6] The masked status bit for the interrupt triggered by a PWM timer 0 TEP event.
                    TIMER0_TEP_INT_ST:  u1, 
                    
                    /// [7:7] The masked status bit for the interrupt triggered by a PWM timer 1 TEP event.
                    TIMER1_TEP_INT_ST:  u1, 
                    
                    /// [8:8] The masked status bit for the interrupt triggered by a PWM timer 2 TEP event.
                    TIMER2_TEP_INT_ST:  u1, 
                    
                    /// [9:9] The masked status bit for the interrupt triggered when event_f0 starts.
                    FAULT0_INT_ST:  u1, 
                    
                    /// [10:10] The masked status bit for the interrupt triggered when event_f1 starts.
                    FAULT1_INT_ST:  u1, 
                    
                    /// [11:11] The masked status bit for the interrupt triggered when event_f2 starts.
                    FAULT2_INT_ST:  u1, 
                    
                    /// [12:12] The masked status bit for the interrupt triggered when event_f0 ends.
                    FAULT0_CLR_INT_ST:  u1, 
                    
                    /// [13:13] The masked status bit for the interrupt triggered when event_f1 ends.
                    FAULT1_CLR_INT_ST:  u1, 
                    
                    /// [14:14] The masked status bit for the interrupt triggered when event_f2 ends.
                    FAULT2_CLR_INT_ST:  u1, 
                    
                    /// [15:15] The masked status bit for the interrupt triggered by a PWM operator 0 TEA event
                    CMPR0_TEA_INT_ST:  u1, 
                    
                    /// [16:16] The masked status bit for the interrupt triggered by a PWM operator 1 TEA event
                    CMPR1_TEA_INT_ST:  u1, 
                    
                    /// [17:17] The masked status bit for the interrupt triggered by a PWM operator 2 TEA event
                    CMPR2_TEA_INT_ST:  u1, 
                    
                    /// [18:18] The masked status bit for the interrupt triggered by a PWM operator 0 TEB event
                    CMPR0_TEB_INT_ST:  u1, 
                    
                    /// [19:19] The masked status bit for the interrupt triggered by a PWM operator 1 TEB event
                    CMPR1_TEB_INT_ST:  u1, 
                    
                    /// [20:20] The masked status bit for the interrupt triggered by a PWM operator 2 TEB event
                    CMPR2_TEB_INT_ST:  u1, 
                    
                    /// [21:21] The masked status bit for the interrupt triggered by a cycle-by-cycle mode action on PWM0.
                    TZ0_CBC_INT_ST:  u1, 
                    
                    /// [22:22] The masked status bit for the interrupt triggered by a cycle-by-cycle mode action on PWM1.
                    TZ1_CBC_INT_ST:  u1, 
                    
                    /// [23:23] The masked status bit for the interrupt triggered by a cycle-by-cycle mode action on PWM2.
                    TZ2_CBC_INT_ST:  u1, 
                    
                    /// [24:24] The masked status bit for the interrupt triggered by a one-shot mode action on PWM0.
                    TZ0_OST_INT_ST:  u1, 
                    
                    /// [25:25] The masked status bit for the interrupt triggered by a one-shot mode action on PWM1.
                    TZ1_OST_INT_ST:  u1, 
                    
                    /// [26:26] The masked status bit for the interrupt triggered by a one-shot mode action on PWM2.
                    TZ2_OST_INT_ST:  u1, 
                    
                    /// [27:27] The masked status bit for the interrupt triggered by capture on channel 0.
                    CAP0_INT_ST:  u1, 
                    
                    /// [28:28] The masked status bit for the interrupt triggered by capture on channel 1.
                    CAP1_INT_ST:  u1, 
                    
                    /// [29:29] The masked status bit for the interrupt triggered by capture on channel 2.
                    CAP2_INT_ST:  u1, 
                    
                    /// [30:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60014118));
                
                /// Interrupt clear bits
                pub const INT_CLR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Set this bit to clear the interrupt triggered when the timer 0 stops.
                    TIMER0_STOP_INT_CLR:  u1, 
                    
                    /// [1:1] Set this bit to clear the interrupt triggered when the timer 1 stops.
                    TIMER1_STOP_INT_CLR:  u1, 
                    
                    /// [2:2] Set this bit to clear the interrupt triggered when the timer 2 stops.
                    TIMER2_STOP_INT_CLR:  u1, 
                    
                    /// [3:3] Set this bit to clear the interrupt triggered by a PWM timer 0 TEZ event.
                    TIMER0_TEZ_INT_CLR:  u1, 
                    
                    /// [4:4] Set this bit to clear the interrupt triggered by a PWM timer 1 TEZ event.
                    TIMER1_TEZ_INT_CLR:  u1, 
                    
                    /// [5:5] Set this bit to clear the interrupt triggered by a PWM timer 2 TEZ event.
                    TIMER2_TEZ_INT_CLR:  u1, 
                    
                    /// [6:6] Set this bit to clear the interrupt triggered by a PWM timer 0 TEP event.
                    TIMER0_TEP_INT_CLR:  u1, 
                    
                    /// [7:7] Set this bit to clear the interrupt triggered by a PWM timer 1 TEP event.
                    TIMER1_TEP_INT_CLR:  u1, 
                    
                    /// [8:8] Set this bit to clear the interrupt triggered by a PWM timer 2 TEP event.
                    TIMER2_TEP_INT_CLR:  u1, 
                    
                    /// [9:9] Set this bit to clear the interrupt triggered when event_f0 starts.
                    FAULT0_INT_CLR:  u1, 
                    
                    /// [10:10] Set this bit to clear the interrupt triggered when event_f1 starts.
                    FAULT1_INT_CLR:  u1, 
                    
                    /// [11:11] Set this bit to clear the interrupt triggered when event_f2 starts.
                    FAULT2_INT_CLR:  u1, 
                    
                    /// [12:12] Set this bit to clear the interrupt triggered when event_f0 ends.
                    FAULT0_CLR_INT_CLR:  u1, 
                    
                    /// [13:13] Set this bit to clear the interrupt triggered when event_f1 ends.
                    FAULT1_CLR_INT_CLR:  u1, 
                    
                    /// [14:14] Set this bit to clear the interrupt triggered when event_f2 ends.
                    FAULT2_CLR_INT_CLR:  u1, 
                    
                    /// [15:15] Set this bit to clear the interrupt triggered by a PWM operator 0 TEA event
                    CMPR0_TEA_INT_CLR:  u1, 
                    
                    /// [16:16] Set this bit to clear the interrupt triggered by a PWM operator 1 TEA event
                    CMPR1_TEA_INT_CLR:  u1, 
                    
                    /// [17:17] Set this bit to clear the interrupt triggered by a PWM operator 2 TEA event
                    CMPR2_TEA_INT_CLR:  u1, 
                    
                    /// [18:18] Set this bit to clear the interrupt triggered by a PWM operator 0 TEB event
                    CMPR0_TEB_INT_CLR:  u1, 
                    
                    /// [19:19] Set this bit to clear the interrupt triggered by a PWM operator 1 TEB event
                    CMPR1_TEB_INT_CLR:  u1, 
                    
                    /// [20:20] Set this bit to clear the interrupt triggered by a PWM operator 2 TEB event
                    CMPR2_TEB_INT_CLR:  u1, 
                    
                    /// [21:21] Set this bit to clear the interrupt triggered by a cycle-by-cycle mode action on PWM0.
                    TZ0_CBC_INT_CLR:  u1, 
                    
                    /// [22:22] Set this bit to clear the interrupt triggered by a cycle-by-cycle mode action on PWM1.
                    TZ1_CBC_INT_CLR:  u1, 
                    
                    /// [23:23] Set this bit to clear the interrupt triggered by a cycle-by-cycle mode action on PWM2.
                    TZ2_CBC_INT_CLR:  u1, 
                    
                    /// [24:24] Set this bit to clear the interrupt triggered by a one-shot mode action on PWM0.
                    TZ0_OST_INT_CLR:  u1, 
                    
                    /// [25:25] Set this bit to clear the interrupt triggered by a one-shot mode action on PWM1.
                    TZ1_OST_INT_CLR:  u1, 
                    
                    /// [26:26] Set this bit to clear the interrupt triggered by a one-shot mode action on PWM2.
                    TZ2_OST_INT_CLR:  u1, 
                    
                    /// [27:27] Set this bit to clear the interrupt triggered by capture on channel 0.
                    CAP0_INT_CLR:  u1, 
                    
                    /// [28:28] Set this bit to clear the interrupt triggered by capture on channel 1.
                    CAP1_INT_CLR:  u1, 
                    
                    /// [29:29] Set this bit to clear the interrupt triggered by capture on channel 2.
                    CAP2_INT_CLR:  u1, 
                    
                    /// [30:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6001411c));
                
                /// MCPWM event enable register
                pub const EVT_EN = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] set this bit high to enable timer0 stop event generate
                    EVT_TIMER0_STOP_EN:  u1, 
                    
                    /// [1:1] set this bit high to enable timer1 stop event generate
                    EVT_TIMER1_STOP_EN:  u1, 
                    
                    /// [2:2] set this bit high to enable timer2 stop event generate
                    EVT_TIMER2_STOP_EN:  u1, 
                    
                    /// [3:3] set this bit high to enable timer0 equal zero event generate
                    EVT_TIMER0_TEZ_EN:  u1, 
                    
                    /// [4:4] set this bit high to enable timer1 equal zero event generate
                    EVT_TIMER1_TEZ_EN:  u1, 
                    
                    /// [5:5] set this bit high to enable timer2 equal zero event generate
                    EVT_TIMER2_TEZ_EN:  u1, 
                    
                    /// [6:6] set this bit high to enable timer0 equal period event generate
                    EVT_TIMER0_TEP_EN:  u1, 
                    
                    /// [7:7] set this bit high to enable timer1 equal period event generate
                    EVT_TIMER1_TEP_EN:  u1, 
                    
                    /// [8:8] set this bit high to enable timer2 equal period event generate
                    EVT_TIMER2_TEP_EN:  u1, 
                    
                    /// [9:9] set this bit high to enable PWM generator0 timer equal a event generate
                    EVT_OP0_TEA_EN:  u1, 
                    
                    /// [10:10] set this bit high to enable PWM generator1 timer equal a event generate
                    EVT_OP1_TEA_EN:  u1, 
                    
                    /// [11:11] set this bit high to enable PWM generator2 timer equal a event generate
                    EVT_OP2_TEA_EN:  u1, 
                    
                    /// [12:12] set this bit high to enable PWM generator0 timer equal b event generate
                    EVT_OP0_TEB_EN:  u1, 
                    
                    /// [13:13] set this bit high to enable PWM generator1 timer equal b event generate
                    EVT_OP1_TEB_EN:  u1, 
                    
                    /// [14:14] set this bit high to enable PWM generator2 timer equal b event generate
                    EVT_OP2_TEB_EN:  u1, 
                    
                    /// [15:15] set this bit high to enable fault0 event generate
                    EVT_F0_EN:  u1, 
                    
                    /// [16:16] set this bit high to enable fault1 event generate
                    EVT_F1_EN:  u1, 
                    
                    /// [17:17] set this bit high to enable fault2 event generate
                    EVT_F2_EN:  u1, 
                    
                    /// [18:18] set this bit high to enable fault0 clear event generate
                    EVT_F0_CLR_EN:  u1, 
                    
                    /// [19:19] set this bit high to enable fault1 clear event generate
                    EVT_F1_CLR_EN:  u1, 
                    
                    /// [20:20] set this bit high to enable fault2 clear event generate
                    EVT_F2_CLR_EN:  u1, 
                    
                    /// [21:21] set this bit high to enable cycle by cycle trip0 event generate
                    EVT_TZ0_CBC_EN:  u1, 
                    
                    /// [22:22] set this bit high to enable cycle by cycle trip1 event generate
                    EVT_TZ1_CBC_EN:  u1, 
                    
                    /// [23:23] set this bit high to enable cycle by cycle trip2 event generate
                    EVT_TZ2_CBC_EN:  u1, 
                    
                    /// [24:24] set this bit high to enable one shot trip0 event generate
                    EVT_TZ0_OST_EN:  u1, 
                    
                    /// [25:25] set this bit high to enable one shot trip1 event generate
                    EVT_TZ1_OST_EN:  u1, 
                    
                    /// [26:26] set this bit high to enable one shot trip2 event generate
                    EVT_TZ2_OST_EN:  u1, 
                    
                    /// [27:27] set this bit high to enable capture0 event generate
                    EVT_CAP0_EN:  u1, 
                    
                    /// [28:28] set this bit high to enable capture1 event generate
                    EVT_CAP1_EN:  u1, 
                    
                    /// [29:29] set this bit high to enable capture2 event generate
                    EVT_CAP2_EN:  u1, 
                    
                    /// [30:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60014120));
                
                /// MCPWM task enable register
                pub const TASK_EN = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] set this bit high to enable PWM generator0 timer stamp A's shadow register update task receive
                    TASK_CMPR0_A_UP_EN:  u1, 
                    
                    /// [1:1] set this bit high to enable PWM generator1 timer stamp A's shadow register update task receive
                    TASK_CMPR1_A_UP_EN:  u1, 
                    
                    /// [2:2] set this bit high to enable PWM generator2 timer stamp A's shadow register update task receive
                    TASK_CMPR2_A_UP_EN:  u1, 
                    
                    /// [3:3] set this bit high to enable PWM generator0 timer stamp B's shadow register update task receive
                    TASK_CMPR0_B_UP_EN:  u1, 
                    
                    /// [4:4] set this bit high to enable PWM generator1 timer stamp B's shadow register update task receive
                    TASK_CMPR1_B_UP_EN:  u1, 
                    
                    /// [5:5] set this bit high to enable PWM generator2 timer stamp B's shadow register update task receive
                    TASK_CMPR2_B_UP_EN:  u1, 
                    
                    /// [6:6] set this bit high to enable all PWM generate stop task receive
                    TASK_GEN_STOP_EN:  u1, 
                    
                    /// [7:7] set this bit high to enable timer0 sync task receive
                    TASK_TIMER0_SYNC_EN:  u1, 
                    
                    /// [8:8] set this bit high to enable timer1 sync task receive
                    TASK_TIMER1_SYNC_EN:  u1, 
                    
                    /// [9:9] set this bit high to enable timer2 sync task receive
                    TASK_TIMER2_SYNC_EN:  u1, 
                    
                    /// [10:10] set this bit high to enable timer0 period update task receive
                    TASK_TIMER0_PERIOD_UP_EN:  u1, 
                    
                    /// [11:11] set this bit high to enable timer1 period update task receive
                    TASK_TIMER1_PERIOD_UP_EN:  u1, 
                    
                    /// [12:12] set this bit high to enable timer2 period update task receive
                    TASK_TIMER2_PERIOD_UP_EN:  u1, 
                    
                    /// [13:13] set this bit high to enable one shot trip0 task receive
                    TASK_TZ0_OST_EN:  u1, 
                    
                    /// [14:14] set this bit high to enable one shot trip1 task receive
                    TASK_TZ1_OST_EN:  u1, 
                    
                    /// [15:15] set this bit high to enable one shot trip2 task receive
                    TASK_TZ2_OST_EN:  u1, 
                    
                    /// [16:16] set this bit high to enable one shot trip0 clear task receive
                    TASK_CLR0_OST_EN:  u1, 
                    
                    /// [17:17] set this bit high to enable one shot trip1 clear task receive
                    TASK_CLR1_OST_EN:  u1, 
                    
                    /// [18:18] set this bit high to enable one shot trip2 clear task receive
                    TASK_CLR2_OST_EN:  u1, 
                    
                    /// [19:19] set this bit high to enable capture0 task receive
                    TASK_CAP0_EN:  u1, 
                    
                    /// [20:20] set this bit high to enable capture1 task receive
                    TASK_CAP1_EN:  u1, 
                    
                    /// [21:21] set this bit high to enable capture2 task receive
                    TASK_CAP2_EN:  u1, 
                    
                    /// [22:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60014124));
                
                /// MCPWM APB configuration register
                pub const CLK = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Force clock on for this register file
                    EN:  u1, 
                    
                    /// [1:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60014128));
                
                /// Version register.
                pub const VERSION = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:27] Version of this register file
                    DATE:  u28, 
                    
                    /// [28:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6001412c));
                
            };
            
            /// MEM_MONITOR Peripheral
            pub const MEM_MONITOR = struct {
                
                /// log config regsiter
                pub const LOG_SETTING = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:2] enable bus log. BIT0: hp-cpu, BIT1: lp-cpu, BIT2: DMA.
                    LOG_ENA:  u3, 
                    
                    /// [3:6] This field must be onehot. 4'b0001 : WR monitor, 4'b0010: WORD monitor, 4'b0100: HALFWORD monitor, 4'b1000: BYTE monitor.
                    LOG_MODE:  u4, 
                    
                    /// [7:7] Set 1 enable mem_loop, it will loop write at the range of MEM_START and MEM_END
                    LOG_MEM_LOOP_ENABLE:  u1, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60092000));
                
                /// check data regsiter
                pub const LOG_CHECK_DATA = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] The special check data, when write this special data, it will trigger logging.
                    LOG_CHECK_DATA:  u32, 
                    
                }), @ptrFromInt(0x60092004));
                
                /// check data mask register
                pub const LOG_DATA_MASK = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:3] byte mask enable, BIT0 mask the first byte of MEM_MONITOR_LOG_CHECK_DATA, and BIT1 mask second byte, and so on.
                    LOG_DATA_MASK:  u4, 
                    
                    /// [4:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60092008));
                
                /// log boundary regsiter
                pub const LOG_MIN = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] the min address of log range
                    LOG_MIN:  u32, 
                    
                }), @ptrFromInt(0x6009200c));
                
                /// log boundary regsiter
                pub const LOG_MAX = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] the max address of log range
                    LOG_MAX:  u32, 
                    
                }), @ptrFromInt(0x60092010));
                
                /// log message store range register
                pub const LOG_MEM_START = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] the start address of writing logging message
                    LOG_MEM_START:  u32, 
                    
                }), @ptrFromInt(0x60092014));
                
                /// log message store range register
                pub const LOG_MEM_END = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] the end address of writing logging message
                    LOG_MEM_END:  u32, 
                    
                }), @ptrFromInt(0x60092018));
                
                /// current writing address.
                pub const LOG_MEM_CURRENT_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] means next writing address
                    LOG_MEM_CURRENT_ADDR:  u32, 
                    
                }), @ptrFromInt(0x6009201c));
                
                /// writing address update
                pub const LOG_MEM_ADDR_UPDATE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Set 1 to updata MEM_MONITOR_LOG_MEM_CURRENT_ADDR, when set 1, MEM_MONITOR_LOG_MEM_CURRENT_ADDR will update to MEM_MONITOR_LOG_MEM_START
                    LOG_MEM_ADDR_UPDATE:  u1, 
                    
                    /// [1:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60092020));
                
                /// full flag status register
                pub const LOG_MEM_FULL_FLAG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] 1 means memory write loop at least one time at the range of MEM_START and MEM_END
                    LOG_MEM_FULL_FLAG:  u1, 
                    
                    /// [1:1] Set 1 to clr MEM_MONITOR_LOG_MEM_FULL_FLAG
                    CLR_LOG_MEM_FULL_FLAG:  u1, 
                    
                    /// [2:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60092024));
                
                /// clock gate force on register
                pub const CLOCK_GATE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Set 1 to force on the clk of mem_monitor register
                    CLK_EN:  u1, 
                    
                    /// [1:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60092028));
                
                /// version register
                pub const DATE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:27] version register
                    DATE:  u28, 
                    
                    /// [28:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600923fc));
                
            };
            
            /// MODEM_LPCON Peripheral
            pub const MODEM_LPCON = struct {
                
                /// 
                pub const TEST_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] 
                    CLK_EN:  u1, 
                    
                    /// [1:1] 
                    CLK_DEBUG_ENA:  u1, 
                    
                    /// [2:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600af000));
                
                /// 
                pub const LP_TIMER_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] 
                    CLK_LP_TIMER_SEL_OSC_SLOW:  u1, 
                    
                    /// [1:1] 
                    CLK_LP_TIMER_SEL_OSC_FAST:  u1, 
                    
                    /// [2:2] 
                    CLK_LP_TIMER_SEL_XTAL:  u1, 
                    
                    /// [3:3] 
                    CLK_LP_TIMER_SEL_XTAL32K:  u1, 
                    
                    /// [4:15] 
                    CLK_LP_TIMER_DIV_NUM:  u12, 
                    
                    /// [16:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600af004));
                
                /// 
                pub const COEX_LP_CLK_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] 
                    CLK_COEX_LP_SEL_OSC_SLOW:  u1, 
                    
                    /// [1:1] 
                    CLK_COEX_LP_SEL_OSC_FAST:  u1, 
                    
                    /// [2:2] 
                    CLK_COEX_LP_SEL_XTAL:  u1, 
                    
                    /// [3:3] 
                    CLK_COEX_LP_SEL_XTAL32K:  u1, 
                    
                    /// [4:15] 
                    CLK_COEX_LP_DIV_NUM:  u12, 
                    
                    /// [16:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600af008));
                
                /// 
                pub const WIFI_LP_CLK_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] 
                    CLK_WIFIPWR_LP_SEL_OSC_SLOW:  u1, 
                    
                    /// [1:1] 
                    CLK_WIFIPWR_LP_SEL_OSC_FAST:  u1, 
                    
                    /// [2:2] 
                    CLK_WIFIPWR_LP_SEL_XTAL:  u1, 
                    
                    /// [3:3] 
                    CLK_WIFIPWR_LP_SEL_XTAL32K:  u1, 
                    
                    /// [4:15] 
                    CLK_WIFIPWR_LP_DIV_NUM:  u12, 
                    
                    /// [16:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600af00c));
                
                /// 
                pub const I2C_MST_CLK_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] 
                    CLK_I2C_MST_SEL_160M:  u1, 
                    
                    /// [1:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600af010));
                
                /// 
                pub const MODEM_32K_CLK_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:1] 
                    CLK_MODEM_32K_SEL:  u2, 
                    
                    /// [2:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600af014));
                
                /// 
                pub const CLK_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] 
                    CLK_WIFIPWR_EN:  u1, 
                    
                    /// [1:1] 
                    CLK_COEX_EN:  u1, 
                    
                    /// [2:2] 
                    CLK_I2C_MST_EN:  u1, 
                    
                    /// [3:3] 
                    CLK_LP_TIMER_EN:  u1, 
                    
                    /// [4:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600af018));
                
                /// 
                pub const CLK_CONF_FORCE_ON = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] 
                    CLK_WIFIPWR_FO:  u1, 
                    
                    /// [1:1] 
                    CLK_COEX_FO:  u1, 
                    
                    /// [2:2] 
                    CLK_I2C_MST_FO:  u1, 
                    
                    /// [3:3] 
                    CLK_LP_TIMER_FO:  u1, 
                    
                    /// [4:4] 
                    CLK_BCMEM_FO:  u1, 
                    
                    /// [5:5] 
                    CLK_I2C_MST_MEM_FO:  u1, 
                    
                    /// [6:6] 
                    CLK_CHAN_FREQ_MEM_FO:  u1, 
                    
                    /// [7:7] 
                    CLK_PBUS_MEM_FO:  u1, 
                    
                    /// [8:8] 
                    CLK_AGC_MEM_FO:  u1, 
                    
                    /// [9:9] 
                    CLK_DC_MEM_FO:  u1, 
                    
                    /// [10:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600af01c));
                
                /// 
                pub const CLK_CONF_POWER_ST = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:15] 
                    res0:  u0, 
                    
                    /// [16:19] 
                    CLK_WIFIPWR_ST_MAP:  u4, 
                    
                    /// [20:23] 
                    CLK_COEX_ST_MAP:  u4, 
                    
                    /// [24:27] 
                    CLK_I2C_MST_ST_MAP:  u4, 
                    
                    /// [28:31] 
                    CLK_LP_APB_ST_MAP:  u4, 
                    
                }), @ptrFromInt(0x600af020));
                
                /// 
                pub const RST_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] 
                    RST_WIFIPWR:  u1, 
                    
                    /// [1:1] 
                    RST_COEX:  u1, 
                    
                    /// [2:2] 
                    RST_I2C_MST:  u1, 
                    
                    /// [3:3] 
                    RST_LP_TIMER:  u1, 
                    
                    /// [4:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600af024));
                
                /// 
                pub const MEM_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] 
                    DC_MEM_FORCE_PU:  u1, 
                    
                    /// [1:1] 
                    DC_MEM_FORCE_PD:  u1, 
                    
                    /// [2:2] 
                    AGC_MEM_FORCE_PU:  u1, 
                    
                    /// [3:3] 
                    AGC_MEM_FORCE_PD:  u1, 
                    
                    /// [4:4] 
                    PBUS_MEM_FORCE_PU:  u1, 
                    
                    /// [5:5] 
                    PBUS_MEM_FORCE_PD:  u1, 
                    
                    /// [6:6] 
                    BC_MEM_FORCE_PU:  u1, 
                    
                    /// [7:7] 
                    BC_MEM_FORCE_PD:  u1, 
                    
                    /// [8:8] 
                    I2C_MST_MEM_FORCE_PU:  u1, 
                    
                    /// [9:9] 
                    I2C_MST_MEM_FORCE_PD:  u1, 
                    
                    /// [10:10] 
                    CHAN_FREQ_MEM_FORCE_PU:  u1, 
                    
                    /// [11:11] 
                    CHAN_FREQ_MEM_FORCE_PD:  u1, 
                    
                    /// [12:14] 
                    MODEM_PWR_MEM_WP:  u3, 
                    
                    /// [15:17] 
                    MODEM_PWR_MEM_WA:  u3, 
                    
                    /// [18:19] 
                    MODEM_PWR_MEM_RA:  u2, 
                    
                    /// [20:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600af028));
                
                /// 
                pub const DATE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:27] 
                    DATE:  u28, 
                    
                    /// [28:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600af02c));
                
            };
            
            /// MODEM_SYSCON Peripheral
            pub const MODEM_SYSCON = struct {
                
                /// 
                pub const TEST_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] 
                    CLK_EN:  u1, 
                    
                    /// [1:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600a9800));
                
                /// 
                pub const CLK_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:20] 
                    res0:  u0, 
                    
                    /// [21:21] 
                    CLK_DATA_DUMP_MUX:  u1, 
                    
                    /// [22:22] 
                    CLK_ETM_EN:  u1, 
                    
                    /// [23:23] 
                    CLK_ZB_APB_EN:  u1, 
                    
                    /// [24:24] 
                    CLK_ZB_MAC_EN:  u1, 
                    
                    /// [25:25] 
                    CLK_MODEM_SEC_ECB_EN:  u1, 
                    
                    /// [26:26] 
                    CLK_MODEM_SEC_CCM_EN:  u1, 
                    
                    /// [27:27] 
                    CLK_MODEM_SEC_BAH_EN:  u1, 
                    
                    /// [28:28] 
                    CLK_MODEM_SEC_APB_EN:  u1, 
                    
                    /// [29:29] 
                    CLK_MODEM_SEC_EN:  u1, 
                    
                    /// [30:30] 
                    CLK_BLE_TIMER_EN:  u1, 
                    
                    /// [31:31] 
                    CLK_DATA_DUMP_EN:  u1, 
                    
                }), @ptrFromInt(0x600a9804));
                
                /// 
                pub const CLK_CONF_FORCE_ON = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:21] 
                    res0:  u0, 
                    
                    /// [22:22] 
                    CLK_ETM_FO:  u1, 
                    
                    /// [23:23] 
                    CLK_ZB_APB_FO:  u1, 
                    
                    /// [24:24] 
                    CLK_ZB_MAC_FO:  u1, 
                    
                    /// [25:25] 
                    CLK_MODEM_SEC_ECB_FO:  u1, 
                    
                    /// [26:26] 
                    CLK_MODEM_SEC_CCM_FO:  u1, 
                    
                    /// [27:27] 
                    CLK_MODEM_SEC_BAH_FO:  u1, 
                    
                    /// [28:28] 
                    CLK_MODEM_SEC_APB_FO:  u1, 
                    
                    /// [29:29] 
                    CLK_MODEM_SEC_FO:  u1, 
                    
                    /// [30:30] 
                    CLK_BLE_TIMER_FO:  u1, 
                    
                    /// [31:31] 
                    CLK_DATA_DUMP_FO:  u1, 
                    
                }), @ptrFromInt(0x600a9808));
                
                /// 
                pub const CLK_CONF_POWER_ST = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] 
                    res0:  u0, 
                    
                    /// [8:11] 
                    CLK_ZB_ST_MAP:  u4, 
                    
                    /// [12:15] 
                    CLK_FE_ST_MAP:  u4, 
                    
                    /// [16:19] 
                    CLK_BT_ST_MAP:  u4, 
                    
                    /// [20:23] 
                    CLK_WIFI_ST_MAP:  u4, 
                    
                    /// [24:27] 
                    CLK_MODEM_PERI_ST_MAP:  u4, 
                    
                    /// [28:31] 
                    CLK_MODEM_APB_ST_MAP:  u4, 
                    
                }), @ptrFromInt(0x600a980c));
                
                /// 
                pub const MODEM_RST_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] 
                    res0:  u0, 
                    
                    /// [8:8] 
                    RST_WIFIBB:  u1, 
                    
                    /// [9:9] 
                    res1:  u0, 
                    
                    /// [10:10] 
                    RST_WIFIMAC:  u1, 
                    
                    /// [11:13] 
                    res2:  u0, 
                    
                    /// [14:14] 
                    RST_FE:  u1, 
                    
                    /// [15:15] 
                    RST_BTMAC_APB:  u1, 
                    
                    /// [16:16] 
                    RST_BTMAC:  u1, 
                    
                    /// [17:17] 
                    RST_BTBB_APB:  u1, 
                    
                    /// [18:18] 
                    RST_BTBB:  u1, 
                    
                    /// [19:21] 
                    res3:  u0, 
                    
                    /// [22:22] 
                    RST_ETM:  u1, 
                    
                    /// [23:23] 
                    res4:  u0, 
                    
                    /// [24:24] 
                    RST_ZBMAC:  u1, 
                    
                    /// [25:25] 
                    RST_MODEM_ECB:  u1, 
                    
                    /// [26:26] 
                    RST_MODEM_CCM:  u1, 
                    
                    /// [27:27] 
                    RST_MODEM_BAH:  u1, 
                    
                    /// [28:28] 
                    res5:  u0, 
                    
                    /// [29:29] 
                    RST_MODEM_SEC:  u1, 
                    
                    /// [30:30] 
                    RST_BLE_TIMER:  u1, 
                    
                    /// [31:31] 
                    RST_DATA_DUMP:  u1, 
                    
                }), @ptrFromInt(0x600a9810));
                
                /// 
                pub const CLK_CONF1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] 
                    CLK_WIFIBB_22M_EN:  u1, 
                    
                    /// [1:1] 
                    CLK_WIFIBB_40M_EN:  u1, 
                    
                    /// [2:2] 
                    CLK_WIFIBB_44M_EN:  u1, 
                    
                    /// [3:3] 
                    CLK_WIFIBB_80M_EN:  u1, 
                    
                    /// [4:4] 
                    CLK_WIFIBB_40X_EN:  u1, 
                    
                    /// [5:5] 
                    CLK_WIFIBB_80X_EN:  u1, 
                    
                    /// [6:6] 
                    CLK_WIFIBB_40X1_EN:  u1, 
                    
                    /// [7:7] 
                    CLK_WIFIBB_80X1_EN:  u1, 
                    
                    /// [8:8] 
                    CLK_WIFIBB_160X1_EN:  u1, 
                    
                    /// [9:9] 
                    CLK_WIFIMAC_EN:  u1, 
                    
                    /// [10:10] 
                    CLK_WIFI_APB_EN:  u1, 
                    
                    /// [11:11] 
                    CLK_FE_20M_EN:  u1, 
                    
                    /// [12:12] 
                    CLK_FE_40M_EN:  u1, 
                    
                    /// [13:13] 
                    CLK_FE_80M_EN:  u1, 
                    
                    /// [14:14] 
                    CLK_FE_160M_EN:  u1, 
                    
                    /// [15:15] 
                    CLK_FE_CAL_160M_EN:  u1, 
                    
                    /// [16:16] 
                    CLK_FE_APB_EN:  u1, 
                    
                    /// [17:17] 
                    CLK_BT_APB_EN:  u1, 
                    
                    /// [18:18] 
                    CLK_BT_EN:  u1, 
                    
                    /// [19:19] 
                    CLK_WIFIBB_480M_EN:  u1, 
                    
                    /// [20:20] 
                    CLK_FE_480M_EN:  u1, 
                    
                    /// [21:21] 
                    CLK_FE_ANAMODE_40M_EN:  u1, 
                    
                    /// [22:22] 
                    CLK_FE_ANAMODE_80M_EN:  u1, 
                    
                    /// [23:23] 
                    CLK_FE_ANAMODE_160M_EN:  u1, 
                    
                    /// [24:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600a9814));
                
                /// 
                pub const CLK_CONF1_FORCE_ON = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] 
                    CLK_WIFIBB_22M_FO:  u1, 
                    
                    /// [1:1] 
                    CLK_WIFIBB_40M_FO:  u1, 
                    
                    /// [2:2] 
                    CLK_WIFIBB_44M_FO:  u1, 
                    
                    /// [3:3] 
                    CLK_WIFIBB_80M_FO:  u1, 
                    
                    /// [4:4] 
                    CLK_WIFIBB_40X_FO:  u1, 
                    
                    /// [5:5] 
                    CLK_WIFIBB_80X_FO:  u1, 
                    
                    /// [6:6] 
                    CLK_WIFIBB_40X1_FO:  u1, 
                    
                    /// [7:7] 
                    CLK_WIFIBB_80X1_FO:  u1, 
                    
                    /// [8:8] 
                    CLK_WIFIBB_160X1_FO:  u1, 
                    
                    /// [9:9] 
                    CLK_WIFIMAC_FO:  u1, 
                    
                    /// [10:10] 
                    CLK_WIFI_APB_FO:  u1, 
                    
                    /// [11:11] 
                    CLK_FE_20M_FO:  u1, 
                    
                    /// [12:12] 
                    CLK_FE_40M_FO:  u1, 
                    
                    /// [13:13] 
                    CLK_FE_80M_FO:  u1, 
                    
                    /// [14:14] 
                    CLK_FE_160M_FO:  u1, 
                    
                    /// [15:15] 
                    CLK_FE_CAL_160M_FO:  u1, 
                    
                    /// [16:16] 
                    CLK_FE_APB_FO:  u1, 
                    
                    /// [17:17] 
                    CLK_BT_APB_FO:  u1, 
                    
                    /// [18:18] 
                    CLK_BT_FO:  u1, 
                    
                    /// [19:19] 
                    CLK_WIFIBB_480M_FO:  u1, 
                    
                    /// [20:20] 
                    CLK_FE_480M_FO:  u1, 
                    
                    /// [21:21] 
                    CLK_FE_ANAMODE_40M_FO:  u1, 
                    
                    /// [22:22] 
                    CLK_FE_ANAMODE_80M_FO:  u1, 
                    
                    /// [23:23] 
                    CLK_FE_ANAMODE_160M_FO:  u1, 
                    
                    /// [24:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600a9818));
                
                /// 
                pub const WIFI_BB_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] 
                    WIFI_BB_CFG:  u32, 
                    
                }), @ptrFromInt(0x600a981c));
                
                /// 
                pub const MEM_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:2] 
                    MODEM_MEM_WP:  u3, 
                    
                    /// [3:5] 
                    MODEM_MEM_WA:  u3, 
                    
                    /// [6:7] 
                    MODEM_MEM_RA:  u2, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600a9820));
                
                /// 
                pub const DATE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:27] 
                    DATE:  u28, 
                    
                    /// [28:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600a9824));
                
            };
            
            /// OTP_DEBUG Peripheral
            pub const OTP_DEBUG = struct {
                
                /// Otp debuger block0 data register1.
                pub const WR_DIS = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Otp block0 write disable data.
                    BLOCK0_WR_DIS:  u32, 
                    
                }), @ptrFromInt(0x600b3c00));
                
                /// Otp debuger block0 data register2.
                pub const BLK0_BACKUP1_W1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Otp block0 backup1 word1 data.
                    OTP_BEBUG_BLOCK0_BACKUP1_W1:  u32, 
                    
                }), @ptrFromInt(0x600b3c04));
                
                /// Otp debuger block0 data register3.
                pub const BLK0_BACKUP1_W2 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Otp block0 backup1 word2 data.
                    OTP_BEBUG_BLOCK0_BACKUP1_W2:  u32, 
                    
                }), @ptrFromInt(0x600b3c08));
                
                /// Otp debuger block0 data register4.
                pub const BLK0_BACKUP1_W3 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Otp block0 backup1 word3 data.
                    OTP_BEBUG_BLOCK0_BACKUP1_W3:  u32, 
                    
                }), @ptrFromInt(0x600b3c0c));
                
                /// Otp debuger block0 data register5.
                pub const BLK0_BACKUP1_W4 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Otp block0 backup1 word4 data.
                    OTP_BEBUG_BLOCK0_BACKUP1_W4:  u32, 
                    
                }), @ptrFromInt(0x600b3c10));
                
                /// Otp debuger block0 data register6.
                pub const BLK0_BACKUP1_W5 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Otp block0 backup1 word5 data.
                    OTP_BEBUG_BLOCK0_BACKUP1_W5:  u32, 
                    
                }), @ptrFromInt(0x600b3c14));
                
                /// Otp debuger block0 data register7.
                pub const BLK0_BACKUP2_W1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Otp block0 backup2 word1 data.
                    OTP_BEBUG_BLOCK0_BACKUP2_W1:  u32, 
                    
                }), @ptrFromInt(0x600b3c18));
                
                /// Otp debuger block0 data register8.
                pub const BLK0_BACKUP2_W2 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Otp block0 backup2 word2 data.
                    OTP_BEBUG_BLOCK0_BACKUP2_W2:  u32, 
                    
                }), @ptrFromInt(0x600b3c1c));
                
                /// Otp debuger block0 data register9.
                pub const BLK0_BACKUP2_W3 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Otp block0 backup2 word3 data.
                    OTP_BEBUG_BLOCK0_BACKUP2_W3:  u32, 
                    
                }), @ptrFromInt(0x600b3c20));
                
                /// Otp debuger block0 data register10.
                pub const BLK0_BACKUP2_W4 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Otp block0 backup2 word4 data.
                    OTP_BEBUG_BLOCK0_BACKUP2_W4:  u32, 
                    
                }), @ptrFromInt(0x600b3c24));
                
                /// Otp debuger block0 data register11.
                pub const BLK0_BACKUP2_W5 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Otp block0 backup2 word5 data.
                    OTP_BEBUG_BLOCK0_BACKUP2_W5:  u32, 
                    
                }), @ptrFromInt(0x600b3c28));
                
                /// Otp debuger block0 data register12.
                pub const BLK0_BACKUP3_W1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Otp block0 backup3 word1 data.
                    OTP_BEBUG_BLOCK0_BACKUP3_W1:  u32, 
                    
                }), @ptrFromInt(0x600b3c2c));
                
                /// Otp debuger block0 data register13.
                pub const BLK0_BACKUP3_W2 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Otp block0 backup3 word2 data.
                    OTP_BEBUG_BLOCK0_BACKUP3_W2:  u32, 
                    
                }), @ptrFromInt(0x600b3c30));
                
                /// Otp debuger block0 data register14.
                pub const BLK0_BACKUP3_W3 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Otp block0 backup3 word3 data.
                    OTP_BEBUG_BLOCK0_BACKUP3_W3:  u32, 
                    
                }), @ptrFromInt(0x600b3c34));
                
                /// Otp debuger block0 data register15.
                pub const BLK0_BACKUP3_W4 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Otp block0 backup3 word4 data.
                    OTP_BEBUG_BLOCK0_BACKUP3_W4:  u32, 
                    
                }), @ptrFromInt(0x600b3c38));
                
                /// Otp debuger block0 data register16.
                pub const BLK0_BACKUP3_W5 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Otp block0 backup3 word5 data.
                    OTP_BEBUG_BLOCK0_BACKUP3_W5:  u32, 
                    
                }), @ptrFromInt(0x600b3c3c));
                
                /// Otp debuger block0 data register17.
                pub const BLK0_BACKUP4_W1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Otp block0 backup4 word1 data.
                    OTP_BEBUG_BLOCK0_BACKUP4_W1:  u32, 
                    
                }), @ptrFromInt(0x600b3c40));
                
                /// Otp debuger block0 data register18.
                pub const BLK0_BACKUP4_W2 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Otp block0 backup4 word2 data.
                    OTP_BEBUG_BLOCK0_BACKUP4_W2:  u32, 
                    
                }), @ptrFromInt(0x600b3c44));
                
                /// Otp debuger block0 data register19.
                pub const BLK0_BACKUP4_W3 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Otp block0 backup4 word3 data.
                    OTP_BEBUG_BLOCK0_BACKUP4_W3:  u32, 
                    
                }), @ptrFromInt(0x600b3c48));
                
                /// Otp debuger block0 data register20.
                pub const BLK0_BACKUP4_W4 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Otp block0 backup4 word4 data.
                    OTP_BEBUG_BLOCK0_BACKUP4_W4:  u32, 
                    
                }), @ptrFromInt(0x600b3c4c));
                
                /// Otp debuger block0 data register21.
                pub const BLK0_BACKUP4_W5 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Otp block0 backup4 word5 data.
                    OTP_BEBUG_BLOCK0_BACKUP4_W5:  u32, 
                    
                }), @ptrFromInt(0x600b3c50));
                
                /// Otp debuger block1 data register1.
                pub const BLK1_W1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Otp block1word1 data.
                    BLOCK1_W1:  u32, 
                    
                }), @ptrFromInt(0x600b3c54));
                
                /// Otp debuger block1 data register2.
                pub const BLK1_W2 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Otp block1word2 data.
                    BLOCK1_W2:  u32, 
                    
                }), @ptrFromInt(0x600b3c58));
                
                /// Otp debuger block1 data register3.
                pub const BLK1_W3 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Otp block1word3 data.
                    BLOCK1_W3:  u32, 
                    
                }), @ptrFromInt(0x600b3c5c));
                
                /// Otp debuger block1 data register4.
                pub const BLK1_W4 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Otp block1word4 data.
                    BLOCK1_W4:  u32, 
                    
                }), @ptrFromInt(0x600b3c60));
                
                /// Otp debuger block1 data register5.
                pub const BLK1_W5 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Otp block1word5 data.
                    BLOCK1_W5:  u32, 
                    
                }), @ptrFromInt(0x600b3c64));
                
                /// Otp debuger block1 data register6.
                pub const BLK1_W6 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Otp block1word6 data.
                    BLOCK1_W6:  u32, 
                    
                }), @ptrFromInt(0x600b3c68));
                
                /// Otp debuger block1 data register7.
                pub const BLK1_W7 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Otp block1word7 data.
                    BLOCK1_W7:  u32, 
                    
                }), @ptrFromInt(0x600b3c6c));
                
                /// Otp debuger block1 data register8.
                pub const BLK1_W8 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Otp block1word8 data.
                    BLOCK1_W8:  u32, 
                    
                }), @ptrFromInt(0x600b3c70));
                
                /// Otp debuger block1 data register9.
                pub const BLK1_W9 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Otp block1word9 data.
                    BLOCK1_W9:  u32, 
                    
                }), @ptrFromInt(0x600b3c74));
                
                /// Otp debuger block2 data register1.
                pub const BLK2_W1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Otp block2 word1 data.
                    BLOCK2_W1:  u32, 
                    
                }), @ptrFromInt(0x600b3c78));
                
                /// Otp debuger block2 data register2.
                pub const BLK2_W2 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Otp block2 word2 data.
                    BLOCK2_W2:  u32, 
                    
                }), @ptrFromInt(0x600b3c7c));
                
                /// Otp debuger block2 data register3.
                pub const BLK2_W3 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Otp block2 word3 data.
                    BLOCK2_W3:  u32, 
                    
                }), @ptrFromInt(0x600b3c80));
                
                /// Otp debuger block2 data register4.
                pub const BLK2_W4 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Otp block2 word4 data.
                    BLOCK2_W4:  u32, 
                    
                }), @ptrFromInt(0x600b3c84));
                
                /// Otp debuger block2 data register5.
                pub const BLK2_W5 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Otp block2 word5 data.
                    BLOCK2_W5:  u32, 
                    
                }), @ptrFromInt(0x600b3c88));
                
                /// Otp debuger block2 data register6.
                pub const BLK2_W6 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Otp block2 word6 data.
                    BLOCK2_W6:  u32, 
                    
                }), @ptrFromInt(0x600b3c8c));
                
                /// Otp debuger block2 data register7.
                pub const BLK2_W7 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Otp block2 word7 data.
                    BLOCK2_W7:  u32, 
                    
                }), @ptrFromInt(0x600b3c90));
                
                /// Otp debuger block2 data register8.
                pub const BLK2_W8 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Otp block2 word8 data.
                    BLOCK2_W8:  u32, 
                    
                }), @ptrFromInt(0x600b3c94));
                
                /// Otp debuger block2 data register9.
                pub const BLK2_W9 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Otp block2 word9 data.
                    BLOCK2_W9:  u32, 
                    
                }), @ptrFromInt(0x600b3c98));
                
                /// Otp debuger block2 data register10.
                pub const BLK2_W10 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Otp block2 word10 data.
                    BLOCK2_W10:  u32, 
                    
                }), @ptrFromInt(0x600b3c9c));
                
                /// Otp debuger block2 data register11.
                pub const BLK2_W11 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Otp block2 word11 data.
                    BLOCK2_W11:  u32, 
                    
                }), @ptrFromInt(0x600b3ca0));
                
                /// Otp debuger block3 data register1.
                pub const BLK3_W1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Otp block3 word1 data.
                    BLOCK3_W1:  u32, 
                    
                }), @ptrFromInt(0x600b3ca4));
                
                /// Otp debuger block3 data register2.
                pub const BLK3_W2 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Otp block3 word2 data.
                    BLOCK3_W2:  u32, 
                    
                }), @ptrFromInt(0x600b3ca8));
                
                /// Otp debuger block3 data register3.
                pub const BLK3_W3 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Otp block3 word3 data.
                    BLOCK3_W3:  u32, 
                    
                }), @ptrFromInt(0x600b3cac));
                
                /// Otp debuger block3 data register4.
                pub const BLK3_W4 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Otp block3 word4 data.
                    BLOCK3_W4:  u32, 
                    
                }), @ptrFromInt(0x600b3cb0));
                
                /// Otp debuger block3 data register5.
                pub const BLK3_W5 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Otp block3 word5 data.
                    BLOCK3_W5:  u32, 
                    
                }), @ptrFromInt(0x600b3cb4));
                
                /// Otp debuger block3 data register6.
                pub const BLK3_W6 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Otp block3 word6 data.
                    BLOCK3_W6:  u32, 
                    
                }), @ptrFromInt(0x600b3cb8));
                
                /// Otp debuger block3 data register7.
                pub const BLK3_W7 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Otp block3 word7 data.
                    BLOCK3_W7:  u32, 
                    
                }), @ptrFromInt(0x600b3cbc));
                
                /// Otp debuger block3 data register8.
                pub const BLK3_W8 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Otp block3 word8 data.
                    BLOCK3_W8:  u32, 
                    
                }), @ptrFromInt(0x600b3cc0));
                
                /// Otp debuger block3 data register9.
                pub const BLK3_W9 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Otp block3 word9 data.
                    BLOCK3_W9:  u32, 
                    
                }), @ptrFromInt(0x600b3cc4));
                
                /// Otp debuger block3 data register10.
                pub const BLK3_W10 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Otp block3 word10 data.
                    BLOCK3_W10:  u32, 
                    
                }), @ptrFromInt(0x600b3cc8));
                
                /// Otp debuger block3 data register11.
                pub const BLK3_W11 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Otp block3 word11 data.
                    BLOCK3_W11:  u32, 
                    
                }), @ptrFromInt(0x600b3ccc));
                
                /// Otp debuger block4 data register1.
                pub const BLK4_W1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Otp block4 word1 data.
                    BLOCK4_W1:  u32, 
                    
                }), @ptrFromInt(0x600b3cd0));
                
                /// Otp debuger block4 data register2.
                pub const BLK4_W2 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Otp block4 word2 data.
                    BLOCK4_W2:  u32, 
                    
                }), @ptrFromInt(0x600b3cd4));
                
                /// Otp debuger block4 data register3.
                pub const BLK4_W3 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Otp block4 word3 data.
                    BLOCK4_W3:  u32, 
                    
                }), @ptrFromInt(0x600b3cd8));
                
                /// Otp debuger block4 data register4.
                pub const BLK4_W4 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Otp block4 word4 data.
                    BLOCK4_W4:  u32, 
                    
                }), @ptrFromInt(0x600b3cdc));
                
                /// Otp debuger block4 data register5.
                pub const BLK4_W5 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Otp block4 word5 data.
                    BLOCK4_W5:  u32, 
                    
                }), @ptrFromInt(0x600b3ce0));
                
                /// Otp debuger block4 data register6.
                pub const BLK4_W6 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Otp block4 word6 data.
                    BLOCK4_W6:  u32, 
                    
                }), @ptrFromInt(0x600b3ce4));
                
                /// Otp debuger block4 data register7.
                pub const BLK4_W7 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Otp block4 word7 data.
                    BLOCK4_W7:  u32, 
                    
                }), @ptrFromInt(0x600b3ce8));
                
                /// Otp debuger block4 data register8.
                pub const BLK4_W8 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Otp block4 word8 data.
                    BLOCK4_W8:  u32, 
                    
                }), @ptrFromInt(0x600b3cec));
                
                /// Otp debuger block4 data register9.
                pub const BLK4_W9 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Otp block4 word9 data.
                    BLOCK4_W9:  u32, 
                    
                }), @ptrFromInt(0x600b3cf0));
                
                /// Otp debuger block4 data registe10.
                pub const BLK4_W10 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Otp block4 word10 data.
                    BLOCK4_W10:  u32, 
                    
                }), @ptrFromInt(0x600b3cf4));
                
                /// Otp debuger block4 data register11.
                pub const BLK4_W11 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Otp block4 word11 data.
                    BLOCK4_W11:  u32, 
                    
                }), @ptrFromInt(0x600b3cf8));
                
                /// Otp debuger block5 data register1.
                pub const BLK5_W1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Otp block5 word1 data.
                    BLOCK5_W1:  u32, 
                    
                }), @ptrFromInt(0x600b3cfc));
                
                /// Otp debuger block5 data register2.
                pub const BLK5_W2 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Otp block5 word2 data.
                    BLOCK5_W2:  u32, 
                    
                }), @ptrFromInt(0x600b3d00));
                
                /// Otp debuger block5 data register3.
                pub const BLK5_W3 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Otp block5 word3 data.
                    BLOCK5_W3:  u32, 
                    
                }), @ptrFromInt(0x600b3d04));
                
                /// Otp debuger block5 data register4.
                pub const BLK5_W4 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Otp block5 word4 data.
                    BLOCK5_W4:  u32, 
                    
                }), @ptrFromInt(0x600b3d08));
                
                /// Otp debuger block5 data register5.
                pub const BLK5_W5 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Otp block5 word5 data.
                    BLOCK5_W5:  u32, 
                    
                }), @ptrFromInt(0x600b3d0c));
                
                /// Otp debuger block5 data register6.
                pub const BLK5_W6 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Otp block5 word6 data.
                    BLOCK5_W6:  u32, 
                    
                }), @ptrFromInt(0x600b3d10));
                
                /// Otp debuger block5 data register7.
                pub const BLK5_W7 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Otp block5 word7 data.
                    BLOCK5_W7:  u32, 
                    
                }), @ptrFromInt(0x600b3d14));
                
                /// Otp debuger block5 data register8.
                pub const BLK5_W8 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Otp block5 word8 data.
                    BLOCK5_W8:  u32, 
                    
                }), @ptrFromInt(0x600b3d18));
                
                /// Otp debuger block5 data register9.
                pub const BLK5_W9 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Otp block5 word9 data.
                    BLOCK5_W9:  u32, 
                    
                }), @ptrFromInt(0x600b3d1c));
                
                /// Otp debuger block5 data register10.
                pub const BLK5_W10 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Otp block5 word10 data.
                    BLOCK5_W10:  u32, 
                    
                }), @ptrFromInt(0x600b3d20));
                
                /// Otp debuger block5 data register11.
                pub const BLK5_W11 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Otp block5 word11 data.
                    BLOCK5_W11:  u32, 
                    
                }), @ptrFromInt(0x600b3d24));
                
                /// Otp debuger block6 data register1.
                pub const BLK6_W1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Otp block6 word1 data.
                    BLOCK6_W1:  u32, 
                    
                }), @ptrFromInt(0x600b3d28));
                
                /// Otp debuger block6 data register2.
                pub const BLK6_W2 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Otp block6 word2 data.
                    BLOCK6_W2:  u32, 
                    
                }), @ptrFromInt(0x600b3d2c));
                
                /// Otp debuger block6 data register3.
                pub const BLK6_W3 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Otp block6 word3 data.
                    BLOCK6_W3:  u32, 
                    
                }), @ptrFromInt(0x600b3d30));
                
                /// Otp debuger block6 data register4.
                pub const BLK6_W4 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Otp block6 word4 data.
                    BLOCK6_W4:  u32, 
                    
                }), @ptrFromInt(0x600b3d34));
                
                /// Otp debuger block6 data register5.
                pub const BLK6_W5 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Otp block6 word5 data.
                    BLOCK6_W5:  u32, 
                    
                }), @ptrFromInt(0x600b3d38));
                
                /// Otp debuger block6 data register6.
                pub const BLK6_W6 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Otp block6 word6 data.
                    BLOCK6_W6:  u32, 
                    
                }), @ptrFromInt(0x600b3d3c));
                
                /// Otp debuger block6 data register7.
                pub const BLK6_W7 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Otp block6 word7 data.
                    BLOCK6_W7:  u32, 
                    
                }), @ptrFromInt(0x600b3d40));
                
                /// Otp debuger block6 data register8.
                pub const BLK6_W8 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Otp block6 word8 data.
                    BLOCK6_W8:  u32, 
                    
                }), @ptrFromInt(0x600b3d44));
                
                /// Otp debuger block6 data register9.
                pub const BLK6_W9 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Otp block6 word9 data.
                    BLOCK6_W9:  u32, 
                    
                }), @ptrFromInt(0x600b3d48));
                
                /// Otp debuger block6 data register10.
                pub const BLK6_W10 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Otp block6 word10 data.
                    BLOCK6_W10:  u32, 
                    
                }), @ptrFromInt(0x600b3d4c));
                
                /// Otp debuger block6 data register11.
                pub const BLK6_W11 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Otp block6 word11 data.
                    BLOCK6_W11:  u32, 
                    
                }), @ptrFromInt(0x600b3d50));
                
                /// Otp debuger block7 data register1.
                pub const BLK7_W1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Otp block7 word1 data.
                    BLOCK7_W1:  u32, 
                    
                }), @ptrFromInt(0x600b3d54));
                
                /// Otp debuger block7 data register2.
                pub const BLK7_W2 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Otp block7 word2 data.
                    BLOCK7_W2:  u32, 
                    
                }), @ptrFromInt(0x600b3d58));
                
                /// Otp debuger block7 data register3.
                pub const BLK7_W3 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Otp block7 word3 data.
                    BLOCK7_W3:  u32, 
                    
                }), @ptrFromInt(0x600b3d5c));
                
                /// Otp debuger block7 data register4.
                pub const BLK7_W4 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Otp block7 word4 data.
                    BLOCK7_W4:  u32, 
                    
                }), @ptrFromInt(0x600b3d60));
                
                /// Otp debuger block7 data register5.
                pub const BLK7_W5 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Otp block7 word5 data.
                    BLOCK7_W5:  u32, 
                    
                }), @ptrFromInt(0x600b3d64));
                
                /// Otp debuger block7 data register6.
                pub const BLK7_W6 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Otp block7 word6 data.
                    BLOCK7_W6:  u32, 
                    
                }), @ptrFromInt(0x600b3d68));
                
                /// Otp debuger block7 data register7.
                pub const BLK7_W7 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Otp block7 word7 data.
                    BLOCK7_W7:  u32, 
                    
                }), @ptrFromInt(0x600b3d6c));
                
                /// Otp debuger block7 data register8.
                pub const BLK7_W8 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Otp block7 word8 data.
                    BLOCK7_W8:  u32, 
                    
                }), @ptrFromInt(0x600b3d70));
                
                /// Otp debuger block7 data register9.
                pub const BLK7_W9 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Otp block7 word9 data.
                    BLOCK7_W9:  u32, 
                    
                }), @ptrFromInt(0x600b3d74));
                
                /// Otp debuger block7 data register10.
                pub const BLK7_W10 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Otp block7 word10 data.
                    BLOCK7_W10:  u32, 
                    
                }), @ptrFromInt(0x600b3d78));
                
                /// Otp debuger block7 data register11.
                pub const BLK7_W11 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Otp block7 word11 data.
                    BLOCK7_W11:  u32, 
                    
                }), @ptrFromInt(0x600b3d7c));
                
                /// Otp debuger block8 data register1.
                pub const BLK8_W1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Otp block8 word1 data.
                    BLOCK8_W1:  u32, 
                    
                }), @ptrFromInt(0x600b3d80));
                
                /// Otp debuger block8 data register2.
                pub const BLK8_W2 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Otp block8 word2 data.
                    BLOCK8_W2:  u32, 
                    
                }), @ptrFromInt(0x600b3d84));
                
                /// Otp debuger block8 data register3.
                pub const BLK8_W3 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Otp block8 word3 data.
                    BLOCK8_W3:  u32, 
                    
                }), @ptrFromInt(0x600b3d88));
                
                /// Otp debuger block8 data register4.
                pub const BLK8_W4 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Otp block8 word4 data.
                    BLOCK8_W4:  u32, 
                    
                }), @ptrFromInt(0x600b3d8c));
                
                /// Otp debuger block8 data register5.
                pub const BLK8_W5 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Otp block8 word5 data.
                    BLOCK8_W5:  u32, 
                    
                }), @ptrFromInt(0x600b3d90));
                
                /// Otp debuger block8 data register6.
                pub const BLK8_W6 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Otp block8 word6 data.
                    BLOCK8_W6:  u32, 
                    
                }), @ptrFromInt(0x600b3d94));
                
                /// Otp debuger block8 data register7.
                pub const BLK8_W7 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Otp block8 word7 data.
                    BLOCK8_W7:  u32, 
                    
                }), @ptrFromInt(0x600b3d98));
                
                /// Otp debuger block8 data register8.
                pub const BLK8_W8 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Otp block8 word8 data.
                    BLOCK8_W8:  u32, 
                    
                }), @ptrFromInt(0x600b3d9c));
                
                /// Otp debuger block8 data register9.
                pub const BLK8_W9 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Otp block8 word9 data.
                    BLOCK8_W9:  u32, 
                    
                }), @ptrFromInt(0x600b3da0));
                
                /// Otp debuger block8 data register10.
                pub const BLK8_W10 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Otp block8 word10 data.
                    BLOCK8_W10:  u32, 
                    
                }), @ptrFromInt(0x600b3da4));
                
                /// Otp debuger block8 data register11.
                pub const BLK8_W11 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Otp block8 word11 data.
                    BLOCK8_W11:  u32, 
                    
                }), @ptrFromInt(0x600b3da8));
                
                /// Otp debuger block9 data register1.
                pub const BLK9_W1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Otp block9 word1 data.
                    BLOCK9_W1:  u32, 
                    
                }), @ptrFromInt(0x600b3dac));
                
                /// Otp debuger block9 data register2.
                pub const BLK9_W2 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Otp block9 word2 data.
                    BLOCK9_W2:  u32, 
                    
                }), @ptrFromInt(0x600b3db0));
                
                /// Otp debuger block9 data register3.
                pub const BLK9_W3 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Otp block9 word3 data.
                    BLOCK9_W3:  u32, 
                    
                }), @ptrFromInt(0x600b3db4));
                
                /// Otp debuger block9 data register4.
                pub const BLK9_W4 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Otp block9 word4 data.
                    BLOCK9_W4:  u32, 
                    
                }), @ptrFromInt(0x600b3db8));
                
                /// Otp debuger block9 data register5.
                pub const BLK9_W5 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Otp block9 word5 data.
                    BLOCK9_W5:  u32, 
                    
                }), @ptrFromInt(0x600b3dbc));
                
                /// Otp debuger block9 data register6.
                pub const BLK9_W6 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Otp block9 word6 data.
                    BLOCK9_W6:  u32, 
                    
                }), @ptrFromInt(0x600b3dc0));
                
                /// Otp debuger block9 data register7.
                pub const BLK9_W7 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Otp block9 word7 data.
                    BLOCK9_W7:  u32, 
                    
                }), @ptrFromInt(0x600b3dc4));
                
                /// Otp debuger block9 data register8.
                pub const BLK9_W8 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Otp block9 word8 data.
                    BLOCK9_W8:  u32, 
                    
                }), @ptrFromInt(0x600b3dc8));
                
                /// Otp debuger block9 data register9.
                pub const BLK9_W9 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Otp block9 word9 data.
                    BLOCK9_W9:  u32, 
                    
                }), @ptrFromInt(0x600b3dcc));
                
                /// Otp debuger block9 data register10.
                pub const BLK9_W10 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Otp block9 word10 data.
                    BLOCK9_W10:  u32, 
                    
                }), @ptrFromInt(0x600b3dd0));
                
                /// Otp debuger block9 data register11.
                pub const BLK9_W11 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Otp block9 word11 data.
                    BLOCK9_W11:  u32, 
                    
                }), @ptrFromInt(0x600b3dd4));
                
                /// Otp debuger block10 data register1.
                pub const BLK10_W1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Otp block10 word1 data.
                    BLOCK10_W1:  u32, 
                    
                }), @ptrFromInt(0x600b3dd8));
                
                /// Otp debuger block10 data register2.
                pub const BLK10_W2 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Otp block10 word2 data.
                    BLOCK10_W2:  u32, 
                    
                }), @ptrFromInt(0x600b3ddc));
                
                /// Otp debuger block10 data register3.
                pub const BLK10_W3 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Otp block10 word3 data.
                    BLOCK10_W3:  u32, 
                    
                }), @ptrFromInt(0x600b3de0));
                
                /// Otp debuger block10 data register4.
                pub const BLK10_W4 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Otp block10 word4 data.
                    BLOCK10_W4:  u32, 
                    
                }), @ptrFromInt(0x600b3de4));
                
                /// Otp debuger block10 data register5.
                pub const BLK10_W5 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Otp block10 word5 data.
                    BLOCK10_W5:  u32, 
                    
                }), @ptrFromInt(0x600b3de8));
                
                /// Otp debuger block10 data register6.
                pub const BLK10_W6 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Otp block10 word6 data.
                    BLOCK10_W6:  u32, 
                    
                }), @ptrFromInt(0x600b3dec));
                
                /// Otp debuger block10 data register7.
                pub const BLK10_W7 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Otp block10 word7 data.
                    BLOCK10_W7:  u32, 
                    
                }), @ptrFromInt(0x600b3df0));
                
                /// Otp debuger block10 data register8.
                pub const BLK10_W8 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Otp block10 word8 data.
                    BLOCK10_W8:  u32, 
                    
                }), @ptrFromInt(0x600b3df4));
                
                /// Otp debuger block10 data register9.
                pub const BLK10_W9 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Otp block10 word9 data.
                    BLOCK10_W9:  u32, 
                    
                }), @ptrFromInt(0x600b3df8));
                
                /// Otp debuger block10 data register10.
                pub const BLK10_W10 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Otp block10 word10 data.
                    BLOCK19_W10:  u32, 
                    
                }), @ptrFromInt(0x600b3dfc));
                
                /// Otp debuger block10 data register11.
                pub const BLK10_W11 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Otp block10 word11 data.
                    BLOCK10_W11:  u32, 
                    
                }), @ptrFromInt(0x600b3e00));
                
                /// Otp debuger clk_en configuration register.
                pub const CLK = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Force clock on for this register file.
                    EN:  u1, 
                    
                    /// [1:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600b3e04));
                
                /// Otp_debuger apb2otp enable configuration register.
                pub const APB2OTP_EN = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Debug mode enable signal.
                    APB2OTP_EN:  u1, 
                    
                    /// [1:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600b3e08));
                
                /// eFuse version register.
                pub const DATE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:27] Stores otp_debug version.
                    DATE:  u28, 
                    
                    /// [28:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600b3e0c));
                
            };
            
            /// PARL_IO Peripheral
            pub const PARL_IO = struct {
                
                /// Parallel RX module configuration register0.
                pub const RX_CFG0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Write 0 to select eof generated manchnism by configured data byte length. Write 1 to select eof generated manchnism by external enable signal.
                    RX_EOF_GEN_SEL:  u1, 
                    
                    /// [1:1] Write 1 to start rx global data sampling.
                    RX_START:  u1, 
                    
                    /// [2:17] Configures rx receieved data byte length.
                    RX_DATA_BYTELEN:  u16, 
                    
                    /// [18:18] Write 1 to enable software data sampling.
                    RX_SW_EN:  u1, 
                    
                    /// [19:22] Pulse submode selection. 0000: positive pulse start(data bit included) &&positive pulse end(data bit included)0001: positive pulse start(data bit included) && positive pulse end (data bit excluded)0010: positive pulse start(data bit excluded) && positive pulse end (data bit included)0011: positive pulse start(data bit excluded) && positive pulse end (data bit excluded)0100: positive pulse start(data bit included) && length end0101: positive pulse start(data bit excluded) && length end0110: negative pulse start(data bit included) &&negative pulse end(data bit included)0111: negative pulse start(data bit included) && negative pulse end (data bit excluded)1000: negative pulse start(data bit excluded) && negative pulse end (data bit included)1001: negative pulse start(data bit excluded) && negative pulse end (data bit excluded)1010: negative pulse start(data bit included) && length end1011: negative pulse start(data bit excluded) && length end
                    RX_PULSE_SUBMODE_SEL:  u4, 
                    
                    /// [23:23] Write 0 to sample data at high level of external enable signal. Write 1 to sample data at low level of external enable signal.
                    RX_LEVEL_SUBMODE_SEL:  u1, 
                    
                    /// [24:25] Rx data sampling mode selection. 000: external level enable mode001: external pulse enable mode010: internal software enable mode
                    RX_SMP_MODE_SEL:  u2, 
                    
                    /// [26:26] Write 0 to enable sampling data on the rising edge of rx clock. Write 0 to enable sampling data on the falling edge of rx clock.
                    RX_CLK_EDGE_SEL:  u1, 
                    
                    /// [27:27] Write 0 to pack bits into 1byte from MSB when data bus width is 4/2/1 bits. Write 0 to pack bits into 1byte from LSB when data bus width is 4/2/1 bits.
                    RX_BIT_PACK_ORDER:  u1, 
                    
                    /// [28:30] Rx data bus width selection. 100: bus width is 1 bit 011: bus width is 2 bits 010: bus width is 4 bits001: bus width is 8 bits000: bus width is 16 bits
                    RX_BUS_WID_SEL:  u3, 
                    
                    /// [31:31] Write 1 to enable soft reset of async fifo in rx module.
                    RX_FIFO_SRST:  u1, 
                    
                }), @ptrFromInt(0x60015000));
                
                /// Parallel RX module configuration register1.
                pub const RX_CFG1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:1] 
                    res0:  u0, 
                    
                    /// [2:2] Write 1 to update rx register configuration signals.
                    RX_REG_UPDATE:  u1, 
                    
                    /// [3:3] Write 1 to enable timeout count to generate error eof.
                    RX_TIMEOUT_EN:  u1, 
                    
                    /// [4:11] 
                    res1:  u0, 
                    
                    /// [12:15] Configures rx external enable signal selection from 16 data lines.
                    RX_EXT_EN_SEL:  u4, 
                    
                    /// [16:31] Configures rx threshold of timeout counter.
                    RX_TIMEOUT_THRESHOLD:  u16, 
                    
                }), @ptrFromInt(0x60015004));
                
                /// Parallel TX module configuration register0.
                pub const TX_CFG0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:1] 
                    res0:  u0, 
                    
                    /// [2:17] Configures tx sending data byte length.
                    TX_BYTELEN:  u16, 
                    
                    /// [18:18] Write 1 to enable output tx clock gating.
                    TX_GATING_EN:  u1, 
                    
                    /// [19:19] Write 1 to start tx global data output.
                    TX_START:  u1, 
                    
                    /// [20:20] Write 1 to enable tx hardware data valid signal.
                    TX_HW_VALID_EN:  u1, 
                    
                    /// [21:24] 
                    res1:  u0, 
                    
                    /// [25:25] Write 0 to enable sampling data on the rising edge of tx clock. Write 0 to enable sampling data on the falling edge of tx clock.
                    TX_SMP_EDGE_SEL:  u1, 
                    
                    /// [26:26] Write 0 to unpack bits from 1byte from MSB when data bus width is 4/2/1 bits. Write 0 to unpack bits from 1byte from LSB when data bus width is 4/2/1 bits.
                    TX_BIT_UNPACK_ORDER:  u1, 
                    
                    /// [27:29] Tx data bus width selection. 100: bus width is 1 bit011: bus width is 2 bits010: bus width is 4 bits001: bus width is 8 bits000: bus width is 16 bits
                    TX_BUS_WID_SEL:  u3, 
                    
                    /// [30:30] Write 1 to enable soft reset of async fifo in tx module.
                    TX_FIFO_SRST:  u1, 
                    
                    /// [31:31] 
                    res2:  u0, 
                    
                }), @ptrFromInt(0x60015008));
                
                /// Parallel TX module configuration register1.
                pub const TX_CFG1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:15] 
                    res0:  u0, 
                    
                    /// [16:31] Configures data value on tx bus when IDLE state.
                    TX_IDLE_VALUE:  u16, 
                    
                }), @ptrFromInt(0x6001500c));
                
                /// Parallel IO module status register0.
                pub const ST = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:30] 
                    res0:  u0, 
                    
                    /// [31:31] Represents the status that tx is ready.
                    TX_READY:  u1, 
                    
                }), @ptrFromInt(0x60015010));
                
                /// Parallel IO interrupt enable singal configuration register.
                pub const INT_ENA = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Write 1 to enable TX_FIFO_REMPTY_INTR.
                    TX_FIFO_REMPTY_INT_ENA:  u1, 
                    
                    /// [1:1] Write 1 to enable RX_FIFO_WFULL_INTR.
                    RX_FIFO_WFULL_INT_ENA:  u1, 
                    
                    /// [2:2] Write 1 to enable TX_EOF_INTR.
                    TX_EOF_INT_ENA:  u1, 
                    
                    /// [3:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60015014));
                
                /// Parallel IO interrupt raw singal status register.
                pub const INT_RAW = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] The raw interrupt status of TX_FIFO_REMPTY_INTR.
                    TX_FIFO_REMPTY_INT_RAW:  u1, 
                    
                    /// [1:1] The raw interrupt status of RX_FIFO_WFULL_INTR.
                    RX_FIFO_WFULL_INT_RAW:  u1, 
                    
                    /// [2:2] The raw interrupt status of TX_EOF_INTR.
                    TX_EOF_INT_RAW:  u1, 
                    
                    /// [3:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60015018));
                
                /// Parallel IO interrupt singal status register.
                pub const INT_ST = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] The masked interrupt status of TX_FIFO_REMPTY_INTR.
                    TX_FIFO_REMPTY_INT_ST:  u1, 
                    
                    /// [1:1] The masked interrupt status of RX_FIFO_WFULL_INTR.
                    RX_FIFO_WFULL_INT_ST:  u1, 
                    
                    /// [2:2] The masked interrupt status of TX_EOF_INTR.
                    TX_EOF_INT_ST:  u1, 
                    
                    /// [3:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6001501c));
                
                /// Parallel IO interruptclear singal configuration register.
                pub const INT_CLR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Write 1 to clear TX_FIFO_REMPTY_INTR.
                    TX_FIFO_REMPTY_INT_CLR:  u1, 
                    
                    /// [1:1] Write 1 to clear RX_FIFO_WFULL_INTR.
                    RX_FIFO_WFULL_INT_CLR:  u1, 
                    
                    /// [2:2] Write 1 to clear TX_EOF_INTR.
                    TX_EOF_INT_CLR:  u1, 
                    
                    /// [3:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60015020));
                
                /// Parallel IO clk configuration register
                pub const CLK = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Force clock on for this register file
                    EN:  u1, 
                    
                    /// [1:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60015120));
                
                /// Version register.
                pub const VERSION = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:27] Version of this register file
                    DATE:  u28, 
                    
                    /// [28:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600153fc));
                
            };
            
            /// PAU Peripheral
            pub const PAU = struct {
                
                /// Peri backup control register
                pub const REGDMA_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:2] backup error type
                    FLOW_ERR:  u3, 
                    
                    /// [3:3] backup start signal
                    START:  u1, 
                    
                    /// [4:4] backup direction(reg to mem / mem to reg)
                    TO_MEM:  u1, 
                    
                    /// [5:6] Link select
                    LINK_SEL:  u2, 
                    
                    /// [7:7] mac sw backup start signal
                    START_MAC:  u1, 
                    
                    /// [8:8] mac sw backup direction(reg to mem / mem to reg)
                    TO_MEM_MAC:  u1, 
                    
                    /// [9:9] mac hw/sw select
                    SEL_MAC:  u1, 
                    
                    /// [10:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60093000));
                
                /// Clock control register
                pub const REGDMA_CLK_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] clock enable
                    CLK_EN:  u1, 
                    
                    /// [1:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60093004));
                
                /// ETM start ctrl reg
                pub const REGDMA_ETM_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] etm_start_0 reg
                    ETM_START_0:  u1, 
                    
                    /// [1:1] etm_start_1 reg
                    ETM_START_1:  u1, 
                    
                    /// [2:2] etm_start_2 reg
                    ETM_START_2:  u1, 
                    
                    /// [3:3] etm_start_3 reg
                    ETM_START_3:  u1, 
                    
                    /// [4:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60093008));
                
                /// link_0_addr
                pub const REGDMA_LINK_0_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] link_0_addr reg
                    LINK_ADDR_0:  u32, 
                    
                }), @ptrFromInt(0x6009300c));
                
                /// Link_1_addr
                pub const REGDMA_LINK_1_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Link_1_addr reg
                    LINK_ADDR_1:  u32, 
                    
                }), @ptrFromInt(0x60093010));
                
                /// Link_2_addr
                pub const REGDMA_LINK_2_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Link_2_addr reg
                    LINK_ADDR_2:  u32, 
                    
                }), @ptrFromInt(0x60093014));
                
                /// Link_3_addr
                pub const REGDMA_LINK_3_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Link_3_addr reg
                    LINK_ADDR_3:  u32, 
                    
                }), @ptrFromInt(0x60093018));
                
                /// Link_mac_addr
                pub const REGDMA_LINK_MAC_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Link_mac_addr reg
                    LINK_ADDR_MAC:  u32, 
                    
                }), @ptrFromInt(0x6009301c));
                
                /// current link addr
                pub const REGDMA_CURRENT_LINK_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] current link addr reg
                    CURRENT_LINK_ADDR:  u32, 
                    
                }), @ptrFromInt(0x60093020));
                
                /// Backup addr
                pub const REGDMA_BACKUP_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] backup addr reg
                    BACKUP_ADDR:  u32, 
                    
                }), @ptrFromInt(0x60093024));
                
                /// mem addr
                pub const REGDMA_MEM_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] mem addr reg
                    MEM_ADDR:  u32, 
                    
                }), @ptrFromInt(0x60093028));
                
                /// backup config
                pub const REGDMA_BKP_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:6] Link read_interval
                    READ_INTERVAL:  u7, 
                    
                    /// [7:16] link wait timeout threshold
                    LINK_TOUT_THRES:  u10, 
                    
                    /// [17:21] burst limit
                    BURST_LIMIT:  u5, 
                    
                    /// [22:31] Backup timeout threshold
                    BACKUP_TOUT_THRES:  u10, 
                    
                }), @ptrFromInt(0x6009302c));
                
                /// retention dma link base
                pub const RETENTION_LINK_BASE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:26] retention dma link base
                    LINK_BASE_ADDR:  u27, 
                    
                    /// [27:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60093030));
                
                /// retention_cfg
                pub const RETENTION_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] retention inv scan out
                    RET_INV_CFG:  u32, 
                    
                }), @ptrFromInt(0x60093034));
                
                /// Read only register for error and done
                pub const INT_ENA = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] backup done flag
                    DONE_INT_ENA:  u1, 
                    
                    /// [1:1] error flag
                    ERROR_INT_ENA:  u1, 
                    
                    /// [2:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60093038));
                
                /// Read only register for error and done
                pub const INT_RAW = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] backup done flag
                    DONE_INT_RAW:  u1, 
                    
                    /// [1:1] error flag
                    ERROR_INT_RAW:  u1, 
                    
                    /// [2:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6009303c));
                
                /// Read only register for error and done
                pub const INT_CLR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] backup done flag
                    DONE_INT_CLR:  u1, 
                    
                    /// [1:1] error flag
                    ERROR_INT_CLR:  u1, 
                    
                    /// [2:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60093040));
                
                /// Read only register for error and done
                pub const INT_ST = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] backup done flag
                    DONE_INT_ST:  u1, 
                    
                    /// [1:1] error flag
                    ERROR_INT_ST:  u1, 
                    
                    /// [2:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60093044));
                
                /// Date register.
                pub const DATE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:27] REGDMA date information/ REGDMA version information.
                    DATE:  u28, 
                    
                    /// [28:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600933fc));
                
            };
            
            /// Pulse Count Controller
            pub const PCNT = struct {
                
                /// Configuration register 0 for unit %s
                pub const U0_CONF0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:9] This sets the maximum threshold, in APB_CLK cycles, for the filter.Any pulses with width less than this will be ignored when the filter is enabled.
                    FILTER_THRES:  u10, 
                    
                    /// [10:10] This is the enable bit for unit %s's input filter.
                    FILTER_EN:  u1, 
                    
                    /// [11:11] This is the enable bit for unit %s's zero comparator.
                    THR_ZERO_EN:  u1, 
                    
                    /// [12:12] This is the enable bit for unit %s's thr_h_lim comparator.
                    THR_H_LIM_EN:  u1, 
                    
                    /// [13:13] This is the enable bit for unit %s's thr_l_lim comparator.
                    THR_L_LIM_EN:  u1, 
                    
                    /// [14:14] This is the enable bit for unit %s's thres0 comparator.
                    THR_THRES0_EN:  u1, 
                    
                    /// [15:15] This is the enable bit for unit %s's thres1 comparator.
                    THR_THRES1_EN:  u1, 
                    
                    /// [16:17] This register sets the behavior when the signal input of channel 0 detects a negative edge.1: Increase the counter.2: Decrease the counter.0, 3: No effect on counter
                    CH0_NEG_MODE:  u2, 
                    
                    /// [18:19] This register sets the behavior when the signal input of channel 0 detects a positive edge.1: Increase the counter.2: Decrease the counter.0, 3: No effect on counter
                    CH0_POS_MODE:  u2, 
                    
                    /// [20:21] This register configures how the CH%s_POS_MODE/CH%s_NEG_MODE settings will be modified when the control signal is high.0: No modification.1: Invert behavior (increase -> decrease, decrease -> increase).2, 3: Inhibit counter modification
                    CH0_HCTRL_MODE:  u2, 
                    
                    /// [22:23] This register configures how the CH%s_POS_MODE/CH%s_NEG_MODE settings will be modified when the control signal is low.0: No modification.1: Invert behavior (increase -> decrease, decrease -> increase).2, 3: Inhibit counter modification
                    CH0_LCTRL_MODE:  u2, 
                    
                    /// [24:25] This register sets the behavior when the signal input of channel 1 detects a negative edge.1: Increment the counter.2: Decrement the counter.0, 3: No effect on counter
                    CH1_NEG_MODE:  u2, 
                    
                    /// [26:27] This register sets the behavior when the signal input of channel 1 detects a positive edge.1: Increment the counter.2: Decrement the counter.0, 3: No effect on counter
                    CH1_POS_MODE:  u2, 
                    
                    /// [28:29] This register configures how the CH%s_POS_MODE/CH%s_NEG_MODE settings will be modified when the control signal is high.0: No modification.1: Invert behavior (increase -> decrease, decrease -> increase).2, 3: Inhibit counter modification
                    CH1_HCTRL_MODE:  u2, 
                    
                    /// [30:31] This register configures how the CH%s_POS_MODE/CH%s_NEG_MODE settings will be modified when the control signal is low.0: No modification.1: Invert behavior (increase -> decrease, decrease -> increase).2, 3: Inhibit counter modification
                    CH1_LCTRL_MODE:  u2, 
                    
                }), @ptrFromInt(0x60012000));
                
                /// Configuration register 0 for unit %s
                pub const U0_CONF0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:9] This sets the maximum threshold, in APB_CLK cycles, for the filter.Any pulses with width less than this will be ignored when the filter is enabled.
                    FILTER_THRES:  u10, 
                    
                    /// [10:10] This is the enable bit for unit %s's input filter.
                    FILTER_EN:  u1, 
                    
                    /// [11:11] This is the enable bit for unit %s's zero comparator.
                    THR_ZERO_EN:  u1, 
                    
                    /// [12:12] This is the enable bit for unit %s's thr_h_lim comparator.
                    THR_H_LIM_EN:  u1, 
                    
                    /// [13:13] This is the enable bit for unit %s's thr_l_lim comparator.
                    THR_L_LIM_EN:  u1, 
                    
                    /// [14:14] This is the enable bit for unit %s's thres0 comparator.
                    THR_THRES0_EN:  u1, 
                    
                    /// [15:15] This is the enable bit for unit %s's thres1 comparator.
                    THR_THRES1_EN:  u1, 
                    
                    /// [16:17] This register sets the behavior when the signal input of channel 0 detects a negative edge.1: Increase the counter.2: Decrease the counter.0, 3: No effect on counter
                    CH0_NEG_MODE:  u2, 
                    
                    /// [18:19] This register sets the behavior when the signal input of channel 0 detects a positive edge.1: Increase the counter.2: Decrease the counter.0, 3: No effect on counter
                    CH0_POS_MODE:  u2, 
                    
                    /// [20:21] This register configures how the CH%s_POS_MODE/CH%s_NEG_MODE settings will be modified when the control signal is high.0: No modification.1: Invert behavior (increase -> decrease, decrease -> increase).2, 3: Inhibit counter modification
                    CH0_HCTRL_MODE:  u2, 
                    
                    /// [22:23] This register configures how the CH%s_POS_MODE/CH%s_NEG_MODE settings will be modified when the control signal is low.0: No modification.1: Invert behavior (increase -> decrease, decrease -> increase).2, 3: Inhibit counter modification
                    CH0_LCTRL_MODE:  u2, 
                    
                    /// [24:25] This register sets the behavior when the signal input of channel 1 detects a negative edge.1: Increment the counter.2: Decrement the counter.0, 3: No effect on counter
                    CH1_NEG_MODE:  u2, 
                    
                    /// [26:27] This register sets the behavior when the signal input of channel 1 detects a positive edge.1: Increment the counter.2: Decrement the counter.0, 3: No effect on counter
                    CH1_POS_MODE:  u2, 
                    
                    /// [28:29] This register configures how the CH%s_POS_MODE/CH%s_NEG_MODE settings will be modified when the control signal is high.0: No modification.1: Invert behavior (increase -> decrease, decrease -> increase).2, 3: Inhibit counter modification
                    CH1_HCTRL_MODE:  u2, 
                    
                    /// [30:31] This register configures how the CH%s_POS_MODE/CH%s_NEG_MODE settings will be modified when the control signal is low.0: No modification.1: Invert behavior (increase -> decrease, decrease -> increase).2, 3: Inhibit counter modification
                    CH1_LCTRL_MODE:  u2, 
                    
                }), @ptrFromInt(0x60012004));
                
                /// Configuration register 0 for unit %s
                pub const U0_CONF0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:9] This sets the maximum threshold, in APB_CLK cycles, for the filter.Any pulses with width less than this will be ignored when the filter is enabled.
                    FILTER_THRES:  u10, 
                    
                    /// [10:10] This is the enable bit for unit %s's input filter.
                    FILTER_EN:  u1, 
                    
                    /// [11:11] This is the enable bit for unit %s's zero comparator.
                    THR_ZERO_EN:  u1, 
                    
                    /// [12:12] This is the enable bit for unit %s's thr_h_lim comparator.
                    THR_H_LIM_EN:  u1, 
                    
                    /// [13:13] This is the enable bit for unit %s's thr_l_lim comparator.
                    THR_L_LIM_EN:  u1, 
                    
                    /// [14:14] This is the enable bit for unit %s's thres0 comparator.
                    THR_THRES0_EN:  u1, 
                    
                    /// [15:15] This is the enable bit for unit %s's thres1 comparator.
                    THR_THRES1_EN:  u1, 
                    
                    /// [16:17] This register sets the behavior when the signal input of channel 0 detects a negative edge.1: Increase the counter.2: Decrease the counter.0, 3: No effect on counter
                    CH0_NEG_MODE:  u2, 
                    
                    /// [18:19] This register sets the behavior when the signal input of channel 0 detects a positive edge.1: Increase the counter.2: Decrease the counter.0, 3: No effect on counter
                    CH0_POS_MODE:  u2, 
                    
                    /// [20:21] This register configures how the CH%s_POS_MODE/CH%s_NEG_MODE settings will be modified when the control signal is high.0: No modification.1: Invert behavior (increase -> decrease, decrease -> increase).2, 3: Inhibit counter modification
                    CH0_HCTRL_MODE:  u2, 
                    
                    /// [22:23] This register configures how the CH%s_POS_MODE/CH%s_NEG_MODE settings will be modified when the control signal is low.0: No modification.1: Invert behavior (increase -> decrease, decrease -> increase).2, 3: Inhibit counter modification
                    CH0_LCTRL_MODE:  u2, 
                    
                    /// [24:25] This register sets the behavior when the signal input of channel 1 detects a negative edge.1: Increment the counter.2: Decrement the counter.0, 3: No effect on counter
                    CH1_NEG_MODE:  u2, 
                    
                    /// [26:27] This register sets the behavior when the signal input of channel 1 detects a positive edge.1: Increment the counter.2: Decrement the counter.0, 3: No effect on counter
                    CH1_POS_MODE:  u2, 
                    
                    /// [28:29] This register configures how the CH%s_POS_MODE/CH%s_NEG_MODE settings will be modified when the control signal is high.0: No modification.1: Invert behavior (increase -> decrease, decrease -> increase).2, 3: Inhibit counter modification
                    CH1_HCTRL_MODE:  u2, 
                    
                    /// [30:31] This register configures how the CH%s_POS_MODE/CH%s_NEG_MODE settings will be modified when the control signal is low.0: No modification.1: Invert behavior (increase -> decrease, decrease -> increase).2, 3: Inhibit counter modification
                    CH1_LCTRL_MODE:  u2, 
                    
                }), @ptrFromInt(0x60012008));
                
                /// Configuration register 0 for unit %s
                pub const U0_CONF0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:9] This sets the maximum threshold, in APB_CLK cycles, for the filter.Any pulses with width less than this will be ignored when the filter is enabled.
                    FILTER_THRES:  u10, 
                    
                    /// [10:10] This is the enable bit for unit %s's input filter.
                    FILTER_EN:  u1, 
                    
                    /// [11:11] This is the enable bit for unit %s's zero comparator.
                    THR_ZERO_EN:  u1, 
                    
                    /// [12:12] This is the enable bit for unit %s's thr_h_lim comparator.
                    THR_H_LIM_EN:  u1, 
                    
                    /// [13:13] This is the enable bit for unit %s's thr_l_lim comparator.
                    THR_L_LIM_EN:  u1, 
                    
                    /// [14:14] This is the enable bit for unit %s's thres0 comparator.
                    THR_THRES0_EN:  u1, 
                    
                    /// [15:15] This is the enable bit for unit %s's thres1 comparator.
                    THR_THRES1_EN:  u1, 
                    
                    /// [16:17] This register sets the behavior when the signal input of channel 0 detects a negative edge.1: Increase the counter.2: Decrease the counter.0, 3: No effect on counter
                    CH0_NEG_MODE:  u2, 
                    
                    /// [18:19] This register sets the behavior when the signal input of channel 0 detects a positive edge.1: Increase the counter.2: Decrease the counter.0, 3: No effect on counter
                    CH0_POS_MODE:  u2, 
                    
                    /// [20:21] This register configures how the CH%s_POS_MODE/CH%s_NEG_MODE settings will be modified when the control signal is high.0: No modification.1: Invert behavior (increase -> decrease, decrease -> increase).2, 3: Inhibit counter modification
                    CH0_HCTRL_MODE:  u2, 
                    
                    /// [22:23] This register configures how the CH%s_POS_MODE/CH%s_NEG_MODE settings will be modified when the control signal is low.0: No modification.1: Invert behavior (increase -> decrease, decrease -> increase).2, 3: Inhibit counter modification
                    CH0_LCTRL_MODE:  u2, 
                    
                    /// [24:25] This register sets the behavior when the signal input of channel 1 detects a negative edge.1: Increment the counter.2: Decrement the counter.0, 3: No effect on counter
                    CH1_NEG_MODE:  u2, 
                    
                    /// [26:27] This register sets the behavior when the signal input of channel 1 detects a positive edge.1: Increment the counter.2: Decrement the counter.0, 3: No effect on counter
                    CH1_POS_MODE:  u2, 
                    
                    /// [28:29] This register configures how the CH%s_POS_MODE/CH%s_NEG_MODE settings will be modified when the control signal is high.0: No modification.1: Invert behavior (increase -> decrease, decrease -> increase).2, 3: Inhibit counter modification
                    CH1_HCTRL_MODE:  u2, 
                    
                    /// [30:31] This register configures how the CH%s_POS_MODE/CH%s_NEG_MODE settings will be modified when the control signal is low.0: No modification.1: Invert behavior (increase -> decrease, decrease -> increase).2, 3: Inhibit counter modification
                    CH1_LCTRL_MODE:  u2, 
                    
                }), @ptrFromInt(0x6001200c));
                
                /// Configuration register 1 for unit %s
                pub const U0_CONF1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:15] This register is used to configure the thres0 value for unit %s.
                    CNT_THRES0:  u16, 
                    
                    /// [16:31] This register is used to configure the thres1 value for unit %s.
                    CNT_THRES1:  u16, 
                    
                }), @ptrFromInt(0x60012004));
                
                /// Configuration register 1 for unit %s
                pub const U0_CONF1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:15] This register is used to configure the thres0 value for unit %s.
                    CNT_THRES0:  u16, 
                    
                    /// [16:31] This register is used to configure the thres1 value for unit %s.
                    CNT_THRES1:  u16, 
                    
                }), @ptrFromInt(0x60012008));
                
                /// Configuration register 1 for unit %s
                pub const U0_CONF1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:15] This register is used to configure the thres0 value for unit %s.
                    CNT_THRES0:  u16, 
                    
                    /// [16:31] This register is used to configure the thres1 value for unit %s.
                    CNT_THRES1:  u16, 
                    
                }), @ptrFromInt(0x6001200c));
                
                /// Configuration register 1 for unit %s
                pub const U0_CONF1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:15] This register is used to configure the thres0 value for unit %s.
                    CNT_THRES0:  u16, 
                    
                    /// [16:31] This register is used to configure the thres1 value for unit %s.
                    CNT_THRES1:  u16, 
                    
                }), @ptrFromInt(0x60012010));
                
                /// Configuration register 2 for unit %s
                pub const U0_CONF2 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:15] This register is used to configure the thr_h_lim value for unit %s.
                    CNT_H_LIM:  u16, 
                    
                    /// [16:31] This register is used to configure the thr_l_lim value for unit %s.
                    CNT_L_LIM:  u16, 
                    
                }), @ptrFromInt(0x60012008));
                
                /// Configuration register 2 for unit %s
                pub const U0_CONF2 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:15] This register is used to configure the thr_h_lim value for unit %s.
                    CNT_H_LIM:  u16, 
                    
                    /// [16:31] This register is used to configure the thr_l_lim value for unit %s.
                    CNT_L_LIM:  u16, 
                    
                }), @ptrFromInt(0x6001200c));
                
                /// Configuration register 2 for unit %s
                pub const U0_CONF2 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:15] This register is used to configure the thr_h_lim value for unit %s.
                    CNT_H_LIM:  u16, 
                    
                    /// [16:31] This register is used to configure the thr_l_lim value for unit %s.
                    CNT_L_LIM:  u16, 
                    
                }), @ptrFromInt(0x60012010));
                
                /// Configuration register 2 for unit %s
                pub const U0_CONF2 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:15] This register is used to configure the thr_h_lim value for unit %s.
                    CNT_H_LIM:  u16, 
                    
                    /// [16:31] This register is used to configure the thr_l_lim value for unit %s.
                    CNT_L_LIM:  u16, 
                    
                }), @ptrFromInt(0x60012014));
                
                /// Counter value for unit %s
                pub const U0_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:15] This register stores the current pulse count value for unit %s.
                    CNT:  u16, 
                    
                    /// [16:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60012030));
                
                /// Counter value for unit %s
                pub const U0_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:15] This register stores the current pulse count value for unit %s.
                    CNT:  u16, 
                    
                    /// [16:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60012034));
                
                /// Counter value for unit %s
                pub const U0_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:15] This register stores the current pulse count value for unit %s.
                    CNT:  u16, 
                    
                    /// [16:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60012038));
                
                /// Counter value for unit %s
                pub const U0_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:15] This register stores the current pulse count value for unit %s.
                    CNT:  u16, 
                    
                    /// [16:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6001203c));
                
                /// Interrupt raw status register
                pub const INT_RAW = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] The raw interrupt status bit for the PCNT_CNT_THR_EVENT_U0_INT interrupt.
                    CNT_THR_EVENT_U0:  u1, 
                    
                    /// [1:1] The raw interrupt status bit for the PCNT_CNT_THR_EVENT_U1_INT interrupt.
                    CNT_THR_EVENT_U1:  u1, 
                    
                    /// [2:2] The raw interrupt status bit for the PCNT_CNT_THR_EVENT_U2_INT interrupt.
                    CNT_THR_EVENT_U2:  u1, 
                    
                    /// [3:3] The raw interrupt status bit for the PCNT_CNT_THR_EVENT_U3_INT interrupt.
                    CNT_THR_EVENT_U3:  u1, 
                    
                    /// [4:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60012040));
                
                /// Interrupt status register
                pub const INT_ST = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] The masked interrupt status bit for the PCNT_CNT_THR_EVENT_U0_INT interrupt.
                    CNT_THR_EVENT_U0:  u1, 
                    
                    /// [1:1] The masked interrupt status bit for the PCNT_CNT_THR_EVENT_U1_INT interrupt.
                    CNT_THR_EVENT_U1:  u1, 
                    
                    /// [2:2] The masked interrupt status bit for the PCNT_CNT_THR_EVENT_U2_INT interrupt.
                    CNT_THR_EVENT_U2:  u1, 
                    
                    /// [3:3] The masked interrupt status bit for the PCNT_CNT_THR_EVENT_U3_INT interrupt.
                    CNT_THR_EVENT_U3:  u1, 
                    
                    /// [4:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60012044));
                
                /// Interrupt enable register
                pub const INT_ENA = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] The interrupt enable bit for the PCNT_CNT_THR_EVENT_U0_INT interrupt.
                    CNT_THR_EVENT_U0:  u1, 
                    
                    /// [1:1] The interrupt enable bit for the PCNT_CNT_THR_EVENT_U1_INT interrupt.
                    CNT_THR_EVENT_U1:  u1, 
                    
                    /// [2:2] The interrupt enable bit for the PCNT_CNT_THR_EVENT_U2_INT interrupt.
                    CNT_THR_EVENT_U2:  u1, 
                    
                    /// [3:3] The interrupt enable bit for the PCNT_CNT_THR_EVENT_U3_INT interrupt.
                    CNT_THR_EVENT_U3:  u1, 
                    
                    /// [4:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60012048));
                
                /// Interrupt clear register
                pub const INT_CLR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Set this bit to clear the PCNT_CNT_THR_EVENT_U0_INT interrupt.
                    CNT_THR_EVENT_U0:  u1, 
                    
                    /// [1:1] Set this bit to clear the PCNT_CNT_THR_EVENT_U1_INT interrupt.
                    CNT_THR_EVENT_U1:  u1, 
                    
                    /// [2:2] Set this bit to clear the PCNT_CNT_THR_EVENT_U2_INT interrupt.
                    CNT_THR_EVENT_U2:  u1, 
                    
                    /// [3:3] Set this bit to clear the PCNT_CNT_THR_EVENT_U3_INT interrupt.
                    CNT_THR_EVENT_U3:  u1, 
                    
                    /// [4:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6001204c));
                
                /// PNCT UNIT%s status register
                pub const U0_STATUS = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:1] The pulse counter status of PCNT_U%s corresponding to 0. 0: pulse counter decreases from positive to 0. 1: pulse counter increases from negative to 0. 2: pulse counter is negative. 3: pulse counter is positive.
                    ZERO_MODE:  u2, 
                    
                    /// [2:2] The latched value of thres1 event of PCNT_U%s when threshold event interrupt is valid. 1: the current pulse counter equals to thres1 and thres1 event is valid. 0: others
                    THRES1:  u1, 
                    
                    /// [3:3] The latched value of thres0 event of PCNT_U%s when threshold event interrupt is valid. 1: the current pulse counter equals to thres0 and thres0 event is valid. 0: others
                    THRES0:  u1, 
                    
                    /// [4:4] The latched value of low limit event of PCNT_U%s when threshold event interrupt is valid. 1: the current pulse counter equals to thr_l_lim and low limit event is valid. 0: others
                    L_LIM:  u1, 
                    
                    /// [5:5] The latched value of high limit event of PCNT_U%s when threshold event interrupt is valid. 1: the current pulse counter equals to thr_h_lim and high limit event is valid. 0: others
                    H_LIM:  u1, 
                    
                    /// [6:6] The latched value of zero threshold event of PCNT_U%s when threshold event interrupt is valid. 1: the current pulse counter equals to 0 and zero threshold event is valid. 0: others
                    ZERO:  u1, 
                    
                    /// [7:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60012050));
                
                /// PNCT UNIT%s status register
                pub const U0_STATUS = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:1] The pulse counter status of PCNT_U%s corresponding to 0. 0: pulse counter decreases from positive to 0. 1: pulse counter increases from negative to 0. 2: pulse counter is negative. 3: pulse counter is positive.
                    ZERO_MODE:  u2, 
                    
                    /// [2:2] The latched value of thres1 event of PCNT_U%s when threshold event interrupt is valid. 1: the current pulse counter equals to thres1 and thres1 event is valid. 0: others
                    THRES1:  u1, 
                    
                    /// [3:3] The latched value of thres0 event of PCNT_U%s when threshold event interrupt is valid. 1: the current pulse counter equals to thres0 and thres0 event is valid. 0: others
                    THRES0:  u1, 
                    
                    /// [4:4] The latched value of low limit event of PCNT_U%s when threshold event interrupt is valid. 1: the current pulse counter equals to thr_l_lim and low limit event is valid. 0: others
                    L_LIM:  u1, 
                    
                    /// [5:5] The latched value of high limit event of PCNT_U%s when threshold event interrupt is valid. 1: the current pulse counter equals to thr_h_lim and high limit event is valid. 0: others
                    H_LIM:  u1, 
                    
                    /// [6:6] The latched value of zero threshold event of PCNT_U%s when threshold event interrupt is valid. 1: the current pulse counter equals to 0 and zero threshold event is valid. 0: others
                    ZERO:  u1, 
                    
                    /// [7:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60012054));
                
                /// PNCT UNIT%s status register
                pub const U0_STATUS = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:1] The pulse counter status of PCNT_U%s corresponding to 0. 0: pulse counter decreases from positive to 0. 1: pulse counter increases from negative to 0. 2: pulse counter is negative. 3: pulse counter is positive.
                    ZERO_MODE:  u2, 
                    
                    /// [2:2] The latched value of thres1 event of PCNT_U%s when threshold event interrupt is valid. 1: the current pulse counter equals to thres1 and thres1 event is valid. 0: others
                    THRES1:  u1, 
                    
                    /// [3:3] The latched value of thres0 event of PCNT_U%s when threshold event interrupt is valid. 1: the current pulse counter equals to thres0 and thres0 event is valid. 0: others
                    THRES0:  u1, 
                    
                    /// [4:4] The latched value of low limit event of PCNT_U%s when threshold event interrupt is valid. 1: the current pulse counter equals to thr_l_lim and low limit event is valid. 0: others
                    L_LIM:  u1, 
                    
                    /// [5:5] The latched value of high limit event of PCNT_U%s when threshold event interrupt is valid. 1: the current pulse counter equals to thr_h_lim and high limit event is valid. 0: others
                    H_LIM:  u1, 
                    
                    /// [6:6] The latched value of zero threshold event of PCNT_U%s when threshold event interrupt is valid. 1: the current pulse counter equals to 0 and zero threshold event is valid. 0: others
                    ZERO:  u1, 
                    
                    /// [7:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60012058));
                
                /// PNCT UNIT%s status register
                pub const U0_STATUS = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:1] The pulse counter status of PCNT_U%s corresponding to 0. 0: pulse counter decreases from positive to 0. 1: pulse counter increases from negative to 0. 2: pulse counter is negative. 3: pulse counter is positive.
                    ZERO_MODE:  u2, 
                    
                    /// [2:2] The latched value of thres1 event of PCNT_U%s when threshold event interrupt is valid. 1: the current pulse counter equals to thres1 and thres1 event is valid. 0: others
                    THRES1:  u1, 
                    
                    /// [3:3] The latched value of thres0 event of PCNT_U%s when threshold event interrupt is valid. 1: the current pulse counter equals to thres0 and thres0 event is valid. 0: others
                    THRES0:  u1, 
                    
                    /// [4:4] The latched value of low limit event of PCNT_U%s when threshold event interrupt is valid. 1: the current pulse counter equals to thr_l_lim and low limit event is valid. 0: others
                    L_LIM:  u1, 
                    
                    /// [5:5] The latched value of high limit event of PCNT_U%s when threshold event interrupt is valid. 1: the current pulse counter equals to thr_h_lim and high limit event is valid. 0: others
                    H_LIM:  u1, 
                    
                    /// [6:6] The latched value of zero threshold event of PCNT_U%s when threshold event interrupt is valid. 1: the current pulse counter equals to 0 and zero threshold event is valid. 0: others
                    ZERO:  u1, 
                    
                    /// [7:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6001205c));
                
                /// Control register for all counters
                pub const CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Set this bit to clear unit 0's counter.
                    CNT_RST_U0:  u1, 
                    
                    /// [1:1] Set this bit to freeze unit 0's counter.
                    CNT_PAUSE_U0:  u1, 
                    
                    /// [2:2] Set this bit to clear unit 1's counter.
                    CNT_RST_U1:  u1, 
                    
                    /// [3:3] Set this bit to freeze unit 1's counter.
                    CNT_PAUSE_U1:  u1, 
                    
                    /// [4:4] Set this bit to clear unit 2's counter.
                    CNT_RST_U2:  u1, 
                    
                    /// [5:5] Set this bit to freeze unit 2's counter.
                    CNT_PAUSE_U2:  u1, 
                    
                    /// [6:6] Set this bit to clear unit 3's counter.
                    CNT_RST_U3:  u1, 
                    
                    /// [7:7] Set this bit to freeze unit 3's counter.
                    CNT_PAUSE_U3:  u1, 
                    
                    /// [8:15] 
                    res0:  u0, 
                    
                    /// [16:16] The registers clock gate enable signal of PCNT module. 1: the registers can be read and written by application. 0: the registers can not be read or written by application
                    CLK_EN:  u1, 
                    
                    /// [17:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x60012060));
                
                /// PCNT version control register
                pub const DATE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] This is the PCNT version control register.
                    DATE:  u32, 
                    
                }), @ptrFromInt(0x600120fc));
                
            };
            
            /// PCR Peripheral
            pub const PCR = struct {
                
                /// UART0 configuration register
                pub const UART0_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Set 1 to enable uart0 apb clock
                    UART0_CLK_EN:  u1, 
                    
                    /// [1:1] Set 0 to reset uart0 module
                    UART0_RST_EN:  u1, 
                    
                    /// [2:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60096000));
                
                /// UART0_SCLK configuration register
                pub const UART0_SCLK_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] Thedenominator of the frequency divider factor of the uart0 function clock.
                    UART0_SCLK_DIV_A:  u6, 
                    
                    /// [6:11] The numerator of the frequency divider factor of the uart0 function clock.
                    UART0_SCLK_DIV_B:  u6, 
                    
                    /// [12:19] The integral part of the frequency divider factor of the uart0 function clock.
                    UART0_SCLK_DIV_NUM:  u8, 
                    
                    /// [20:21] set this field to select clock-source. 0: do not select anyone clock, 1: 80MHz, 2: FOSC, 3(default): XTAL.
                    UART0_SCLK_SEL:  u2, 
                    
                    /// [22:22] Set 1 to enable uart0 function clock
                    UART0_SCLK_EN:  u1, 
                    
                    /// [23:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60096004));
                
                /// UART0 power control register
                pub const UART0_PD_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] 
                    res0:  u0, 
                    
                    /// [1:1] Set this bit to force power down UART0 memory.
                    UART0_MEM_FORCE_PU:  u1, 
                    
                    /// [2:2] Set this bit to force power up UART0 memory.
                    UART0_MEM_FORCE_PD:  u1, 
                    
                    /// [3:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x60096008));
                
                /// UART1 configuration register
                pub const UART1_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Set 1 to enable uart1 apb clock
                    UART1_CLK_EN:  u1, 
                    
                    /// [1:1] Set 0 to reset uart1 module
                    UART1_RST_EN:  u1, 
                    
                    /// [2:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6009600c));
                
                /// UART1_SCLK configuration register
                pub const UART1_SCLK_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] Thedenominator of the frequency divider factor of the uart1 function clock.
                    UART1_SCLK_DIV_A:  u6, 
                    
                    /// [6:11] The numerator of the frequency divider factor of the uart1 function clock.
                    UART1_SCLK_DIV_B:  u6, 
                    
                    /// [12:19] The integral part of the frequency divider factor of the uart1 function clock.
                    UART1_SCLK_DIV_NUM:  u8, 
                    
                    /// [20:21] set this field to select clock-source. 0: do not select anyone clock, 1: 80MHz, 2: FOSC, 3(default): XTAL.
                    UART1_SCLK_SEL:  u2, 
                    
                    /// [22:22] Set 1 to enable uart0 function clock
                    UART1_SCLK_EN:  u1, 
                    
                    /// [23:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60096010));
                
                /// UART1 power control register
                pub const UART1_PD_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] 
                    res0:  u0, 
                    
                    /// [1:1] Set this bit to force power down UART1 memory.
                    UART1_MEM_FORCE_PU:  u1, 
                    
                    /// [2:2] Set this bit to force power up UART1 memory.
                    UART1_MEM_FORCE_PD:  u1, 
                    
                    /// [3:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x60096014));
                
                /// MSPI configuration register
                pub const MSPI_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Set 1 to enable mspi clock, include mspi pll clock
                    MSPI_CLK_EN:  u1, 
                    
                    /// [1:1] Set 0 to reset mspi module
                    MSPI_RST_EN:  u1, 
                    
                    /// [2:2] Set 1 to enable mspi pll clock
                    MSPI_PLL_CLK_EN:  u1, 
                    
                    /// [3:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60096018));
                
                /// MSPI_CLK configuration register
                pub const MSPI_CLK_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] Set as one within (0,1,2) to generate div1(default)/div2/div4 of low-speed clock-source to drive clk_mspi_fast. Only avaiable whe the clck-source is a low-speed clock-source such as XTAL/FOSC.
                    MSPI_FAST_LS_DIV_NUM:  u8, 
                    
                    /// [8:15] Set as one within (3,4,5) to generate div4(default)/div5/div6 of high-speed clock-source to drive clk_mspi_fast. Only avaiable whe the clck-source is a high-speed clock-source such as SPLL.
                    MSPI_FAST_HS_DIV_NUM:  u8, 
                    
                    /// [16:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6009601c));
                
                /// I2C configuration register
                pub const I2C0_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Set 1 to enable i2c apb clock
                    I2C0_CLK_EN:  u1, 
                    
                    /// [1:1] Set 0 to reset i2c module
                    I2C0_RST_EN:  u1, 
                    
                    /// [2:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60096020));
                
                /// I2C_SCLK configuration register
                pub const I2C_SCLK_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] Thedenominator of the frequency divider factor of the i2c function clock.
                    I2C_SCLK_DIV_A:  u6, 
                    
                    /// [6:11] The numerator of the frequency divider factor of the i2c function clock.
                    I2C_SCLK_DIV_B:  u6, 
                    
                    /// [12:19] The integral part of the frequency divider factor of the i2c function clock.
                    I2C_SCLK_DIV_NUM:  u8, 
                    
                    /// [20:20] set this field to select clock-source. 0(default): XTAL, 1: FOSC.
                    I2C_SCLK_SEL:  u1, 
                    
                    /// [21:21] 
                    res0:  u0, 
                    
                    /// [22:22] Set 1 to enable i2c function clock
                    I2C_SCLK_EN:  u1, 
                    
                    /// [23:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x60096024));
                
                /// UHCI configuration register
                pub const UHCI_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Set 1 to enable uhci clock
                    UHCI_CLK_EN:  u1, 
                    
                    /// [1:1] Set 0 to reset uhci module
                    UHCI_RST_EN:  u1, 
                    
                    /// [2:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60096028));
                
                /// RMT configuration register
                pub const RMT_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Set 1 to enable rmt apb clock
                    RMT_CLK_EN:  u1, 
                    
                    /// [1:1] Set 0 to reset rmt module
                    RMT_RST_EN:  u1, 
                    
                    /// [2:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6009602c));
                
                /// RMT_SCLK configuration register
                pub const RMT_SCLK_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] Thedenominator of the frequency divider factor of the rmt function clock.
                    SCLK_DIV_A:  u6, 
                    
                    /// [6:11] The numerator of the frequency divider factor of the rmt function clock.
                    SCLK_DIV_B:  u6, 
                    
                    /// [12:19] The integral part of the frequency divider factor of the rmt function clock.
                    SCLK_DIV_NUM:  u8, 
                    
                    /// [20:21] set this field to select clock-source. 0: do not select anyone clock, 1(default): 80MHz, 2: FOSC, 3: XTAL.
                    SCLK_SEL:  u2, 
                    
                    /// [22:22] Set 1 to enable rmt function clock
                    SCLK_EN:  u1, 
                    
                    /// [23:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60096030));
                
                /// LEDC configuration register
                pub const LEDC_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Set 1 to enable ledc apb clock
                    LEDC_CLK_EN:  u1, 
                    
                    /// [1:1] Set 0 to reset ledc module
                    LEDC_RST_EN:  u1, 
                    
                    /// [2:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60096034));
                
                /// LEDC_SCLK configuration register
                pub const LEDC_SCLK_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:19] 
                    res0:  u0, 
                    
                    /// [20:21] set this field to select clock-source. 0(default): do not select anyone clock, 1: 80MHz, 2: FOSC, 3: XTAL.
                    LEDC_SCLK_SEL:  u2, 
                    
                    /// [22:22] Set 1 to enable ledc function clock
                    LEDC_SCLK_EN:  u1, 
                    
                    /// [23:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x60096038));
                
                /// TIMERGROUP0 configuration register
                pub const TIMERGROUP0_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Set 1 to enable timer_group0 apb clock
                    TG0_CLK_EN:  u1, 
                    
                    /// [1:1] Set 0 to reset timer_group0 module
                    TG0_RST_EN:  u1, 
                    
                    /// [2:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6009603c));
                
                /// TIMERGROUP0_TIMER_CLK configuration register
                pub const TIMERGROUP0_TIMER_CLK_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:19] 
                    res0:  u0, 
                    
                    /// [20:21] set this field to select clock-source. 0(default): XTAL, 1: 80MHz, 2: FOSC, 3: reserved.
                    TG0_TIMER_CLK_SEL:  u2, 
                    
                    /// [22:22] Set 1 to enable timer_group0 timer clock
                    TG0_TIMER_CLK_EN:  u1, 
                    
                    /// [23:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x60096040));
                
                /// TIMERGROUP0_WDT_CLK configuration register
                pub const TIMERGROUP0_WDT_CLK_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:19] 
                    res0:  u0, 
                    
                    /// [20:21] set this field to select clock-source. 0(default): XTAL, 1: 80MHz, 2: FOSC, 3: reserved.
                    TG0_WDT_CLK_SEL:  u2, 
                    
                    /// [22:22] Set 1 to enable timer_group0 wdt clock
                    TG0_WDT_CLK_EN:  u1, 
                    
                    /// [23:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x60096044));
                
                /// TIMERGROUP1 configuration register
                pub const TIMERGROUP1_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Set 1 to enable timer_group1 apb clock
                    TG1_CLK_EN:  u1, 
                    
                    /// [1:1] Set 0 to reset timer_group1 module
                    TG1_RST_EN:  u1, 
                    
                    /// [2:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60096048));
                
                /// TIMERGROUP1_TIMER_CLK configuration register
                pub const TIMERGROUP1_TIMER_CLK_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:19] 
                    res0:  u0, 
                    
                    /// [20:21] set this field to select clock-source. 0(default): XTAL, 1: 80MHz, 2: FOSC, 3: reserved.
                    TG1_TIMER_CLK_SEL:  u2, 
                    
                    /// [22:22] Set 1 to enable timer_group1 timer clock
                    TG1_TIMER_CLK_EN:  u1, 
                    
                    /// [23:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x6009604c));
                
                /// TIMERGROUP1_WDT_CLK configuration register
                pub const TIMERGROUP1_WDT_CLK_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:19] 
                    res0:  u0, 
                    
                    /// [20:21] set this field to select clock-source. 0(default): XTAL, 1: 80MHz, 2: FOSC, 3: reserved.
                    TG1_WDT_CLK_SEL:  u2, 
                    
                    /// [22:22] Set 1 to enable timer_group0 wdt clock
                    TG1_WDT_CLK_EN:  u1, 
                    
                    /// [23:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x60096050));
                
                /// SYSTIMER configuration register
                pub const SYSTIMER_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Set 1 to enable systimer apb clock
                    SYSTIMER_CLK_EN:  u1, 
                    
                    /// [1:1] Set 0 to reset systimer module
                    SYSTIMER_RST_EN:  u1, 
                    
                    /// [2:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60096054));
                
                /// SYSTIMER_FUNC_CLK configuration register
                pub const SYSTIMER_FUNC_CLK_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:19] 
                    res0:  u0, 
                    
                    /// [20:20] set this field to select clock-source. 0(default): XTAL, 1: FOSC.
                    SYSTIMER_FUNC_CLK_SEL:  u1, 
                    
                    /// [21:21] 
                    res1:  u0, 
                    
                    /// [22:22] Set 1 to enable systimer function clock
                    SYSTIMER_FUNC_CLK_EN:  u1, 
                    
                    /// [23:31] 
                    res2:  u0, 
                    
                }), @ptrFromInt(0x60096058));
                
                /// TWAI0 configuration register
                pub const TWAI0_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Set 1 to enable twai0 apb clock
                    TWAI0_CLK_EN:  u1, 
                    
                    /// [1:1] Set 0 to reset twai0 module
                    TWAI0_RST_EN:  u1, 
                    
                    /// [2:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6009605c));
                
                /// TWAI0_FUNC_CLK configuration register
                pub const TWAI0_FUNC_CLK_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:19] 
                    res0:  u0, 
                    
                    /// [20:20] set this field to select clock-source. 0(default): XTAL, 1: FOSC.
                    TWAI0_FUNC_CLK_SEL:  u1, 
                    
                    /// [21:21] 
                    res1:  u0, 
                    
                    /// [22:22] Set 1 to enable twai0 function clock
                    TWAI0_FUNC_CLK_EN:  u1, 
                    
                    /// [23:31] 
                    res2:  u0, 
                    
                }), @ptrFromInt(0x60096060));
                
                /// TWAI1 configuration register
                pub const TWAI1_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Set 1 to enable twai1 apb clock
                    TWAI1_CLK_EN:  u1, 
                    
                    /// [1:1] Set 0 to reset twai1 module
                    TWAI1_RST_EN:  u1, 
                    
                    /// [2:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60096064));
                
                /// TWAI1_FUNC_CLK configuration register
                pub const TWAI1_FUNC_CLK_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:19] 
                    res0:  u0, 
                    
                    /// [20:20] set this field to select clock-source. 0(default): XTAL, 1: FOSC.
                    TWAI1_FUNC_CLK_SEL:  u1, 
                    
                    /// [21:21] 
                    res1:  u0, 
                    
                    /// [22:22] Set 1 to enable twai1 function clock
                    TWAI1_FUNC_CLK_EN:  u1, 
                    
                    /// [23:31] 
                    res2:  u0, 
                    
                }), @ptrFromInt(0x60096068));
                
                /// I2S configuration register
                pub const I2S_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Set 1 to enable i2s apb clock
                    I2S_CLK_EN:  u1, 
                    
                    /// [1:1] Set 0 to reset i2s module
                    I2S_RST_EN:  u1, 
                    
                    /// [2:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6009606c));
                
                /// I2S_TX_CLKM configuration register
                pub const I2S_TX_CLKM_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:11] 
                    res0:  u0, 
                    
                    /// [12:19] Integral I2S TX clock divider value. f_I2S_CLK = f_I2S_CLK_S/(N+b/a). There will be (a-b) * n-div and b * (n+1)-div.So the average combination will be:for b <= a/2, z * [x * n-div + (n+1)-div] + y * n-div. For b > a/2, z * [n-div + x * (n+1)-div] + y * (n+1)-div.
                    I2S_TX_CLKM_DIV_NUM:  u8, 
                    
                    /// [20:21] Select I2S Tx module source clock. 0: XTAL clock. 1: APLL. 2: CLK160. 3: I2S_MCLK_in.
                    I2S_TX_CLKM_SEL:  u2, 
                    
                    /// [22:22] Set 1 to enable i2s_tx function clock
                    I2S_TX_CLKM_EN:  u1, 
                    
                    /// [23:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x60096070));
                
                /// I2S_TX_CLKM_DIV configuration register
                pub const I2S_TX_CLKM_DIV_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:8] For b <= a/2, the value of I2S_TX_CLKM_DIV_Z is b. For b > a/2, the value of I2S_TX_CLKM_DIV_Z is (a-b).
                    I2S_TX_CLKM_DIV_Z:  u9, 
                    
                    /// [9:17] For b <= a/2, the value of I2S_TX_CLKM_DIV_Y is (a%b) . For b > a/2, the value of I2S_TX_CLKM_DIV_Y is (a%(a-b)).
                    I2S_TX_CLKM_DIV_Y:  u9, 
                    
                    /// [18:26] For b <= a/2, the value of I2S_TX_CLKM_DIV_X is (a/b) - 1. For b > a/2, the value of I2S_TX_CLKM_DIV_X is (a/(a-b)) - 1.
                    I2S_TX_CLKM_DIV_X:  u9, 
                    
                    /// [27:27] For b <= a/2, the value of I2S_TX_CLKM_DIV_YN1 is 0 . For b > a/2, the value of I2S_TX_CLKM_DIV_YN1 is 1.
                    I2S_TX_CLKM_DIV_YN1:  u1, 
                    
                    /// [28:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60096074));
                
                /// I2S_RX_CLKM configuration register
                pub const I2S_RX_CLKM_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:11] 
                    res0:  u0, 
                    
                    /// [12:19] Integral I2S clock divider value
                    I2S_RX_CLKM_DIV_NUM:  u8, 
                    
                    /// [20:21] Select I2S Rx module source clock. 0: no clock. 1: APLL. 2: CLK160. 3: I2S_MCLK_in.
                    I2S_RX_CLKM_SEL:  u2, 
                    
                    /// [22:22] Set 1 to enable i2s_rx function clock
                    I2S_RX_CLKM_EN:  u1, 
                    
                    /// [23:23] This field is used to select master-clock. 0(default): clk_i2s_rx, 1: clk_i2s_tx
                    I2S_MCLK_SEL:  u1, 
                    
                    /// [24:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x60096078));
                
                /// I2S_RX_CLKM_DIV configuration register
                pub const I2S_RX_CLKM_DIV_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:8] For b <= a/2, the value of I2S_RX_CLKM_DIV_Z is b. For b > a/2, the value of I2S_RX_CLKM_DIV_Z is (a-b).
                    I2S_RX_CLKM_DIV_Z:  u9, 
                    
                    /// [9:17] For b <= a/2, the value of I2S_RX_CLKM_DIV_Y is (a%b) . For b > a/2, the value of I2S_RX_CLKM_DIV_Y is (a%(a-b)).
                    I2S_RX_CLKM_DIV_Y:  u9, 
                    
                    /// [18:26] For b <= a/2, the value of I2S_RX_CLKM_DIV_X is (a/b) - 1. For b > a/2, the value of I2S_RX_CLKM_DIV_X is (a/(a-b)) - 1.
                    I2S_RX_CLKM_DIV_X:  u9, 
                    
                    /// [27:27] For b <= a/2, the value of I2S_RX_CLKM_DIV_YN1 is 0 . For b > a/2, the value of I2S_RX_CLKM_DIV_YN1 is 1.
                    I2S_RX_CLKM_DIV_YN1:  u1, 
                    
                    /// [28:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6009607c));
                
                /// SARADC configuration register
                pub const SARADC_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] no use
                    SARADC_CLK_EN:  u1, 
                    
                    /// [1:1] Set 0 to reset function_register of saradc module
                    SARADC_RST_EN:  u1, 
                    
                    /// [2:2] Set 1 to enable saradc apb clock
                    SARADC_REG_CLK_EN:  u1, 
                    
                    /// [3:3] Set 0 to reset apb_register of saradc module
                    SARADC_REG_RST_EN:  u1, 
                    
                    /// [4:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60096080));
                
                /// SARADC_CLKM configuration register
                pub const SARADC_CLKM_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] Thedenominator of the frequency divider factor of the saradc function clock.
                    SARADC_CLKM_DIV_A:  u6, 
                    
                    /// [6:11] The numerator of the frequency divider factor of the saradc function clock.
                    SARADC_CLKM_DIV_B:  u6, 
                    
                    /// [12:19] The integral part of the frequency divider factor of the saradc function clock.
                    SARADC_CLKM_DIV_NUM:  u8, 
                    
                    /// [20:21] set this field to select clock-source. 0(default): XTAL, 1: 240MHz, 2: FOSC, 3: reserved.
                    SARADC_CLKM_SEL:  u2, 
                    
                    /// [22:22] Set 1 to enable saradc function clock
                    SARADC_CLKM_EN:  u1, 
                    
                    /// [23:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60096084));
                
                /// TSENS_CLK configuration register
                pub const TSENS_CLK_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:19] 
                    res0:  u0, 
                    
                    /// [20:20] set this field to select clock-source. 0(default): FOSC, 1: XTAL.
                    TSENS_CLK_SEL:  u1, 
                    
                    /// [21:21] 
                    res1:  u0, 
                    
                    /// [22:22] Set 1 to enable tsens clock
                    TSENS_CLK_EN:  u1, 
                    
                    /// [23:23] Set 0 to reset tsens module
                    TSENS_RST_EN:  u1, 
                    
                    /// [24:31] 
                    res2:  u0, 
                    
                }), @ptrFromInt(0x60096088));
                
                /// USB_DEVICE configuration register
                pub const USB_DEVICE_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Set 1 to enable usb_device clock
                    USB_DEVICE_CLK_EN:  u1, 
                    
                    /// [1:1] Set 0 to reset usb_device module
                    USB_DEVICE_RST_EN:  u1, 
                    
                    /// [2:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6009608c));
                
                /// INTMTX configuration register
                pub const INTMTX_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Set 1 to enable intmtx clock
                    INTMTX_CLK_EN:  u1, 
                    
                    /// [1:1] Set 0 to reset intmtx module
                    INTMTX_RST_EN:  u1, 
                    
                    /// [2:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60096090));
                
                /// PCNT configuration register
                pub const PCNT_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Set 1 to enable pcnt clock
                    PCNT_CLK_EN:  u1, 
                    
                    /// [1:1] Set 0 to reset pcnt module
                    PCNT_RST_EN:  u1, 
                    
                    /// [2:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60096094));
                
                /// ETM configuration register
                pub const ETM_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Set 1 to enable etm clock
                    ETM_CLK_EN:  u1, 
                    
                    /// [1:1] Set 0 to reset etm module
                    ETM_RST_EN:  u1, 
                    
                    /// [2:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60096098));
                
                /// PWM configuration register
                pub const PWM_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Set 1 to enable pwm clock
                    PWM_CLK_EN:  u1, 
                    
                    /// [1:1] Set 0 to reset pwm module
                    PWM_RST_EN:  u1, 
                    
                    /// [2:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6009609c));
                
                /// PWM_CLK configuration register
                pub const PWM_CLK_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:11] 
                    res0:  u0, 
                    
                    /// [12:19] The integral part of the frequency divider factor of the pwm function clock.
                    PWM_DIV_NUM:  u8, 
                    
                    /// [20:21] set this field to select clock-source. 0(default): do not select anyone clock, 1: 160MHz, 2: XTAL, 3: FOSC.
                    PWM_CLKM_SEL:  u2, 
                    
                    /// [22:22] set this field as 1 to activate pwm clkm.
                    PWM_CLKM_EN:  u1, 
                    
                    /// [23:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x600960a0));
                
                /// PARL_IO configuration register
                pub const PARL_IO_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Set 1 to enable parl apb clock
                    PARL_CLK_EN:  u1, 
                    
                    /// [1:1] Set 0 to reset parl apb reg
                    PARL_RST_EN:  u1, 
                    
                    /// [2:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600960a4));
                
                /// PARL_CLK_RX configuration register
                pub const PARL_CLK_RX_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:15] The integral part of the frequency divider factor of the parl rx clock.
                    PARL_CLK_RX_DIV_NUM:  u16, 
                    
                    /// [16:17] set this field to select clock-source. 0(default): XTAL, 1: 240MHz, 2: FOSC, 3: user clock from pad.
                    PARL_CLK_RX_SEL:  u2, 
                    
                    /// [18:18] Set 1 to enable parl rx clock
                    PARL_CLK_RX_EN:  u1, 
                    
                    /// [19:19] Set 0 to reset parl rx module
                    PARL_RX_RST_EN:  u1, 
                    
                    /// [20:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600960a8));
                
                /// PARL_CLK_TX configuration register
                pub const PARL_CLK_TX_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:15] The integral part of the frequency divider factor of the parl tx clock.
                    PARL_CLK_TX_DIV_NUM:  u16, 
                    
                    /// [16:17] set this field to select clock-source. 0(default): XTAL, 1: 240MHz, 2: FOSC, 3: user clock from pad.
                    PARL_CLK_TX_SEL:  u2, 
                    
                    /// [18:18] Set 1 to enable parl tx clock
                    PARL_CLK_TX_EN:  u1, 
                    
                    /// [19:19] Set 0 to reset parl tx module
                    PARL_TX_RST_EN:  u1, 
                    
                    /// [20:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600960ac));
                
                /// SDIO_SLAVE configuration register
                pub const SDIO_SLAVE_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Set 1 to enable sdio_slave clock
                    SDIO_SLAVE_CLK_EN:  u1, 
                    
                    /// [1:1] Set 0 to reset sdio_slave module
                    SDIO_SLAVE_RST_EN:  u1, 
                    
                    /// [2:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600960b0));
                
                /// PVT_MONITOR configuration register
                pub const PVT_MONITOR_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Set 1 to enable apb clock of pvt module
                    PVT_MONITOR_CLK_EN:  u1, 
                    
                    /// [1:1] Set 0 to reset all pvt monitor module
                    PVT_MONITOR_RST_EN:  u1, 
                    
                    /// [2:2] Set 1 to enable function clock of modem pvt module
                    PVT_MONITOR_SITE1_CLK_EN:  u1, 
                    
                    /// [3:3] Set 1 to enable function clock of cpu pvt module
                    PVT_MONITOR_SITE2_CLK_EN:  u1, 
                    
                    /// [4:4] Set 1 to enable function clock of hp_peri pvt module
                    PVT_MONITOR_SITE3_CLK_EN:  u1, 
                    
                    /// [5:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600960b4));
                
                /// PVT_MONITOR function clock configuration register
                pub const PVT_MONITOR_FUNC_CLK_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:3] The integral part of the frequency divider factor of the pvt_monitor function clock.
                    PVT_MONITOR_FUNC_CLK_DIV_NUM:  u4, 
                    
                    /// [4:19] 
                    res0:  u0, 
                    
                    /// [20:20] set this field to select clock-source. 0: XTAL, 1(default): 160MHz drived by SPLL divided by 3.
                    PVT_MONITOR_FUNC_CLK_SEL:  u1, 
                    
                    /// [21:21] 
                    res1:  u0, 
                    
                    /// [22:22] Set 1 to enable source clock of pvt sitex
                    PVT_MONITOR_FUNC_CLK_EN:  u1, 
                    
                    /// [23:31] 
                    res2:  u0, 
                    
                }), @ptrFromInt(0x600960b8));
                
                /// GDMA configuration register
                pub const GDMA_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Set 1 to enable gdma clock
                    GDMA_CLK_EN:  u1, 
                    
                    /// [1:1] Set 0 to reset gdma module
                    GDMA_RST_EN:  u1, 
                    
                    /// [2:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600960bc));
                
                /// SPI2 configuration register
                pub const SPI2_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Set 1 to enable spi2 apb clock
                    SPI2_CLK_EN:  u1, 
                    
                    /// [1:1] Set 0 to reset spi2 module
                    SPI2_RST_EN:  u1, 
                    
                    /// [2:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600960c0));
                
                /// SPI2_CLKM configuration register
                pub const SPI2_CLKM_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:19] 
                    res0:  u0, 
                    
                    /// [20:21] set this field to select clock-source. 0(default): XTAL, 1: 80MHz, 2: FOSC, 3: reserved.
                    SPI2_CLKM_SEL:  u2, 
                    
                    /// [22:22] Set 1 to enable spi2 function clock
                    SPI2_CLKM_EN:  u1, 
                    
                    /// [23:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x600960c4));
                
                /// AES configuration register
                pub const AES_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Set 1 to enable aes clock
                    AES_CLK_EN:  u1, 
                    
                    /// [1:1] Set 0 to reset aes module
                    AES_RST_EN:  u1, 
                    
                    /// [2:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600960c8));
                
                /// SHA configuration register
                pub const SHA_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Set 1 to enable sha clock
                    SHA_CLK_EN:  u1, 
                    
                    /// [1:1] Set 0 to reset sha module
                    SHA_RST_EN:  u1, 
                    
                    /// [2:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600960cc));
                
                /// RSA configuration register
                pub const RSA_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Set 1 to enable rsa clock
                    RSA_CLK_EN:  u1, 
                    
                    /// [1:1] Set 0 to reset rsa module
                    RSA_RST_EN:  u1, 
                    
                    /// [2:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600960d0));
                
                /// RSA power control register
                pub const RSA_PD_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Set this bit to power down rsa internal memory.
                    RSA_MEM_PD:  u1, 
                    
                    /// [1:1] Set this bit to force power up rsa internal memory
                    RSA_MEM_FORCE_PU:  u1, 
                    
                    /// [2:2] Set this bit to force power down rsa internal memory.
                    RSA_MEM_FORCE_PD:  u1, 
                    
                    /// [3:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600960d4));
                
                /// ECC configuration register
                pub const ECC_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Set 1 to enable ecc clock
                    ECC_CLK_EN:  u1, 
                    
                    /// [1:1] Set 0 to reset ecc module
                    ECC_RST_EN:  u1, 
                    
                    /// [2:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600960d8));
                
                /// ECC power control register
                pub const ECC_PD_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Set this bit to power down ecc internal memory.
                    ECC_MEM_PD:  u1, 
                    
                    /// [1:1] Set this bit to force power up ecc internal memory
                    ECC_MEM_FORCE_PU:  u1, 
                    
                    /// [2:2] Set this bit to force power down ecc internal memory.
                    ECC_MEM_FORCE_PD:  u1, 
                    
                    /// [3:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600960dc));
                
                /// DS configuration register
                pub const DS_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Set 1 to enable ds clock
                    DS_CLK_EN:  u1, 
                    
                    /// [1:1] Set 0 to reset ds module
                    DS_RST_EN:  u1, 
                    
                    /// [2:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600960e0));
                
                /// HMAC configuration register
                pub const HMAC_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Set 1 to enable hmac clock
                    HMAC_CLK_EN:  u1, 
                    
                    /// [1:1] Set 0 to reset hmac module
                    HMAC_RST_EN:  u1, 
                    
                    /// [2:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600960e4));
                
                /// IOMUX configuration register
                pub const IOMUX_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Set 1 to enable iomux apb clock
                    IOMUX_CLK_EN:  u1, 
                    
                    /// [1:1] Set 0 to reset iomux module
                    IOMUX_RST_EN:  u1, 
                    
                    /// [2:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600960e8));
                
                /// IOMUX_CLK configuration register
                pub const IOMUX_CLK_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:19] 
                    res0:  u0, 
                    
                    /// [20:21] set this field to select clock-source. 0: do not select anyone clock, 1: 80MHz, 2: FOSC, 3(default): XTAL.
                    IOMUX_FUNC_CLK_SEL:  u2, 
                    
                    /// [22:22] Set 1 to enable iomux function clock
                    IOMUX_FUNC_CLK_EN:  u1, 
                    
                    /// [23:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x600960ec));
                
                /// MEM_MONITOR configuration register
                pub const MEM_MONITOR_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Set 1 to enable mem_monitor clock
                    MEM_MONITOR_CLK_EN:  u1, 
                    
                    /// [1:1] Set 0 to reset mem_monitor module
                    MEM_MONITOR_RST_EN:  u1, 
                    
                    /// [2:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600960f0));
                
                /// REGDMA configuration register
                pub const REGDMA_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Set 1 to enable regdma clock
                    REGDMA_CLK_EN:  u1, 
                    
                    /// [1:1] Set 0 to reset regdma module
                    REGDMA_RST_EN:  u1, 
                    
                    /// [2:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600960f4));
                
                /// retention configuration register
                pub const RETENTION_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Set 1 to enable retention clock
                    RETENTION_CLK_EN:  u1, 
                    
                    /// [1:1] Set 0 to reset retention module
                    RETENTION_RST_EN:  u1, 
                    
                    /// [2:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600960f8));
                
                /// TRACE configuration register
                pub const TRACE_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Set 1 to enable trace clock
                    TRACE_CLK_EN:  u1, 
                    
                    /// [1:1] Set 0 to reset trace module
                    TRACE_RST_EN:  u1, 
                    
                    /// [2:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600960fc));
                
                /// ASSIST configuration register
                pub const ASSIST_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Set 1 to enable assist clock
                    ASSIST_CLK_EN:  u1, 
                    
                    /// [1:1] Set 0 to reset assist module
                    ASSIST_RST_EN:  u1, 
                    
                    /// [2:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60096100));
                
                /// CACHE configuration register
                pub const CACHE_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Set 1 to enable cache clock
                    CACHE_CLK_EN:  u1, 
                    
                    /// [1:1] Set 0 to reset cache module
                    CACHE_RST_EN:  u1, 
                    
                    /// [2:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60096104));
                
                /// MODEM_APB configuration register
                pub const MODEM_APB_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] This field indicates if modem_apb clock is enable. 0: disable, 1: enable(default).
                    MODEM_APB_CLK_EN:  u1, 
                    
                    /// [1:1] Set this file as 1 to reset modem-subsystem.
                    MODEM_RST_EN:  u1, 
                    
                    /// [2:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60096108));
                
                /// TIMEOUT configuration register
                pub const TIMEOUT_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] 
                    res0:  u0, 
                    
                    /// [1:1] Set 0 to reset cpu_peri timeout module
                    CPU_TIMEOUT_RST_EN:  u1, 
                    
                    /// [2:2] Set 0 to reset hp_peri timeout module and hp_modem timeout module
                    HP_TIMEOUT_RST_EN:  u1, 
                    
                    /// [3:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x6009610c));
                
                /// SYSCLK configuration register
                pub const SYSCLK_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] clk_hproot is div1 of low-speed clock-source if clck-source is a low-speed clock-source such as XTAL/FOSC.
                    LS_DIV_NUM:  u8, 
                    
                    /// [8:15] clk_hproot is div3 of SPLL if the clock-source is high-speed clock SPLL.
                    HS_DIV_NUM:  u8, 
                    
                    /// [16:17] This field is used to select clock source. 0: XTAL, 1: SPLL, 2: FOSC, 3: reserved.
                    SOC_CLK_SEL:  u2, 
                    
                    /// [18:23] 
                    res0:  u0, 
                    
                    /// [24:30] This field indicates the frequency(MHz) of XTAL.
                    CLK_XTAL_FREQ:  u7, 
                    
                    /// [31:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x60096110));
                
                /// CPU_WAITI configuration register
                pub const CPU_WAITI_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:1] Reserved. This filed has been replaced by PCR_CPU_HS_DIV_NUM and PCR_CPU_LS_DIV_NUM
                    CPUPERIOD_SEL:  u2, 
                    
                    /// [2:2] Reserved. This filed has been replaced by PCR_CPU_HS_DIV_NUM and PCR_CPU_LS_DIV_NUM
                    PLL_FREQ_SEL:  u1, 
                    
                    /// [3:3] Set 1 to force cpu_waiti_clk enable.
                    CPU_WAIT_MODE_FORCE_ON:  u1, 
                    
                    /// [4:7] This field used to set delay cycle when cpu enter waiti mode, after delay waiti_clk will close
                    CPU_WAITI_DELAY_NUM:  u4, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60096114));
                
                /// CPU_FREQ configuration register
                pub const CPU_FREQ_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] Set as one within (0,1,3) to generate clk_cpu drived by clk_hproot. The clk_cpu is div1(default)/div2/div4 of clk_hproot. This field is only avaliable for low-speed clock-source such as XTAL/FOSC, and should be used together with PCR_AHB_LS_DIV_NUM.
                    CPU_LS_DIV_NUM:  u8, 
                    
                    /// [8:15] Set as one within (0,1,3) to generate clk_cpu drived by clk_hproot. The clk_cpu is div1(default)/div2/div4 of clk_hproot. This field is only avaliable for high-speed clock-source such as SPLL, and should be used together with PCR_AHB_HS_DIV_NUM.
                    CPU_HS_DIV_NUM:  u8, 
                    
                    /// [16:16] Given that PCR_CPU_HS_DIV_NUM is 0, set this field as 1 to force clk_cpu at 120MHz. Only avaliable when PCR_CPU_HS_DIV_NUM is 0 and clk_cpu is driven by SPLL.
                    CPU_HS_120M_FORCE:  u1, 
                    
                    /// [17:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60096118));
                
                /// AHB_FREQ configuration register
                pub const AHB_FREQ_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] Set as one within (0,1,3,7) to generate clk_ahb drived by clk_hproot. The clk_ahb is div1(default)/div2/div4/div8 of clk_hproot. This field is only avaliable for low-speed clock-source such as XTAL/FOSC, and should be used together with PCR_CPU_LS_DIV_NUM.
                    AHB_LS_DIV_NUM:  u8, 
                    
                    /// [8:15] Set as one within (3,7,15) to generate clk_ahb drived by clk_hproot. The clk_ahb is div4(default)/div8/div16 of clk_hproot. This field is only avaliable for high-speed clock-source such as SPLL, and should be used together with PCR_CPU_HS_DIV_NUM.
                    AHB_HS_DIV_NUM:  u8, 
                    
                    /// [16:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6009611c));
                
                /// APB_FREQ configuration register
                pub const APB_FREQ_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] If this field's value is grater than PCR_APB_DIV_NUM, the clk_apb will be automatically down to clk_apb_decrease only when no access is on apb-bus, and will recover to the previous frequency when a new access appears on apb-bus. Set as one within (0,1,3) to set clk_apb_decrease as div1/div2/div4(default) of clk_ahb. Note that enable this function will reduce performance. Users can set this field as zero to disable the auto-decrease-apb-freq function. By default, this function is disable.
                    APB_DECREASE_DIV_NUM:  u8, 
                    
                    /// [8:15] Set as one within (0,1,3) to generate clk_apb drived by clk_ahb. The clk_apb is div1(default)/div2/div4 of clk_ahb.
                    APB_DIV_NUM:  u8, 
                    
                    /// [16:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60096120));
                
                /// SYSCLK frequency query 0 register
                pub const SYSCLK_FREQ_QUERY_0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] This field indicates the frequency(MHz) of FOSC.
                    FOSC_FREQ:  u8, 
                    
                    /// [8:17] This field indicates the frequency(MHz) of SPLL.
                    PLL_FREQ:  u10, 
                    
                    /// [18:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60096124));
                
                /// SPLL DIV clock-gating configuration register
                pub const PLL_DIV_CLK_EN = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] This field is used to open 240 MHz clock (div2 of SPLL) drived from SPLL. 0: close, 1: open(default). Only avaliable when high-speed clock-source SPLL is active.
                    PLL_240M_CLK_EN:  u1, 
                    
                    /// [1:1] This field is used to open 160 MHz clock (div3 of SPLL) drived from SPLL. 0: close, 1: open(default). Only avaliable when high-speed clock-source SPLL is active.
                    PLL_160M_CLK_EN:  u1, 
                    
                    /// [2:2] This field is used to open 120 MHz clock (div4 of SPLL) drived from SPLL. 0: close, 1: open(default). Only avaliable when high-speed clock-source SPLL is active.
                    PLL_120M_CLK_EN:  u1, 
                    
                    /// [3:3] This field is used to open 80 MHz clock (div6of SPLL) drived from SPLL. 0: close, 1: open(default). Only avaliable when high-speed clock-source SPLL is active.
                    PLL_80M_CLK_EN:  u1, 
                    
                    /// [4:4] This field is used to open 48 MHz clock (div10 of SPLL) drived from SPLL. 0: close, 1: open(default). Only avaliable when high-speed clock-source SPLL is active.
                    PLL_48M_CLK_EN:  u1, 
                    
                    /// [5:5] This field is used to open 40 MHz clock (div12 of SPLL) drived from SPLL. 0: close, 1: open(default). Only avaliable when high-speed clock-source SPLL is active.
                    PLL_40M_CLK_EN:  u1, 
                    
                    /// [6:6] This field is used to open 20 MHz clock (div24 of SPLL) drived from SPLL. 0: close, 1: open(default). Only avaliable when high-speed clock-source SPLL is active.
                    PLL_20M_CLK_EN:  u1, 
                    
                    /// [7:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60096128));
                
                /// CLK_OUT_EN configuration register
                pub const CTRL_CLK_OUT_EN = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Set 1 to enable 20m clock
                    CLK20_OEN:  u1, 
                    
                    /// [1:1] Set 1 to enable 22m clock
                    CLK22_OEN:  u1, 
                    
                    /// [2:2] Set 1 to enable 44m clock
                    CLK44_OEN:  u1, 
                    
                    /// [3:3] Set 1 to enable bb clock
                    CLK_BB_OEN:  u1, 
                    
                    /// [4:4] Set 1 to enable 80m clock
                    CLK80_OEN:  u1, 
                    
                    /// [5:5] Set 1 to enable 160m clock
                    CLK160_OEN:  u1, 
                    
                    /// [6:6] Set 1 to enable 320m clock
                    CLK_320M_OEN:  u1, 
                    
                    /// [7:7] Reserved
                    CLK_ADC_INF_OEN:  u1, 
                    
                    /// [8:8] Reserved
                    CLK_DAC_CPU_OEN:  u1, 
                    
                    /// [9:9] Set 1 to enable 40x_bb clock
                    CLK40X_BB_OEN:  u1, 
                    
                    /// [10:10] Set 1 to enable xtal clock
                    CLK_XTAL_OEN:  u1, 
                    
                    /// [11:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6009612c));
                
                /// TICK configuration register
                pub const CTRL_TICK_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] ******* Description ***********
                    XTAL_TICK_NUM:  u8, 
                    
                    /// [8:15] ******* Description ***********
                    FOSC_TICK_NUM:  u8, 
                    
                    /// [16:16] ******* Description ***********
                    TICK_ENABLE:  u1, 
                    
                    /// [17:17] ******* Description ***********
                    RST_TICK_CNT:  u1, 
                    
                    /// [18:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60096130));
                
                /// 32KHz clock configuration register
                pub const CTRL_32K_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:1] This field indicates which one 32KHz clock will be used by MODEM_SYSTEM and timergroup. 0: OSC32K(default), 1: XTAL32K, 2/3: 32KHz from pad GPIO0.
                    CLK_32K_SEL:  u2, 
                    
                    /// [2:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60096134));
                
                /// HP SRAM/ROM configuration register
                pub const SRAM_POWER_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:3] Set this bit to force power up SRAM
                    SRAM_FORCE_PU:  u4, 
                    
                    /// [4:7] Set this bit to force power down SRAM.
                    SRAM_FORCE_PD:  u4, 
                    
                    /// [8:11] 1: Force to open the clock and bypass the gate-clock when accessing the SRAM. 0: A gate-clock will be used when accessing the SRAM.
                    SRAM_CLKGATE_FORCE_ON:  u4, 
                    
                    /// [12:14] Set this bit to force power up ROM
                    ROM_FORCE_PU:  u3, 
                    
                    /// [15:17] Set this bit to force power down ROM.
                    ROM_FORCE_PD:  u3, 
                    
                    /// [18:20] 1: Force to open the clock and bypass the gate-clock when accessing the ROM. 0: A gate-clock will be used when accessing the ROM.
                    ROM_CLKGATE_FORCE_ON:  u3, 
                    
                    /// [21:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60096138));
                
                /// reset event bypass backdoor configuration register
                pub const RESET_EVENT_BYPASS = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] This field is used to control reset event relationship for tee_reg/apm_reg/hp_system_reg. 1: tee_reg/apm_reg/hp_system_reg will only be reset by power-reset. some reset event will be bypass. 0: tee_reg/apm_reg/hp_system_reg will not only be reset by power-reset, but also some reset event.
                    APM:  u1, 
                    
                    /// [1:1] This field is used to control reset event relationship for system-bus. 1: system bus (including arbiter/router) will only be reset by power-reset. some reset event will be bypass. 0: system bus (including arbiter/router) will not only be reset by power-reset, but also some reset event.
                    RESET_EVENT_BYPASS:  u1, 
                    
                    /// [2:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60096ff0));
                
                /// fpga debug register
                pub const FPGA_DEBUG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Only used in fpga debug.
                    FPGA_DEBUG:  u32, 
                    
                }), @ptrFromInt(0x60096ff4));
                
                /// PCR clock gating configure register
                pub const CLOCK_GATE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Set this bit as 1 to force on clock gating.
                    CLK_EN:  u1, 
                    
                    /// [1:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60096ff8));
                
                /// Date register.
                pub const DATE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:27] PCR version information.
                    DATE:  u28, 
                    
                    /// [28:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60096ffc));
                
            };
            
            /// PMU Peripheral
            pub const PMU = struct {
                
                /// need_des
                pub const HP_ACTIVE_DIG_POWER = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:20] 
                    res0:  u0, 
                    
                    /// [21:21] need_des
                    HP_ACTIVE_VDD_SPI_PD_EN:  u1, 
                    
                    /// [22:22] need_des
                    HP_ACTIVE_HP_MEM_DSLP:  u1, 
                    
                    /// [23:26] need_des
                    HP_ACTIVE_PD_HP_MEM_PD_EN:  u4, 
                    
                    /// [27:27] need_des
                    HP_ACTIVE_PD_HP_WIFI_PD_EN:  u1, 
                    
                    /// [28:28] 
                    res1:  u0, 
                    
                    /// [29:29] need_des
                    HP_ACTIVE_PD_HP_CPU_PD_EN:  u1, 
                    
                    /// [30:30] need_des
                    HP_ACTIVE_PD_HP_AON_PD_EN:  u1, 
                    
                    /// [31:31] need_des
                    HP_ACTIVE_PD_TOP_PD_EN:  u1, 
                    
                }), @ptrFromInt(0x600b0000));
                
                /// need_des
                pub const HP_ACTIVE_ICG_HP_FUNC = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] need_des
                    HP_ACTIVE_DIG_ICG_FUNC_EN:  u32, 
                    
                }), @ptrFromInt(0x600b0004));
                
                /// need_des
                pub const HP_ACTIVE_ICG_HP_APB = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] need_des
                    HP_ACTIVE_DIG_ICG_APB_EN:  u32, 
                    
                }), @ptrFromInt(0x600b0008));
                
                /// need_des
                pub const HP_ACTIVE_ICG_MODEM = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:29] 
                    res0:  u0, 
                    
                    /// [30:31] need_des
                    HP_ACTIVE_DIG_ICG_MODEM_CODE:  u2, 
                    
                }), @ptrFromInt(0x600b000c));
                
                /// need_des
                pub const HP_ACTIVE_HP_SYS_CNTL = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:23] 
                    res0:  u0, 
                    
                    /// [24:24] need_des
                    HP_ACTIVE_UART_WAKEUP_EN:  u1, 
                    
                    /// [25:25] need_des
                    HP_ACTIVE_LP_PAD_HOLD_ALL:  u1, 
                    
                    /// [26:26] need_des
                    HP_ACTIVE_HP_PAD_HOLD_ALL:  u1, 
                    
                    /// [27:27] need_des
                    HP_ACTIVE_DIG_PAD_SLP_SEL:  u1, 
                    
                    /// [28:28] need_des
                    HP_ACTIVE_DIG_PAUSE_WDT:  u1, 
                    
                    /// [29:29] need_des
                    HP_ACTIVE_DIG_CPU_STALL:  u1, 
                    
                    /// [30:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x600b0010));
                
                /// need_des
                pub const HP_ACTIVE_HP_CK_POWER = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:25] 
                    res0:  u0, 
                    
                    /// [26:26] need_des
                    HP_ACTIVE_I2C_ISO_EN:  u1, 
                    
                    /// [27:27] need_des
                    HP_ACTIVE_I2C_RETENTION:  u1, 
                    
                    /// [28:28] need_des
                    HP_ACTIVE_XPD_BB_I2C:  u1, 
                    
                    /// [29:29] need_des
                    HP_ACTIVE_XPD_BBPLL_I2C:  u1, 
                    
                    /// [30:30] need_des
                    HP_ACTIVE_XPD_BBPLL:  u1, 
                    
                    /// [31:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x600b0014));
                
                /// need_des
                pub const HP_ACTIVE_BIAS = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:24] 
                    res0:  u0, 
                    
                    /// [25:25] need_des
                    HP_ACTIVE_XPD_BIAS:  u1, 
                    
                    /// [26:29] need_des
                    HP_ACTIVE_DBG_ATTEN:  u4, 
                    
                    /// [30:30] need_des
                    HP_ACTIVE_PD_CUR:  u1, 
                    
                    /// [31:31] need_des
                    SLEEP:  u1, 
                    
                }), @ptrFromInt(0x600b0018));
                
                /// need_des
                pub const HP_ACTIVE_BACKUP = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:3] 
                    res0:  u0, 
                    
                    /// [4:5] need_des
                    HP_SLEEP2ACTIVE_BACKUP_MODEM_CLK_CODE:  u2, 
                    
                    /// [6:7] need_des
                    HP_MODEM2ACTIVE_BACKUP_MODEM_CLK_CODE:  u2, 
                    
                    /// [8:9] 
                    res1:  u0, 
                    
                    /// [10:10] need_des
                    HP_ACTIVE_RETENTION_MODE:  u1, 
                    
                    /// [11:11] need_des
                    HP_SLEEP2ACTIVE_RETENTION_EN:  u1, 
                    
                    /// [12:12] need_des
                    HP_MODEM2ACTIVE_RETENTION_EN:  u1, 
                    
                    /// [13:13] 
                    res2:  u0, 
                    
                    /// [14:15] need_des
                    HP_SLEEP2ACTIVE_BACKUP_CLK_SEL:  u2, 
                    
                    /// [16:17] need_des
                    HP_MODEM2ACTIVE_BACKUP_CLK_SEL:  u2, 
                    
                    /// [18:19] 
                    res3:  u0, 
                    
                    /// [20:22] need_des
                    HP_SLEEP2ACTIVE_BACKUP_MODE:  u3, 
                    
                    /// [23:25] need_des
                    HP_MODEM2ACTIVE_BACKUP_MODE:  u3, 
                    
                    /// [26:28] 
                    res4:  u0, 
                    
                    /// [29:29] need_des
                    HP_SLEEP2ACTIVE_BACKUP_EN:  u1, 
                    
                    /// [30:30] need_des
                    HP_MODEM2ACTIVE_BACKUP_EN:  u1, 
                    
                    /// [31:31] 
                    res5:  u0, 
                    
                }), @ptrFromInt(0x600b001c));
                
                /// need_des
                pub const HP_ACTIVE_BACKUP_CLK = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] need_des
                    HP_ACTIVE_BACKUP_ICG_FUNC_EN:  u32, 
                    
                }), @ptrFromInt(0x600b0020));
                
                /// need_des
                pub const HP_ACTIVE_SYSCLK = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:25] 
                    res0:  u0, 
                    
                    /// [26:26] need_des
                    HP_ACTIVE_DIG_SYS_CLK_NO_DIV:  u1, 
                    
                    /// [27:27] need_des
                    HP_ACTIVE_ICG_SYS_CLOCK_EN:  u1, 
                    
                    /// [28:28] need_des
                    HP_ACTIVE_SYS_CLK_SLP_SEL:  u1, 
                    
                    /// [29:29] need_des
                    HP_ACTIVE_ICG_SLP_SEL:  u1, 
                    
                    /// [30:31] need_des
                    HP_ACTIVE_DIG_SYS_CLK_SEL:  u2, 
                    
                }), @ptrFromInt(0x600b0024));
                
                /// need_des
                pub const HP_ACTIVE_HP_REGULATOR0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:3] 
                    res0:  u0, 
                    
                    /// [4:8] need_des
                    LP_DBIAS_VOL:  u5, 
                    
                    /// [9:13] need_des
                    HP_DBIAS_VOL:  u5, 
                    
                    /// [14:14] need_des
                    DIG_REGULATOR0_DBIAS_SEL:  u1, 
                    
                    /// [15:15] need_des
                    DIG_DBIAS_INIT:  u1, 
                    
                    /// [16:16] need_des
                    HP_ACTIVE_HP_REGULATOR_SLP_MEM_XPD:  u1, 
                    
                    /// [17:17] need_des
                    HP_ACTIVE_HP_REGULATOR_SLP_LOGIC_XPD:  u1, 
                    
                    /// [18:18] need_des
                    HP_ACTIVE_HP_REGULATOR_XPD:  u1, 
                    
                    /// [19:22] need_des
                    HP_ACTIVE_HP_REGULATOR_SLP_MEM_DBIAS:  u4, 
                    
                    /// [23:26] need_des
                    HP_ACTIVE_HP_REGULATOR_SLP_LOGIC_DBIAS:  u4, 
                    
                    /// [27:31] need_des
                    HP_ACTIVE_HP_REGULATOR_DBIAS:  u5, 
                    
                }), @ptrFromInt(0x600b0028));
                
                /// need_des
                pub const HP_ACTIVE_HP_REGULATOR1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] 
                    res0:  u0, 
                    
                    /// [8:31] need_des
                    HP_ACTIVE_HP_REGULATOR_DRV_B:  u24, 
                    
                }), @ptrFromInt(0x600b002c));
                
                /// need_des
                pub const HP_ACTIVE_XTAL = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:30] 
                    res0:  u0, 
                    
                    /// [31:31] need_des
                    HP_ACTIVE_XPD_XTAL:  u1, 
                    
                }), @ptrFromInt(0x600b0030));
                
                /// need_des
                pub const HP_MODEM_DIG_POWER = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:20] 
                    res0:  u0, 
                    
                    /// [21:21] need_des
                    HP_MODEM_VDD_SPI_PD_EN:  u1, 
                    
                    /// [22:22] need_des
                    HP_MODEM_HP_MEM_DSLP:  u1, 
                    
                    /// [23:26] need_des
                    HP_MODEM_PD_HP_MEM_PD_EN:  u4, 
                    
                    /// [27:27] need_des
                    HP_MODEM_PD_HP_WIFI_PD_EN:  u1, 
                    
                    /// [28:28] 
                    res1:  u0, 
                    
                    /// [29:29] need_des
                    HP_MODEM_PD_HP_CPU_PD_EN:  u1, 
                    
                    /// [30:30] need_des
                    HP_MODEM_PD_HP_AON_PD_EN:  u1, 
                    
                    /// [31:31] need_des
                    HP_MODEM_PD_TOP_PD_EN:  u1, 
                    
                }), @ptrFromInt(0x600b0034));
                
                /// need_des
                pub const HP_MODEM_ICG_HP_FUNC = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] need_des
                    HP_MODEM_DIG_ICG_FUNC_EN:  u32, 
                    
                }), @ptrFromInt(0x600b0038));
                
                /// need_des
                pub const HP_MODEM_ICG_HP_APB = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] need_des
                    HP_MODEM_DIG_ICG_APB_EN:  u32, 
                    
                }), @ptrFromInt(0x600b003c));
                
                /// need_des
                pub const HP_MODEM_ICG_MODEM = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:29] 
                    res0:  u0, 
                    
                    /// [30:31] need_des
                    HP_MODEM_DIG_ICG_MODEM_CODE:  u2, 
                    
                }), @ptrFromInt(0x600b0040));
                
                /// need_des
                pub const HP_MODEM_HP_SYS_CNTL = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:23] 
                    res0:  u0, 
                    
                    /// [24:24] need_des
                    HP_MODEM_UART_WAKEUP_EN:  u1, 
                    
                    /// [25:25] need_des
                    HP_MODEM_LP_PAD_HOLD_ALL:  u1, 
                    
                    /// [26:26] need_des
                    HP_MODEM_HP_PAD_HOLD_ALL:  u1, 
                    
                    /// [27:27] need_des
                    HP_MODEM_DIG_PAD_SLP_SEL:  u1, 
                    
                    /// [28:28] need_des
                    HP_MODEM_DIG_PAUSE_WDT:  u1, 
                    
                    /// [29:29] need_des
                    HP_MODEM_DIG_CPU_STALL:  u1, 
                    
                    /// [30:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x600b0044));
                
                /// need_des
                pub const HP_MODEM_HP_CK_POWER = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:25] 
                    res0:  u0, 
                    
                    /// [26:26] need_des
                    HP_MODEM_I2C_ISO_EN:  u1, 
                    
                    /// [27:27] need_des
                    HP_MODEM_I2C_RETENTION:  u1, 
                    
                    /// [28:28] need_des
                    HP_MODEM_XPD_BB_I2C:  u1, 
                    
                    /// [29:29] need_des
                    HP_MODEM_XPD_BBPLL_I2C:  u1, 
                    
                    /// [30:30] need_des
                    HP_MODEM_XPD_BBPLL:  u1, 
                    
                    /// [31:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x600b0048));
                
                /// need_des
                pub const HP_MODEM_BIAS = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:24] 
                    res0:  u0, 
                    
                    /// [25:25] need_des
                    HP_MODEM_XPD_BIAS:  u1, 
                    
                    /// [26:29] need_des
                    HP_MODEM_DBG_ATTEN:  u4, 
                    
                    /// [30:30] need_des
                    HP_MODEM_PD_CUR:  u1, 
                    
                    /// [31:31] need_des
                    SLEEP:  u1, 
                    
                }), @ptrFromInt(0x600b004c));
                
                /// need_des
                pub const HP_MODEM_BACKUP = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:3] 
                    res0:  u0, 
                    
                    /// [4:5] need_des
                    HP_SLEEP2MODEM_BACKUP_MODEM_CLK_CODE:  u2, 
                    
                    /// [6:9] 
                    res1:  u0, 
                    
                    /// [10:10] need_des
                    HP_MODEM_RETENTION_MODE:  u1, 
                    
                    /// [11:11] need_des
                    HP_SLEEP2MODEM_RETENTION_EN:  u1, 
                    
                    /// [12:13] 
                    res2:  u0, 
                    
                    /// [14:15] need_des
                    HP_SLEEP2MODEM_BACKUP_CLK_SEL:  u2, 
                    
                    /// [16:19] 
                    res3:  u0, 
                    
                    /// [20:22] need_des
                    HP_SLEEP2MODEM_BACKUP_MODE:  u3, 
                    
                    /// [23:28] 
                    res4:  u0, 
                    
                    /// [29:29] need_des
                    HP_SLEEP2MODEM_BACKUP_EN:  u1, 
                    
                    /// [30:31] 
                    res5:  u0, 
                    
                }), @ptrFromInt(0x600b0050));
                
                /// need_des
                pub const HP_MODEM_BACKUP_CLK = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] need_des
                    HP_MODEM_BACKUP_ICG_FUNC_EN:  u32, 
                    
                }), @ptrFromInt(0x600b0054));
                
                /// need_des
                pub const HP_MODEM_SYSCLK = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:25] 
                    res0:  u0, 
                    
                    /// [26:26] need_des
                    HP_MODEM_DIG_SYS_CLK_NO_DIV:  u1, 
                    
                    /// [27:27] need_des
                    HP_MODEM_ICG_SYS_CLOCK_EN:  u1, 
                    
                    /// [28:28] need_des
                    HP_MODEM_SYS_CLK_SLP_SEL:  u1, 
                    
                    /// [29:29] need_des
                    HP_MODEM_ICG_SLP_SEL:  u1, 
                    
                    /// [30:31] need_des
                    HP_MODEM_DIG_SYS_CLK_SEL:  u2, 
                    
                }), @ptrFromInt(0x600b0058));
                
                /// need_des
                pub const HP_MODEM_HP_REGULATOR0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:15] 
                    res0:  u0, 
                    
                    /// [16:16] need_des
                    HP_MODEM_HP_REGULATOR_SLP_MEM_XPD:  u1, 
                    
                    /// [17:17] need_des
                    HP_MODEM_HP_REGULATOR_SLP_LOGIC_XPD:  u1, 
                    
                    /// [18:18] need_des
                    HP_MODEM_HP_REGULATOR_XPD:  u1, 
                    
                    /// [19:22] need_des
                    HP_MODEM_HP_REGULATOR_SLP_MEM_DBIAS:  u4, 
                    
                    /// [23:26] need_des
                    HP_MODEM_HP_REGULATOR_SLP_LOGIC_DBIAS:  u4, 
                    
                    /// [27:31] need_des
                    HP_MODEM_HP_REGULATOR_DBIAS:  u5, 
                    
                }), @ptrFromInt(0x600b005c));
                
                /// need_des
                pub const HP_MODEM_HP_REGULATOR1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] 
                    res0:  u0, 
                    
                    /// [8:31] need_des
                    HP_MODEM_HP_REGULATOR_DRV_B:  u24, 
                    
                }), @ptrFromInt(0x600b0060));
                
                /// need_des
                pub const HP_MODEM_XTAL = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:30] 
                    res0:  u0, 
                    
                    /// [31:31] need_des
                    HP_MODEM_XPD_XTAL:  u1, 
                    
                }), @ptrFromInt(0x600b0064));
                
                /// need_des
                pub const HP_SLEEP_DIG_POWER = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:20] 
                    res0:  u0, 
                    
                    /// [21:21] need_des
                    HP_SLEEP_VDD_SPI_PD_EN:  u1, 
                    
                    /// [22:22] need_des
                    HP_SLEEP_HP_MEM_DSLP:  u1, 
                    
                    /// [23:26] need_des
                    HP_SLEEP_PD_HP_MEM_PD_EN:  u4, 
                    
                    /// [27:27] need_des
                    HP_SLEEP_PD_HP_WIFI_PD_EN:  u1, 
                    
                    /// [28:28] 
                    res1:  u0, 
                    
                    /// [29:29] need_des
                    HP_SLEEP_PD_HP_CPU_PD_EN:  u1, 
                    
                    /// [30:30] need_des
                    HP_SLEEP_PD_HP_AON_PD_EN:  u1, 
                    
                    /// [31:31] need_des
                    HP_SLEEP_PD_TOP_PD_EN:  u1, 
                    
                }), @ptrFromInt(0x600b0068));
                
                /// need_des
                pub const HP_SLEEP_ICG_HP_FUNC = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] need_des
                    HP_SLEEP_DIG_ICG_FUNC_EN:  u32, 
                    
                }), @ptrFromInt(0x600b006c));
                
                /// need_des
                pub const HP_SLEEP_ICG_HP_APB = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] need_des
                    HP_SLEEP_DIG_ICG_APB_EN:  u32, 
                    
                }), @ptrFromInt(0x600b0070));
                
                /// need_des
                pub const HP_SLEEP_ICG_MODEM = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:29] 
                    res0:  u0, 
                    
                    /// [30:31] need_des
                    HP_SLEEP_DIG_ICG_MODEM_CODE:  u2, 
                    
                }), @ptrFromInt(0x600b0074));
                
                /// need_des
                pub const HP_SLEEP_HP_SYS_CNTL = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:23] 
                    res0:  u0, 
                    
                    /// [24:24] need_des
                    HP_SLEEP_UART_WAKEUP_EN:  u1, 
                    
                    /// [25:25] need_des
                    HP_SLEEP_LP_PAD_HOLD_ALL:  u1, 
                    
                    /// [26:26] need_des
                    HP_SLEEP_HP_PAD_HOLD_ALL:  u1, 
                    
                    /// [27:27] need_des
                    HP_SLEEP_DIG_PAD_SLP_SEL:  u1, 
                    
                    /// [28:28] need_des
                    HP_SLEEP_DIG_PAUSE_WDT:  u1, 
                    
                    /// [29:29] need_des
                    HP_SLEEP_DIG_CPU_STALL:  u1, 
                    
                    /// [30:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x600b0078));
                
                /// need_des
                pub const HP_SLEEP_HP_CK_POWER = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:25] 
                    res0:  u0, 
                    
                    /// [26:26] need_des
                    HP_SLEEP_I2C_ISO_EN:  u1, 
                    
                    /// [27:27] need_des
                    HP_SLEEP_I2C_RETENTION:  u1, 
                    
                    /// [28:28] need_des
                    HP_SLEEP_XPD_BB_I2C:  u1, 
                    
                    /// [29:29] need_des
                    HP_SLEEP_XPD_BBPLL_I2C:  u1, 
                    
                    /// [30:30] need_des
                    HP_SLEEP_XPD_BBPLL:  u1, 
                    
                    /// [31:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x600b007c));
                
                /// need_des
                pub const HP_SLEEP_BIAS = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:24] 
                    res0:  u0, 
                    
                    /// [25:25] need_des
                    HP_SLEEP_XPD_BIAS:  u1, 
                    
                    /// [26:29] need_des
                    HP_SLEEP_DBG_ATTEN:  u4, 
                    
                    /// [30:30] need_des
                    HP_SLEEP_PD_CUR:  u1, 
                    
                    /// [31:31] need_des
                    SLEEP:  u1, 
                    
                }), @ptrFromInt(0x600b0080));
                
                /// need_des
                pub const HP_SLEEP_BACKUP = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] 
                    res0:  u0, 
                    
                    /// [6:7] need_des
                    HP_MODEM2SLEEP_BACKUP_MODEM_CLK_CODE:  u2, 
                    
                    /// [8:9] need_des
                    HP_ACTIVE2SLEEP_BACKUP_MODEM_CLK_CODE:  u2, 
                    
                    /// [10:10] need_des
                    HP_SLEEP_RETENTION_MODE:  u1, 
                    
                    /// [11:11] 
                    res1:  u0, 
                    
                    /// [12:12] need_des
                    HP_MODEM2SLEEP_RETENTION_EN:  u1, 
                    
                    /// [13:13] need_des
                    HP_ACTIVE2SLEEP_RETENTION_EN:  u1, 
                    
                    /// [14:15] 
                    res2:  u0, 
                    
                    /// [16:17] need_des
                    HP_MODEM2SLEEP_BACKUP_CLK_SEL:  u2, 
                    
                    /// [18:19] need_des
                    HP_ACTIVE2SLEEP_BACKUP_CLK_SEL:  u2, 
                    
                    /// [20:22] 
                    res3:  u0, 
                    
                    /// [23:25] need_des
                    HP_MODEM2SLEEP_BACKUP_MODE:  u3, 
                    
                    /// [26:28] need_des
                    HP_ACTIVE2SLEEP_BACKUP_MODE:  u3, 
                    
                    /// [29:29] 
                    res4:  u0, 
                    
                    /// [30:30] need_des
                    HP_MODEM2SLEEP_BACKUP_EN:  u1, 
                    
                    /// [31:31] need_des
                    HP_ACTIVE2SLEEP_BACKUP_EN:  u1, 
                    
                }), @ptrFromInt(0x600b0084));
                
                /// need_des
                pub const HP_SLEEP_BACKUP_CLK = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] need_des
                    HP_SLEEP_BACKUP_ICG_FUNC_EN:  u32, 
                    
                }), @ptrFromInt(0x600b0088));
                
                /// need_des
                pub const HP_SLEEP_SYSCLK = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:25] 
                    res0:  u0, 
                    
                    /// [26:26] need_des
                    HP_SLEEP_DIG_SYS_CLK_NO_DIV:  u1, 
                    
                    /// [27:27] need_des
                    HP_SLEEP_ICG_SYS_CLOCK_EN:  u1, 
                    
                    /// [28:28] need_des
                    HP_SLEEP_SYS_CLK_SLP_SEL:  u1, 
                    
                    /// [29:29] need_des
                    HP_SLEEP_ICG_SLP_SEL:  u1, 
                    
                    /// [30:31] need_des
                    HP_SLEEP_DIG_SYS_CLK_SEL:  u2, 
                    
                }), @ptrFromInt(0x600b008c));
                
                /// need_des
                pub const HP_SLEEP_HP_REGULATOR0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:15] 
                    res0:  u0, 
                    
                    /// [16:16] need_des
                    HP_SLEEP_HP_REGULATOR_SLP_MEM_XPD:  u1, 
                    
                    /// [17:17] need_des
                    HP_SLEEP_HP_REGULATOR_SLP_LOGIC_XPD:  u1, 
                    
                    /// [18:18] need_des
                    HP_SLEEP_HP_REGULATOR_XPD:  u1, 
                    
                    /// [19:22] need_des
                    HP_SLEEP_HP_REGULATOR_SLP_MEM_DBIAS:  u4, 
                    
                    /// [23:26] need_des
                    HP_SLEEP_HP_REGULATOR_SLP_LOGIC_DBIAS:  u4, 
                    
                    /// [27:31] need_des
                    HP_SLEEP_HP_REGULATOR_DBIAS:  u5, 
                    
                }), @ptrFromInt(0x600b0090));
                
                /// need_des
                pub const HP_SLEEP_HP_REGULATOR1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] 
                    res0:  u0, 
                    
                    /// [8:31] need_des
                    HP_SLEEP_HP_REGULATOR_DRV_B:  u24, 
                    
                }), @ptrFromInt(0x600b0094));
                
                /// need_des
                pub const HP_SLEEP_XTAL = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:30] 
                    res0:  u0, 
                    
                    /// [31:31] need_des
                    HP_SLEEP_XPD_XTAL:  u1, 
                    
                }), @ptrFromInt(0x600b0098));
                
                /// need_des
                pub const HP_SLEEP_LP_REGULATOR0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:20] 
                    res0:  u0, 
                    
                    /// [21:21] need_des
                    HP_SLEEP_LP_REGULATOR_SLP_XPD:  u1, 
                    
                    /// [22:22] need_des
                    HP_SLEEP_LP_REGULATOR_XPD:  u1, 
                    
                    /// [23:26] need_des
                    HP_SLEEP_LP_REGULATOR_SLP_DBIAS:  u4, 
                    
                    /// [27:31] need_des
                    HP_SLEEP_LP_REGULATOR_DBIAS:  u5, 
                    
                }), @ptrFromInt(0x600b009c));
                
                /// need_des
                pub const HP_SLEEP_LP_REGULATOR1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:27] 
                    res0:  u0, 
                    
                    /// [28:31] need_des
                    HP_SLEEP_LP_REGULATOR_DRV_B:  u4, 
                    
                }), @ptrFromInt(0x600b00a0));
                
                /// need_des
                pub const HP_SLEEP_LP_DCDC_RESERVE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] need_des
                    HP_SLEEP_LP_DCDC_RESERVE:  u32, 
                    
                }), @ptrFromInt(0x600b00a4));
                
                /// need_des
                pub const HP_SLEEP_LP_DIG_POWER = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:29] 
                    res0:  u0, 
                    
                    /// [30:30] need_des
                    HP_SLEEP_LP_MEM_DSLP:  u1, 
                    
                    /// [31:31] need_des
                    HP_SLEEP_PD_LP_PERI_PD_EN:  u1, 
                    
                }), @ptrFromInt(0x600b00a8));
                
                /// need_des
                pub const HP_SLEEP_LP_CK_POWER = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:27] 
                    res0:  u0, 
                    
                    /// [28:28] need_des
                    HP_SLEEP_XPD_XTAL32K:  u1, 
                    
                    /// [29:29] need_des
                    HP_SLEEP_XPD_RC32K:  u1, 
                    
                    /// [30:30] need_des
                    HP_SLEEP_XPD_FOSC_CLK:  u1, 
                    
                    /// [31:31] need_des
                    HP_SLEEP_PD_OSC_CLK:  u1, 
                    
                }), @ptrFromInt(0x600b00ac));
                
                /// need_des
                pub const LP_SLEEP_LP_BIAS_RESERVE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] need_des
                    LP_SLEEP_LP_BIAS_RESERVE:  u32, 
                    
                }), @ptrFromInt(0x600b00b0));
                
                /// need_des
                pub const LP_SLEEP_LP_REGULATOR0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:20] 
                    res0:  u0, 
                    
                    /// [21:21] need_des
                    LP_SLEEP_LP_REGULATOR_SLP_XPD:  u1, 
                    
                    /// [22:22] need_des
                    LP_SLEEP_LP_REGULATOR_XPD:  u1, 
                    
                    /// [23:26] need_des
                    LP_SLEEP_LP_REGULATOR_SLP_DBIAS:  u4, 
                    
                    /// [27:31] need_des
                    LP_SLEEP_LP_REGULATOR_DBIAS:  u5, 
                    
                }), @ptrFromInt(0x600b00b4));
                
                /// need_des
                pub const LP_SLEEP_LP_REGULATOR1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:27] 
                    res0:  u0, 
                    
                    /// [28:31] need_des
                    LP_SLEEP_LP_REGULATOR_DRV_B:  u4, 
                    
                }), @ptrFromInt(0x600b00b8));
                
                /// need_des
                pub const LP_SLEEP_XTAL = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:30] 
                    res0:  u0, 
                    
                    /// [31:31] need_des
                    LP_SLEEP_XPD_XTAL:  u1, 
                    
                }), @ptrFromInt(0x600b00bc));
                
                /// need_des
                pub const LP_SLEEP_LP_DIG_POWER = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:29] 
                    res0:  u0, 
                    
                    /// [30:30] need_des
                    LP_SLEEP_LP_MEM_DSLP:  u1, 
                    
                    /// [31:31] need_des
                    LP_SLEEP_PD_LP_PERI_PD_EN:  u1, 
                    
                }), @ptrFromInt(0x600b00c0));
                
                /// need_des
                pub const LP_SLEEP_LP_CK_POWER = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:27] 
                    res0:  u0, 
                    
                    /// [28:28] need_des
                    LP_SLEEP_XPD_XTAL32K:  u1, 
                    
                    /// [29:29] need_des
                    LP_SLEEP_XPD_RC32K:  u1, 
                    
                    /// [30:30] need_des
                    LP_SLEEP_XPD_FOSC_CLK:  u1, 
                    
                    /// [31:31] need_des
                    LP_SLEEP_PD_OSC_CLK:  u1, 
                    
                }), @ptrFromInt(0x600b00c4));
                
                /// need_des
                pub const LP_SLEEP_BIAS = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:24] 
                    res0:  u0, 
                    
                    /// [25:25] need_des
                    LP_SLEEP_XPD_BIAS:  u1, 
                    
                    /// [26:29] need_des
                    LP_SLEEP_DBG_ATTEN:  u4, 
                    
                    /// [30:30] need_des
                    LP_SLEEP_PD_CUR:  u1, 
                    
                    /// [31:31] need_des
                    SLEEP:  u1, 
                    
                }), @ptrFromInt(0x600b00c8));
                
                /// need_des
                pub const IMM_HP_CK_POWER = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] need_des
                    TIE_LOW_GLOBAL_BBPLL_ICG:  u1, 
                    
                    /// [1:1] need_des
                    TIE_LOW_GLOBAL_XTAL_ICG:  u1, 
                    
                    /// [2:2] need_des
                    TIE_LOW_I2C_RETENTION:  u1, 
                    
                    /// [3:3] need_des
                    TIE_LOW_XPD_BB_I2C:  u1, 
                    
                    /// [4:4] need_des
                    TIE_LOW_XPD_BBPLL_I2C:  u1, 
                    
                    /// [5:5] need_des
                    TIE_LOW_XPD_BBPLL:  u1, 
                    
                    /// [6:6] need_des
                    TIE_LOW_XPD_XTAL:  u1, 
                    
                    /// [7:24] 
                    res0:  u0, 
                    
                    /// [25:25] need_des
                    TIE_HIGH_GLOBAL_BBPLL_ICG:  u1, 
                    
                    /// [26:26] need_des
                    TIE_HIGH_GLOBAL_XTAL_ICG:  u1, 
                    
                    /// [27:27] need_des
                    TIE_HIGH_I2C_RETENTION:  u1, 
                    
                    /// [28:28] need_des
                    TIE_HIGH_XPD_BB_I2C:  u1, 
                    
                    /// [29:29] need_des
                    TIE_HIGH_XPD_BBPLL_I2C:  u1, 
                    
                    /// [30:30] need_des
                    TIE_HIGH_XPD_BBPLL:  u1, 
                    
                    /// [31:31] need_des
                    TIE_HIGH_XPD_XTAL:  u1, 
                    
                }), @ptrFromInt(0x600b00cc));
                
                /// need_des
                pub const IMM_SLEEP_SYSCLK = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:27] 
                    res0:  u0, 
                    
                    /// [28:28] need_des
                    UPDATE_DIG_ICG_SWITCH:  u1, 
                    
                    /// [29:29] need_des
                    TIE_LOW_ICG_SLP_SEL:  u1, 
                    
                    /// [30:30] need_des
                    TIE_HIGH_ICG_SLP_SEL:  u1, 
                    
                    /// [31:31] need_des
                    UPDATE_DIG_SYS_CLK_SEL:  u1, 
                    
                }), @ptrFromInt(0x600b00d0));
                
                /// need_des
                pub const IMM_HP_FUNC_ICG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:30] 
                    res0:  u0, 
                    
                    /// [31:31] need_des
                    UPDATE_DIG_ICG_FUNC_EN:  u1, 
                    
                }), @ptrFromInt(0x600b00d4));
                
                /// need_des
                pub const IMM_HP_APB_ICG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:30] 
                    res0:  u0, 
                    
                    /// [31:31] need_des
                    UPDATE_DIG_ICG_APB_EN:  u1, 
                    
                }), @ptrFromInt(0x600b00d8));
                
                /// need_des
                pub const IMM_MODEM_ICG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:30] 
                    res0:  u0, 
                    
                    /// [31:31] need_des
                    UPDATE_DIG_ICG_MODEM_EN:  u1, 
                    
                }), @ptrFromInt(0x600b00dc));
                
                /// need_des
                pub const IMM_LP_ICG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:29] 
                    res0:  u0, 
                    
                    /// [30:30] need_des
                    TIE_LOW_LP_ROOTCLK_SEL:  u1, 
                    
                    /// [31:31] need_des
                    TIE_HIGH_LP_ROOTCLK_SEL:  u1, 
                    
                }), @ptrFromInt(0x600b00e0));
                
                /// need_des
                pub const IMM_PAD_HOLD_ALL = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:27] 
                    res0:  u0, 
                    
                    /// [28:28] need_des
                    TIE_HIGH_LP_PAD_HOLD_ALL:  u1, 
                    
                    /// [29:29] need_des
                    TIE_LOW_LP_PAD_HOLD_ALL:  u1, 
                    
                    /// [30:30] need_des
                    TIE_HIGH_HP_PAD_HOLD_ALL:  u1, 
                    
                    /// [31:31] need_des
                    TIE_LOW_HP_PAD_HOLD_ALL:  u1, 
                    
                }), @ptrFromInt(0x600b00e4));
                
                /// need_des
                pub const IMM_I2C_ISO = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:29] 
                    res0:  u0, 
                    
                    /// [30:30] need_des
                    TIE_HIGH_I2C_ISO_EN:  u1, 
                    
                    /// [31:31] need_des
                    TIE_LOW_I2C_ISO_EN:  u1, 
                    
                }), @ptrFromInt(0x600b00e8));
                
                /// need_des
                pub const POWER_WAIT_TIMER0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:4] 
                    res0:  u0, 
                    
                    /// [5:13] need_des
                    DG_HP_POWERDOWN_TIMER:  u9, 
                    
                    /// [14:22] need_des
                    DG_HP_POWERUP_TIMER:  u9, 
                    
                    /// [23:31] need_des
                    DG_HP_WAIT_TIMER:  u9, 
                    
                }), @ptrFromInt(0x600b00ec));
                
                /// need_des
                pub const POWER_WAIT_TIMER1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:8] 
                    res0:  u0, 
                    
                    /// [9:15] need_des
                    DG_LP_POWERDOWN_TIMER:  u7, 
                    
                    /// [16:22] need_des
                    DG_LP_POWERUP_TIMER:  u7, 
                    
                    /// [23:31] need_des
                    DG_LP_WAIT_TIMER:  u9, 
                    
                }), @ptrFromInt(0x600b00f0));
                
                /// need_des
                pub const POWER_PD_TOP_CNTL = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] need_des
                    FORCE_TOP_RESET:  u1, 
                    
                    /// [1:1] need_des
                    FORCE_TOP_ISO:  u1, 
                    
                    /// [2:2] need_des
                    FORCE_TOP_PU:  u1, 
                    
                    /// [3:3] need_des
                    FORCE_TOP_NO_RESET:  u1, 
                    
                    /// [4:4] need_des
                    FORCE_TOP_NO_ISO:  u1, 
                    
                    /// [5:5] need_des
                    FORCE_TOP_PD:  u1, 
                    
                    /// [6:10] need_des
                    PD_TOP_MASK:  u5, 
                    
                    /// [11:26] 
                    res0:  u0, 
                    
                    /// [27:31] need_des
                    PD_TOP_PD_MASK:  u5, 
                    
                }), @ptrFromInt(0x600b00f4));
                
                /// need_des
                pub const POWER_PD_HPAON_CNTL = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] need_des
                    FORCE_HP_AON_RESET:  u1, 
                    
                    /// [1:1] need_des
                    FORCE_HP_AON_ISO:  u1, 
                    
                    /// [2:2] need_des
                    FORCE_HP_AON_PU:  u1, 
                    
                    /// [3:3] need_des
                    FORCE_HP_AON_NO_RESET:  u1, 
                    
                    /// [4:4] need_des
                    FORCE_HP_AON_NO_ISO:  u1, 
                    
                    /// [5:5] need_des
                    FORCE_HP_AON_PD:  u1, 
                    
                    /// [6:10] need_des
                    PD_HP_AON_MASK:  u5, 
                    
                    /// [11:26] 
                    res0:  u0, 
                    
                    /// [27:31] need_des
                    PD_HP_AON_PD_MASK:  u5, 
                    
                }), @ptrFromInt(0x600b00f8));
                
                /// need_des
                pub const POWER_PD_HPCPU_CNTL = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] need_des
                    FORCE_HP_CPU_RESET:  u1, 
                    
                    /// [1:1] need_des
                    FORCE_HP_CPU_ISO:  u1, 
                    
                    /// [2:2] need_des
                    FORCE_HP_CPU_PU:  u1, 
                    
                    /// [3:3] need_des
                    FORCE_HP_CPU_NO_RESET:  u1, 
                    
                    /// [4:4] need_des
                    FORCE_HP_CPU_NO_ISO:  u1, 
                    
                    /// [5:5] need_des
                    FORCE_HP_CPU_PD:  u1, 
                    
                    /// [6:10] need_des
                    PD_HP_CPU_MASK:  u5, 
                    
                    /// [11:26] 
                    res0:  u0, 
                    
                    /// [27:31] need_des
                    PD_HP_CPU_PD_MASK:  u5, 
                    
                }), @ptrFromInt(0x600b00fc));
                
                /// need_des
                pub const POWER_PD_HPPERI_RESERVE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] need_des
                    HP_PERI_RESERVE:  u32, 
                    
                }), @ptrFromInt(0x600b0100));
                
                /// need_des
                pub const POWER_PD_HPWIFI_CNTL = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] need_des
                    FORCE_HP_WIFI_RESET:  u1, 
                    
                    /// [1:1] need_des
                    FORCE_HP_WIFI_ISO:  u1, 
                    
                    /// [2:2] need_des
                    FORCE_HP_WIFI_PU:  u1, 
                    
                    /// [3:3] need_des
                    FORCE_HP_WIFI_NO_RESET:  u1, 
                    
                    /// [4:4] need_des
                    FORCE_HP_WIFI_NO_ISO:  u1, 
                    
                    /// [5:5] need_des
                    FORCE_HP_WIFI_PD:  u1, 
                    
                    /// [6:10] need_des
                    PD_HP_WIFI_MASK:  u5, 
                    
                    /// [11:26] 
                    res0:  u0, 
                    
                    /// [27:31] need_des
                    PD_HP_WIFI_PD_MASK:  u5, 
                    
                }), @ptrFromInt(0x600b0104));
                
                /// need_des
                pub const POWER_PD_LPPERI_CNTL = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] need_des
                    FORCE_LP_PERI_RESET:  u1, 
                    
                    /// [1:1] need_des
                    FORCE_LP_PERI_ISO:  u1, 
                    
                    /// [2:2] need_des
                    FORCE_LP_PERI_PU:  u1, 
                    
                    /// [3:3] need_des
                    FORCE_LP_PERI_NO_RESET:  u1, 
                    
                    /// [4:4] need_des
                    FORCE_LP_PERI_NO_ISO:  u1, 
                    
                    /// [5:5] need_des
                    FORCE_LP_PERI_PD:  u1, 
                    
                    /// [6:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600b0108));
                
                /// need_des
                pub const POWER_PD_MEM_CNTL = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:3] need_des
                    FORCE_HP_MEM_ISO:  u4, 
                    
                    /// [4:7] need_des
                    FORCE_HP_MEM_PD:  u4, 
                    
                    /// [8:23] 
                    res0:  u0, 
                    
                    /// [24:27] need_des
                    FORCE_HP_MEM_NO_ISO:  u4, 
                    
                    /// [28:31] need_des
                    FORCE_HP_MEM_PU:  u4, 
                    
                }), @ptrFromInt(0x600b010c));
                
                /// need_des
                pub const POWER_PD_MEM_MASK = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:4] need_des
                    PD_HP_MEM2_PD_MASK:  u5, 
                    
                    /// [5:9] need_des
                    PD_HP_MEM1_PD_MASK:  u5, 
                    
                    /// [10:14] need_des
                    PD_HP_MEM0_PD_MASK:  u5, 
                    
                    /// [15:16] 
                    res0:  u0, 
                    
                    /// [17:21] need_des
                    PD_HP_MEM2_MASK:  u5, 
                    
                    /// [22:26] need_des
                    PD_HP_MEM1_MASK:  u5, 
                    
                    /// [27:31] need_des
                    PD_HP_MEM0_MASK:  u5, 
                    
                }), @ptrFromInt(0x600b0110));
                
                /// need_des
                pub const POWER_HP_PAD = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] need_des
                    FORCE_HP_PAD_NO_ISO_ALL:  u1, 
                    
                    /// [1:1] need_des
                    FORCE_HP_PAD_ISO_ALL:  u1, 
                    
                    /// [2:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600b0114));
                
                /// need_des
                pub const POWER_VDD_SPI_CNTL = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:17] 
                    res0:  u0, 
                    
                    /// [18:28] need_des
                    VDD_SPI_PWR_WAIT:  u11, 
                    
                    /// [29:30] need_des
                    VDD_SPI_PWR_SW:  u2, 
                    
                    /// [31:31] need_des
                    VDD_SPI_PWR_SEL_SW:  u1, 
                    
                }), @ptrFromInt(0x600b0118));
                
                /// need_des
                pub const POWER_CK_WAIT_CNTL = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:15] need_des
                    WAIT_XTL_STABLE:  u16, 
                    
                    /// [16:31] need_des
                    WAIT_PLL_STABLE:  u16, 
                    
                }), @ptrFromInt(0x600b011c));
                
                /// need_des
                pub const SLP_WAKEUP_CNTL0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:30] 
                    res0:  u0, 
                    
                    /// [31:31] need_des
                    SLEEP_REQ:  u1, 
                    
                }), @ptrFromInt(0x600b0120));
                
                /// need_des
                pub const SLP_WAKEUP_CNTL1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:30] need_des
                    SLEEP_REJECT_ENA:  u31, 
                    
                    /// [31:31] need_des
                    SLP_REJECT_EN:  u1, 
                    
                }), @ptrFromInt(0x600b0124));
                
                /// need_des
                pub const SLP_WAKEUP_CNTL2 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] need_des
                    WAKEUP_ENA:  u32, 
                    
                }), @ptrFromInt(0x600b0128));
                
                /// need_des
                pub const SLP_WAKEUP_CNTL3 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] need_des
                    LP_MIN_SLP_VAL:  u8, 
                    
                    /// [8:15] need_des
                    HP_MIN_SLP_VAL:  u8, 
                    
                    /// [16:17] need_des
                    SLEEP_PRT_SEL:  u2, 
                    
                    /// [18:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600b012c));
                
                /// need_des
                pub const SLP_WAKEUP_CNTL4 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:30] 
                    res0:  u0, 
                    
                    /// [31:31] need_des
                    SLP_REJECT_CAUSE_CLR:  u1, 
                    
                }), @ptrFromInt(0x600b0130));
                
                /// need_des
                pub const SLP_WAKEUP_CNTL5 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:19] need_des
                    MODEM_WAIT_TARGET:  u20, 
                    
                    /// [20:23] 
                    res0:  u0, 
                    
                    /// [24:31] need_des
                    LP_ANA_WAIT_TARGET:  u8, 
                    
                }), @ptrFromInt(0x600b0134));
                
                /// need_des
                pub const SLP_WAKEUP_CNTL6 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:19] need_des
                    SOC_WAKEUP_WAIT:  u20, 
                    
                    /// [20:29] 
                    res0:  u0, 
                    
                    /// [30:31] need_des
                    SOC_WAKEUP_WAIT_CFG:  u2, 
                    
                }), @ptrFromInt(0x600b0138));
                
                /// need_des
                pub const SLP_WAKEUP_CNTL7 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:15] 
                    res0:  u0, 
                    
                    /// [16:31] need_des
                    ANA_WAIT_TARGET:  u16, 
                    
                }), @ptrFromInt(0x600b013c));
                
                /// need_des
                pub const SLP_WAKEUP_STATUS0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] need_des
                    WAKEUP_CAUSE:  u32, 
                    
                }), @ptrFromInt(0x600b0140));
                
                /// need_des
                pub const SLP_WAKEUP_STATUS1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] need_des
                    REJECT_CAUSE:  u32, 
                    
                }), @ptrFromInt(0x600b0144));
                
                /// need_des
                pub const HP_CK_POWERON = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] need_des
                    I2C_POR_WAIT_TARGET:  u8, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600b0148));
                
                /// need_des
                pub const HP_CK_CNTL = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] need_des
                    MODIFY_ICG_CNTL_WAIT:  u8, 
                    
                    /// [8:15] need_des
                    SWITCH_ICG_CNTL_WAIT:  u8, 
                    
                    /// [16:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600b014c));
                
                /// need_des
                pub const POR_STATUS = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:30] 
                    res0:  u0, 
                    
                    /// [31:31] need_des
                    POR_DONE:  u1, 
                    
                }), @ptrFromInt(0x600b0150));
                
                /// need_des
                pub const RF_PWC = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:25] 
                    res0:  u0, 
                    
                    /// [26:26] need_des
                    PERIF_I2C_RSTB:  u1, 
                    
                    /// [27:27] need_des
                    XPD_PERIF_I2C:  u1, 
                    
                    /// [28:28] need_des
                    XPD_TXRF_I2C:  u1, 
                    
                    /// [29:29] need_des
                    XPD_RFRX_PBUS:  u1, 
                    
                    /// [30:30] need_des
                    XPD_CKGEN_I2C:  u1, 
                    
                    /// [31:31] need_des
                    XPD_PLL_I2C:  u1, 
                    
                }), @ptrFromInt(0x600b0154));
                
                /// need_des
                pub const BACKUP_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:30] 
                    res0:  u0, 
                    
                    /// [31:31] need_des
                    BACKUP_SYS_CLK_NO_DIV:  u1, 
                    
                }), @ptrFromInt(0x600b0158));
                
                /// need_des
                pub const INT_RAW = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:26] 
                    res0:  u0, 
                    
                    /// [27:27] need_des
                    LP_CPU_EXC_INT_RAW:  u1, 
                    
                    /// [28:28] need_des
                    SDIO_IDLE_INT_RAW:  u1, 
                    
                    /// [29:29] need_des
                    SW_INT_RAW:  u1, 
                    
                    /// [30:30] need_des
                    SOC_SLEEP_REJECT_INT_RAW:  u1, 
                    
                    /// [31:31] need_des
                    SOC_WAKEUP_INT_RAW:  u1, 
                    
                }), @ptrFromInt(0x600b015c));
                
                /// need_des
                pub const HP_INT_ST = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:26] 
                    res0:  u0, 
                    
                    /// [27:27] need_des
                    LP_CPU_EXC_INT_ST:  u1, 
                    
                    /// [28:28] need_des
                    SDIO_IDLE_INT_ST:  u1, 
                    
                    /// [29:29] need_des
                    SW_INT_ST:  u1, 
                    
                    /// [30:30] need_des
                    SOC_SLEEP_REJECT_INT_ST:  u1, 
                    
                    /// [31:31] need_des
                    SOC_WAKEUP_INT_ST:  u1, 
                    
                }), @ptrFromInt(0x600b0160));
                
                /// need_des
                pub const HP_INT_ENA = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:26] 
                    res0:  u0, 
                    
                    /// [27:27] need_des
                    LP_CPU_EXC_INT_ENA:  u1, 
                    
                    /// [28:28] need_des
                    SDIO_IDLE_INT_ENA:  u1, 
                    
                    /// [29:29] need_des
                    SW_INT_ENA:  u1, 
                    
                    /// [30:30] need_des
                    SOC_SLEEP_REJECT_INT_ENA:  u1, 
                    
                    /// [31:31] need_des
                    SOC_WAKEUP_INT_ENA:  u1, 
                    
                }), @ptrFromInt(0x600b0164));
                
                /// need_des
                pub const HP_INT_CLR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:26] 
                    res0:  u0, 
                    
                    /// [27:27] need_des
                    LP_CPU_EXC_INT_CLR:  u1, 
                    
                    /// [28:28] need_des
                    SDIO_IDLE_INT_CLR:  u1, 
                    
                    /// [29:29] need_des
                    SW_INT_CLR:  u1, 
                    
                    /// [30:30] need_des
                    SOC_SLEEP_REJECT_INT_CLR:  u1, 
                    
                    /// [31:31] need_des
                    SOC_WAKEUP_INT_CLR:  u1, 
                    
                }), @ptrFromInt(0x600b0168));
                
                /// need_des
                pub const LP_INT_RAW = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:19] 
                    res0:  u0, 
                    
                    /// [20:20] need_des
                    LP_CPU_WAKEUP_INT_RAW:  u1, 
                    
                    /// [21:21] need_des
                    MODEM_SWITCH_ACTIVE_END_INT_RAW:  u1, 
                    
                    /// [22:22] need_des
                    SLEEP_SWITCH_ACTIVE_END_INT_RAW:  u1, 
                    
                    /// [23:23] need_des
                    SLEEP_SWITCH_MODEM_END_INT_RAW:  u1, 
                    
                    /// [24:24] need_des
                    MODEM_SWITCH_SLEEP_END_INT_RAW:  u1, 
                    
                    /// [25:25] need_des
                    ACTIVE_SWITCH_SLEEP_END_INT_RAW:  u1, 
                    
                    /// [26:26] need_des
                    MODEM_SWITCH_ACTIVE_START_INT_RAW:  u1, 
                    
                    /// [27:27] need_des
                    SLEEP_SWITCH_ACTIVE_START_INT_RAW:  u1, 
                    
                    /// [28:28] need_des
                    SLEEP_SWITCH_MODEM_START_INT_RAW:  u1, 
                    
                    /// [29:29] need_des
                    MODEM_SWITCH_SLEEP_START_INT_RAW:  u1, 
                    
                    /// [30:30] need_des
                    ACTIVE_SWITCH_SLEEP_START_INT_RAW:  u1, 
                    
                    /// [31:31] need_des
                    HP_SW_TRIGGER_INT_RAW:  u1, 
                    
                }), @ptrFromInt(0x600b016c));
                
                /// need_des
                pub const LP_INT_ST = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:19] 
                    res0:  u0, 
                    
                    /// [20:20] need_des
                    LP_CPU_WAKEUP_INT_ST:  u1, 
                    
                    /// [21:21] need_des
                    MODEM_SWITCH_ACTIVE_END_INT_ST:  u1, 
                    
                    /// [22:22] need_des
                    SLEEP_SWITCH_ACTIVE_END_INT_ST:  u1, 
                    
                    /// [23:23] need_des
                    SLEEP_SWITCH_MODEM_END_INT_ST:  u1, 
                    
                    /// [24:24] need_des
                    MODEM_SWITCH_SLEEP_END_INT_ST:  u1, 
                    
                    /// [25:25] need_des
                    ACTIVE_SWITCH_SLEEP_END_INT_ST:  u1, 
                    
                    /// [26:26] need_des
                    MODEM_SWITCH_ACTIVE_START_INT_ST:  u1, 
                    
                    /// [27:27] need_des
                    SLEEP_SWITCH_ACTIVE_START_INT_ST:  u1, 
                    
                    /// [28:28] need_des
                    SLEEP_SWITCH_MODEM_START_INT_ST:  u1, 
                    
                    /// [29:29] need_des
                    MODEM_SWITCH_SLEEP_START_INT_ST:  u1, 
                    
                    /// [30:30] need_des
                    ACTIVE_SWITCH_SLEEP_START_INT_ST:  u1, 
                    
                    /// [31:31] need_des
                    HP_SW_TRIGGER_INT_ST:  u1, 
                    
                }), @ptrFromInt(0x600b0170));
                
                /// need_des
                pub const LP_INT_ENA = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:19] 
                    res0:  u0, 
                    
                    /// [20:20] need_des
                    LP_CPU_WAKEUP_INT_ENA:  u1, 
                    
                    /// [21:21] need_des
                    MODEM_SWITCH_ACTIVE_END_INT_ENA:  u1, 
                    
                    /// [22:22] need_des
                    SLEEP_SWITCH_ACTIVE_END_INT_ENA:  u1, 
                    
                    /// [23:23] need_des
                    SLEEP_SWITCH_MODEM_END_INT_ENA:  u1, 
                    
                    /// [24:24] need_des
                    MODEM_SWITCH_SLEEP_END_INT_ENA:  u1, 
                    
                    /// [25:25] need_des
                    ACTIVE_SWITCH_SLEEP_END_INT_ENA:  u1, 
                    
                    /// [26:26] need_des
                    MODEM_SWITCH_ACTIVE_START_INT_ENA:  u1, 
                    
                    /// [27:27] need_des
                    SLEEP_SWITCH_ACTIVE_START_INT_ENA:  u1, 
                    
                    /// [28:28] need_des
                    SLEEP_SWITCH_MODEM_START_INT_ENA:  u1, 
                    
                    /// [29:29] need_des
                    MODEM_SWITCH_SLEEP_START_INT_ENA:  u1, 
                    
                    /// [30:30] need_des
                    ACTIVE_SWITCH_SLEEP_START_INT_ENA:  u1, 
                    
                    /// [31:31] need_des
                    HP_SW_TRIGGER_INT_ENA:  u1, 
                    
                }), @ptrFromInt(0x600b0174));
                
                /// need_des
                pub const LP_INT_CLR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:19] 
                    res0:  u0, 
                    
                    /// [20:20] need_des
                    LP_CPU_WAKEUP_INT_CLR:  u1, 
                    
                    /// [21:21] need_des
                    MODEM_SWITCH_ACTIVE_END_INT_CLR:  u1, 
                    
                    /// [22:22] need_des
                    SLEEP_SWITCH_ACTIVE_END_INT_CLR:  u1, 
                    
                    /// [23:23] need_des
                    SLEEP_SWITCH_MODEM_END_INT_CLR:  u1, 
                    
                    /// [24:24] need_des
                    MODEM_SWITCH_SLEEP_END_INT_CLR:  u1, 
                    
                    /// [25:25] need_des
                    ACTIVE_SWITCH_SLEEP_END_INT_CLR:  u1, 
                    
                    /// [26:26] need_des
                    MODEM_SWITCH_ACTIVE_START_INT_CLR:  u1, 
                    
                    /// [27:27] need_des
                    SLEEP_SWITCH_ACTIVE_START_INT_CLR:  u1, 
                    
                    /// [28:28] need_des
                    SLEEP_SWITCH_MODEM_START_INT_CLR:  u1, 
                    
                    /// [29:29] need_des
                    MODEM_SWITCH_SLEEP_START_INT_CLR:  u1, 
                    
                    /// [30:30] need_des
                    ACTIVE_SWITCH_SLEEP_START_INT_CLR:  u1, 
                    
                    /// [31:31] need_des
                    HP_SW_TRIGGER_INT_CLR:  u1, 
                    
                }), @ptrFromInt(0x600b0178));
                
                /// need_des
                pub const LP_CPU_PWR0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] need_des
                    LP_CPU_WAITI_RDY:  u1, 
                    
                    /// [1:1] need_des
                    LP_CPU_STALL_RDY:  u1, 
                    
                    /// [2:17] 
                    res0:  u0, 
                    
                    /// [18:18] need_des
                    LP_CPU_FORCE_STALL:  u1, 
                    
                    /// [19:19] need_des
                    LP_CPU_SLP_WAITI_FLAG_EN:  u1, 
                    
                    /// [20:20] need_des
                    LP_CPU_SLP_STALL_FLAG_EN:  u1, 
                    
                    /// [21:28] need_des
                    LP_CPU_SLP_STALL_WAIT:  u8, 
                    
                    /// [29:29] need_des
                    LP_CPU_SLP_STALL_EN:  u1, 
                    
                    /// [30:30] need_des
                    LP_CPU_SLP_RESET_EN:  u1, 
                    
                    /// [31:31] need_des
                    LP_CPU_SLP_BYPASS_INTR_EN:  u1, 
                    
                }), @ptrFromInt(0x600b017c));
                
                /// need_des
                pub const LP_CPU_PWR1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:15] need_des
                    LP_CPU_WAKEUP_EN:  u16, 
                    
                    /// [16:30] 
                    res0:  u0, 
                    
                    /// [31:31] need_des
                    LP_CPU_SLEEP_REQ:  u1, 
                    
                }), @ptrFromInt(0x600b0180));
                
                /// need_des
                pub const HP_LP_CPU_COMM = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:29] 
                    res0:  u0, 
                    
                    /// [30:30] need_des
                    LP_TRIGGER_HP:  u1, 
                    
                    /// [31:31] need_des
                    HP_TRIGGER_LP:  u1, 
                    
                }), @ptrFromInt(0x600b0184));
                
                /// need_des
                pub const HP_REGULATOR_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:30] 
                    res0:  u0, 
                    
                    /// [31:31] need_des
                    DIG_REGULATOR_EN_CAL:  u1, 
                    
                }), @ptrFromInt(0x600b0188));
                
                /// need_des
                pub const MAIN_STATE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:10] 
                    res0:  u0, 
                    
                    /// [11:17] need_des
                    MAIN_LAST_ST_STATE:  u7, 
                    
                    /// [18:24] need_des
                    MAIN_TAR_ST_STATE:  u7, 
                    
                    /// [25:31] need_des
                    MAIN_CUR_ST_STATE:  u7, 
                    
                }), @ptrFromInt(0x600b018c));
                
                /// need_des
                pub const PWR_STATE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:12] 
                    res0:  u0, 
                    
                    /// [13:17] need_des
                    BACKUP_ST_STATE:  u5, 
                    
                    /// [18:22] need_des
                    LP_PWR_ST_STATE:  u5, 
                    
                    /// [23:31] need_des
                    HP_PWR_ST_STATE:  u9, 
                    
                }), @ptrFromInt(0x600b0190));
                
                /// need_des
                pub const CLK_STATE0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] need_des
                    STABLE_XPD_BBPLL_STATE:  u1, 
                    
                    /// [1:1] need_des
                    STABLE_XPD_XTAL_STATE:  u1, 
                    
                    /// [2:14] 
                    res0:  u0, 
                    
                    /// [15:15] need_des
                    SYS_CLK_SLP_SEL_STATE:  u1, 
                    
                    /// [16:17] need_des
                    SYS_CLK_SEL_STATE:  u2, 
                    
                    /// [18:18] need_des
                    SYS_CLK_NO_DIV_STATE:  u1, 
                    
                    /// [19:19] need_des
                    ICG_SYS_CLK_EN_STATE:  u1, 
                    
                    /// [20:20] need_des
                    ICG_MODEM_SWITCH_STATE:  u1, 
                    
                    /// [21:22] need_des
                    ICG_MODEM_CODE_STATE:  u2, 
                    
                    /// [23:23] need_des
                    ICG_SLP_SEL_STATE:  u1, 
                    
                    /// [24:24] need_des
                    ICG_GLOBAL_XTAL_STATE:  u1, 
                    
                    /// [25:25] need_des
                    ICG_GLOBAL_PLL_STATE:  u1, 
                    
                    /// [26:26] need_des
                    ANA_I2C_ISO_EN_STATE:  u1, 
                    
                    /// [27:27] need_des
                    ANA_I2C_RETENTION_STATE:  u1, 
                    
                    /// [28:28] need_des
                    ANA_XPD_BB_I2C_STATE:  u1, 
                    
                    /// [29:29] need_des
                    ANA_XPD_BBPLL_I2C_STATE:  u1, 
                    
                    /// [30:30] need_des
                    ANA_XPD_BBPLL_STATE:  u1, 
                    
                    /// [31:31] need_des
                    ANA_XPD_XTAL_STATE:  u1, 
                    
                }), @ptrFromInt(0x600b0194));
                
                /// need_des
                pub const CLK_STATE1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] need_des
                    ICG_FUNC_EN_STATE:  u32, 
                    
                }), @ptrFromInt(0x600b0198));
                
                /// need_des
                pub const CLK_STATE2 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] need_des
                    ICG_APB_EN_STATE:  u32, 
                    
                }), @ptrFromInt(0x600b019c));
                
                /// need_des
                pub const VDD_SPI_STATUS = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:30] 
                    res0:  u0, 
                    
                    /// [31:31] need_des
                    STABLE_VDD_SPI_PWR_DRV:  u1, 
                    
                }), @ptrFromInt(0x600b01a0));
                
                /// need_des
                pub const DATE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:30] need_des
                    PMU_DATE:  u31, 
                    
                    /// [31:31] need_des
                    CLK_EN:  u1, 
                    
                }), @ptrFromInt(0x600b03fc));
                
            };
            
            /// Remote Control
            pub const RMT = struct {
                
                /// The read and writedata register for CHANNEL%s by apb fifo access.
                pub const CH0DATA = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Read and write data for channel %s via APB FIFO.
                    DATA:  u32, 
                    
                }), @ptrFromInt(0x60006000));
                
                /// The read and writedata register for CHANNEL%s by apb fifo access.
                pub const CH0DATA = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Read and write data for channel %s via APB FIFO.
                    DATA:  u32, 
                    
                }), @ptrFromInt(0x60006004));
                
                /// The read and writedata register for CHANNEL%s by apb fifo access.
                pub const CH0DATA = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Read and write data for channel %s via APB FIFO.
                    DATA:  u32, 
                    
                }), @ptrFromInt(0x60006008));
                
                /// The read and writedata register for CHANNEL%s by apb fifo access.
                pub const CH0DATA = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Read and write data for channel %s via APB FIFO.
                    DATA:  u32, 
                    
                }), @ptrFromInt(0x6000600c));
                
                /// Channel %s configure register 0
                pub const CH0_TX_CONF0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Set this bit to start sending data on CHANNEL%s.
                    TX_START:  u1, 
                    
                    /// [1:1] Set this bit to reset read ram address for CHANNEL%s by accessing transmitter.
                    MEM_RD_RST:  u1, 
                    
                    /// [2:2] Set this bit to reset W/R ram address for CHANNEL%s by accessing apb fifo.
                    APB_MEM_RST:  u1, 
                    
                    /// [3:3] Set this bit to restart transmissionfrom the first data to the last data in CHANNEL%s.
                    TX_CONTI_MODE:  u1, 
                    
                    /// [4:4] This is the channel %s enable bit for wraparound mode: it will resume sending at the start when the data to be sent is more than its memory size.
                    MEM_TX_WRAP_EN:  u1, 
                    
                    /// [5:5] This bit configures the level of output signal in CHANNEL%s when the latter is in IDLE state.
                    IDLE_OUT_LV:  u1, 
                    
                    /// [6:6] This is the output enable-control bit for CHANNEL%s in IDLE state.
                    IDLE_OUT_EN:  u1, 
                    
                    /// [7:7] Set this bit to stop the transmitter of CHANNEL%s sending data out.
                    TX_STOP:  u1, 
                    
                    /// [8:15] This register is used to configure the divider for clock of CHANNEL%s.
                    DIV_CNT:  u8, 
                    
                    /// [16:18] This register is used to configure the maximum size of memory allocated to CHANNEL%s.
                    MEM_SIZE:  u3, 
                    
                    /// [19:19] 
                    res0:  u0, 
                    
                    /// [20:20] 1: Add carrier modulation on the output signal only at the send data state for CHANNEL%s. 0: Add carrier modulation on the output signal at all state for CHANNEL%s. Only valid when RMT_CARRIER_EN_CH%s is 1.
                    CARRIER_EFF_EN:  u1, 
                    
                    /// [21:21] This is the carrier modulation enable-control bit for CHANNEL%s. 1: Add carrier modulation in the output signal. 0: No carrier modulation in sig_out.
                    CARRIER_EN:  u1, 
                    
                    /// [22:22] This bit is used to configure the position of carrier wave for CHANNEL%s.1'h0: add carrier wave on low level.1'h1: add carrier wave on high level.
                    CARRIER_OUT_LV:  u1, 
                    
                    /// [23:23] Reserved
                    AFIFO_RST:  u1, 
                    
                    /// [24:24] synchronization bit for CHANNEL%s
                    CONF_UPDATE:  u1, 
                    
                    /// [25:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x60006010));
                
                /// Channel %s configure register 0
                pub const CH0_TX_CONF0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Set this bit to start sending data on CHANNEL%s.
                    TX_START:  u1, 
                    
                    /// [1:1] Set this bit to reset read ram address for CHANNEL%s by accessing transmitter.
                    MEM_RD_RST:  u1, 
                    
                    /// [2:2] Set this bit to reset W/R ram address for CHANNEL%s by accessing apb fifo.
                    APB_MEM_RST:  u1, 
                    
                    /// [3:3] Set this bit to restart transmissionfrom the first data to the last data in CHANNEL%s.
                    TX_CONTI_MODE:  u1, 
                    
                    /// [4:4] This is the channel %s enable bit for wraparound mode: it will resume sending at the start when the data to be sent is more than its memory size.
                    MEM_TX_WRAP_EN:  u1, 
                    
                    /// [5:5] This bit configures the level of output signal in CHANNEL%s when the latter is in IDLE state.
                    IDLE_OUT_LV:  u1, 
                    
                    /// [6:6] This is the output enable-control bit for CHANNEL%s in IDLE state.
                    IDLE_OUT_EN:  u1, 
                    
                    /// [7:7] Set this bit to stop the transmitter of CHANNEL%s sending data out.
                    TX_STOP:  u1, 
                    
                    /// [8:15] This register is used to configure the divider for clock of CHANNEL%s.
                    DIV_CNT:  u8, 
                    
                    /// [16:18] This register is used to configure the maximum size of memory allocated to CHANNEL%s.
                    MEM_SIZE:  u3, 
                    
                    /// [19:19] 
                    res0:  u0, 
                    
                    /// [20:20] 1: Add carrier modulation on the output signal only at the send data state for CHANNEL%s. 0: Add carrier modulation on the output signal at all state for CHANNEL%s. Only valid when RMT_CARRIER_EN_CH%s is 1.
                    CARRIER_EFF_EN:  u1, 
                    
                    /// [21:21] This is the carrier modulation enable-control bit for CHANNEL%s. 1: Add carrier modulation in the output signal. 0: No carrier modulation in sig_out.
                    CARRIER_EN:  u1, 
                    
                    /// [22:22] This bit is used to configure the position of carrier wave for CHANNEL%s.1'h0: add carrier wave on low level.1'h1: add carrier wave on high level.
                    CARRIER_OUT_LV:  u1, 
                    
                    /// [23:23] Reserved
                    AFIFO_RST:  u1, 
                    
                    /// [24:24] synchronization bit for CHANNEL%s
                    CONF_UPDATE:  u1, 
                    
                    /// [25:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x60006014));
                
                /// Channel %s configure register 0
                pub const CH0_RX_CONF0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] This register is used to configure the divider for clock of CHANNEL%s.
                    DIV_CNT:  u8, 
                    
                    /// [8:22] When no edge is detected on the input signal and continuous clock cycles is longer than this register value, received process is finished.
                    IDLE_THRES:  u15, 
                    
                    /// [23:25] This register is used to configure the maximum size of memory allocated to CHANNEL%s.
                    MEM_SIZE:  u3, 
                    
                    /// [26:27] 
                    res0:  u0, 
                    
                    /// [28:28] This is the carrier modulation enable-control bit for CHANNEL%s. 1: Add carrier modulation in the output signal. 0: No carrier modulation in sig_out.
                    CARRIER_EN:  u1, 
                    
                    /// [29:29] This bit is used to configure the position of carrier wave for CHANNEL%s.1'h0: add carrier wave on low level.1'h1: add carrier wave on high level.
                    CARRIER_OUT_LV:  u1, 
                    
                    /// [30:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x60006018));
                
                /// Channel %s configure register 0
                pub const CH0_RX_CONF0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] This register is used to configure the divider for clock of CHANNEL%s.
                    DIV_CNT:  u8, 
                    
                    /// [8:22] When no edge is detected on the input signal and continuous clock cycles is longer than this register value, received process is finished.
                    IDLE_THRES:  u15, 
                    
                    /// [23:25] This register is used to configure the maximum size of memory allocated to CHANNEL%s.
                    MEM_SIZE:  u3, 
                    
                    /// [26:27] 
                    res0:  u0, 
                    
                    /// [28:28] This is the carrier modulation enable-control bit for CHANNEL%s. 1: Add carrier modulation in the output signal. 0: No carrier modulation in sig_out.
                    CARRIER_EN:  u1, 
                    
                    /// [29:29] This bit is used to configure the position of carrier wave for CHANNEL%s.1'h0: add carrier wave on low level.1'h1: add carrier wave on high level.
                    CARRIER_OUT_LV:  u1, 
                    
                    /// [30:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x6000601c));
                
                /// Channel %s configure register 1
                pub const CH0_RX_CONF1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Set this bit to enable receiver to receive data on CHANNEL%s.
                    RX_EN:  u1, 
                    
                    /// [1:1] Set this bit to reset write ram address for CHANNEL%s by accessing receiver.
                    MEM_WR_RST:  u1, 
                    
                    /// [2:2] Set this bit to reset W/R ram address for CHANNEL%s by accessing apb fifo.
                    APB_MEM_RST:  u1, 
                    
                    /// [3:3] This register marks the ownership of CHANNEL%s's ram block.1'h1: Receiver is using the ram. 1'h0: APB bus is using the ram.
                    MEM_OWNER:  u1, 
                    
                    /// [4:4] This is the receive filter's enable bit for CHANNEL%s.
                    RX_FILTER_EN:  u1, 
                    
                    /// [5:12] Ignores the input pulse when its width is smaller than this register value in APB clock periods (in receive mode).
                    RX_FILTER_THRES:  u8, 
                    
                    /// [13:13] This is the channel %s enable bit for wraparound mode: it will resume receiving at the start when the data to be received is more than its memory size.
                    MEM_RX_WRAP_EN:  u1, 
                    
                    /// [14:14] Reserved
                    AFIFO_RST:  u1, 
                    
                    /// [15:15] synchronization bit for CHANNEL%s
                    CONF_UPDATE:  u1, 
                    
                    /// [16:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000601c));
                
                /// Channel %s configure register 1
                pub const CH0_RX_CONF1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Set this bit to enable receiver to receive data on CHANNEL%s.
                    RX_EN:  u1, 
                    
                    /// [1:1] Set this bit to reset write ram address for CHANNEL%s by accessing receiver.
                    MEM_WR_RST:  u1, 
                    
                    /// [2:2] Set this bit to reset W/R ram address for CHANNEL%s by accessing apb fifo.
                    APB_MEM_RST:  u1, 
                    
                    /// [3:3] This register marks the ownership of CHANNEL%s's ram block.1'h1: Receiver is using the ram. 1'h0: APB bus is using the ram.
                    MEM_OWNER:  u1, 
                    
                    /// [4:4] This is the receive filter's enable bit for CHANNEL%s.
                    RX_FILTER_EN:  u1, 
                    
                    /// [5:12] Ignores the input pulse when its width is smaller than this register value in APB clock periods (in receive mode).
                    RX_FILTER_THRES:  u8, 
                    
                    /// [13:13] This is the channel %s enable bit for wraparound mode: it will resume receiving at the start when the data to be received is more than its memory size.
                    MEM_RX_WRAP_EN:  u1, 
                    
                    /// [14:14] Reserved
                    AFIFO_RST:  u1, 
                    
                    /// [15:15] synchronization bit for CHANNEL%s
                    CONF_UPDATE:  u1, 
                    
                    /// [16:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60006020));
                
                /// Channel %s status register
                pub const CH0_TX_STATUS = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:8] This register records the memory address offset when transmitter of CHANNEL%s is using the RAM.
                    MEM_RADDR_EX:  u9, 
                    
                    /// [9:11] This register records the FSM status of CHANNEL%s.
                    STATE:  u3, 
                    
                    /// [12:20] This register records the memory address offset when writes RAM over APB bus.
                    APB_MEM_WADDR:  u9, 
                    
                    /// [21:21] This status bit will be set if the offset address out of memory size when reading via APB bus.
                    APB_MEM_RD_ERR:  u1, 
                    
                    /// [22:22] This status bit will be set when the data to be set is more than memory size and the wraparound mode is disabled.
                    MEM_EMPTY:  u1, 
                    
                    /// [23:23] This status bit will be set if the offset address out of memory size when writes via APB bus.
                    APB_MEM_WR_ERR:  u1, 
                    
                    /// [24:31] This register records the memory address offset when reading RAM over APB bus.
                    APB_MEM_RADDR:  u8, 
                    
                }), @ptrFromInt(0x60006028));
                
                /// Channel %s status register
                pub const CH0_TX_STATUS = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:8] This register records the memory address offset when transmitter of CHANNEL%s is using the RAM.
                    MEM_RADDR_EX:  u9, 
                    
                    /// [9:11] This register records the FSM status of CHANNEL%s.
                    STATE:  u3, 
                    
                    /// [12:20] This register records the memory address offset when writes RAM over APB bus.
                    APB_MEM_WADDR:  u9, 
                    
                    /// [21:21] This status bit will be set if the offset address out of memory size when reading via APB bus.
                    APB_MEM_RD_ERR:  u1, 
                    
                    /// [22:22] This status bit will be set when the data to be set is more than memory size and the wraparound mode is disabled.
                    MEM_EMPTY:  u1, 
                    
                    /// [23:23] This status bit will be set if the offset address out of memory size when writes via APB bus.
                    APB_MEM_WR_ERR:  u1, 
                    
                    /// [24:31] This register records the memory address offset when reading RAM over APB bus.
                    APB_MEM_RADDR:  u8, 
                    
                }), @ptrFromInt(0x6000602c));
                
                /// Channel %s status register
                pub const CH0_RX_STATUS = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:8] This register records the memory address offset when receiver of CHANNEL%s is using the RAM.
                    MEM_WADDR_EX:  u9, 
                    
                    /// [9:11] 
                    res0:  u0, 
                    
                    /// [12:20] This register records the memory address offset when reads RAM over APB bus.
                    APB_MEM_RADDR:  u9, 
                    
                    /// [21:21] 
                    res1:  u0, 
                    
                    /// [22:24] This register records the FSM status of CHANNEL%s.
                    STATE:  u3, 
                    
                    /// [25:25] This status bit will be set when the ownership of memory block is wrong.
                    MEM_OWNER_ERR:  u1, 
                    
                    /// [26:26] This status bit will be set if the receiver receives more data than the memory size.
                    MEM_FULL:  u1, 
                    
                    /// [27:27] This status bit will be set if the offset address out of memory size when reads via APB bus.
                    APB_MEM_RD_ERR:  u1, 
                    
                    /// [28:31] 
                    res2:  u0, 
                    
                }), @ptrFromInt(0x60006030));
                
                /// Channel %s status register
                pub const CH0_RX_STATUS = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:8] This register records the memory address offset when receiver of CHANNEL%s is using the RAM.
                    MEM_WADDR_EX:  u9, 
                    
                    /// [9:11] 
                    res0:  u0, 
                    
                    /// [12:20] This register records the memory address offset when reads RAM over APB bus.
                    APB_MEM_RADDR:  u9, 
                    
                    /// [21:21] 
                    res1:  u0, 
                    
                    /// [22:24] This register records the FSM status of CHANNEL%s.
                    STATE:  u3, 
                    
                    /// [25:25] This status bit will be set when the ownership of memory block is wrong.
                    MEM_OWNER_ERR:  u1, 
                    
                    /// [26:26] This status bit will be set if the receiver receives more data than the memory size.
                    MEM_FULL:  u1, 
                    
                    /// [27:27] This status bit will be set if the offset address out of memory size when reads via APB bus.
                    APB_MEM_RD_ERR:  u1, 
                    
                    /// [28:31] 
                    res2:  u0, 
                    
                }), @ptrFromInt(0x60006034));
                
                /// Raw interrupt status
                pub const INT_RAW = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] The interrupt raw bit for CHANNEL%s. Triggered when transmission done.
                    CH%s_TX_END:  u1, 
                    
                    /// [1:1] 
                    res0:  u0, 
                    
                    /// [2:2] The interrupt raw bit for CHANNEL2. Triggered when reception done.
                    CH%s_RX_END:  u1, 
                    
                    /// [3:3] 
                    res1:  u0, 
                    
                    /// [4:4] The interrupt raw bit for CHANNEL4. Triggered when error occurs.
                    CH%s_TX_ERR:  u1, 
                    
                    /// [5:5] 
                    res2:  u0, 
                    
                    /// [6:6] The interrupt raw bit for CHANNEL6. Triggered when error occurs.
                    CH%s_RX_ERR:  u1, 
                    
                    /// [7:7] 
                    res3:  u0, 
                    
                    /// [8:8] The interrupt raw bit for CHANNEL%s. Triggered when transmitter sent more data than configured value.
                    CH%s_TX_THR_EVENT:  u1, 
                    
                    /// [9:9] 
                    res4:  u0, 
                    
                    /// [10:10] The interrupt raw bit for CHANNEL2. Triggered when receiver receive more data than configured value.
                    CH%s_RX_THR_EVENT:  u1, 
                    
                    /// [11:11] 
                    res5:  u0, 
                    
                    /// [12:12] The interrupt raw bit for CHANNEL%s. Triggered when the loop count reaches the configured threshold value.
                    CH%s_TX_LOOP:  u1, 
                    
                    /// [13:31] 
                    res6:  u0, 
                    
                }), @ptrFromInt(0x60006038));
                
                /// Masked interrupt status
                pub const INT_ST = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] The masked interrupt status bit for CH%s_TX_END_INT.
                    CH%s_TX_END:  u1, 
                    
                    /// [1:1] 
                    res0:  u0, 
                    
                    /// [2:2] The masked interrupt status bit for CH2_RX_END_INT.
                    CH%s_RX_END:  u1, 
                    
                    /// [3:3] 
                    res1:  u0, 
                    
                    /// [4:4] The masked interrupt status bit for CH4_ERR_INT.
                    CH%s_TX_ERR:  u1, 
                    
                    /// [5:5] 
                    res2:  u0, 
                    
                    /// [6:6] The masked interrupt status bit for CH6_ERR_INT.
                    CH%s_RX_ERR:  u1, 
                    
                    /// [7:7] 
                    res3:  u0, 
                    
                    /// [8:8] The masked interrupt status bit for CH%s_TX_THR_EVENT_INT.
                    CH%s_TX_THR_EVENT:  u1, 
                    
                    /// [9:9] 
                    res4:  u0, 
                    
                    /// [10:10] The masked interrupt status bit for CH2_RX_THR_EVENT_INT.
                    CH%s_RX_THR_EVENT:  u1, 
                    
                    /// [11:11] 
                    res5:  u0, 
                    
                    /// [12:12] The masked interrupt status bit for CH%s_TX_LOOP_INT.
                    CH%s_X_LOOP:  u1, 
                    
                    /// [13:31] 
                    res6:  u0, 
                    
                }), @ptrFromInt(0x6000603c));
                
                /// Interrupt enable bits
                pub const INT_ENA = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] The interrupt enable bit for CH%s_TX_END_INT.
                    CH%s_TX_END:  u1, 
                    
                    /// [1:1] 
                    res0:  u0, 
                    
                    /// [2:2] The interrupt enable bit for CH2_RX_END_INT.
                    CH%s_RX_END:  u1, 
                    
                    /// [3:3] 
                    res1:  u0, 
                    
                    /// [4:4] The interrupt enable bit for CH4_ERR_INT.
                    CH%s_TX_ERR:  u1, 
                    
                    /// [5:5] 
                    res2:  u0, 
                    
                    /// [6:6] The interrupt enable bit for CH6_ERR_INT.
                    CH%s_RX_ERR:  u1, 
                    
                    /// [7:7] 
                    res3:  u0, 
                    
                    /// [8:8] The interrupt enable bit for CH%s_TX_THR_EVENT_INT.
                    CH%s_TX_THR_EVENT:  u1, 
                    
                    /// [9:9] 
                    res4:  u0, 
                    
                    /// [10:10] The interrupt enable bit for CH2_RX_THR_EVENT_INT.
                    CH%s_RX_THR_EVENT:  u1, 
                    
                    /// [11:11] 
                    res5:  u0, 
                    
                    /// [12:12] The interrupt enable bit for CH%s_TX_LOOP_INT.
                    CH%s_X_LOOP:  u1, 
                    
                    /// [13:31] 
                    res6:  u0, 
                    
                }), @ptrFromInt(0x60006040));
                
                /// Interrupt clear bits
                pub const INT_CLR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Set this bit to clear theCH%s_TX_END_INT interrupt.
                    CH%s_TX_END:  u1, 
                    
                    /// [1:1] 
                    res0:  u0, 
                    
                    /// [2:2] Set this bit to clear theCH2_RX_END_INT interrupt.
                    CH%s_RX_END:  u1, 
                    
                    /// [3:3] 
                    res1:  u0, 
                    
                    /// [4:4] Set this bit to clear theCH4_ERR_INT interrupt.
                    CH%s_TX_ERR:  u1, 
                    
                    /// [5:5] 
                    res2:  u0, 
                    
                    /// [6:6] Set this bit to clear theCH6_ERR_INT interrupt.
                    CH%s_RX_ERR:  u1, 
                    
                    /// [7:7] 
                    res3:  u0, 
                    
                    /// [8:8] Set this bit to clear theCH%s_TX_THR_EVENT_INT interrupt.
                    CH%s_TX_THR_EVENT:  u1, 
                    
                    /// [9:9] 
                    res4:  u0, 
                    
                    /// [10:10] Set this bit to clear theCH2_RX_THR_EVENT_INT interrupt.
                    CH%s_RX_THR_EVENT:  u1, 
                    
                    /// [11:11] 
                    res5:  u0, 
                    
                    /// [12:12] Set this bit to clear theCH%s_TX_LOOP_INT interrupt.
                    CH%s_TX_LOOP:  u1, 
                    
                    /// [13:31] 
                    res6:  u0, 
                    
                }), @ptrFromInt(0x60006044));
                
                /// Channel %s duty cycle configuration register
                pub const CH0CARRIER_DUTY = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:15] This register is used to configure carrier wave 's low level clock period for CHANNEL%s.
                    CARRIER_LOW:  u16, 
                    
                    /// [16:31] This register is used to configure carrier wave 's high level clock period for CHANNEL%s.
                    CARRIER_HIGH:  u16, 
                    
                }), @ptrFromInt(0x60006048));
                
                /// Channel %s duty cycle configuration register
                pub const CH0CARRIER_DUTY = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:15] This register is used to configure carrier wave 's low level clock period for CHANNEL%s.
                    CARRIER_LOW:  u16, 
                    
                    /// [16:31] This register is used to configure carrier wave 's high level clock period for CHANNEL%s.
                    CARRIER_HIGH:  u16, 
                    
                }), @ptrFromInt(0x6000604c));
                
                /// Channel %s carrier remove register
                pub const CH0_RX_CARRIER_RM = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:15] The low level period in a carrier modulation mode is (REG_RMT_REG_CARRIER_LOW_THRES_CH%s + 1) for channel %s.
                    CARRIER_LOW_THRES:  u16, 
                    
                    /// [16:31] The high level period in a carrier modulation mode is (REG_RMT_REG_CARRIER_HIGH_THRES_CH%s + 1) for channel %s.
                    CARRIER_HIGH_THRES:  u16, 
                    
                }), @ptrFromInt(0x60006050));
                
                /// Channel %s carrier remove register
                pub const CH0_RX_CARRIER_RM = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:15] The low level period in a carrier modulation mode is (REG_RMT_REG_CARRIER_LOW_THRES_CH%s + 1) for channel %s.
                    CARRIER_LOW_THRES:  u16, 
                    
                    /// [16:31] The high level period in a carrier modulation mode is (REG_RMT_REG_CARRIER_HIGH_THRES_CH%s + 1) for channel %s.
                    CARRIER_HIGH_THRES:  u16, 
                    
                }), @ptrFromInt(0x60006054));
                
                /// Channel %s Tx event configuration register
                pub const CH0_TX_LIM = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:8] This register is used to configure the maximum entries that CHANNEL%s can send out.
                    TX_LIM:  u9, 
                    
                    /// [9:18] This register is used to configure the maximum loop count when tx_conti_mode is valid.
                    TX_LOOP_NUM:  u10, 
                    
                    /// [19:19] This register is the enabled bit for loop count.
                    TX_LOOP_CNT_EN:  u1, 
                    
                    /// [20:20] This register is used to reset the loop count when tx_conti_mode is valid.
                    LOOP_COUNT_RESET:  u1, 
                    
                    /// [21:21] This bit is used to enable the loop send stop function after the loop counter counts toloop number for CHANNEL%s.
                    LOOP_STOP_EN:  u1, 
                    
                    /// [22:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60006058));
                
                /// Channel %s Tx event configuration register
                pub const CH0_TX_LIM = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:8] This register is used to configure the maximum entries that CHANNEL%s can send out.
                    TX_LIM:  u9, 
                    
                    /// [9:18] This register is used to configure the maximum loop count when tx_conti_mode is valid.
                    TX_LOOP_NUM:  u10, 
                    
                    /// [19:19] This register is the enabled bit for loop count.
                    TX_LOOP_CNT_EN:  u1, 
                    
                    /// [20:20] This register is used to reset the loop count when tx_conti_mode is valid.
                    LOOP_COUNT_RESET:  u1, 
                    
                    /// [21:21] This bit is used to enable the loop send stop function after the loop counter counts toloop number for CHANNEL%s.
                    LOOP_STOP_EN:  u1, 
                    
                    /// [22:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000605c));
                
                /// Channel %s Rx event configuration register
                pub const CH0_RX_LIM = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:8] This register is used to configure the maximum entries that CHANNEL%s can receive.
                    RMT_RX_LIM:  u9, 
                    
                    /// [9:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60006060));
                
                /// Channel %s Rx event configuration register
                pub const CH0_RX_LIM = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:8] This register is used to configure the maximum entries that CHANNEL%s can receive.
                    RMT_RX_LIM:  u9, 
                    
                    /// [9:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60006064));
                
                /// RMT apb configuration register
                pub const SYS_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] 1'h1: access memory directly. 1'h0: access memory by FIFO.
                    APB_FIFO_MASK:  u1, 
                    
                    /// [1:1] Set this bit to enable the clock for RMT memory.
                    MEM_CLK_FORCE_ON:  u1, 
                    
                    /// [2:2] Set this bit to power down RMT memory.
                    MEM_FORCE_PD:  u1, 
                    
                    /// [3:3] 1: Disable RMT memory light sleep power down function. 0: Power down RMT memory when RMT is in light sleep mode.
                    MEM_FORCE_PU:  u1, 
                    
                    /// [4:11] the integral part of the fractional divisor
                    SCLK_DIV_NUM:  u8, 
                    
                    /// [12:17] the numerator of the fractional part of the fractional divisor
                    SCLK_DIV_A:  u6, 
                    
                    /// [18:23] the denominator of the fractional part of the fractional divisor
                    SCLK_DIV_B:  u6, 
                    
                    /// [24:25] choose the clock source of rmt_sclk. 1:CLK_80Mhz,2:CLK_FOSC, 3:XTAL
                    SCLK_SEL:  u2, 
                    
                    /// [26:26] rmt_sclk switch
                    SCLK_ACTIVE:  u1, 
                    
                    /// [27:30] 
                    res0:  u0, 
                    
                    /// [31:31] RMT register clock gate enable signal. 1: Power up the drive clock of registers. 0: Power down the drive clock of registers
                    CLK_EN:  u1, 
                    
                }), @ptrFromInt(0x60006068));
                
                /// RMT TX synchronous register
                pub const TX_SIM = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Set this bit to enable CHANNEL0 to start sending data synchronously with other enabled channels.
                    CH0:  u1, 
                    
                    /// [1:1] Set this bit to enable CHANNEL1 to start sending data synchronously with other enabled channels.
                    CH1:  u1, 
                    
                    /// [2:2] This register is used to enable multiple of channels to start sending data synchronously.
                    EN:  u1, 
                    
                    /// [3:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000606c));
                
                /// RMT clock divider reset register
                pub const REF_CNT_RST = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] This register is used to reset the clock divider of CHANNEL0.
                    TX_REF_CNT_RST:  u1, 
                    
                    /// [1:1] This register is used to reset the clock divider of CHANNEL1.
                    TX_REF_CNT_RST_CH1:  u1, 
                    
                    /// [2:2] This register is used to reset the clock divider of CHANNEL2.
                    RX_REF_CNT_RST_CH2:  u1, 
                    
                    /// [3:3] This register is used to reset the clock divider of CHANNEL3.
                    RX_REF_CNT_RST_CH3:  u1, 
                    
                    /// [4:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60006070));
                
                /// RMT version register
                pub const DATE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:27] This is the version register.
                    RMT_DATE:  u28, 
                    
                    /// [28:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600060cc));
                
            };
            
            /// Hardware Random Number Generator
            pub const RNG = struct {
                
                /// Random number data
                pub const DATA = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x600b2808));
                
            };
            
            /// RSA (Rivest Shamir Adleman) Accelerator
            pub const RSA = struct {
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a000));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a001));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a002));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a003));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a004));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a005));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a006));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a007));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a008));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a009));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a00a));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a00b));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a00c));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a00d));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a00e));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a00f));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a010));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a011));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a012));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a013));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a014));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a015));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a016));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a017));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a018));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a019));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a01a));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a01b));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a01c));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a01d));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a01e));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a01f));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a020));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a021));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a022));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a023));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a024));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a025));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a026));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a027));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a028));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a029));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a02a));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a02b));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a02c));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a02d));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a02e));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a02f));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a030));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a031));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a032));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a033));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a034));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a035));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a036));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a037));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a038));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a039));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a03a));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a03b));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a03c));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a03d));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a03e));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a03f));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a040));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a041));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a042));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a043));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a044));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a045));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a046));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a047));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a048));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a049));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a04a));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a04b));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a04c));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a04d));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a04e));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a04f));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a050));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a051));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a052));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a053));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a054));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a055));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a056));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a057));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a058));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a059));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a05a));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a05b));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a05c));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a05d));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a05e));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a05f));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a060));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a061));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a062));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a063));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a064));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a065));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a066));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a067));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a068));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a069));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a06a));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a06b));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a06c));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a06d));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a06e));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a06f));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a070));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a071));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a072));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a073));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a074));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a075));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a076));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a077));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a078));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a079));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a07a));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a07b));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a07c));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a07d));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a07e));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a07f));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a080));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a081));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a082));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a083));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a084));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a085));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a086));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a087));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a088));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a089));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a08a));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a08b));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a08c));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a08d));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a08e));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a08f));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a090));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a091));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a092));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a093));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a094));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a095));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a096));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a097));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a098));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a099));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a09a));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a09b));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a09c));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a09d));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a09e));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a09f));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a0a0));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a0a1));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a0a2));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a0a3));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a0a4));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a0a5));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a0a6));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a0a7));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a0a8));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a0a9));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a0aa));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a0ab));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a0ac));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a0ad));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a0ae));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a0af));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a0b0));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a0b1));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a0b2));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a0b3));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a0b4));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a0b5));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a0b6));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a0b7));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a0b8));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a0b9));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a0ba));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a0bb));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a0bc));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a0bd));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a0be));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a0bf));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a0c0));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a0c1));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a0c2));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a0c3));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a0c4));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a0c5));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a0c6));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a0c7));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a0c8));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a0c9));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a0ca));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a0cb));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a0cc));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a0cd));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a0ce));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a0cf));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a0d0));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a0d1));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a0d2));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a0d3));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a0d4));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a0d5));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a0d6));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a0d7));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a0d8));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a0d9));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a0da));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a0db));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a0dc));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a0dd));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a0de));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a0df));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a0e0));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a0e1));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a0e2));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a0e3));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a0e4));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a0e5));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a0e6));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a0e7));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a0e8));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a0e9));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a0ea));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a0eb));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a0ec));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a0ed));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a0ee));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a0ef));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a0f0));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a0f1));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a0f2));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a0f3));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a0f4));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a0f5));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a0f6));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a0f7));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a0f8));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a0f9));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a0fa));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a0fb));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a0fc));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a0fd));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a0fe));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a0ff));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a100));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a101));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a102));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a103));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a104));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a105));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a106));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a107));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a108));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a109));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a10a));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a10b));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a10c));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a10d));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a10e));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a10f));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a110));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a111));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a112));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a113));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a114));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a115));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a116));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a117));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a118));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a119));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a11a));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a11b));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a11c));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a11d));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a11e));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a11f));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a120));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a121));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a122));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a123));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a124));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a125));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a126));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a127));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a128));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a129));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a12a));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a12b));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a12c));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a12d));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a12e));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a12f));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a130));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a131));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a132));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a133));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a134));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a135));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a136));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a137));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a138));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a139));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a13a));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a13b));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a13c));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a13d));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a13e));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a13f));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a140));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a141));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a142));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a143));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a144));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a145));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a146));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a147));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a148));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a149));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a14a));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a14b));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a14c));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a14d));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a14e));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a14f));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a150));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a151));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a152));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a153));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a154));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a155));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a156));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a157));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a158));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a159));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a15a));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a15b));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a15c));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a15d));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a15e));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a15f));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a160));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a161));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a162));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a163));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a164));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a165));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a166));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a167));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a168));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a169));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a16a));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a16b));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a16c));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a16d));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a16e));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a16f));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a170));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a171));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a172));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a173));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a174));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a175));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a176));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a177));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a178));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a179));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a17a));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a17b));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a17c));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a17d));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a17e));
                
                /// The memory that stores M
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a17f));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a200));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a201));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a202));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a203));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a204));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a205));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a206));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a207));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a208));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a209));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a20a));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a20b));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a20c));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a20d));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a20e));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a20f));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a210));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a211));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a212));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a213));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a214));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a215));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a216));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a217));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a218));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a219));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a21a));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a21b));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a21c));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a21d));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a21e));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a21f));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a220));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a221));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a222));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a223));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a224));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a225));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a226));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a227));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a228));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a229));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a22a));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a22b));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a22c));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a22d));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a22e));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a22f));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a230));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a231));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a232));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a233));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a234));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a235));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a236));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a237));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a238));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a239));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a23a));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a23b));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a23c));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a23d));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a23e));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a23f));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a240));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a241));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a242));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a243));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a244));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a245));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a246));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a247));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a248));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a249));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a24a));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a24b));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a24c));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a24d));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a24e));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a24f));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a250));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a251));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a252));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a253));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a254));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a255));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a256));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a257));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a258));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a259));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a25a));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a25b));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a25c));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a25d));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a25e));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a25f));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a260));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a261));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a262));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a263));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a264));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a265));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a266));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a267));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a268));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a269));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a26a));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a26b));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a26c));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a26d));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a26e));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a26f));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a270));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a271));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a272));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a273));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a274));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a275));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a276));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a277));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a278));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a279));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a27a));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a27b));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a27c));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a27d));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a27e));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a27f));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a280));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a281));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a282));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a283));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a284));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a285));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a286));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a287));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a288));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a289));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a28a));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a28b));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a28c));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a28d));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a28e));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a28f));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a290));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a291));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a292));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a293));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a294));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a295));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a296));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a297));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a298));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a299));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a29a));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a29b));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a29c));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a29d));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a29e));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a29f));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a2a0));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a2a1));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a2a2));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a2a3));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a2a4));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a2a5));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a2a6));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a2a7));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a2a8));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a2a9));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a2aa));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a2ab));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a2ac));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a2ad));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a2ae));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a2af));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a2b0));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a2b1));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a2b2));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a2b3));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a2b4));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a2b5));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a2b6));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a2b7));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a2b8));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a2b9));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a2ba));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a2bb));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a2bc));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a2bd));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a2be));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a2bf));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a2c0));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a2c1));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a2c2));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a2c3));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a2c4));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a2c5));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a2c6));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a2c7));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a2c8));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a2c9));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a2ca));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a2cb));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a2cc));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a2cd));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a2ce));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a2cf));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a2d0));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a2d1));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a2d2));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a2d3));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a2d4));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a2d5));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a2d6));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a2d7));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a2d8));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a2d9));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a2da));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a2db));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a2dc));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a2dd));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a2de));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a2df));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a2e0));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a2e1));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a2e2));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a2e3));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a2e4));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a2e5));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a2e6));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a2e7));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a2e8));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a2e9));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a2ea));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a2eb));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a2ec));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a2ed));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a2ee));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a2ef));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a2f0));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a2f1));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a2f2));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a2f3));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a2f4));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a2f5));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a2f6));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a2f7));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a2f8));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a2f9));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a2fa));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a2fb));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a2fc));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a2fd));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a2fe));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a2ff));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a300));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a301));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a302));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a303));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a304));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a305));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a306));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a307));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a308));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a309));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a30a));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a30b));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a30c));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a30d));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a30e));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a30f));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a310));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a311));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a312));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a313));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a314));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a315));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a316));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a317));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a318));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a319));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a31a));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a31b));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a31c));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a31d));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a31e));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a31f));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a320));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a321));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a322));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a323));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a324));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a325));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a326));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a327));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a328));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a329));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a32a));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a32b));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a32c));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a32d));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a32e));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a32f));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a330));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a331));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a332));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a333));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a334));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a335));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a336));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a337));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a338));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a339));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a33a));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a33b));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a33c));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a33d));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a33e));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a33f));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a340));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a341));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a342));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a343));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a344));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a345));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a346));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a347));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a348));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a349));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a34a));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a34b));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a34c));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a34d));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a34e));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a34f));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a350));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a351));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a352));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a353));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a354));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a355));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a356));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a357));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a358));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a359));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a35a));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a35b));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a35c));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a35d));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a35e));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a35f));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a360));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a361));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a362));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a363));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a364));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a365));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a366));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a367));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a368));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a369));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a36a));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a36b));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a36c));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a36d));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a36e));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a36f));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a370));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a371));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a372));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a373));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a374));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a375));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a376));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a377));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a378));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a379));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a37a));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a37b));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a37c));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a37d));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a37e));
                
                /// The memory that stores Z
                pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a37f));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a400));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a401));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a402));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a403));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a404));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a405));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a406));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a407));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a408));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a409));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a40a));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a40b));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a40c));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a40d));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a40e));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a40f));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a410));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a411));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a412));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a413));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a414));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a415));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a416));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a417));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a418));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a419));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a41a));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a41b));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a41c));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a41d));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a41e));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a41f));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a420));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a421));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a422));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a423));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a424));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a425));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a426));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a427));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a428));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a429));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a42a));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a42b));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a42c));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a42d));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a42e));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a42f));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a430));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a431));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a432));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a433));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a434));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a435));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a436));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a437));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a438));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a439));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a43a));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a43b));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a43c));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a43d));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a43e));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a43f));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a440));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a441));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a442));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a443));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a444));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a445));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a446));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a447));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a448));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a449));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a44a));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a44b));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a44c));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a44d));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a44e));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a44f));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a450));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a451));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a452));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a453));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a454));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a455));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a456));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a457));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a458));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a459));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a45a));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a45b));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a45c));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a45d));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a45e));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a45f));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a460));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a461));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a462));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a463));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a464));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a465));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a466));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a467));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a468));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a469));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a46a));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a46b));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a46c));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a46d));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a46e));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a46f));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a470));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a471));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a472));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a473));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a474));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a475));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a476));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a477));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a478));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a479));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a47a));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a47b));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a47c));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a47d));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a47e));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a47f));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a480));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a481));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a482));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a483));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a484));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a485));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a486));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a487));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a488));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a489));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a48a));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a48b));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a48c));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a48d));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a48e));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a48f));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a490));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a491));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a492));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a493));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a494));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a495));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a496));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a497));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a498));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a499));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a49a));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a49b));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a49c));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a49d));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a49e));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a49f));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a4a0));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a4a1));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a4a2));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a4a3));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a4a4));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a4a5));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a4a6));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a4a7));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a4a8));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a4a9));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a4aa));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a4ab));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a4ac));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a4ad));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a4ae));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a4af));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a4b0));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a4b1));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a4b2));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a4b3));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a4b4));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a4b5));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a4b6));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a4b7));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a4b8));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a4b9));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a4ba));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a4bb));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a4bc));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a4bd));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a4be));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a4bf));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a4c0));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a4c1));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a4c2));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a4c3));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a4c4));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a4c5));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a4c6));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a4c7));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a4c8));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a4c9));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a4ca));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a4cb));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a4cc));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a4cd));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a4ce));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a4cf));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a4d0));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a4d1));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a4d2));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a4d3));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a4d4));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a4d5));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a4d6));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a4d7));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a4d8));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a4d9));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a4da));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a4db));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a4dc));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a4dd));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a4de));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a4df));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a4e0));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a4e1));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a4e2));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a4e3));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a4e4));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a4e5));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a4e6));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a4e7));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a4e8));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a4e9));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a4ea));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a4eb));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a4ec));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a4ed));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a4ee));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a4ef));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a4f0));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a4f1));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a4f2));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a4f3));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a4f4));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a4f5));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a4f6));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a4f7));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a4f8));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a4f9));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a4fa));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a4fb));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a4fc));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a4fd));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a4fe));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a4ff));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a500));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a501));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a502));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a503));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a504));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a505));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a506));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a507));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a508));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a509));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a50a));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a50b));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a50c));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a50d));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a50e));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a50f));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a510));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a511));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a512));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a513));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a514));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a515));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a516));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a517));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a518));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a519));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a51a));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a51b));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a51c));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a51d));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a51e));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a51f));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a520));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a521));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a522));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a523));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a524));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a525));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a526));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a527));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a528));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a529));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a52a));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a52b));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a52c));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a52d));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a52e));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a52f));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a530));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a531));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a532));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a533));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a534));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a535));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a536));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a537));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a538));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a539));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a53a));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a53b));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a53c));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a53d));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a53e));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a53f));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a540));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a541));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a542));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a543));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a544));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a545));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a546));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a547));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a548));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a549));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a54a));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a54b));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a54c));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a54d));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a54e));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a54f));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a550));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a551));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a552));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a553));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a554));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a555));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a556));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a557));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a558));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a559));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a55a));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a55b));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a55c));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a55d));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a55e));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a55f));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a560));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a561));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a562));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a563));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a564));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a565));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a566));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a567));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a568));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a569));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a56a));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a56b));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a56c));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a56d));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a56e));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a56f));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a570));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a571));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a572));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a573));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a574));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a575));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a576));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a577));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a578));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a579));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a57a));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a57b));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a57c));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a57d));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a57e));
                
                /// The memory that stores Y
                pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a57f));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a600));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a601));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a602));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a603));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a604));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a605));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a606));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a607));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a608));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a609));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a60a));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a60b));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a60c));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a60d));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a60e));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a60f));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a610));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a611));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a612));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a613));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a614));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a615));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a616));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a617));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a618));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a619));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a61a));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a61b));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a61c));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a61d));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a61e));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a61f));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a620));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a621));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a622));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a623));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a624));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a625));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a626));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a627));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a628));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a629));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a62a));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a62b));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a62c));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a62d));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a62e));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a62f));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a630));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a631));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a632));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a633));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a634));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a635));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a636));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a637));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a638));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a639));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a63a));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a63b));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a63c));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a63d));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a63e));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a63f));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a640));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a641));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a642));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a643));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a644));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a645));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a646));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a647));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a648));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a649));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a64a));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a64b));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a64c));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a64d));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a64e));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a64f));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a650));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a651));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a652));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a653));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a654));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a655));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a656));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a657));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a658));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a659));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a65a));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a65b));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a65c));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a65d));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a65e));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a65f));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a660));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a661));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a662));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a663));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a664));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a665));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a666));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a667));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a668));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a669));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a66a));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a66b));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a66c));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a66d));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a66e));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a66f));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a670));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a671));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a672));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a673));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a674));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a675));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a676));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a677));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a678));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a679));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a67a));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a67b));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a67c));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a67d));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a67e));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a67f));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a680));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a681));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a682));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a683));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a684));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a685));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a686));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a687));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a688));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a689));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a68a));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a68b));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a68c));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a68d));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a68e));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a68f));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a690));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a691));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a692));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a693));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a694));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a695));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a696));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a697));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a698));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a699));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a69a));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a69b));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a69c));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a69d));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a69e));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a69f));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a6a0));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a6a1));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a6a2));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a6a3));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a6a4));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a6a5));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a6a6));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a6a7));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a6a8));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a6a9));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a6aa));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a6ab));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a6ac));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a6ad));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a6ae));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a6af));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a6b0));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a6b1));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a6b2));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a6b3));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a6b4));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a6b5));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a6b6));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a6b7));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a6b8));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a6b9));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a6ba));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a6bb));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a6bc));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a6bd));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a6be));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a6bf));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a6c0));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a6c1));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a6c2));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a6c3));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a6c4));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a6c5));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a6c6));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a6c7));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a6c8));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a6c9));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a6ca));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a6cb));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a6cc));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a6cd));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a6ce));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a6cf));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a6d0));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a6d1));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a6d2));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a6d3));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a6d4));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a6d5));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a6d6));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a6d7));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a6d8));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a6d9));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a6da));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a6db));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a6dc));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a6dd));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a6de));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a6df));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a6e0));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a6e1));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a6e2));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a6e3));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a6e4));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a6e5));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a6e6));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a6e7));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a6e8));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a6e9));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a6ea));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a6eb));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a6ec));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a6ed));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a6ee));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a6ef));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a6f0));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a6f1));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a6f2));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a6f3));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a6f4));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a6f5));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a6f6));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a6f7));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a6f8));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a6f9));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a6fa));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a6fb));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a6fc));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a6fd));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a6fe));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a6ff));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a700));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a701));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a702));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a703));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a704));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a705));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a706));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a707));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a708));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a709));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a70a));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a70b));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a70c));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a70d));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a70e));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a70f));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a710));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a711));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a712));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a713));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a714));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a715));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a716));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a717));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a718));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a719));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a71a));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a71b));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a71c));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a71d));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a71e));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a71f));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a720));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a721));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a722));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a723));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a724));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a725));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a726));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a727));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a728));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a729));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a72a));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a72b));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a72c));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a72d));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a72e));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a72f));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a730));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a731));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a732));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a733));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a734));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a735));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a736));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a737));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a738));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a739));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a73a));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a73b));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a73c));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a73d));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a73e));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a73f));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a740));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a741));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a742));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a743));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a744));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a745));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a746));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a747));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a748));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a749));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a74a));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a74b));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a74c));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a74d));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a74e));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a74f));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a750));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a751));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a752));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a753));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a754));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a755));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a756));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a757));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a758));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a759));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a75a));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a75b));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a75c));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a75d));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a75e));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a75f));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a760));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a761));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a762));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a763));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a764));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a765));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a766));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a767));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a768));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a769));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a76a));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a76b));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a76c));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a76d));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a76e));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a76f));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a770));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a771));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a772));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a773));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a774));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a775));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a776));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a777));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a778));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a779));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a77a));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a77b));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a77c));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a77d));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a77e));
                
                /// The memory that stores X
                pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008a77f));
                
                /// RSA M_prime register
                pub const M_PRIME = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Those bits stores m'
                    M_PRIME:  u32, 
                    
                }), @ptrFromInt(0x6008a800));
                
                /// RSA mode register
                pub const MODE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:6] rsa mode (rsa length).
                    MODE:  u7, 
                    
                    /// [7:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6008a804));
                
                /// RSA query clean register
                pub const QUERY_CLEAN = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] query clean
                    QUERY_CLEAN:  u1, 
                    
                    /// [1:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6008a808));
                
                /// RSA modular exponentiation trigger register.
                pub const SET_START_MODEXP = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] start modular exponentiation
                    SET_START_MODEXP:  u1, 
                    
                    /// [1:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6008a80c));
                
                /// RSA modular multiplication trigger register.
                pub const SET_START_MODMULT = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] start modular multiplication
                    SET_START_MODMULT:  u1, 
                    
                    /// [1:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6008a810));
                
                /// RSA normal multiplication trigger register.
                pub const SET_START_MULT = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] start multiplicaiton
                    SET_START_MULT:  u1, 
                    
                    /// [1:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6008a814));
                
                /// RSA query idle register
                pub const QUERY_IDLE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] query rsa idle. 1'b0: busy, 1'b1: idle
                    QUERY_IDLE:  u1, 
                    
                    /// [1:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6008a818));
                
                /// RSA interrupt clear register
                pub const INT_CLR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] set this bit to clear RSA interrupt.
                    CLEAR_INTERRUPT:  u1, 
                    
                    /// [1:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6008a81c));
                
                /// RSA constant time option register
                pub const CONSTANT_TIME = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Configure this bit to 0 for acceleration. 0: with acceleration, 1: without acceleration(defalut).
                    CONSTANT_TIME:  u1, 
                    
                    /// [1:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6008a820));
                
                /// RSA search option
                pub const SEARCH_ENABLE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Configure this bit to 1 for acceleration. 1: with acceleration, 0: without acceleration(default). This option should be used together with RSA_SEARCH_POS.
                    SEARCH_ENABLE:  u1, 
                    
                    /// [1:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6008a824));
                
                /// RSA search position configure register
                pub const SEARCH_POS = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:11] Configure this field to set search position. This field should be used together with RSA_SEARCH_ENABLE. The field is only meaningful when RSA_SEARCH_ENABLE is high.
                    SEARCH_POS:  u12, 
                    
                    /// [12:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6008a828));
                
                /// RSA interrupt enable register
                pub const INT_ENA = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Set this bit to enable interrupt that occurs when rsa calculation is done. 1'b0: disable, 1'b1: enable(default).
                    INT_ENA:  u1, 
                    
                    /// [1:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6008a82c));
                
                /// RSA version control register
                pub const DATE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:29] rsa version information
                    DATE:  u30, 
                    
                    /// [30:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6008a830));
                
            };
            
            /// SHA (Secure Hash Algorithm) Accelerator
            pub const SHA = struct {
                
                /// Initial configuration register.
                pub const MODE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:2] Sha mode.
                    MODE:  u3, 
                    
                    /// [3:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60089000));
                
                /// SHA 512/t configuration register 0.
                pub const T_STRING = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Sha t_string (used if and only if mode == SHA_512/t).
                    T_STRING:  u32, 
                    
                }), @ptrFromInt(0x60089004));
                
                /// SHA 512/t configuration register 1.
                pub const T_LENGTH = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] Sha t_length (used if and only if mode == SHA_512/t).
                    T_LENGTH:  u6, 
                    
                    /// [6:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60089008));
                
                /// DMA configuration register 0.
                pub const DMA_BLOCK_NUM = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] Dma-sha block number.
                    DMA_BLOCK_NUM:  u6, 
                    
                    /// [6:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6008900c));
                
                /// Typical SHA configuration register 0.
                pub const START = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] 
                    res0:  u0, 
                    
                    /// [1:31] Reserved.
                    START:  u31, 
                    
                }), @ptrFromInt(0x60089010));
                
                /// Typical SHA configuration register 1.
                pub const CONTINUE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] 
                    res0:  u0, 
                    
                    /// [1:31] Reserved.
                    CONTINUE:  u31, 
                    
                }), @ptrFromInt(0x60089014));
                
                /// Busy register.
                pub const BUSY = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Sha busy state. 1'b0: idle. 1'b1: busy.
                    STATE:  u1, 
                    
                    /// [1:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60089018));
                
                /// DMA configuration register 1.
                pub const DMA_START = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Start dma-sha.
                    DMA_START:  u1, 
                    
                    /// [1:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6008901c));
                
                /// DMA configuration register 2.
                pub const DMA_CONTINUE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Continue dma-sha.
                    DMA_CONTINUE:  u1, 
                    
                    /// [1:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60089020));
                
                /// Interrupt clear register.
                pub const CLEAR_IRQ = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Clear sha interrupt.
                    CLEAR_INTERRUPT:  u1, 
                    
                    /// [1:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60089024));
                
                /// Interrupt enable register.
                pub const IRQ_ENA = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Sha interrupt enable register. 1'b0: disable(default). 1'b1: enable.
                    INTERRUPT_ENA:  u1, 
                    
                    /// [1:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60089028));
                
                /// Date register.
                pub const DATE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:29] Sha date information/ sha version information.
                    DATE:  u30, 
                    
                    /// [30:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6008902c));
                
                /// Sha H memory which contains intermediate hash or finial hash.
                pub const H_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x60089040));
                
                /// Sha H memory which contains intermediate hash or finial hash.
                pub const H_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x60089041));
                
                /// Sha H memory which contains intermediate hash or finial hash.
                pub const H_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x60089042));
                
                /// Sha H memory which contains intermediate hash or finial hash.
                pub const H_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x60089043));
                
                /// Sha H memory which contains intermediate hash or finial hash.
                pub const H_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x60089044));
                
                /// Sha H memory which contains intermediate hash or finial hash.
                pub const H_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x60089045));
                
                /// Sha H memory which contains intermediate hash or finial hash.
                pub const H_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x60089046));
                
                /// Sha H memory which contains intermediate hash or finial hash.
                pub const H_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x60089047));
                
                /// Sha H memory which contains intermediate hash or finial hash.
                pub const H_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x60089048));
                
                /// Sha H memory which contains intermediate hash or finial hash.
                pub const H_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x60089049));
                
                /// Sha H memory which contains intermediate hash or finial hash.
                pub const H_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008904a));
                
                /// Sha H memory which contains intermediate hash or finial hash.
                pub const H_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008904b));
                
                /// Sha H memory which contains intermediate hash or finial hash.
                pub const H_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008904c));
                
                /// Sha H memory which contains intermediate hash or finial hash.
                pub const H_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008904d));
                
                /// Sha H memory which contains intermediate hash or finial hash.
                pub const H_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008904e));
                
                /// Sha H memory which contains intermediate hash or finial hash.
                pub const H_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008904f));
                
                /// Sha H memory which contains intermediate hash or finial hash.
                pub const H_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x60089050));
                
                /// Sha H memory which contains intermediate hash or finial hash.
                pub const H_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x60089051));
                
                /// Sha H memory which contains intermediate hash or finial hash.
                pub const H_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x60089052));
                
                /// Sha H memory which contains intermediate hash or finial hash.
                pub const H_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x60089053));
                
                /// Sha H memory which contains intermediate hash or finial hash.
                pub const H_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x60089054));
                
                /// Sha H memory which contains intermediate hash or finial hash.
                pub const H_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x60089055));
                
                /// Sha H memory which contains intermediate hash or finial hash.
                pub const H_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x60089056));
                
                /// Sha H memory which contains intermediate hash or finial hash.
                pub const H_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x60089057));
                
                /// Sha H memory which contains intermediate hash or finial hash.
                pub const H_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x60089058));
                
                /// Sha H memory which contains intermediate hash or finial hash.
                pub const H_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x60089059));
                
                /// Sha H memory which contains intermediate hash or finial hash.
                pub const H_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008905a));
                
                /// Sha H memory which contains intermediate hash or finial hash.
                pub const H_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008905b));
                
                /// Sha H memory which contains intermediate hash or finial hash.
                pub const H_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008905c));
                
                /// Sha H memory which contains intermediate hash or finial hash.
                pub const H_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008905d));
                
                /// Sha H memory which contains intermediate hash or finial hash.
                pub const H_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008905e));
                
                /// Sha H memory which contains intermediate hash or finial hash.
                pub const H_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008905f));
                
                /// Sha H memory which contains intermediate hash or finial hash.
                pub const H_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x60089060));
                
                /// Sha H memory which contains intermediate hash or finial hash.
                pub const H_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x60089061));
                
                /// Sha H memory which contains intermediate hash or finial hash.
                pub const H_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x60089062));
                
                /// Sha H memory which contains intermediate hash or finial hash.
                pub const H_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x60089063));
                
                /// Sha H memory which contains intermediate hash or finial hash.
                pub const H_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x60089064));
                
                /// Sha H memory which contains intermediate hash or finial hash.
                pub const H_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x60089065));
                
                /// Sha H memory which contains intermediate hash or finial hash.
                pub const H_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x60089066));
                
                /// Sha H memory which contains intermediate hash or finial hash.
                pub const H_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x60089067));
                
                /// Sha H memory which contains intermediate hash or finial hash.
                pub const H_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x60089068));
                
                /// Sha H memory which contains intermediate hash or finial hash.
                pub const H_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x60089069));
                
                /// Sha H memory which contains intermediate hash or finial hash.
                pub const H_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008906a));
                
                /// Sha H memory which contains intermediate hash or finial hash.
                pub const H_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008906b));
                
                /// Sha H memory which contains intermediate hash or finial hash.
                pub const H_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008906c));
                
                /// Sha H memory which contains intermediate hash or finial hash.
                pub const H_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008906d));
                
                /// Sha H memory which contains intermediate hash or finial hash.
                pub const H_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008906e));
                
                /// Sha H memory which contains intermediate hash or finial hash.
                pub const H_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008906f));
                
                /// Sha H memory which contains intermediate hash or finial hash.
                pub const H_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x60089070));
                
                /// Sha H memory which contains intermediate hash or finial hash.
                pub const H_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x60089071));
                
                /// Sha H memory which contains intermediate hash or finial hash.
                pub const H_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x60089072));
                
                /// Sha H memory which contains intermediate hash or finial hash.
                pub const H_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x60089073));
                
                /// Sha H memory which contains intermediate hash or finial hash.
                pub const H_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x60089074));
                
                /// Sha H memory which contains intermediate hash or finial hash.
                pub const H_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x60089075));
                
                /// Sha H memory which contains intermediate hash or finial hash.
                pub const H_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x60089076));
                
                /// Sha H memory which contains intermediate hash or finial hash.
                pub const H_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x60089077));
                
                /// Sha H memory which contains intermediate hash or finial hash.
                pub const H_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x60089078));
                
                /// Sha H memory which contains intermediate hash or finial hash.
                pub const H_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x60089079));
                
                /// Sha H memory which contains intermediate hash or finial hash.
                pub const H_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008907a));
                
                /// Sha H memory which contains intermediate hash or finial hash.
                pub const H_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008907b));
                
                /// Sha H memory which contains intermediate hash or finial hash.
                pub const H_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008907c));
                
                /// Sha H memory which contains intermediate hash or finial hash.
                pub const H_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008907d));
                
                /// Sha H memory which contains intermediate hash or finial hash.
                pub const H_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008907e));
                
                /// Sha H memory which contains intermediate hash or finial hash.
                pub const H_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008907f));
                
                /// Sha M memory which contains message.
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x60089080));
                
                /// Sha M memory which contains message.
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x60089081));
                
                /// Sha M memory which contains message.
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x60089082));
                
                /// Sha M memory which contains message.
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x60089083));
                
                /// Sha M memory which contains message.
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x60089084));
                
                /// Sha M memory which contains message.
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x60089085));
                
                /// Sha M memory which contains message.
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x60089086));
                
                /// Sha M memory which contains message.
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x60089087));
                
                /// Sha M memory which contains message.
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x60089088));
                
                /// Sha M memory which contains message.
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x60089089));
                
                /// Sha M memory which contains message.
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008908a));
                
                /// Sha M memory which contains message.
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008908b));
                
                /// Sha M memory which contains message.
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008908c));
                
                /// Sha M memory which contains message.
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008908d));
                
                /// Sha M memory which contains message.
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008908e));
                
                /// Sha M memory which contains message.
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008908f));
                
                /// Sha M memory which contains message.
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x60089090));
                
                /// Sha M memory which contains message.
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x60089091));
                
                /// Sha M memory which contains message.
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x60089092));
                
                /// Sha M memory which contains message.
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x60089093));
                
                /// Sha M memory which contains message.
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x60089094));
                
                /// Sha M memory which contains message.
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x60089095));
                
                /// Sha M memory which contains message.
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x60089096));
                
                /// Sha M memory which contains message.
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x60089097));
                
                /// Sha M memory which contains message.
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x60089098));
                
                /// Sha M memory which contains message.
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x60089099));
                
                /// Sha M memory which contains message.
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008909a));
                
                /// Sha M memory which contains message.
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008909b));
                
                /// Sha M memory which contains message.
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008909c));
                
                /// Sha M memory which contains message.
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008909d));
                
                /// Sha M memory which contains message.
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008909e));
                
                /// Sha M memory which contains message.
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x6008909f));
                
                /// Sha M memory which contains message.
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x600890a0));
                
                /// Sha M memory which contains message.
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x600890a1));
                
                /// Sha M memory which contains message.
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x600890a2));
                
                /// Sha M memory which contains message.
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x600890a3));
                
                /// Sha M memory which contains message.
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x600890a4));
                
                /// Sha M memory which contains message.
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x600890a5));
                
                /// Sha M memory which contains message.
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x600890a6));
                
                /// Sha M memory which contains message.
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x600890a7));
                
                /// Sha M memory which contains message.
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x600890a8));
                
                /// Sha M memory which contains message.
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x600890a9));
                
                /// Sha M memory which contains message.
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x600890aa));
                
                /// Sha M memory which contains message.
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x600890ab));
                
                /// Sha M memory which contains message.
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x600890ac));
                
                /// Sha M memory which contains message.
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x600890ad));
                
                /// Sha M memory which contains message.
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x600890ae));
                
                /// Sha M memory which contains message.
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x600890af));
                
                /// Sha M memory which contains message.
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x600890b0));
                
                /// Sha M memory which contains message.
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x600890b1));
                
                /// Sha M memory which contains message.
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x600890b2));
                
                /// Sha M memory which contains message.
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x600890b3));
                
                /// Sha M memory which contains message.
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x600890b4));
                
                /// Sha M memory which contains message.
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x600890b5));
                
                /// Sha M memory which contains message.
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x600890b6));
                
                /// Sha M memory which contains message.
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x600890b7));
                
                /// Sha M memory which contains message.
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x600890b8));
                
                /// Sha M memory which contains message.
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x600890b9));
                
                /// Sha M memory which contains message.
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x600890ba));
                
                /// Sha M memory which contains message.
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x600890bb));
                
                /// Sha M memory which contains message.
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x600890bc));
                
                /// Sha M memory which contains message.
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x600890bd));
                
                /// Sha M memory which contains message.
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x600890be));
                
                /// Sha M memory which contains message.
                pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {
                    
                    /// [0:7] 
                    raw:  u0, 
                    
                }), @ptrFromInt(0x600890bf));
                
            };
            
            /// SLCHOST Peripheral
            pub const SLCHOST = struct {
                
                /// *******Description***********
                pub const FUNC2_0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:23] 
                    res0:  u0, 
                    
                    /// [24:24] *******Description***********
                    SLC_FUNC2_INT:  u1, 
                    
                    /// [25:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x60017010));
                
                /// *******Description***********
                pub const FUNC2_1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] *******Description***********
                    SLC_FUNC2_INT_EN:  u1, 
                    
                    /// [1:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60017014));
                
                /// *******Description***********
                pub const FUNC2_2 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] *******Description***********
                    SLC_FUNC1_MDSTAT:  u1, 
                    
                    /// [1:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60017020));
                
                /// *******Description***********
                pub const GPIO_STATUS0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] *******Description***********
                    GPIO_SDIO_INT0:  u32, 
                    
                }), @ptrFromInt(0x60017034));
                
                /// *******Description***********
                pub const GPIO_STATUS1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] *******Description***********
                    GPIO_SDIO_INT1:  u32, 
                    
                }), @ptrFromInt(0x60017038));
                
                /// *******Description***********
                pub const GPIO_IN0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] *******Description***********
                    GPIO_SDIO_IN0:  u32, 
                    
                }), @ptrFromInt(0x6001703c));
                
                /// *******Description***********
                pub const GPIO_IN1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] *******Description***********
                    GPIO_SDIO_IN1:  u32, 
                    
                }), @ptrFromInt(0x60017040));
                
                /// *******Description***********
                pub const SLC0HOST_TOKEN_RDATA = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:11] *******Description***********
                    SLC0_TOKEN0:  u12, 
                    
                    /// [12:12] *******Description***********
                    SLC0_RX_PF_VALID:  u1, 
                    
                    /// [13:15] 
                    res0:  u0, 
                    
                    /// [16:27] *******Description***********
                    HOSTSLCHOST_SLC0_TOKEN1:  u12, 
                    
                    /// [28:31] *******Description***********
                    SLC0_RX_PF_EOF:  u4, 
                    
                }), @ptrFromInt(0x60017044));
                
                /// *******Description***********
                pub const SLC0_HOST_PF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] *******Description***********
                    SLC0_PF_DATA:  u32, 
                    
                }), @ptrFromInt(0x60017048));
                
                /// *******Description***********
                pub const SLC1_HOST_PF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] *******Description***********
                    SLC1_PF_DATA:  u32, 
                    
                }), @ptrFromInt(0x6001704c));
                
                /// *******Description***********
                pub const SLC0HOST_INT_RAW = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] *******Description***********
                    SLC0_TOHOST_BIT0_INT_RAW:  u1, 
                    
                    /// [1:1] *******Description***********
                    SLC0_TOHOST_BIT1_INT_RAW:  u1, 
                    
                    /// [2:2] *******Description***********
                    SLC0_TOHOST_BIT2_INT_RAW:  u1, 
                    
                    /// [3:3] *******Description***********
                    SLC0_TOHOST_BIT3_INT_RAW:  u1, 
                    
                    /// [4:4] *******Description***********
                    SLC0_TOHOST_BIT4_INT_RAW:  u1, 
                    
                    /// [5:5] *******Description***********
                    SLC0_TOHOST_BIT5_INT_RAW:  u1, 
                    
                    /// [6:6] *******Description***********
                    SLC0_TOHOST_BIT6_INT_RAW:  u1, 
                    
                    /// [7:7] *******Description***********
                    SLC0_TOHOST_BIT7_INT_RAW:  u1, 
                    
                    /// [8:8] *******Description***********
                    SLC0_TOKEN0_1TO0_INT_RAW:  u1, 
                    
                    /// [9:9] *******Description***********
                    SLC0_TOKEN1_1TO0_INT_RAW:  u1, 
                    
                    /// [10:10] *******Description***********
                    SLC0_TOKEN0_0TO1_INT_RAW:  u1, 
                    
                    /// [11:11] *******Description***********
                    SLC0_TOKEN1_0TO1_INT_RAW:  u1, 
                    
                    /// [12:12] *******Description***********
                    SLC0HOST_RX_SOF_INT_RAW:  u1, 
                    
                    /// [13:13] *******Description***********
                    SLC0HOST_RX_EOF_INT_RAW:  u1, 
                    
                    /// [14:14] *******Description***********
                    SLC0HOST_RX_START_INT_RAW:  u1, 
                    
                    /// [15:15] *******Description***********
                    SLC0HOST_TX_START_INT_RAW:  u1, 
                    
                    /// [16:16] *******Description***********
                    SLC0_RX_UDF_INT_RAW:  u1, 
                    
                    /// [17:17] *******Description***********
                    SLC0_TX_OVF_INT_RAW:  u1, 
                    
                    /// [18:18] *******Description***********
                    SLC0_RX_PF_VALID_INT_RAW:  u1, 
                    
                    /// [19:19] *******Description***********
                    SLC0_EXT_BIT0_INT_RAW:  u1, 
                    
                    /// [20:20] *******Description***********
                    SLC0_EXT_BIT1_INT_RAW:  u1, 
                    
                    /// [21:21] *******Description***********
                    SLC0_EXT_BIT2_INT_RAW:  u1, 
                    
                    /// [22:22] *******Description***********
                    SLC0_EXT_BIT3_INT_RAW:  u1, 
                    
                    /// [23:23] *******Description***********
                    SLC0_RX_NEW_PACKET_INT_RAW:  u1, 
                    
                    /// [24:24] *******Description***********
                    SLC0_HOST_RD_RETRY_INT_RAW:  u1, 
                    
                    /// [25:25] *******Description***********
                    GPIO_SDIO_INT_RAW:  u1, 
                    
                    /// [26:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60017050));
                
                /// *******Description***********
                pub const SLC1HOST_INT_RAW = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] *******Description***********
                    SLC1_TOHOST_BIT0_INT_RAW:  u1, 
                    
                    /// [1:1] *******Description***********
                    SLC1_TOHOST_BIT1_INT_RAW:  u1, 
                    
                    /// [2:2] *******Description***********
                    SLC1_TOHOST_BIT2_INT_RAW:  u1, 
                    
                    /// [3:3] *******Description***********
                    SLC1_TOHOST_BIT3_INT_RAW:  u1, 
                    
                    /// [4:4] *******Description***********
                    SLC1_TOHOST_BIT4_INT_RAW:  u1, 
                    
                    /// [5:5] *******Description***********
                    SLC1_TOHOST_BIT5_INT_RAW:  u1, 
                    
                    /// [6:6] *******Description***********
                    SLC1_TOHOST_BIT6_INT_RAW:  u1, 
                    
                    /// [7:7] *******Description***********
                    SLC1_TOHOST_BIT7_INT_RAW:  u1, 
                    
                    /// [8:8] *******Description***********
                    SLC1_TOKEN0_1TO0_INT_RAW:  u1, 
                    
                    /// [9:9] *******Description***********
                    SLC1_TOKEN1_1TO0_INT_RAW:  u1, 
                    
                    /// [10:10] *******Description***********
                    SLC1_TOKEN0_0TO1_INT_RAW:  u1, 
                    
                    /// [11:11] *******Description***********
                    SLC1_TOKEN1_0TO1_INT_RAW:  u1, 
                    
                    /// [12:12] *******Description***********
                    SLC1HOST_RX_SOF_INT_RAW:  u1, 
                    
                    /// [13:13] *******Description***********
                    SLC1HOST_RX_EOF_INT_RAW:  u1, 
                    
                    /// [14:14] *******Description***********
                    SLC1HOST_RX_START_INT_RAW:  u1, 
                    
                    /// [15:15] *******Description***********
                    SLC1HOST_TX_START_INT_RAW:  u1, 
                    
                    /// [16:16] *******Description***********
                    SLC1_RX_UDF_INT_RAW:  u1, 
                    
                    /// [17:17] *******Description***********
                    SLC1_TX_OVF_INT_RAW:  u1, 
                    
                    /// [18:18] *******Description***********
                    SLC1_RX_PF_VALID_INT_RAW:  u1, 
                    
                    /// [19:19] *******Description***********
                    SLC1_EXT_BIT0_INT_RAW:  u1, 
                    
                    /// [20:20] *******Description***********
                    SLC1_EXT_BIT1_INT_RAW:  u1, 
                    
                    /// [21:21] *******Description***********
                    SLC1_EXT_BIT2_INT_RAW:  u1, 
                    
                    /// [22:22] *******Description***********
                    SLC1_EXT_BIT3_INT_RAW:  u1, 
                    
                    /// [23:23] *******Description***********
                    SLC1_WIFI_RX_NEW_PACKET_INT_RAW:  u1, 
                    
                    /// [24:24] *******Description***********
                    SLC1_HOST_RD_RETRY_INT_RAW:  u1, 
                    
                    /// [25:25] *******Description***********
                    SLC1_BT_RX_NEW_PACKET_INT_RAW:  u1, 
                    
                    /// [26:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60017054));
                
                /// *******Description***********
                pub const SLC0HOST_INT_ST = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] *******Description***********
                    SLC0_TOHOST_BIT0_INT_ST:  u1, 
                    
                    /// [1:1] *******Description***********
                    SLC0_TOHOST_BIT1_INT_ST:  u1, 
                    
                    /// [2:2] *******Description***********
                    SLC0_TOHOST_BIT2_INT_ST:  u1, 
                    
                    /// [3:3] *******Description***********
                    SLC0_TOHOST_BIT3_INT_ST:  u1, 
                    
                    /// [4:4] *******Description***********
                    SLC0_TOHOST_BIT4_INT_ST:  u1, 
                    
                    /// [5:5] *******Description***********
                    SLC0_TOHOST_BIT5_INT_ST:  u1, 
                    
                    /// [6:6] *******Description***********
                    SLC0_TOHOST_BIT6_INT_ST:  u1, 
                    
                    /// [7:7] *******Description***********
                    SLC0_TOHOST_BIT7_INT_ST:  u1, 
                    
                    /// [8:8] *******Description***********
                    SLC0_TOKEN0_1TO0_INT_ST:  u1, 
                    
                    /// [9:9] *******Description***********
                    SLC0_TOKEN1_1TO0_INT_ST:  u1, 
                    
                    /// [10:10] *******Description***********
                    SLC0_TOKEN0_0TO1_INT_ST:  u1, 
                    
                    /// [11:11] *******Description***********
                    SLC0_TOKEN1_0TO1_INT_ST:  u1, 
                    
                    /// [12:12] *******Description***********
                    SLC0HOST_RX_SOF_INT_ST:  u1, 
                    
                    /// [13:13] *******Description***********
                    SLC0HOST_RX_EOF_INT_ST:  u1, 
                    
                    /// [14:14] *******Description***********
                    SLC0HOST_RX_START_INT_ST:  u1, 
                    
                    /// [15:15] *******Description***********
                    SLC0HOST_TX_START_INT_ST:  u1, 
                    
                    /// [16:16] *******Description***********
                    SLC0_RX_UDF_INT_ST:  u1, 
                    
                    /// [17:17] *******Description***********
                    SLC0_TX_OVF_INT_ST:  u1, 
                    
                    /// [18:18] *******Description***********
                    SLC0_RX_PF_VALID_INT_ST:  u1, 
                    
                    /// [19:19] *******Description***********
                    SLC0_EXT_BIT0_INT_ST:  u1, 
                    
                    /// [20:20] *******Description***********
                    SLC0_EXT_BIT1_INT_ST:  u1, 
                    
                    /// [21:21] *******Description***********
                    SLC0_EXT_BIT2_INT_ST:  u1, 
                    
                    /// [22:22] *******Description***********
                    SLC0_EXT_BIT3_INT_ST:  u1, 
                    
                    /// [23:23] *******Description***********
                    SLC0_RX_NEW_PACKET_INT_ST:  u1, 
                    
                    /// [24:24] *******Description***********
                    SLC0_HOST_RD_RETRY_INT_ST:  u1, 
                    
                    /// [25:25] *******Description***********
                    GPIO_SDIO_INT_ST:  u1, 
                    
                    /// [26:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60017058));
                
                /// *******Description***********
                pub const SLC1HOST_INT_ST = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] *******Description***********
                    SLC1_TOHOST_BIT0_INT_ST:  u1, 
                    
                    /// [1:1] *******Description***********
                    SLC1_TOHOST_BIT1_INT_ST:  u1, 
                    
                    /// [2:2] *******Description***********
                    SLC1_TOHOST_BIT2_INT_ST:  u1, 
                    
                    /// [3:3] *******Description***********
                    SLC1_TOHOST_BIT3_INT_ST:  u1, 
                    
                    /// [4:4] *******Description***********
                    SLC1_TOHOST_BIT4_INT_ST:  u1, 
                    
                    /// [5:5] *******Description***********
                    SLC1_TOHOST_BIT5_INT_ST:  u1, 
                    
                    /// [6:6] *******Description***********
                    SLC1_TOHOST_BIT6_INT_ST:  u1, 
                    
                    /// [7:7] *******Description***********
                    SLC1_TOHOST_BIT7_INT_ST:  u1, 
                    
                    /// [8:8] *******Description***********
                    SLC1_TOKEN0_1TO0_INT_ST:  u1, 
                    
                    /// [9:9] *******Description***********
                    SLC1_TOKEN1_1TO0_INT_ST:  u1, 
                    
                    /// [10:10] *******Description***********
                    SLC1_TOKEN0_0TO1_INT_ST:  u1, 
                    
                    /// [11:11] *******Description***********
                    SLC1_TOKEN1_0TO1_INT_ST:  u1, 
                    
                    /// [12:12] *******Description***********
                    SLC1HOST_RX_SOF_INT_ST:  u1, 
                    
                    /// [13:13] *******Description***********
                    SLC1HOST_RX_EOF_INT_ST:  u1, 
                    
                    /// [14:14] *******Description***********
                    SLC1HOST_RX_START_INT_ST:  u1, 
                    
                    /// [15:15] *******Description***********
                    SLC1HOST_TX_START_INT_ST:  u1, 
                    
                    /// [16:16] *******Description***********
                    SLC1_RX_UDF_INT_ST:  u1, 
                    
                    /// [17:17] *******Description***********
                    SLC1_TX_OVF_INT_ST:  u1, 
                    
                    /// [18:18] *******Description***********
                    SLC1_RX_PF_VALID_INT_ST:  u1, 
                    
                    /// [19:19] *******Description***********
                    SLC1_EXT_BIT0_INT_ST:  u1, 
                    
                    /// [20:20] *******Description***********
                    SLC1_EXT_BIT1_INT_ST:  u1, 
                    
                    /// [21:21] *******Description***********
                    SLC1_EXT_BIT2_INT_ST:  u1, 
                    
                    /// [22:22] *******Description***********
                    SLC1_EXT_BIT3_INT_ST:  u1, 
                    
                    /// [23:23] *******Description***********
                    SLC1_WIFI_RX_NEW_PACKET_INT_ST:  u1, 
                    
                    /// [24:24] *******Description***********
                    SLC1_HOST_RD_RETRY_INT_ST:  u1, 
                    
                    /// [25:25] *******Description***********
                    SLC1_BT_RX_NEW_PACKET_INT_ST:  u1, 
                    
                    /// [26:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6001705c));
                
                /// *******Description***********
                pub const PKT_LEN = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:19] *******Description***********
                    HOSTSLCHOST_SLC0_LEN:  u20, 
                    
                    /// [20:31] *******Description***********
                    HOSTSLCHOST_SLC0_LEN_CHECK:  u12, 
                    
                }), @ptrFromInt(0x60017060));
                
                /// *******Description***********
                pub const STATE_W0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] *******Description***********
                    SLCHOST_STATE0:  u8, 
                    
                    /// [8:15] *******Description***********
                    SLCHOST_STATE1:  u8, 
                    
                    /// [16:23] *******Description***********
                    SLCHOST_STATE2:  u8, 
                    
                    /// [24:31] *******Description***********
                    SLCHOST_STATE3:  u8, 
                    
                }), @ptrFromInt(0x60017064));
                
                /// *******Description***********
                pub const STATE_W1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] *******Description***********
                    SLCHOST_STATE4:  u8, 
                    
                    /// [8:15] *******Description***********
                    SLCHOST_STATE5:  u8, 
                    
                    /// [16:23] *******Description***********
                    SLCHOST_STATE6:  u8, 
                    
                    /// [24:31] *******Description***********
                    SLCHOST_STATE7:  u8, 
                    
                }), @ptrFromInt(0x60017068));
                
                /// *******Description***********
                pub const CONF_W0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] *******Description***********
                    SLCHOST_CONF0:  u8, 
                    
                    /// [8:15] *******Description***********
                    SLCHOST_CONF1:  u8, 
                    
                    /// [16:23] *******Description***********
                    SLCHOST_CONF2:  u8, 
                    
                    /// [24:31] *******Description***********
                    SLCHOST_CONF3:  u8, 
                    
                }), @ptrFromInt(0x6001706c));
                
                /// *******Description***********
                pub const CONF_W1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] *******Description***********
                    SLCHOST_CONF4:  u8, 
                    
                    /// [8:15] *******Description***********
                    SLCHOST_CONF5:  u8, 
                    
                    /// [16:23] *******Description***********
                    SLCHOST_CONF6:  u8, 
                    
                    /// [24:31] *******Description***********
                    SLCHOST_CONF7:  u8, 
                    
                }), @ptrFromInt(0x60017070));
                
                /// *******Description***********
                pub const CONF_W2 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] *******Description***********
                    SLCHOST_CONF8:  u8, 
                    
                    /// [8:15] *******Description***********
                    SLCHOST_CONF9:  u8, 
                    
                    /// [16:23] *******Description***********
                    SLCHOST_CONF10:  u8, 
                    
                    /// [24:31] *******Description***********
                    SLCHOST_CONF11:  u8, 
                    
                }), @ptrFromInt(0x60017074));
                
                /// *******Description***********
                pub const CONF_W3 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] *******Description***********
                    SLCHOST_CONF12:  u8, 
                    
                    /// [8:15] *******Description***********
                    SLCHOST_CONF13:  u8, 
                    
                    /// [16:23] *******Description***********
                    SLCHOST_CONF14:  u8, 
                    
                    /// [24:31] *******Description***********
                    SLCHOST_CONF15:  u8, 
                    
                }), @ptrFromInt(0x60017078));
                
                /// *******Description***********
                pub const CONF_W4 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] *******Description***********
                    SLCHOST_CONF16:  u8, 
                    
                    /// [8:15] *******Description***********
                    SLCHOST_CONF17:  u8, 
                    
                    /// [16:23] *******Description***********
                    SLCHOST_CONF18:  u8, 
                    
                    /// [24:31] *******Description***********
                    SLCHOST_CONF19:  u8, 
                    
                }), @ptrFromInt(0x6001707c));
                
                /// *******Description***********
                pub const CONF_W5 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] *******Description***********
                    SLCHOST_CONF20:  u8, 
                    
                    /// [8:15] *******Description***********
                    SLCHOST_CONF21:  u8, 
                    
                    /// [16:23] *******Description***********
                    SLCHOST_CONF22:  u8, 
                    
                    /// [24:31] *******Description***********
                    SLCHOST_CONF23:  u8, 
                    
                }), @ptrFromInt(0x60017080));
                
                /// *******Description***********
                pub const WIN_CMD = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:15] *******Description***********
                    SLCHOST_WIN_CMD:  u16, 
                    
                    /// [16:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60017084));
                
                /// *******Description***********
                pub const CONF_W6 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] *******Description***********
                    SLCHOST_CONF24:  u8, 
                    
                    /// [8:15] *******Description***********
                    SLCHOST_CONF25:  u8, 
                    
                    /// [16:23] *******Description***********
                    SLCHOST_CONF26:  u8, 
                    
                    /// [24:31] *******Description***********
                    SLCHOST_CONF27:  u8, 
                    
                }), @ptrFromInt(0x60017088));
                
                /// *******Description***********
                pub const CONF_W7 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] *******Description***********
                    SLCHOST_CONF28:  u8, 
                    
                    /// [8:15] *******Description***********
                    SLCHOST_CONF29:  u8, 
                    
                    /// [16:23] *******Description***********
                    SLCHOST_CONF30:  u8, 
                    
                    /// [24:31] *******Description***********
                    SLCHOST_CONF31:  u8, 
                    
                }), @ptrFromInt(0x6001708c));
                
                /// *******Description***********
                pub const PKT_LEN0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:19] *******Description***********
                    HOSTSLCHOST_SLC0_LEN0:  u20, 
                    
                    /// [20:31] *******Description***********
                    HOSTSLCHOST_SLC0_LEN0_CHECK:  u12, 
                    
                }), @ptrFromInt(0x60017090));
                
                /// *******Description***********
                pub const PKT_LEN1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:19] *******Description***********
                    HOSTSLCHOST_SLC0_LEN1:  u20, 
                    
                    /// [20:31] *******Description***********
                    HOSTSLCHOST_SLC0_LEN1_CHECK:  u12, 
                    
                }), @ptrFromInt(0x60017094));
                
                /// *******Description***********
                pub const PKT_LEN2 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:19] *******Description***********
                    HOSTSLCHOST_SLC0_LEN2:  u20, 
                    
                    /// [20:31] *******Description***********
                    HOSTSLCHOST_SLC0_LEN2_CHECK:  u12, 
                    
                }), @ptrFromInt(0x60017098));
                
                /// *******Description***********
                pub const CONF_W8 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] *******Description***********
                    SLCHOST_CONF32:  u8, 
                    
                    /// [8:15] *******Description***********
                    SLCHOST_CONF33:  u8, 
                    
                    /// [16:23] *******Description***********
                    SLCHOST_CONF34:  u8, 
                    
                    /// [24:31] *******Description***********
                    SLCHOST_CONF35:  u8, 
                    
                }), @ptrFromInt(0x6001709c));
                
                /// *******Description***********
                pub const CONF_W9 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] *******Description***********
                    SLCHOST_CONF36:  u8, 
                    
                    /// [8:15] *******Description***********
                    SLCHOST_CONF37:  u8, 
                    
                    /// [16:23] *******Description***********
                    SLCHOST_CONF38:  u8, 
                    
                    /// [24:31] *******Description***********
                    SLCHOST_CONF39:  u8, 
                    
                }), @ptrFromInt(0x600170a0));
                
                /// *******Description***********
                pub const CONF_W10 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] *******Description***********
                    SLCHOST_CONF40:  u8, 
                    
                    /// [8:15] *******Description***********
                    SLCHOST_CONF41:  u8, 
                    
                    /// [16:23] *******Description***********
                    SLCHOST_CONF42:  u8, 
                    
                    /// [24:31] *******Description***********
                    SLCHOST_CONF43:  u8, 
                    
                }), @ptrFromInt(0x600170a4));
                
                /// *******Description***********
                pub const CONF_W11 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] *******Description***********
                    SLCHOST_CONF44:  u8, 
                    
                    /// [8:15] *******Description***********
                    SLCHOST_CONF45:  u8, 
                    
                    /// [16:23] *******Description***********
                    SLCHOST_CONF46:  u8, 
                    
                    /// [24:31] *******Description***********
                    SLCHOST_CONF47:  u8, 
                    
                }), @ptrFromInt(0x600170a8));
                
                /// *******Description***********
                pub const CONF_W12 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] *******Description***********
                    SLCHOST_CONF48:  u8, 
                    
                    /// [8:15] *******Description***********
                    SLCHOST_CONF49:  u8, 
                    
                    /// [16:23] *******Description***********
                    SLCHOST_CONF50:  u8, 
                    
                    /// [24:31] *******Description***********
                    SLCHOST_CONF51:  u8, 
                    
                }), @ptrFromInt(0x600170ac));
                
                /// *******Description***********
                pub const CONF_W13 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] *******Description***********
                    SLCHOST_CONF52:  u8, 
                    
                    /// [8:15] *******Description***********
                    SLCHOST_CONF53:  u8, 
                    
                    /// [16:23] *******Description***********
                    SLCHOST_CONF54:  u8, 
                    
                    /// [24:31] *******Description***********
                    SLCHOST_CONF55:  u8, 
                    
                }), @ptrFromInt(0x600170b0));
                
                /// *******Description***********
                pub const CONF_W14 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] *******Description***********
                    SLCHOST_CONF56:  u8, 
                    
                    /// [8:15] *******Description***********
                    SLCHOST_CONF57:  u8, 
                    
                    /// [16:23] *******Description***********
                    SLCHOST_CONF58:  u8, 
                    
                    /// [24:31] *******Description***********
                    SLCHOST_CONF59:  u8, 
                    
                }), @ptrFromInt(0x600170b4));
                
                /// *******Description***********
                pub const CONF_W15 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] *******Description***********
                    SLCHOST_CONF60:  u8, 
                    
                    /// [8:15] *******Description***********
                    SLCHOST_CONF61:  u8, 
                    
                    /// [16:23] *******Description***********
                    SLCHOST_CONF62:  u8, 
                    
                    /// [24:31] *******Description***********
                    SLCHOST_CONF63:  u8, 
                    
                }), @ptrFromInt(0x600170b8));
                
                /// *******Description***********
                pub const CHECK_SUM0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] *******Description***********
                    SLCHOST_CHECK_SUM0:  u32, 
                    
                }), @ptrFromInt(0x600170bc));
                
                /// *******Description***********
                pub const CHECK_SUM1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] *******Description***********
                    SLCHOST_CHECK_SUM1:  u32, 
                    
                }), @ptrFromInt(0x600170c0));
                
                /// *******Description***********
                pub const SLC1HOST_TOKEN_RDATA = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:11] *******Description***********
                    SLC1_TOKEN0:  u12, 
                    
                    /// [12:12] *******Description***********
                    SLC1_RX_PF_VALID:  u1, 
                    
                    /// [13:15] 
                    res0:  u0, 
                    
                    /// [16:27] *******Description***********
                    HOSTSLCHOST_SLC1_TOKEN1:  u12, 
                    
                    /// [28:31] *******Description***********
                    SLC1_RX_PF_EOF:  u4, 
                    
                }), @ptrFromInt(0x600170c4));
                
                /// *******Description***********
                pub const SLC0HOST_TOKEN_WDATA = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:11] *******Description***********
                    SLC0HOST_TOKEN0_WD:  u12, 
                    
                    /// [12:15] 
                    res0:  u0, 
                    
                    /// [16:27] *******Description***********
                    SLC0HOST_TOKEN1_WD:  u12, 
                    
                    /// [28:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x600170c8));
                
                /// *******Description***********
                pub const SLC1HOST_TOKEN_WDATA = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:11] *******Description***********
                    SLC1HOST_TOKEN0_WD:  u12, 
                    
                    /// [12:15] 
                    res0:  u0, 
                    
                    /// [16:27] *******Description***********
                    SLC1HOST_TOKEN1_WD:  u12, 
                    
                    /// [28:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x600170cc));
                
                /// *******Description***********
                pub const TOKEN_CON = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] *******Description***********
                    SLC0HOST_TOKEN0_DEC:  u1, 
                    
                    /// [1:1] *******Description***********
                    SLC0HOST_TOKEN1_DEC:  u1, 
                    
                    /// [2:2] *******Description***********
                    SLC0HOST_TOKEN0_WR:  u1, 
                    
                    /// [3:3] *******Description***********
                    SLC0HOST_TOKEN1_WR:  u1, 
                    
                    /// [4:4] *******Description***********
                    SLC1HOST_TOKEN0_DEC:  u1, 
                    
                    /// [5:5] *******Description***********
                    SLC1HOST_TOKEN1_DEC:  u1, 
                    
                    /// [6:6] *******Description***********
                    SLC1HOST_TOKEN0_WR:  u1, 
                    
                    /// [7:7] *******Description***********
                    SLC1HOST_TOKEN1_WR:  u1, 
                    
                    /// [8:8] *******Description***********
                    SLC0HOST_LEN_WR:  u1, 
                    
                    /// [9:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600170d0));
                
                /// *******Description***********
                pub const SLC0HOST_INT_CLR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] *******Description***********
                    SLC0_TOHOST_BIT0_INT_CLR:  u1, 
                    
                    /// [1:1] *******Description***********
                    SLC0_TOHOST_BIT1_INT_CLR:  u1, 
                    
                    /// [2:2] *******Description***********
                    SLC0_TOHOST_BIT2_INT_CLR:  u1, 
                    
                    /// [3:3] *******Description***********
                    SLC0_TOHOST_BIT3_INT_CLR:  u1, 
                    
                    /// [4:4] *******Description***********
                    SLC0_TOHOST_BIT4_INT_CLR:  u1, 
                    
                    /// [5:5] *******Description***********
                    SLC0_TOHOST_BIT5_INT_CLR:  u1, 
                    
                    /// [6:6] *******Description***********
                    SLC0_TOHOST_BIT6_INT_CLR:  u1, 
                    
                    /// [7:7] *******Description***********
                    SLC0_TOHOST_BIT7_INT_CLR:  u1, 
                    
                    /// [8:8] *******Description***********
                    SLC0_TOKEN0_1TO0_INT_CLR:  u1, 
                    
                    /// [9:9] *******Description***********
                    SLC0_TOKEN1_1TO0_INT_CLR:  u1, 
                    
                    /// [10:10] *******Description***********
                    SLC0_TOKEN0_0TO1_INT_CLR:  u1, 
                    
                    /// [11:11] *******Description***********
                    SLC0_TOKEN1_0TO1_INT_CLR:  u1, 
                    
                    /// [12:12] *******Description***********
                    SLC0HOST_RX_SOF_INT_CLR:  u1, 
                    
                    /// [13:13] *******Description***********
                    SLC0HOST_RX_EOF_INT_CLR:  u1, 
                    
                    /// [14:14] *******Description***********
                    SLC0HOST_RX_START_INT_CLR:  u1, 
                    
                    /// [15:15] *******Description***********
                    SLC0HOST_TX_START_INT_CLR:  u1, 
                    
                    /// [16:16] *******Description***********
                    SLC0_RX_UDF_INT_CLR:  u1, 
                    
                    /// [17:17] *******Description***********
                    SLC0_TX_OVF_INT_CLR:  u1, 
                    
                    /// [18:18] *******Description***********
                    SLC0_RX_PF_VALID_INT_CLR:  u1, 
                    
                    /// [19:19] *******Description***********
                    SLC0_EXT_BIT0_INT_CLR:  u1, 
                    
                    /// [20:20] *******Description***********
                    SLC0_EXT_BIT1_INT_CLR:  u1, 
                    
                    /// [21:21] *******Description***********
                    SLC0_EXT_BIT2_INT_CLR:  u1, 
                    
                    /// [22:22] *******Description***********
                    SLC0_EXT_BIT3_INT_CLR:  u1, 
                    
                    /// [23:23] *******Description***********
                    SLC0_RX_NEW_PACKET_INT_CLR:  u1, 
                    
                    /// [24:24] *******Description***********
                    SLC0_HOST_RD_RETRY_INT_CLR:  u1, 
                    
                    /// [25:25] *******Description***********
                    GPIO_SDIO_INT_CLR:  u1, 
                    
                    /// [26:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600170d4));
                
                /// *******Description***********
                pub const SLC1HOST_INT_CLR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] *******Description***********
                    SLC1_TOHOST_BIT0_INT_CLR:  u1, 
                    
                    /// [1:1] *******Description***********
                    SLC1_TOHOST_BIT1_INT_CLR:  u1, 
                    
                    /// [2:2] *******Description***********
                    SLC1_TOHOST_BIT2_INT_CLR:  u1, 
                    
                    /// [3:3] *******Description***********
                    SLC1_TOHOST_BIT3_INT_CLR:  u1, 
                    
                    /// [4:4] *******Description***********
                    SLC1_TOHOST_BIT4_INT_CLR:  u1, 
                    
                    /// [5:5] *******Description***********
                    SLC1_TOHOST_BIT5_INT_CLR:  u1, 
                    
                    /// [6:6] *******Description***********
                    SLC1_TOHOST_BIT6_INT_CLR:  u1, 
                    
                    /// [7:7] *******Description***********
                    SLC1_TOHOST_BIT7_INT_CLR:  u1, 
                    
                    /// [8:8] *******Description***********
                    SLC1_TOKEN0_1TO0_INT_CLR:  u1, 
                    
                    /// [9:9] *******Description***********
                    SLC1_TOKEN1_1TO0_INT_CLR:  u1, 
                    
                    /// [10:10] *******Description***********
                    SLC1_TOKEN0_0TO1_INT_CLR:  u1, 
                    
                    /// [11:11] *******Description***********
                    SLC1_TOKEN1_0TO1_INT_CLR:  u1, 
                    
                    /// [12:12] *******Description***********
                    SLC1HOST_RX_SOF_INT_CLR:  u1, 
                    
                    /// [13:13] *******Description***********
                    SLC1HOST_RX_EOF_INT_CLR:  u1, 
                    
                    /// [14:14] *******Description***********
                    SLC1HOST_RX_START_INT_CLR:  u1, 
                    
                    /// [15:15] *******Description***********
                    SLC1HOST_TX_START_INT_CLR:  u1, 
                    
                    /// [16:16] *******Description***********
                    SLC1_RX_UDF_INT_CLR:  u1, 
                    
                    /// [17:17] *******Description***********
                    SLC1_TX_OVF_INT_CLR:  u1, 
                    
                    /// [18:18] *******Description***********
                    SLC1_RX_PF_VALID_INT_CLR:  u1, 
                    
                    /// [19:19] *******Description***********
                    SLC1_EXT_BIT0_INT_CLR:  u1, 
                    
                    /// [20:20] *******Description***********
                    SLC1_EXT_BIT1_INT_CLR:  u1, 
                    
                    /// [21:21] *******Description***********
                    SLC1_EXT_BIT2_INT_CLR:  u1, 
                    
                    /// [22:22] *******Description***********
                    SLC1_EXT_BIT3_INT_CLR:  u1, 
                    
                    /// [23:23] *******Description***********
                    SLC1_WIFI_RX_NEW_PACKET_INT_CLR:  u1, 
                    
                    /// [24:24] *******Description***********
                    SLC1_HOST_RD_RETRY_INT_CLR:  u1, 
                    
                    /// [25:25] *******Description***********
                    SLC1_BT_RX_NEW_PACKET_INT_CLR:  u1, 
                    
                    /// [26:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600170d8));
                
                /// *******Description***********
                pub const SLC0HOST_FUNC1_INT_ENA = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] *******Description***********
                    FN1_SLC0_TOHOST_BIT0_INT_ENA:  u1, 
                    
                    /// [1:1] *******Description***********
                    FN1_SLC0_TOHOST_BIT1_INT_ENA:  u1, 
                    
                    /// [2:2] *******Description***********
                    FN1_SLC0_TOHOST_BIT2_INT_ENA:  u1, 
                    
                    /// [3:3] *******Description***********
                    FN1_SLC0_TOHOST_BIT3_INT_ENA:  u1, 
                    
                    /// [4:4] *******Description***********
                    FN1_SLC0_TOHOST_BIT4_INT_ENA:  u1, 
                    
                    /// [5:5] *******Description***********
                    FN1_SLC0_TOHOST_BIT5_INT_ENA:  u1, 
                    
                    /// [6:6] *******Description***********
                    FN1_SLC0_TOHOST_BIT6_INT_ENA:  u1, 
                    
                    /// [7:7] *******Description***********
                    FN1_SLC0_TOHOST_BIT7_INT_ENA:  u1, 
                    
                    /// [8:8] *******Description***********
                    FN1_SLC0_TOKEN0_1TO0_INT_ENA:  u1, 
                    
                    /// [9:9] *******Description***********
                    FN1_SLC0_TOKEN1_1TO0_INT_ENA:  u1, 
                    
                    /// [10:10] *******Description***********
                    FN1_SLC0_TOKEN0_0TO1_INT_ENA:  u1, 
                    
                    /// [11:11] *******Description***********
                    FN1_SLC0_TOKEN1_0TO1_INT_ENA:  u1, 
                    
                    /// [12:12] *******Description***********
                    FN1_SLC0HOST_RX_SOF_INT_ENA:  u1, 
                    
                    /// [13:13] *******Description***********
                    FN1_SLC0HOST_RX_EOF_INT_ENA:  u1, 
                    
                    /// [14:14] *******Description***********
                    FN1_SLC0HOST_RX_START_INT_ENA:  u1, 
                    
                    /// [15:15] *******Description***********
                    FN1_SLC0HOST_TX_START_INT_ENA:  u1, 
                    
                    /// [16:16] *******Description***********
                    FN1_SLC0_RX_UDF_INT_ENA:  u1, 
                    
                    /// [17:17] *******Description***********
                    FN1_SLC0_TX_OVF_INT_ENA:  u1, 
                    
                    /// [18:18] *******Description***********
                    FN1_SLC0_RX_PF_VALID_INT_ENA:  u1, 
                    
                    /// [19:19] *******Description***********
                    FN1_SLC0_EXT_BIT0_INT_ENA:  u1, 
                    
                    /// [20:20] *******Description***********
                    FN1_SLC0_EXT_BIT1_INT_ENA:  u1, 
                    
                    /// [21:21] *******Description***********
                    FN1_SLC0_EXT_BIT2_INT_ENA:  u1, 
                    
                    /// [22:22] *******Description***********
                    FN1_SLC0_EXT_BIT3_INT_ENA:  u1, 
                    
                    /// [23:23] *******Description***********
                    FN1_SLC0_RX_NEW_PACKET_INT_ENA:  u1, 
                    
                    /// [24:24] *******Description***********
                    FN1_SLC0_HOST_RD_RETRY_INT_ENA:  u1, 
                    
                    /// [25:25] *******Description***********
                    FN1_GPIO_SDIO_INT_ENA:  u1, 
                    
                    /// [26:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600170dc));
                
                /// *******Description***********
                pub const SLC1HOST_FUNC1_INT_ENA = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] *******Description***********
                    FN1_SLC1_TOHOST_BIT0_INT_ENA:  u1, 
                    
                    /// [1:1] *******Description***********
                    FN1_SLC1_TOHOST_BIT1_INT_ENA:  u1, 
                    
                    /// [2:2] *******Description***********
                    FN1_SLC1_TOHOST_BIT2_INT_ENA:  u1, 
                    
                    /// [3:3] *******Description***********
                    FN1_SLC1_TOHOST_BIT3_INT_ENA:  u1, 
                    
                    /// [4:4] *******Description***********
                    FN1_SLC1_TOHOST_BIT4_INT_ENA:  u1, 
                    
                    /// [5:5] *******Description***********
                    FN1_SLC1_TOHOST_BIT5_INT_ENA:  u1, 
                    
                    /// [6:6] *******Description***********
                    FN1_SLC1_TOHOST_BIT6_INT_ENA:  u1, 
                    
                    /// [7:7] *******Description***********
                    FN1_SLC1_TOHOST_BIT7_INT_ENA:  u1, 
                    
                    /// [8:8] *******Description***********
                    FN1_SLC1_TOKEN0_1TO0_INT_ENA:  u1, 
                    
                    /// [9:9] *******Description***********
                    FN1_SLC1_TOKEN1_1TO0_INT_ENA:  u1, 
                    
                    /// [10:10] *******Description***********
                    FN1_SLC1_TOKEN0_0TO1_INT_ENA:  u1, 
                    
                    /// [11:11] *******Description***********
                    FN1_SLC1_TOKEN1_0TO1_INT_ENA:  u1, 
                    
                    /// [12:12] *******Description***********
                    FN1_SLC1HOST_RX_SOF_INT_ENA:  u1, 
                    
                    /// [13:13] *******Description***********
                    FN1_SLC1HOST_RX_EOF_INT_ENA:  u1, 
                    
                    /// [14:14] *******Description***********
                    FN1_SLC1HOST_RX_START_INT_ENA:  u1, 
                    
                    /// [15:15] *******Description***********
                    FN1_SLC1HOST_TX_START_INT_ENA:  u1, 
                    
                    /// [16:16] *******Description***********
                    FN1_SLC1_RX_UDF_INT_ENA:  u1, 
                    
                    /// [17:17] *******Description***********
                    FN1_SLC1_TX_OVF_INT_ENA:  u1, 
                    
                    /// [18:18] *******Description***********
                    FN1_SLC1_RX_PF_VALID_INT_ENA:  u1, 
                    
                    /// [19:19] *******Description***********
                    FN1_SLC1_EXT_BIT0_INT_ENA:  u1, 
                    
                    /// [20:20] *******Description***********
                    FN1_SLC1_EXT_BIT1_INT_ENA:  u1, 
                    
                    /// [21:21] *******Description***********
                    FN1_SLC1_EXT_BIT2_INT_ENA:  u1, 
                    
                    /// [22:22] *******Description***********
                    FN1_SLC1_EXT_BIT3_INT_ENA:  u1, 
                    
                    /// [23:23] *******Description***********
                    FN1_SLC1_WIFI_RX_NEW_PACKET_INT_ENA:  u1, 
                    
                    /// [24:24] *******Description***********
                    FN1_SLC1_HOST_RD_RETRY_INT_ENA:  u1, 
                    
                    /// [25:25] *******Description***********
                    FN1_SLC1_BT_RX_NEW_PACKET_INT_ENA:  u1, 
                    
                    /// [26:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600170e0));
                
                /// *******Description***********
                pub const SLC0HOST_FUNC2_INT_ENA = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] *******Description***********
                    FN2_SLC0_TOHOST_BIT0_INT_ENA:  u1, 
                    
                    /// [1:1] *******Description***********
                    FN2_SLC0_TOHOST_BIT1_INT_ENA:  u1, 
                    
                    /// [2:2] *******Description***********
                    FN2_SLC0_TOHOST_BIT2_INT_ENA:  u1, 
                    
                    /// [3:3] *******Description***********
                    FN2_SLC0_TOHOST_BIT3_INT_ENA:  u1, 
                    
                    /// [4:4] *******Description***********
                    FN2_SLC0_TOHOST_BIT4_INT_ENA:  u1, 
                    
                    /// [5:5] *******Description***********
                    FN2_SLC0_TOHOST_BIT5_INT_ENA:  u1, 
                    
                    /// [6:6] *******Description***********
                    FN2_SLC0_TOHOST_BIT6_INT_ENA:  u1, 
                    
                    /// [7:7] *******Description***********
                    FN2_SLC0_TOHOST_BIT7_INT_ENA:  u1, 
                    
                    /// [8:8] *******Description***********
                    FN2_SLC0_TOKEN0_1TO0_INT_ENA:  u1, 
                    
                    /// [9:9] *******Description***********
                    FN2_SLC0_TOKEN1_1TO0_INT_ENA:  u1, 
                    
                    /// [10:10] *******Description***********
                    FN2_SLC0_TOKEN0_0TO1_INT_ENA:  u1, 
                    
                    /// [11:11] *******Description***********
                    FN2_SLC0_TOKEN1_0TO1_INT_ENA:  u1, 
                    
                    /// [12:12] *******Description***********
                    FN2_SLC0HOST_RX_SOF_INT_ENA:  u1, 
                    
                    /// [13:13] *******Description***********
                    FN2_SLC0HOST_RX_EOF_INT_ENA:  u1, 
                    
                    /// [14:14] *******Description***********
                    FN2_SLC0HOST_RX_START_INT_ENA:  u1, 
                    
                    /// [15:15] *******Description***********
                    FN2_SLC0HOST_TX_START_INT_ENA:  u1, 
                    
                    /// [16:16] *******Description***********
                    FN2_SLC0_RX_UDF_INT_ENA:  u1, 
                    
                    /// [17:17] *******Description***********
                    FN2_SLC0_TX_OVF_INT_ENA:  u1, 
                    
                    /// [18:18] *******Description***********
                    FN2_SLC0_RX_PF_VALID_INT_ENA:  u1, 
                    
                    /// [19:19] *******Description***********
                    FN2_SLC0_EXT_BIT0_INT_ENA:  u1, 
                    
                    /// [20:20] *******Description***********
                    FN2_SLC0_EXT_BIT1_INT_ENA:  u1, 
                    
                    /// [21:21] *******Description***********
                    FN2_SLC0_EXT_BIT2_INT_ENA:  u1, 
                    
                    /// [22:22] *******Description***********
                    FN2_SLC0_EXT_BIT3_INT_ENA:  u1, 
                    
                    /// [23:23] *******Description***********
                    FN2_SLC0_RX_NEW_PACKET_INT_ENA:  u1, 
                    
                    /// [24:24] *******Description***********
                    FN2_SLC0_HOST_RD_RETRY_INT_ENA:  u1, 
                    
                    /// [25:25] *******Description***********
                    FN2_GPIO_SDIO_INT_ENA:  u1, 
                    
                    /// [26:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600170e4));
                
                /// *******Description***********
                pub const SLC1HOST_FUNC2_INT_ENA = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] *******Description***********
                    FN2_SLC1_TOHOST_BIT0_INT_ENA:  u1, 
                    
                    /// [1:1] *******Description***********
                    FN2_SLC1_TOHOST_BIT1_INT_ENA:  u1, 
                    
                    /// [2:2] *******Description***********
                    FN2_SLC1_TOHOST_BIT2_INT_ENA:  u1, 
                    
                    /// [3:3] *******Description***********
                    FN2_SLC1_TOHOST_BIT3_INT_ENA:  u1, 
                    
                    /// [4:4] *******Description***********
                    FN2_SLC1_TOHOST_BIT4_INT_ENA:  u1, 
                    
                    /// [5:5] *******Description***********
                    FN2_SLC1_TOHOST_BIT5_INT_ENA:  u1, 
                    
                    /// [6:6] *******Description***********
                    FN2_SLC1_TOHOST_BIT6_INT_ENA:  u1, 
                    
                    /// [7:7] *******Description***********
                    FN2_SLC1_TOHOST_BIT7_INT_ENA:  u1, 
                    
                    /// [8:8] *******Description***********
                    FN2_SLC1_TOKEN0_1TO0_INT_ENA:  u1, 
                    
                    /// [9:9] *******Description***********
                    FN2_SLC1_TOKEN1_1TO0_INT_ENA:  u1, 
                    
                    /// [10:10] *******Description***********
                    FN2_SLC1_TOKEN0_0TO1_INT_ENA:  u1, 
                    
                    /// [11:11] *******Description***********
                    FN2_SLC1_TOKEN1_0TO1_INT_ENA:  u1, 
                    
                    /// [12:12] *******Description***********
                    FN2_SLC1HOST_RX_SOF_INT_ENA:  u1, 
                    
                    /// [13:13] *******Description***********
                    FN2_SLC1HOST_RX_EOF_INT_ENA:  u1, 
                    
                    /// [14:14] *******Description***********
                    FN2_SLC1HOST_RX_START_INT_ENA:  u1, 
                    
                    /// [15:15] *******Description***********
                    FN2_SLC1HOST_TX_START_INT_ENA:  u1, 
                    
                    /// [16:16] *******Description***********
                    FN2_SLC1_RX_UDF_INT_ENA:  u1, 
                    
                    /// [17:17] *******Description***********
                    FN2_SLC1_TX_OVF_INT_ENA:  u1, 
                    
                    /// [18:18] *******Description***********
                    FN2_SLC1_RX_PF_VALID_INT_ENA:  u1, 
                    
                    /// [19:19] *******Description***********
                    FN2_SLC1_EXT_BIT0_INT_ENA:  u1, 
                    
                    /// [20:20] *******Description***********
                    FN2_SLC1_EXT_BIT1_INT_ENA:  u1, 
                    
                    /// [21:21] *******Description***********
                    FN2_SLC1_EXT_BIT2_INT_ENA:  u1, 
                    
                    /// [22:22] *******Description***********
                    FN2_SLC1_EXT_BIT3_INT_ENA:  u1, 
                    
                    /// [23:23] *******Description***********
                    FN2_SLC1_WIFI_RX_NEW_PACKET_INT_ENA:  u1, 
                    
                    /// [24:24] *******Description***********
                    FN2_SLC1_HOST_RD_RETRY_INT_ENA:  u1, 
                    
                    /// [25:25] *******Description***********
                    FN2_SLC1_BT_RX_NEW_PACKET_INT_ENA:  u1, 
                    
                    /// [26:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600170e8));
                
                /// *******Description***********
                pub const SLC0HOST_INT_ENA = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] *******Description***********
                    SLC0_TOHOST_BIT0_INT_ENA:  u1, 
                    
                    /// [1:1] *******Description***********
                    SLC0_TOHOST_BIT1_INT_ENA:  u1, 
                    
                    /// [2:2] *******Description***********
                    SLC0_TOHOST_BIT2_INT_ENA:  u1, 
                    
                    /// [3:3] *******Description***********
                    SLC0_TOHOST_BIT3_INT_ENA:  u1, 
                    
                    /// [4:4] *******Description***********
                    SLC0_TOHOST_BIT4_INT_ENA:  u1, 
                    
                    /// [5:5] *******Description***********
                    SLC0_TOHOST_BIT5_INT_ENA:  u1, 
                    
                    /// [6:6] *******Description***********
                    SLC0_TOHOST_BIT6_INT_ENA:  u1, 
                    
                    /// [7:7] *******Description***********
                    SLC0_TOHOST_BIT7_INT_ENA:  u1, 
                    
                    /// [8:8] *******Description***********
                    SLC0_TOKEN0_1TO0_INT_ENA:  u1, 
                    
                    /// [9:9] *******Description***********
                    SLC0_TOKEN1_1TO0_INT_ENA:  u1, 
                    
                    /// [10:10] *******Description***********
                    SLC0_TOKEN0_0TO1_INT_ENA:  u1, 
                    
                    /// [11:11] *******Description***********
                    SLC0_TOKEN1_0TO1_INT_ENA:  u1, 
                    
                    /// [12:12] *******Description***********
                    SLC0HOST_RX_SOF_INT_ENA:  u1, 
                    
                    /// [13:13] *******Description***********
                    SLC0HOST_RX_EOF_INT_ENA:  u1, 
                    
                    /// [14:14] *******Description***********
                    SLC0HOST_RX_START_INT_ENA:  u1, 
                    
                    /// [15:15] *******Description***********
                    SLC0HOST_TX_START_INT_ENA:  u1, 
                    
                    /// [16:16] *******Description***********
                    SLC0_RX_UDF_INT_ENA:  u1, 
                    
                    /// [17:17] *******Description***********
                    SLC0_TX_OVF_INT_ENA:  u1, 
                    
                    /// [18:18] *******Description***********
                    SLC0_RX_PF_VALID_INT_ENA:  u1, 
                    
                    /// [19:19] *******Description***********
                    SLC0_EXT_BIT0_INT_ENA:  u1, 
                    
                    /// [20:20] *******Description***********
                    SLC0_EXT_BIT1_INT_ENA:  u1, 
                    
                    /// [21:21] *******Description***********
                    SLC0_EXT_BIT2_INT_ENA:  u1, 
                    
                    /// [22:22] *******Description***********
                    SLC0_EXT_BIT3_INT_ENA:  u1, 
                    
                    /// [23:23] *******Description***********
                    SLC0_RX_NEW_PACKET_INT_ENA:  u1, 
                    
                    /// [24:24] *******Description***********
                    SLC0_HOST_RD_RETRY_INT_ENA:  u1, 
                    
                    /// [25:25] *******Description***********
                    GPIO_SDIO_INT_ENA:  u1, 
                    
                    /// [26:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600170ec));
                
                /// *******Description***********
                pub const SLC1HOST_INT_ENA = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] *******Description***********
                    SLC1_TOHOST_BIT0_INT_ENA:  u1, 
                    
                    /// [1:1] *******Description***********
                    SLC1_TOHOST_BIT1_INT_ENA:  u1, 
                    
                    /// [2:2] *******Description***********
                    SLC1_TOHOST_BIT2_INT_ENA:  u1, 
                    
                    /// [3:3] *******Description***********
                    SLC1_TOHOST_BIT3_INT_ENA:  u1, 
                    
                    /// [4:4] *******Description***********
                    SLC1_TOHOST_BIT4_INT_ENA:  u1, 
                    
                    /// [5:5] *******Description***********
                    SLC1_TOHOST_BIT5_INT_ENA:  u1, 
                    
                    /// [6:6] *******Description***********
                    SLC1_TOHOST_BIT6_INT_ENA:  u1, 
                    
                    /// [7:7] *******Description***********
                    SLC1_TOHOST_BIT7_INT_ENA:  u1, 
                    
                    /// [8:8] *******Description***********
                    SLC1_TOKEN0_1TO0_INT_ENA:  u1, 
                    
                    /// [9:9] *******Description***********
                    SLC1_TOKEN1_1TO0_INT_ENA:  u1, 
                    
                    /// [10:10] *******Description***********
                    SLC1_TOKEN0_0TO1_INT_ENA:  u1, 
                    
                    /// [11:11] *******Description***********
                    SLC1_TOKEN1_0TO1_INT_ENA:  u1, 
                    
                    /// [12:12] *******Description***********
                    SLC1HOST_RX_SOF_INT_ENA:  u1, 
                    
                    /// [13:13] *******Description***********
                    SLC1HOST_RX_EOF_INT_ENA:  u1, 
                    
                    /// [14:14] *******Description***********
                    SLC1HOST_RX_START_INT_ENA:  u1, 
                    
                    /// [15:15] *******Description***********
                    SLC1HOST_TX_START_INT_ENA:  u1, 
                    
                    /// [16:16] *******Description***********
                    SLC1_RX_UDF_INT_ENA:  u1, 
                    
                    /// [17:17] *******Description***********
                    SLC1_TX_OVF_INT_ENA:  u1, 
                    
                    /// [18:18] *******Description***********
                    SLC1_RX_PF_VALID_INT_ENA:  u1, 
                    
                    /// [19:19] *******Description***********
                    SLC1_EXT_BIT0_INT_ENA:  u1, 
                    
                    /// [20:20] *******Description***********
                    SLC1_EXT_BIT1_INT_ENA:  u1, 
                    
                    /// [21:21] *******Description***********
                    SLC1_EXT_BIT2_INT_ENA:  u1, 
                    
                    /// [22:22] *******Description***********
                    SLC1_EXT_BIT3_INT_ENA:  u1, 
                    
                    /// [23:23] *******Description***********
                    SLC1_WIFI_RX_NEW_PACKET_INT_ENA:  u1, 
                    
                    /// [24:24] *******Description***********
                    SLC1_HOST_RD_RETRY_INT_ENA:  u1, 
                    
                    /// [25:25] *******Description***********
                    SLC1_BT_RX_NEW_PACKET_INT_ENA:  u1, 
                    
                    /// [26:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600170f0));
                
                /// *******Description***********
                pub const SLC0HOST_RX_INFOR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:19] *******Description***********
                    SLC0HOST_RX_INFOR:  u20, 
                    
                    /// [20:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600170f4));
                
                /// *******Description***********
                pub const SLC1HOST_RX_INFOR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:19] *******Description***********
                    SLC1HOST_RX_INFOR:  u20, 
                    
                    /// [20:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600170f8));
                
                /// *******Description***********
                pub const SLC0HOST_LEN_WD = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] *******Description***********
                    SLC0HOST_LEN_WD:  u32, 
                    
                }), @ptrFromInt(0x600170fc));
                
                /// *******Description***********
                pub const SLC_APBWIN_WDATA = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] *******Description***********
                    SLC_APBWIN_WDATA:  u32, 
                    
                }), @ptrFromInt(0x60017100));
                
                /// *******Description***********
                pub const SLC_APBWIN_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:27] *******Description***********
                    SLC_APBWIN_ADDR:  u28, 
                    
                    /// [28:28] *******Description***********
                    SLC_APBWIN_WR:  u1, 
                    
                    /// [29:29] *******Description***********
                    SLC_APBWIN_START:  u1, 
                    
                    /// [30:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60017104));
                
                /// *******Description***********
                pub const SLC_APBWIN_RDATA = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] *******Description***********
                    SLC_APBWIN_RDATA:  u32, 
                    
                }), @ptrFromInt(0x60017108));
                
                /// *******Description***********
                pub const RDCLR0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:8] *******Description***********
                    SLCHOST_SLC0_BIT7_CLRADDR:  u9, 
                    
                    /// [9:17] *******Description***********
                    SLCHOST_SLC0_BIT6_CLRADDR:  u9, 
                    
                    /// [18:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6001710c));
                
                /// *******Description***********
                pub const RDCLR1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:8] *******Description***********
                    SLCHOST_SLC1_BIT7_CLRADDR:  u9, 
                    
                    /// [9:17] *******Description***********
                    SLCHOST_SLC1_BIT6_CLRADDR:  u9, 
                    
                    /// [18:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60017110));
                
                /// *******Description***********
                pub const SLC0HOST_INT_ENA1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] *******Description***********
                    SLC0_TOHOST_BIT0_INT_ENA1:  u1, 
                    
                    /// [1:1] *******Description***********
                    SLC0_TOHOST_BIT1_INT_ENA1:  u1, 
                    
                    /// [2:2] *******Description***********
                    SLC0_TOHOST_BIT2_INT_ENA1:  u1, 
                    
                    /// [3:3] *******Description***********
                    SLC0_TOHOST_BIT3_INT_ENA1:  u1, 
                    
                    /// [4:4] *******Description***********
                    SLC0_TOHOST_BIT4_INT_ENA1:  u1, 
                    
                    /// [5:5] *******Description***********
                    SLC0_TOHOST_BIT5_INT_ENA1:  u1, 
                    
                    /// [6:6] *******Description***********
                    SLC0_TOHOST_BIT6_INT_ENA1:  u1, 
                    
                    /// [7:7] *******Description***********
                    SLC0_TOHOST_BIT7_INT_ENA1:  u1, 
                    
                    /// [8:8] *******Description***********
                    SLC0_TOKEN0_1TO0_INT_ENA1:  u1, 
                    
                    /// [9:9] *******Description***********
                    SLC0_TOKEN1_1TO0_INT_ENA1:  u1, 
                    
                    /// [10:10] *******Description***********
                    SLC0_TOKEN0_0TO1_INT_ENA1:  u1, 
                    
                    /// [11:11] *******Description***********
                    SLC0_TOKEN1_0TO1_INT_ENA1:  u1, 
                    
                    /// [12:12] *******Description***********
                    SLC0HOST_RX_SOF_INT_ENA1:  u1, 
                    
                    /// [13:13] *******Description***********
                    SLC0HOST_RX_EOF_INT_ENA1:  u1, 
                    
                    /// [14:14] *******Description***********
                    SLC0HOST_RX_START_INT_ENA1:  u1, 
                    
                    /// [15:15] *******Description***********
                    SLC0HOST_TX_START_INT_ENA1:  u1, 
                    
                    /// [16:16] *******Description***********
                    SLC0_RX_UDF_INT_ENA1:  u1, 
                    
                    /// [17:17] *******Description***********
                    SLC0_TX_OVF_INT_ENA1:  u1, 
                    
                    /// [18:18] *******Description***********
                    SLC0_RX_PF_VALID_INT_ENA1:  u1, 
                    
                    /// [19:19] *******Description***********
                    SLC0_EXT_BIT0_INT_ENA1:  u1, 
                    
                    /// [20:20] *******Description***********
                    SLC0_EXT_BIT1_INT_ENA1:  u1, 
                    
                    /// [21:21] *******Description***********
                    SLC0_EXT_BIT2_INT_ENA1:  u1, 
                    
                    /// [22:22] *******Description***********
                    SLC0_EXT_BIT3_INT_ENA1:  u1, 
                    
                    /// [23:23] *******Description***********
                    SLC0_RX_NEW_PACKET_INT_ENA1:  u1, 
                    
                    /// [24:24] *******Description***********
                    SLC0_HOST_RD_RETRY_INT_ENA1:  u1, 
                    
                    /// [25:25] *******Description***********
                    GPIO_SDIO_INT_ENA1:  u1, 
                    
                    /// [26:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60017114));
                
                /// *******Description***********
                pub const SLC1HOST_INT_ENA1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] *******Description***********
                    SLC1_TOHOST_BIT0_INT_ENA1:  u1, 
                    
                    /// [1:1] *******Description***********
                    SLC1_TOHOST_BIT1_INT_ENA1:  u1, 
                    
                    /// [2:2] *******Description***********
                    SLC1_TOHOST_BIT2_INT_ENA1:  u1, 
                    
                    /// [3:3] *******Description***********
                    SLC1_TOHOST_BIT3_INT_ENA1:  u1, 
                    
                    /// [4:4] *******Description***********
                    SLC1_TOHOST_BIT4_INT_ENA1:  u1, 
                    
                    /// [5:5] *******Description***********
                    SLC1_TOHOST_BIT5_INT_ENA1:  u1, 
                    
                    /// [6:6] *******Description***********
                    SLC1_TOHOST_BIT6_INT_ENA1:  u1, 
                    
                    /// [7:7] *******Description***********
                    SLC1_TOHOST_BIT7_INT_ENA1:  u1, 
                    
                    /// [8:8] *******Description***********
                    SLC1_TOKEN0_1TO0_INT_ENA1:  u1, 
                    
                    /// [9:9] *******Description***********
                    SLC1_TOKEN1_1TO0_INT_ENA1:  u1, 
                    
                    /// [10:10] *******Description***********
                    SLC1_TOKEN0_0TO1_INT_ENA1:  u1, 
                    
                    /// [11:11] *******Description***********
                    SLC1_TOKEN1_0TO1_INT_ENA1:  u1, 
                    
                    /// [12:12] *******Description***********
                    SLC1HOST_RX_SOF_INT_ENA1:  u1, 
                    
                    /// [13:13] *******Description***********
                    SLC1HOST_RX_EOF_INT_ENA1:  u1, 
                    
                    /// [14:14] *******Description***********
                    SLC1HOST_RX_START_INT_ENA1:  u1, 
                    
                    /// [15:15] *******Description***********
                    SLC1HOST_TX_START_INT_ENA1:  u1, 
                    
                    /// [16:16] *******Description***********
                    SLC1_RX_UDF_INT_ENA1:  u1, 
                    
                    /// [17:17] *******Description***********
                    SLC1_TX_OVF_INT_ENA1:  u1, 
                    
                    /// [18:18] *******Description***********
                    SLC1_RX_PF_VALID_INT_ENA1:  u1, 
                    
                    /// [19:19] *******Description***********
                    SLC1_EXT_BIT0_INT_ENA1:  u1, 
                    
                    /// [20:20] *******Description***********
                    SLC1_EXT_BIT1_INT_ENA1:  u1, 
                    
                    /// [21:21] *******Description***********
                    SLC1_EXT_BIT2_INT_ENA1:  u1, 
                    
                    /// [22:22] *******Description***********
                    SLC1_EXT_BIT3_INT_ENA1:  u1, 
                    
                    /// [23:23] *******Description***********
                    SLC1_WIFI_RX_NEW_PACKET_INT_ENA1:  u1, 
                    
                    /// [24:24] *******Description***********
                    SLC1_HOST_RD_RETRY_INT_ENA1:  u1, 
                    
                    /// [25:25] *******Description***********
                    SLC1_BT_RX_NEW_PACKET_INT_ENA1:  u1, 
                    
                    /// [26:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60017118));
                
                /// *******Description***********
                pub const SLCHOSTDATE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] *******Description***********
                    SLCHOST_DATE:  u32, 
                    
                }), @ptrFromInt(0x60017178));
                
                /// *******Description***********
                pub const SLCHOSTID = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] *******Description***********
                    SLCHOST_ID:  u32, 
                    
                }), @ptrFromInt(0x6001717c));
                
                /// *******Description***********
                pub const CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:4] *******Description***********
                    FRC_SDIO11:  u5, 
                    
                    /// [5:9] *******Description***********
                    FRC_SDIO20:  u5, 
                    
                    /// [10:14] *******Description***********
                    FRC_NEG_SAMP:  u5, 
                    
                    /// [15:19] *******Description***********
                    FRC_POS_SAMP:  u5, 
                    
                    /// [20:24] *******Description***********
                    FRC_QUICK_IN:  u5, 
                    
                    /// [25:25] *******Description***********
                    SDIO20_INT_DELAY:  u1, 
                    
                    /// [26:26] *******Description***********
                    SDIO_PAD_PULLUP:  u1, 
                    
                    /// [27:27] *******Description***********
                    HSPEED_CON_EN:  u1, 
                    
                    /// [28:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600171f0));
                
                /// *******Description***********
                pub const INF_ST = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:4] *******Description***********
                    SDIO20_MODE:  u5, 
                    
                    /// [5:9] *******Description***********
                    SDIO_NEG_SAMP:  u5, 
                    
                    /// [10:14] *******Description***********
                    SDIO_QUICK_IN:  u5, 
                    
                    /// [15:15] dll is controlled by software
                    DLL_ON_SW:  u1, 
                    
                    /// [16:16] Software dll on
                    DLL_ON:  u1, 
                    
                    /// [17:17] dll clock mode is controlled by software
                    CLK_MODE_SW:  u1, 
                    
                    /// [18:19] Software set clock mode
                    CLK_MODE:  u2, 
                    
                    /// [20:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600171f4));
                
            };
            
            /// SOC_ETM Peripheral
            pub const SOC_ETM = struct {
                
                /// channel enable register
                pub const CH_ENA_AD0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] ch0 enable
                    CH_ENA0:  u1, 
                    
                    /// [1:1] ch1 enable
                    CH_ENA1:  u1, 
                    
                    /// [2:2] ch2 enable
                    CH_ENA2:  u1, 
                    
                    /// [3:3] ch3 enable
                    CH_ENA3:  u1, 
                    
                    /// [4:4] ch4 enable
                    CH_ENA4:  u1, 
                    
                    /// [5:5] ch5 enable
                    CH_ENA5:  u1, 
                    
                    /// [6:6] ch6 enable
                    CH_ENA6:  u1, 
                    
                    /// [7:7] ch7 enable
                    CH_ENA7:  u1, 
                    
                    /// [8:8] ch8 enable
                    CH_ENA8:  u1, 
                    
                    /// [9:9] ch9 enable
                    CH_ENA9:  u1, 
                    
                    /// [10:10] ch10 enable
                    CH_ENA10:  u1, 
                    
                    /// [11:11] ch11 enable
                    CH_ENA11:  u1, 
                    
                    /// [12:12] ch12 enable
                    CH_ENA12:  u1, 
                    
                    /// [13:13] ch13 enable
                    CH_ENA13:  u1, 
                    
                    /// [14:14] ch14 enable
                    CH_ENA14:  u1, 
                    
                    /// [15:15] ch15 enable
                    CH_ENA15:  u1, 
                    
                    /// [16:16] ch16 enable
                    CH_ENA16:  u1, 
                    
                    /// [17:17] ch17 enable
                    CH_ENA17:  u1, 
                    
                    /// [18:18] ch18 enable
                    CH_ENA18:  u1, 
                    
                    /// [19:19] ch19 enable
                    CH_ENA19:  u1, 
                    
                    /// [20:20] ch20 enable
                    CH_ENA20:  u1, 
                    
                    /// [21:21] ch21 enable
                    CH_ENA21:  u1, 
                    
                    /// [22:22] ch22 enable
                    CH_ENA22:  u1, 
                    
                    /// [23:23] ch23 enable
                    CH_ENA23:  u1, 
                    
                    /// [24:24] ch24 enable
                    CH_ENA24:  u1, 
                    
                    /// [25:25] ch25 enable
                    CH_ENA25:  u1, 
                    
                    /// [26:26] ch26 enable
                    CH_ENA26:  u1, 
                    
                    /// [27:27] ch27 enable
                    CH_ENA27:  u1, 
                    
                    /// [28:28] ch28 enable
                    CH_ENA28:  u1, 
                    
                    /// [29:29] ch29 enable
                    CH_ENA29:  u1, 
                    
                    /// [30:30] ch30 enable
                    CH_ENA30:  u1, 
                    
                    /// [31:31] ch31 enable
                    CH_ENA31:  u1, 
                    
                }), @ptrFromInt(0x60013000));
                
                /// channel enable set register
                pub const CH_ENA_AD0_SET = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] ch0 set
                    CH_SET0:  u1, 
                    
                    /// [1:1] ch1 set
                    CH_SET1:  u1, 
                    
                    /// [2:2] ch2 set
                    CH_SET2:  u1, 
                    
                    /// [3:3] ch3 set
                    CH_SET3:  u1, 
                    
                    /// [4:4] ch4 set
                    CH_SET4:  u1, 
                    
                    /// [5:5] ch5 set
                    CH_SET5:  u1, 
                    
                    /// [6:6] ch6 set
                    CH_SET6:  u1, 
                    
                    /// [7:7] ch7 set
                    CH_SET7:  u1, 
                    
                    /// [8:8] ch8 set
                    CH_SET8:  u1, 
                    
                    /// [9:9] ch9 set
                    CH_SET9:  u1, 
                    
                    /// [10:10] ch10 set
                    CH_SET10:  u1, 
                    
                    /// [11:11] ch11 set
                    CH_SET11:  u1, 
                    
                    /// [12:12] ch12 set
                    CH_SET12:  u1, 
                    
                    /// [13:13] ch13 set
                    CH_SET13:  u1, 
                    
                    /// [14:14] ch14 set
                    CH_SET14:  u1, 
                    
                    /// [15:15] ch15 set
                    CH_SET15:  u1, 
                    
                    /// [16:16] ch16 set
                    CH_SET16:  u1, 
                    
                    /// [17:17] ch17 set
                    CH_SET17:  u1, 
                    
                    /// [18:18] ch18 set
                    CH_SET18:  u1, 
                    
                    /// [19:19] ch19 set
                    CH_SET19:  u1, 
                    
                    /// [20:20] ch20 set
                    CH_SET20:  u1, 
                    
                    /// [21:21] ch21 set
                    CH_SET21:  u1, 
                    
                    /// [22:22] ch22 set
                    CH_SET22:  u1, 
                    
                    /// [23:23] ch23 set
                    CH_SET23:  u1, 
                    
                    /// [24:24] ch24 set
                    CH_SET24:  u1, 
                    
                    /// [25:25] ch25 set
                    CH_SET25:  u1, 
                    
                    /// [26:26] ch26 set
                    CH_SET26:  u1, 
                    
                    /// [27:27] ch27 set
                    CH_SET27:  u1, 
                    
                    /// [28:28] ch28 set
                    CH_SET28:  u1, 
                    
                    /// [29:29] ch29 set
                    CH_SET29:  u1, 
                    
                    /// [30:30] ch30 set
                    CH_SET30:  u1, 
                    
                    /// [31:31] ch31 set
                    CH_SET31:  u1, 
                    
                }), @ptrFromInt(0x60013004));
                
                /// channel enable clear register
                pub const CH_ENA_AD0_CLR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] ch0 clear
                    CH_CLR0:  u1, 
                    
                    /// [1:1] ch1 clear
                    CH_CLR1:  u1, 
                    
                    /// [2:2] ch2 clear
                    CH_CLR2:  u1, 
                    
                    /// [3:3] ch3 clear
                    CH_CLR3:  u1, 
                    
                    /// [4:4] ch4 clear
                    CH_CLR4:  u1, 
                    
                    /// [5:5] ch5 clear
                    CH_CLR5:  u1, 
                    
                    /// [6:6] ch6 clear
                    CH_CLR6:  u1, 
                    
                    /// [7:7] ch7 clear
                    CH_CLR7:  u1, 
                    
                    /// [8:8] ch8 clear
                    CH_CLR8:  u1, 
                    
                    /// [9:9] ch9 clear
                    CH_CLR9:  u1, 
                    
                    /// [10:10] ch10 clear
                    CH_CLR10:  u1, 
                    
                    /// [11:11] ch11 clear
                    CH_CLR11:  u1, 
                    
                    /// [12:12] ch12 clear
                    CH_CLR12:  u1, 
                    
                    /// [13:13] ch13 clear
                    CH_CLR13:  u1, 
                    
                    /// [14:14] ch14 clear
                    CH_CLR14:  u1, 
                    
                    /// [15:15] ch15 clear
                    CH_CLR15:  u1, 
                    
                    /// [16:16] ch16 clear
                    CH_CLR16:  u1, 
                    
                    /// [17:17] ch17 clear
                    CH_CLR17:  u1, 
                    
                    /// [18:18] ch18 clear
                    CH_CLR18:  u1, 
                    
                    /// [19:19] ch19 clear
                    CH_CLR19:  u1, 
                    
                    /// [20:20] ch20 clear
                    CH_CLR20:  u1, 
                    
                    /// [21:21] ch21 clear
                    CH_CLR21:  u1, 
                    
                    /// [22:22] ch22 clear
                    CH_CLR22:  u1, 
                    
                    /// [23:23] ch23 clear
                    CH_CLR23:  u1, 
                    
                    /// [24:24] ch24 clear
                    CH_CLR24:  u1, 
                    
                    /// [25:25] ch25 clear
                    CH_CLR25:  u1, 
                    
                    /// [26:26] ch26 clear
                    CH_CLR26:  u1, 
                    
                    /// [27:27] ch27 clear
                    CH_CLR27:  u1, 
                    
                    /// [28:28] ch28 clear
                    CH_CLR28:  u1, 
                    
                    /// [29:29] ch29 clear
                    CH_CLR29:  u1, 
                    
                    /// [30:30] ch30 clear
                    CH_CLR30:  u1, 
                    
                    /// [31:31] ch31 clear
                    CH_CLR31:  u1, 
                    
                }), @ptrFromInt(0x60013008));
                
                /// channel enable register
                pub const CH_ENA_AD1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] ch32 enable
                    CH_ENA32:  u1, 
                    
                    /// [1:1] ch33 enable
                    CH_ENA33:  u1, 
                    
                    /// [2:2] ch34 enable
                    CH_ENA34:  u1, 
                    
                    /// [3:3] ch35 enable
                    CH_ENA35:  u1, 
                    
                    /// [4:4] ch36 enable
                    CH_ENA36:  u1, 
                    
                    /// [5:5] ch37 enable
                    CH_ENA37:  u1, 
                    
                    /// [6:6] ch38 enable
                    CH_ENA38:  u1, 
                    
                    /// [7:7] ch39 enable
                    CH_ENA39:  u1, 
                    
                    /// [8:8] ch40 enable
                    CH_ENA40:  u1, 
                    
                    /// [9:9] ch41 enable
                    CH_ENA41:  u1, 
                    
                    /// [10:10] ch42 enable
                    CH_ENA42:  u1, 
                    
                    /// [11:11] ch43 enable
                    CH_ENA43:  u1, 
                    
                    /// [12:12] ch44 enable
                    CH_ENA44:  u1, 
                    
                    /// [13:13] ch45 enable
                    CH_ENA45:  u1, 
                    
                    /// [14:14] ch46 enable
                    CH_ENA46:  u1, 
                    
                    /// [15:15] ch47 enable
                    CH_ENA47:  u1, 
                    
                    /// [16:16] ch48 enable
                    CH_ENA48:  u1, 
                    
                    /// [17:17] ch49 enable
                    CH_ENA49:  u1, 
                    
                    /// [18:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6001300c));
                
                /// channel enable set register
                pub const CH_ENA_AD1_SET = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] ch32 set
                    CH_SET32:  u1, 
                    
                    /// [1:1] ch33 set
                    CH_SET33:  u1, 
                    
                    /// [2:2] ch34 set
                    CH_SET34:  u1, 
                    
                    /// [3:3] ch35 set
                    CH_SET35:  u1, 
                    
                    /// [4:4] ch36 set
                    CH_SET36:  u1, 
                    
                    /// [5:5] ch37 set
                    CH_SET37:  u1, 
                    
                    /// [6:6] ch38 set
                    CH_SET38:  u1, 
                    
                    /// [7:7] ch39 set
                    CH_SET39:  u1, 
                    
                    /// [8:8] ch40 set
                    CH_SET40:  u1, 
                    
                    /// [9:9] ch41 set
                    CH_SET41:  u1, 
                    
                    /// [10:10] ch42 set
                    CH_SET42:  u1, 
                    
                    /// [11:11] ch43 set
                    CH_SET43:  u1, 
                    
                    /// [12:12] ch44 set
                    CH_SET44:  u1, 
                    
                    /// [13:13] ch45 set
                    CH_SET45:  u1, 
                    
                    /// [14:14] ch46 set
                    CH_SET46:  u1, 
                    
                    /// [15:15] ch47 set
                    CH_SET47:  u1, 
                    
                    /// [16:16] ch48 set
                    CH_SET48:  u1, 
                    
                    /// [17:17] ch49 set
                    CH_SET49:  u1, 
                    
                    /// [18:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60013010));
                
                /// channel enable clear register
                pub const CH_ENA_AD1_CLR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] ch32 clear
                    CH_CLR32:  u1, 
                    
                    /// [1:1] ch33 clear
                    CH_CLR33:  u1, 
                    
                    /// [2:2] ch34 clear
                    CH_CLR34:  u1, 
                    
                    /// [3:3] ch35 clear
                    CH_CLR35:  u1, 
                    
                    /// [4:4] ch36 clear
                    CH_CLR36:  u1, 
                    
                    /// [5:5] ch37 clear
                    CH_CLR37:  u1, 
                    
                    /// [6:6] ch38 clear
                    CH_CLR38:  u1, 
                    
                    /// [7:7] ch39 clear
                    CH_CLR39:  u1, 
                    
                    /// [8:8] ch40 clear
                    CH_CLR40:  u1, 
                    
                    /// [9:9] ch41 clear
                    CH_CLR41:  u1, 
                    
                    /// [10:10] ch42 clear
                    CH_CLR42:  u1, 
                    
                    /// [11:11] ch43 clear
                    CH_CLR43:  u1, 
                    
                    /// [12:12] ch44 clear
                    CH_CLR44:  u1, 
                    
                    /// [13:13] ch45 clear
                    CH_CLR45:  u1, 
                    
                    /// [14:14] ch46 clear
                    CH_CLR46:  u1, 
                    
                    /// [15:15] ch47 clear
                    CH_CLR47:  u1, 
                    
                    /// [16:16] ch48 clear
                    CH_CLR48:  u1, 
                    
                    /// [17:17] ch49 clear
                    CH_CLR49:  u1, 
                    
                    /// [18:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60013014));
                
                /// channel0 event id register
                pub const CH0_EVT_ID = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] ch0_evt_id
                    CH0_EVT_ID:  u8, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60013018));
                
                /// channel0 task id register
                pub const CH0_TASK_ID = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] ch0_task_id
                    CH0_TASK_ID:  u8, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6001301c));
                
                /// channel1 event id register
                pub const CH1_EVT_ID = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] ch1_evt_id
                    CH1_EVT_ID:  u8, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60013020));
                
                /// channel1 task id register
                pub const CH1_TASK_ID = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] ch1_task_id
                    CH1_TASK_ID:  u8, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60013024));
                
                /// channel2 event id register
                pub const CH2_EVT_ID = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] ch2_evt_id
                    CH2_EVT_ID:  u8, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60013028));
                
                /// channel2 task id register
                pub const CH2_TASK_ID = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] ch2_task_id
                    CH2_TASK_ID:  u8, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6001302c));
                
                /// channel3 event id register
                pub const CH3_EVT_ID = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] ch3_evt_id
                    CH3_EVT_ID:  u8, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60013030));
                
                /// channel3 task id register
                pub const CH3_TASK_ID = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] ch3_task_id
                    CH3_TASK_ID:  u8, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60013034));
                
                /// channel4 event id register
                pub const CH4_EVT_ID = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] ch4_evt_id
                    CH4_EVT_ID:  u8, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60013038));
                
                /// channel4 task id register
                pub const CH4_TASK_ID = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] ch4_task_id
                    CH4_TASK_ID:  u8, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6001303c));
                
                /// channel5 event id register
                pub const CH5_EVT_ID = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] ch5_evt_id
                    CH5_EVT_ID:  u8, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60013040));
                
                /// channel5 task id register
                pub const CH5_TASK_ID = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] ch5_task_id
                    CH5_TASK_ID:  u8, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60013044));
                
                /// channel6 event id register
                pub const CH6_EVT_ID = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] ch6_evt_id
                    CH6_EVT_ID:  u8, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60013048));
                
                /// channel6 task id register
                pub const CH6_TASK_ID = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] ch6_task_id
                    CH6_TASK_ID:  u8, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6001304c));
                
                /// channel7 event id register
                pub const CH7_EVT_ID = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] ch7_evt_id
                    CH7_EVT_ID:  u8, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60013050));
                
                /// channel7 task id register
                pub const CH7_TASK_ID = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] ch7_task_id
                    CH7_TASK_ID:  u8, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60013054));
                
                /// channel8 event id register
                pub const CH8_EVT_ID = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] ch8_evt_id
                    CH8_EVT_ID:  u8, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60013058));
                
                /// channel8 task id register
                pub const CH8_TASK_ID = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] ch8_task_id
                    CH8_TASK_ID:  u8, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6001305c));
                
                /// channel9 event id register
                pub const CH9_EVT_ID = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] ch9_evt_id
                    CH9_EVT_ID:  u8, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60013060));
                
                /// channel9 task id register
                pub const CH9_TASK_ID = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] ch9_task_id
                    CH9_TASK_ID:  u8, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60013064));
                
                /// channel10 event id register
                pub const CH10_EVT_ID = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] ch10_evt_id
                    CH10_EVT_ID:  u8, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60013068));
                
                /// channel10 task id register
                pub const CH10_TASK_ID = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] ch10_task_id
                    CH10_TASK_ID:  u8, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6001306c));
                
                /// channel11 event id register
                pub const CH11_EVT_ID = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] ch11_evt_id
                    CH11_EVT_ID:  u8, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60013070));
                
                /// channel11 task id register
                pub const CH11_TASK_ID = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] ch11_task_id
                    CH11_TASK_ID:  u8, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60013074));
                
                /// channel12 event id register
                pub const CH12_EVT_ID = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] ch12_evt_id
                    CH12_EVT_ID:  u8, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60013078));
                
                /// channel12 task id register
                pub const CH12_TASK_ID = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] ch12_task_id
                    CH12_TASK_ID:  u8, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6001307c));
                
                /// channel13 event id register
                pub const CH13_EVT_ID = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] ch13_evt_id
                    CH13_EVT_ID:  u8, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60013080));
                
                /// channel13 task id register
                pub const CH13_TASK_ID = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] ch13_task_id
                    CH13_TASK_ID:  u8, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60013084));
                
                /// channel14 event id register
                pub const CH14_EVT_ID = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] ch14_evt_id
                    CH14_EVT_ID:  u8, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60013088));
                
                /// channel14 task id register
                pub const CH14_TASK_ID = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] ch14_task_id
                    CH14_TASK_ID:  u8, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6001308c));
                
                /// channel15 event id register
                pub const CH15_EVT_ID = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] ch15_evt_id
                    CH15_EVT_ID:  u8, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60013090));
                
                /// channel15 task id register
                pub const CH15_TASK_ID = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] ch15_task_id
                    CH15_TASK_ID:  u8, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60013094));
                
                /// channel16 event id register
                pub const CH16_EVT_ID = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] ch16_evt_id
                    CH16_EVT_ID:  u8, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60013098));
                
                /// channel16 task id register
                pub const CH16_TASK_ID = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] ch16_task_id
                    CH16_TASK_ID:  u8, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6001309c));
                
                /// channel17 event id register
                pub const CH17_EVT_ID = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] ch17_evt_id
                    CH17_EVT_ID:  u8, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600130a0));
                
                /// channel17 task id register
                pub const CH17_TASK_ID = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] ch17_task_id
                    CH17_TASK_ID:  u8, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600130a4));
                
                /// channel18 event id register
                pub const CH18_EVT_ID = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] ch18_evt_id
                    CH18_EVT_ID:  u8, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600130a8));
                
                /// channel18 task id register
                pub const CH18_TASK_ID = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] ch18_task_id
                    CH18_TASK_ID:  u8, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600130ac));
                
                /// channel19 event id register
                pub const CH19_EVT_ID = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] ch19_evt_id
                    CH19_EVT_ID:  u8, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600130b0));
                
                /// channel19 task id register
                pub const CH19_TASK_ID = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] ch19_task_id
                    CH19_TASK_ID:  u8, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600130b4));
                
                /// channel20 event id register
                pub const CH20_EVT_ID = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] ch20_evt_id
                    CH20_EVT_ID:  u8, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600130b8));
                
                /// channel20 task id register
                pub const CH20_TASK_ID = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] ch20_task_id
                    CH20_TASK_ID:  u8, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600130bc));
                
                /// channel21 event id register
                pub const CH21_EVT_ID = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] ch21_evt_id
                    CH21_EVT_ID:  u8, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600130c0));
                
                /// channel21 task id register
                pub const CH21_TASK_ID = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] ch21_task_id
                    CH21_TASK_ID:  u8, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600130c4));
                
                /// channel22 event id register
                pub const CH22_EVT_ID = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] ch22_evt_id
                    CH22_EVT_ID:  u8, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600130c8));
                
                /// channel22 task id register
                pub const CH22_TASK_ID = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] ch22_task_id
                    CH22_TASK_ID:  u8, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600130cc));
                
                /// channel23 event id register
                pub const CH23_EVT_ID = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] ch23_evt_id
                    CH23_EVT_ID:  u8, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600130d0));
                
                /// channel23 task id register
                pub const CH23_TASK_ID = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] ch23_task_id
                    CH23_TASK_ID:  u8, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600130d4));
                
                /// channel24 event id register
                pub const CH24_EVT_ID = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] ch24_evt_id
                    CH24_EVT_ID:  u8, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600130d8));
                
                /// channel24 task id register
                pub const CH24_TASK_ID = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] ch24_task_id
                    CH24_TASK_ID:  u8, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600130dc));
                
                /// channel25 event id register
                pub const CH25_EVT_ID = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] ch25_evt_id
                    CH25_EVT_ID:  u8, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600130e0));
                
                /// channel25 task id register
                pub const CH25_TASK_ID = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] ch25_task_id
                    CH25_TASK_ID:  u8, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600130e4));
                
                /// channel26 event id register
                pub const CH26_EVT_ID = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] ch26_evt_id
                    CH26_EVT_ID:  u8, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600130e8));
                
                /// channel26 task id register
                pub const CH26_TASK_ID = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] ch26_task_id
                    CH26_TASK_ID:  u8, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600130ec));
                
                /// channel27 event id register
                pub const CH27_EVT_ID = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] ch27_evt_id
                    CH27_EVT_ID:  u8, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600130f0));
                
                /// channel27 task id register
                pub const CH27_TASK_ID = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] ch27_task_id
                    CH27_TASK_ID:  u8, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600130f4));
                
                /// channel28 event id register
                pub const CH28_EVT_ID = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] ch28_evt_id
                    CH28_EVT_ID:  u8, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600130f8));
                
                /// channel28 task id register
                pub const CH28_TASK_ID = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] ch28_task_id
                    CH28_TASK_ID:  u8, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600130fc));
                
                /// channel29 event id register
                pub const CH29_EVT_ID = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] ch29_evt_id
                    CH29_EVT_ID:  u8, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60013100));
                
                /// channel29 task id register
                pub const CH29_TASK_ID = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] ch29_task_id
                    CH29_TASK_ID:  u8, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60013104));
                
                /// channel30 event id register
                pub const CH30_EVT_ID = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] ch30_evt_id
                    CH30_EVT_ID:  u8, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60013108));
                
                /// channel30 task id register
                pub const CH30_TASK_ID = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] ch30_task_id
                    CH30_TASK_ID:  u8, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6001310c));
                
                /// channel31 event id register
                pub const CH31_EVT_ID = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] ch31_evt_id
                    CH31_EVT_ID:  u8, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60013110));
                
                /// channel31 task id register
                pub const CH31_TASK_ID = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] ch31_task_id
                    CH31_TASK_ID:  u8, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60013114));
                
                /// channel32 event id register
                pub const CH32_EVT_ID = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] ch32_evt_id
                    CH32_EVT_ID:  u8, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60013118));
                
                /// channel32 task id register
                pub const CH32_TASK_ID = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] ch32_task_id
                    CH32_TASK_ID:  u8, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6001311c));
                
                /// channel33 event id register
                pub const CH33_EVT_ID = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] ch33_evt_id
                    CH33_EVT_ID:  u8, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60013120));
                
                /// channel33 task id register
                pub const CH33_TASK_ID = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] ch33_task_id
                    CH33_TASK_ID:  u8, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60013124));
                
                /// channel34 event id register
                pub const CH34_EVT_ID = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] ch34_evt_id
                    CH34_EVT_ID:  u8, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60013128));
                
                /// channel34 task id register
                pub const CH34_TASK_ID = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] ch34_task_id
                    CH34_TASK_ID:  u8, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6001312c));
                
                /// channel35 event id register
                pub const CH35_EVT_ID = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] ch35_evt_id
                    CH35_EVT_ID:  u8, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60013130));
                
                /// channel35 task id register
                pub const CH35_TASK_ID = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] ch35_task_id
                    CH35_TASK_ID:  u8, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60013134));
                
                /// channel36 event id register
                pub const CH36_EVT_ID = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] ch36_evt_id
                    CH36_EVT_ID:  u8, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60013138));
                
                /// channel36 task id register
                pub const CH36_TASK_ID = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] ch36_task_id
                    CH36_TASK_ID:  u8, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6001313c));
                
                /// channel37 event id register
                pub const CH37_EVT_ID = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] ch37_evt_id
                    CH37_EVT_ID:  u8, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60013140));
                
                /// channel37 task id register
                pub const CH37_TASK_ID = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] ch37_task_id
                    CH37_TASK_ID:  u8, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60013144));
                
                /// channel38 event id register
                pub const CH38_EVT_ID = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] ch38_evt_id
                    CH38_EVT_ID:  u8, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60013148));
                
                /// channel38 task id register
                pub const CH38_TASK_ID = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] ch38_task_id
                    CH38_TASK_ID:  u8, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6001314c));
                
                /// channel39 event id register
                pub const CH39_EVT_ID = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] ch39_evt_id
                    CH39_EVT_ID:  u8, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60013150));
                
                /// channel39 task id register
                pub const CH39_TASK_ID = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] ch39_task_id
                    CH39_TASK_ID:  u8, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60013154));
                
                /// channel40 event id register
                pub const CH40_EVT_ID = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] ch40_evt_id
                    CH40_EVT_ID:  u8, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60013158));
                
                /// channel40 task id register
                pub const CH40_TASK_ID = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] ch40_task_id
                    CH40_TASK_ID:  u8, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6001315c));
                
                /// channel41 event id register
                pub const CH41_EVT_ID = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] ch41_evt_id
                    CH41_EVT_ID:  u8, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60013160));
                
                /// channel41 task id register
                pub const CH41_TASK_ID = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] ch41_task_id
                    CH41_TASK_ID:  u8, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60013164));
                
                /// channel42 event id register
                pub const CH42_EVT_ID = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] ch42_evt_id
                    CH42_EVT_ID:  u8, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60013168));
                
                /// channel42 task id register
                pub const CH42_TASK_ID = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] ch42_task_id
                    CH42_TASK_ID:  u8, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6001316c));
                
                /// channel43 event id register
                pub const CH43_EVT_ID = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] ch43_evt_id
                    CH43_EVT_ID:  u8, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60013170));
                
                /// channel43 task id register
                pub const CH43_TASK_ID = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] ch43_task_id
                    CH43_TASK_ID:  u8, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60013174));
                
                /// channel44 event id register
                pub const CH44_EVT_ID = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] ch44_evt_id
                    CH44_EVT_ID:  u8, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60013178));
                
                /// channel44 task id register
                pub const CH44_TASK_ID = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] ch44_task_id
                    CH44_TASK_ID:  u8, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6001317c));
                
                /// channel45 event id register
                pub const CH45_EVT_ID = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] ch45_evt_id
                    CH45_EVT_ID:  u8, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60013180));
                
                /// channel45 task id register
                pub const CH45_TASK_ID = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] ch45_task_id
                    CH45_TASK_ID:  u8, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60013184));
                
                /// channel46 event id register
                pub const CH46_EVT_ID = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] ch46_evt_id
                    CH46_EVT_ID:  u8, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60013188));
                
                /// channel46 task id register
                pub const CH46_TASK_ID = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] ch46_task_id
                    CH46_TASK_ID:  u8, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6001318c));
                
                /// channel47 event id register
                pub const CH47_EVT_ID = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] ch47_evt_id
                    CH47_EVT_ID:  u8, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60013190));
                
                /// channel47 task id register
                pub const CH47_TASK_ID = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] ch47_task_id
                    CH47_TASK_ID:  u8, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60013194));
                
                /// channel48 event id register
                pub const CH48_EVT_ID = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] ch48_evt_id
                    CH48_EVT_ID:  u8, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60013198));
                
                /// channel48 task id register
                pub const CH48_TASK_ID = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] ch48_task_id
                    CH48_TASK_ID:  u8, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6001319c));
                
                /// channel49 event id register
                pub const CH49_EVT_ID = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] ch49_evt_id
                    CH49_EVT_ID:  u8, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600131a0));
                
                /// channel49 task id register
                pub const CH49_TASK_ID = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] ch49_task_id
                    CH49_TASK_ID:  u8, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600131a4));
                
                /// etm clock enable register
                pub const CLK_EN = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] clock enable
                    CLK_EN:  u1, 
                    
                    /// [1:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600131a8));
                
                /// etm date register
                pub const DATE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:27] date
                    DATE:  u28, 
                    
                    /// [28:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600131ac));
                
            };
            
            /// SPI (Serial Peripheral Interface) Controller 0
            pub const SPI0 = struct {
                
                /// SPI0 FSM status register
                pub const SPI_MEM_CMD = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:3] The current status of SPI0 master FSM: spi0_mst_st. 0: idle state, 1:SPI0_GRANT , 2: program/erase suspend state, 3: SPI0 read data state, 4: wait cache/EDMA sent data is stored in SPI0 TX FIFO, 5: SPI0 write data state.
                    SPI_MEM_MST_ST:  u4, 
                    
                    /// [4:7] The current status of SPI0 slave FSM: mspi_st. 0: idle state, 1: preparation state, 2: send command state, 3: send address state, 4: wait state, 5: read data state, 6:write data state, 7: done state, 8: read data end state.
                    SPI_MEM_SLV_ST:  u4, 
                    
                    /// [8:17] 
                    res0:  u0, 
                    
                    /// [18:18] SPI0 USR_CMD start bit, only used when SPI_MEM_AXI_REQ_EN is cleared.An operation will be triggered when the bit is set. The bit will be cleared once the operation done.1: enable 0: disable.
                    SPI_MEM_USR:  u1, 
                    
                    /// [19:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x60002000));
                
                /// SPI0 control register.
                pub const SPI_MEM_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] In the dummy phase of an MSPI write data transfer when accesses to flash, the level of SPI_DQS is output by the MSPI controller.
                    SPI_MEM_WDUMMY_DQS_ALWAYS_OUT:  u1, 
                    
                    /// [1:1] In the dummy phase of an MSPI write data transfer when accesses to flash, the level of SPI_IO[7:0] is output by the MSPI controller.
                    SPI_MEM_WDUMMY_ALWAYS_OUT:  u1, 
                    
                    /// [2:2] In an MSPI read data transfer when accesses to flash, the level of SPI_IO[7:0] is output by the MSPI controller in the first half part of dummy phase. It is used to mask invalid SPI_DQS in the half part of dummy phase.
                    SPI_MEM_FDUMMY_RIN:  u1, 
                    
                    /// [3:3] In an MSPI write data transfer when accesses to flash, the level of SPI_IO[7:0] is output by the MSPI controller in the second half part of dummy phase. It is used to pre-drive flash.
                    SPI_MEM_FDUMMY_WOUT:  u1, 
                    
                    /// [4:4] Apply 8 signals during write-data phase 1:enable 0: disable
                    SPI_MEM_FDOUT_OCT:  u1, 
                    
                    /// [5:5] Apply 8 signals during read-data phase 1:enable 0: disable
                    SPI_MEM_FDIN_OCT:  u1, 
                    
                    /// [6:6] Apply 8 signals during address phase 1:enable 0: disable
                    SPI_MEM_FADDR_OCT:  u1, 
                    
                    /// [7:7] 
                    res0:  u0, 
                    
                    /// [8:8] Apply 4 signals during command phase 1:enable 0: disable
                    SPI_MEM_FCMD_QUAD:  u1, 
                    
                    /// [9:9] Apply 8 signals during command phase 1:enable 0: disable
                    SPI_MEM_FCMD_OCT:  u1, 
                    
                    /// [10:12] 
                    res1:  u0, 
                    
                    /// [13:13] This bit enable the bits: SPI_MEM_FREAD_QIO, SPI_MEM_FREAD_DIO, SPI_MEM_FREAD_QOUT and SPI_MEM_FREAD_DOUT. 1: enable 0: disable.
                    SPI_MEM_FASTRD_MODE:  u1, 
                    
                    /// [14:14] In the read operations, read-data phase apply 2 signals. 1: enable 0: disable.
                    SPI_MEM_FREAD_DUAL:  u1, 
                    
                    /// [15:17] 
                    res2:  u0, 
                    
                    /// [18:18] The bit is used to set MISO line polarity, 1: high 0, low
                    SPI_MEM_Q_POL:  u1, 
                    
                    /// [19:19] The bit is used to set MOSI line polarity, 1: high 0, low
                    SPI_MEM_D_POL:  u1, 
                    
                    /// [20:20] In the read operations read-data phase apply 4 signals. 1: enable 0: disable.
                    SPI_MEM_FREAD_QUAD:  u1, 
                    
                    /// [21:21] Write protect signal output when SPI is idle.1: output high, 0: output low.
                    SPI_MEM_WP:  u1, 
                    
                    /// [22:22] 
                    res3:  u0, 
                    
                    /// [23:23] In the read operations address phase and read-data phase apply 2 signals. 1: enable 0: disable.
                    SPI_MEM_FREAD_DIO:  u1, 
                    
                    /// [24:24] In the read operations address phase and read-data phase apply 4 signals. 1: enable 0: disable.
                    SPI_MEM_FREAD_QIO:  u1, 
                    
                    /// [25:29] 
                    res4:  u0, 
                    
                    /// [30:30] When accesses to flash, 1: the IE signals of pads connected to SPI_DQS are always 1. 0: Others.
                    SPI_MEM_DQS_IE_ALWAYS_ON:  u1, 
                    
                    /// [31:31] When accesses to flash, 1: the IE signals of pads connected to SPI_IO[7:0] are always 1. 0: Others.
                    SPI_MEM_DATA_IE_ALWAYS_ON:  u1, 
                    
                }), @ptrFromInt(0x60002008));
                
                /// SPI0 control1 register.
                pub const SPI_MEM_CTRL1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:1] SPI clock mode bits. 0: SPI clock is off when CS inactive 1: SPI clock is delayed one cycle after CS inactive 2: SPI clock is delayed two cycles after CS inactive 3: SPI clock is alwasy on.
                    SPI_MEM_CLK_MODE:  u2, 
                    
                    /// [2:20] 
                    res0:  u0, 
                    
                    /// [21:21] 1: MSPI supports ARSIZE 0~3. When ARSIZE =0~2, MSPI read address is 4*n and reply the real AXI read data back. 0: When ARSIZE 0~1, MSPI reply SLV_ERR.
                    SPI_AR_SIZE0_1_SUPPORT_EN:  u1, 
                    
                    /// [22:22] 1: MSPI supports AWSIZE 0~3. 0: When AWSIZE 0~1, MSPI reply SLV_ERR.
                    SPI_AW_SIZE0_1_SUPPORT_EN:  u1, 
                    
                    /// [23:23] 1: Reply AXI read data to AXI bus when one AXI read beat data is available. 0: Reply AXI read data to AXI bus when all the read data is available.
                    SPI_AXI_RDATA_BACK_FAST:  u1, 
                    
                    /// [24:24] 1: RRESP is SLV_ERR when there is a ECC error in AXI read data. 0: RRESP is OKAY when there is a ECC error in AXI read data. The ECC error information is recorded in SPI_MEM_ECC_ERR_ADDR_REG.
                    SPI_MEM_RRESP_ECC_ERR_EN:  u1, 
                    
                    /// [25:25] Set this bit to enable AXI Read Splice-transfer.
                    SPI_MEM_AR_SPLICE_EN:  u1, 
                    
                    /// [26:26] Set this bit to enable AXI Write Splice-transfer.
                    SPI_MEM_AW_SPLICE_EN:  u1, 
                    
                    /// [27:27] When SPI_MEM_DUAL_RAM_EN is 0 and SPI_MEM_RAM0_EN is 1, only EXT_RAM0 will be accessed. When SPI_MEM_DUAL_RAM_EN is 0 and SPI_MEM_RAM0_EN is 0, only EXT_RAM1 will be accessed. When SPI_MEM_DUAL_RAM_EN is 1,EXT_RAM0 and EXT_RAM1 will be accessed at the same time.
                    SPI_MEM_RAM0_EN:  u1, 
                    
                    /// [28:28] Set this bit to enable DUAL-RAM mode, EXT_RAM0 and EXT_RAM1 will be accessed at the same time.
                    SPI_MEM_DUAL_RAM_EN:  u1, 
                    
                    /// [29:29] Set this bit to write data faster, do not wait write data has been stored in tx_bus_fifo_l2. It will wait 4*T_clk_ctrl to insure the write data has been stored intx_bus_fifo_l2.
                    SPI_MEM_FAST_WRITE_EN:  u1, 
                    
                    /// [30:30] The synchronous reset signal for SPI0 RX AFIFO and all the AES_MSPI SYNC FIFO to receive signals from AXI.Set this bit to reset these FIFO.
                    SPI_MEM_RXFIFO_RST:  u1, 
                    
                    /// [31:31] The synchronous reset signal for SPI0 TX AFIFO and all the AES_MSPI SYNC FIFO to send signals to AXI. Set this bit to reset these FIFO.
                    SPI_MEM_TXFIFO_RST:  u1, 
                    
                }), @ptrFromInt(0x6000200c));
                
                /// SPI0 control2 register.
                pub const SPI_MEM_CTRL2 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:4] (cycles-1) of prepare phase by SPI Bus clock, this bits are combined with SPI_MEM_CS_SETUP bit.
                    SPI_MEM_CS_SETUP_TIME:  u5, 
                    
                    /// [5:9] SPI CS signal is delayed to inactive by SPI bus clock, this bits are combined with SPI_MEM_CS_HOLD bit.
                    SPI_MEM_CS_HOLD_TIME:  u5, 
                    
                    /// [10:12] SPI_MEM_CS_HOLD_TIME + SPI_MEM_ECC_CS_HOLD_TIME is the SPI0 CS hold cycle in ECC mode when accessed flash.
                    SPI_MEM_ECC_CS_HOLD_TIME:  u3, 
                    
                    /// [13:13] 1: SPI0 and SPI1 skip page corner when accesses flash. 0: Not skip page corner when accesses flash.
                    SPI_MEM_ECC_SKIP_PAGE_CORNER:  u1, 
                    
                    /// [14:14] Set this bit to enable SPI0 and SPI1 ECC 16 bytes data with 2 ECC bytes mode when accesses flash.
                    SPI_MEM_ECC_16TO18_BYTE_EN:  u1, 
                    
                    /// [15:23] 
                    res0:  u0, 
                    
                    /// [24:24] Set this bit to enable SPI0 split one AXI read flash transfer into two SPI transfers when one transfer will cross flash or EXT_RAM page corner, valid no matter whether there is an ECC region or not.
                    SPI_MEM_SPLIT_TRANS_EN:  u1, 
                    
                    /// [25:30] These bits are used to set the minimum CS high time tSHSL between SPI burst transfer when accesses to flash. tSHSL is (SPI_MEM_CS_HOLD_DELAY[5:0] + 1) MSPI core clock cycles.
                    SPI_MEM_CS_HOLD_DELAY:  u6, 
                    
                    /// [31:31] The spi0_mst_st and spi0_slv_st will be reset.
                    SPI_MEM_SYNC_RESET:  u1, 
                    
                }), @ptrFromInt(0x60002010));
                
                /// SPI clock division control register.
                pub const SPI_MEM_CLOCK = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] In the master mode it must be equal to spi_mem_clkcnt_N.
                    SPI_MEM_CLKCNT_L:  u8, 
                    
                    /// [8:15] In the master mode it must be floor((spi_mem_clkcnt_N+1)/2-1).
                    SPI_MEM_CLKCNT_H:  u8, 
                    
                    /// [16:23] In the master mode it is the divider of spi_mem_clk. So spi_mem_clk frequency is system/(spi_mem_clkcnt_N+1)
                    SPI_MEM_CLKCNT_N:  u8, 
                    
                    /// [24:30] 
                    res0:  u0, 
                    
                    /// [31:31] 1: 1-division mode, the frequency of SPI bus clock equals to that of MSPI module clock.
                    SPI_MEM_CLK_EQU_SYSCLK:  u1, 
                    
                }), @ptrFromInt(0x60002014));
                
                /// SPI0 user register.
                pub const SPI_MEM_USER = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] 
                    res0:  u0, 
                    
                    /// [6:6] spi cs keep low when spi is indonephase. 1: enable 0: disable.
                    SPI_MEM_CS_HOLD:  u1, 
                    
                    /// [7:7] spi cs is enable when spi is inpreparephase. 1: enable 0: disable.
                    SPI_MEM_CS_SETUP:  u1, 
                    
                    /// [8:8] 
                    res1:  u0, 
                    
                    /// [9:9] The bit combined with SPI_MEM_CK_IDLE_EDGE bit to control SPI clock mode 0~3.
                    SPI_MEM_CK_OUT_EDGE:  u1, 
                    
                    /// [10:25] 
                    res2:  u0, 
                    
                    /// [26:26] spi clock is disable in dummy phase when the bit is enable.
                    SPI_MEM_USR_DUMMY_IDLE:  u1, 
                    
                    /// [27:28] 
                    res3:  u0, 
                    
                    /// [29:29] This bit enable the dummy phase of an operation.
                    SPI_MEM_USR_DUMMY:  u1, 
                    
                    /// [30:31] 
                    res4:  u0, 
                    
                }), @ptrFromInt(0x60002018));
                
                /// SPI0 user1 register.
                pub const SPI_MEM_USER1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] The length in spi_mem_clk cycles of dummy phase. The register value shall be (cycle_num-1).
                    SPI_MEM_USR_DUMMY_CYCLELEN:  u6, 
                    
                    /// [6:8] SPI0 USR_CMD read or write data byte length -1
                    SPI_MEM_USR_DBYTELEN:  u3, 
                    
                    /// [9:25] 
                    res0:  u0, 
                    
                    /// [26:31] The length in bits of address phase. The register value shall be (bit_num-1).
                    SPI_MEM_USR_ADDR_BITLEN:  u6, 
                    
                }), @ptrFromInt(0x6000201c));
                
                /// SPI0 user2 register.
                pub const SPI_MEM_USER2 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:15] The value ofcommand.
                    SPI_MEM_USR_COMMAND_VALUE:  u16, 
                    
                    /// [16:27] 
                    res0:  u0, 
                    
                    /// [28:31] The length in bits of command phase. The register value shall be (bit_num-1)
                    SPI_MEM_USR_COMMAND_BITLEN:  u4, 
                    
                }), @ptrFromInt(0x60002020));
                
                /// SPI0 read control register.
                pub const SPI_MEM_RD_STATUS = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:15] 
                    res0:  u0, 
                    
                    /// [16:23] Mode bits in the flash fast read modeit is combined with spi_mem_fastrd_mode bit.
                    SPI_MEM_WB_MODE:  u8, 
                    
                    /// [24:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x6000202c));
                
                /// SPI0 misc register
                pub const SPI_MEM_MISC = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:6] 
                    res0:  u0, 
                    
                    /// [7:7] For SPI0,flash is connected to SUBPINs.
                    SPI_MEM_FSUB_PIN:  u1, 
                    
                    /// [8:8] For SPI0,sram is connected to SUBPINs.
                    SPI_MEM_SSUB_PIN:  u1, 
                    
                    /// [9:9] 1: SPI_CLK line is high when idle 0: spi clk line is low when idle
                    SPI_MEM_CK_IDLE_EDGE:  u1, 
                    
                    /// [10:10] SPI_CS line keep low when the bit is set.
                    SPI_MEM_CS_KEEP_ACTIVE:  u1, 
                    
                    /// [11:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x60002034));
                
                /// SPI0 bit mode control register.
                pub const SPI_MEM_CACHE_FCTRL = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] For SPI0, AXI master access enable, 1: enable, 0:disable.
                    SPI_MEM_AXI_REQ_EN:  u1, 
                    
                    /// [1:1] For SPI0,cacheread flash with 4 bytes address, 1: enable, 0:disable.
                    SPI_MEM_CACHE_USR_ADDR_4BYTE:  u1, 
                    
                    /// [2:2] For SPI0,cacheread flash for user define command, 1: enable, 0:disable.
                    SPI_MEM_CACHE_FLASH_USR_CMD:  u1, 
                    
                    /// [3:3] For SPI0 flash, din phase apply 2 signals. 1: enable 0: disable. The bit is the same with spi_mem_fread_dio.
                    SPI_MEM_FDIN_DUAL:  u1, 
                    
                    /// [4:4] For SPI0 flash, dout phase apply 2 signals. 1: enable 0: disable. The bit is the same with spi_mem_fread_dio.
                    SPI_MEM_FDOUT_DUAL:  u1, 
                    
                    /// [5:5] For SPI0 flash, address phase apply 2 signals. 1: enable 0: disable.The bit is the same with spi_mem_fread_dio.
                    SPI_MEM_FADDR_DUAL:  u1, 
                    
                    /// [6:6] For SPI0 flash, din phase apply 4 signals. 1: enable 0: disable.The bit is the same with spi_mem_fread_qio.
                    SPI_MEM_FDIN_QUAD:  u1, 
                    
                    /// [7:7] For SPI0 flash, dout phase apply 4 signals. 1: enable 0: disable.The bit is the same with spi_mem_fread_qio.
                    SPI_MEM_FDOUT_QUAD:  u1, 
                    
                    /// [8:8] For SPI0 flash, address phase apply 4 signals. 1: enable 0: disable.The bit is the same with spi_mem_fread_qio.
                    SPI_MEM_FADDR_QUAD:  u1, 
                    
                    /// [9:29] 
                    res0:  u0, 
                    
                    /// [30:30] Set this bit to check AXI read/write the same address region.
                    SPI_SAME_AW_AR_ADDR_CHK_EN:  u1, 
                    
                    /// [31:31] Set this bit to close AXI read/write transfer to MSPI, which means that only SLV_ERR will be replied to BRESP/RRESP.
                    SPI_CLOSE_AXI_INF_EN:  u1, 
                    
                }), @ptrFromInt(0x6000203c));
                
                /// SPI0 external RAM control register
                pub const SPI_MEM_CACHE_SCTRL = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] For SPI0, In the external RAM mode, cache read flash with 4 bytes command, 1: enable, 0:disable.
                    SPI_MEM_CACHE_USR_SADDR_4BYTE:  u1, 
                    
                    /// [1:1] For SPI0, In the external RAM mode, spi dual I/O mode enable, 1: enable, 0:disable
                    SPI_MEM_USR_SRAM_DIO:  u1, 
                    
                    /// [2:2] For SPI0, In the external RAM mode, spi quad I/O mode enable, 1: enable, 0:disable
                    SPI_MEM_USR_SRAM_QIO:  u1, 
                    
                    /// [3:3] For SPI0, In the external RAM mode, it is the enable bit of dummy phase for write operations.
                    SPI_MEM_USR_WR_SRAM_DUMMY:  u1, 
                    
                    /// [4:4] For SPI0, In the external RAM mode, it is the enable bit of dummy phase for read operations.
                    SPI_MEM_USR_RD_SRAM_DUMMY:  u1, 
                    
                    /// [5:5] For SPI0, In the external RAM mode cache read external RAM for user define command.
                    SPI_MEM_CACHE_SRAM_USR_RCMD:  u1, 
                    
                    /// [6:11] For SPI0, In the external RAM mode, it is the length in bits of read dummy phase. The register value shall be (bit_num-1).
                    SPI_MEM_SRAM_RDUMMY_CYCLELEN:  u6, 
                    
                    /// [12:13] 
                    res0:  u0, 
                    
                    /// [14:19] For SPI0, In the external RAM mode, it is the length in bits of address phase. The register value shall be (bit_num-1).
                    SPI_MEM_SRAM_ADDR_BITLEN:  u6, 
                    
                    /// [20:20] For SPI0, In the external RAM mode cache write sram for user define command
                    SPI_MEM_CACHE_SRAM_USR_WCMD:  u1, 
                    
                    /// [21:21] reserved
                    SPI_MEM_SRAM_OCT:  u1, 
                    
                    /// [22:27] For SPI0, In the external RAM mode, it is the length in bits of write dummy phase. The register value shall be (bit_num-1).
                    SPI_MEM_SRAM_WDUMMY_CYCLELEN:  u6, 
                    
                    /// [28:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x60002040));
                
                /// SPI0 external RAM mode control register
                pub const SPI_MEM_SRAM_CMD = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:1] SPI clock mode bits. 0: SPI clock is off when CS inactive 1: SPI clock is delayed one cycle after CS inactive 2: SPI clock is delayed two cycles after CS inactive 3: SPI clock is always on.
                    SPI_MEM_SCLK_MODE:  u2, 
                    
                    /// [2:9] Mode bits in the external RAM fast read modeit is combined with spi_mem_fastrd_mode bit.
                    SPI_MEM_SWB_MODE:  u8, 
                    
                    /// [10:10] For SPI0 external RAM , din phase apply 2 signals. 1: enable 0: disable. The bit is the same with spi_mem_usr_sram_dio.
                    SPI_MEM_SDIN_DUAL:  u1, 
                    
                    /// [11:11] For SPI0 external RAM , dout phase apply 2 signals. 1: enable 0: disable. The bit is the same with spi_mem_usr_sram_dio.
                    SPI_MEM_SDOUT_DUAL:  u1, 
                    
                    /// [12:12] For SPI0 external RAM , address phase apply 2 signals. 1: enable 0: disable. The bit is the same with spi_mem_usr_sram_dio.
                    SPI_MEM_SADDR_DUAL:  u1, 
                    
                    /// [13:13] 
                    res0:  u0, 
                    
                    /// [14:14] For SPI0 external RAM , din phase apply 4 signals. 1: enable 0: disable. The bit is the same with spi_mem_usr_sram_qio.
                    SPI_MEM_SDIN_QUAD:  u1, 
                    
                    /// [15:15] For SPI0 external RAM , dout phase apply 4 signals. 1: enable 0: disable. The bit is the same with spi_mem_usr_sram_qio.
                    SPI_MEM_SDOUT_QUAD:  u1, 
                    
                    /// [16:16] For SPI0 external RAM , address phase apply 4 signals. 1: enable 0: disable. The bit is the same with spi_mem_usr_sram_qio.
                    SPI_MEM_SADDR_QUAD:  u1, 
                    
                    /// [17:17] For SPI0 external RAM , cmd phase apply 4 signals. 1: enable 0: disable. The bit is the same with spi_mem_usr_sram_qio.
                    SPI_MEM_SCMD_QUAD:  u1, 
                    
                    /// [18:18] For SPI0 external RAM , din phase apply 8 signals. 1: enable 0: disable.
                    SPI_MEM_SDIN_OCT:  u1, 
                    
                    /// [19:19] For SPI0 external RAM , dout phase apply 8 signals. 1: enable 0: disable.
                    SPI_MEM_SDOUT_OCT:  u1, 
                    
                    /// [20:20] For SPI0 external RAM , address phase apply 4 signals. 1: enable 0: disable.
                    SPI_MEM_SADDR_OCT:  u1, 
                    
                    /// [21:21] For SPI0 external RAM , cmd phase apply 8 signals. 1: enable 0: disable.
                    SPI_MEM_SCMD_OCT:  u1, 
                    
                    /// [22:22] In the dummy phase of a MSPI read data transfer when accesses to external RAM, the signal level of SPI bus is output by the MSPI controller.
                    SPI_MEM_SDUMMY_RIN:  u1, 
                    
                    /// [23:23] In the dummy phase of a MSPI write data transfer when accesses to external RAM, the signal level of SPI bus is output by the MSPI controller.
                    SPI_MEM_SDUMMY_WOUT:  u1, 
                    
                    /// [24:24] In the dummy phase of an MSPI write data transfer when accesses to external RAM, the level of SPI_DQS is output by the MSPI controller.
                    SPI_SMEM_WDUMMY_DQS_ALWAYS_OUT:  u1, 
                    
                    /// [25:25] In the dummy phase of an MSPI write data transfer when accesses to external RAM, the level of SPI_IO[7:0] is output by the MSPI controller.
                    SPI_SMEM_WDUMMY_ALWAYS_OUT:  u1, 
                    
                    /// [26:29] 
                    res1:  u0, 
                    
                    /// [30:30] When accesses to external RAM, 1: the IE signals of pads connected to SPI_DQS are always 1. 0: Others.
                    SPI_SMEM_DQS_IE_ALWAYS_ON:  u1, 
                    
                    /// [31:31] When accesses to external RAM, 1: the IE signals of pads connected to SPI_IO[7:0] are always 1. 0: Others.
                    SPI_SMEM_DATA_IE_ALWAYS_ON:  u1, 
                    
                }), @ptrFromInt(0x60002044));
                
                /// SPI0 external RAM DDR read command control register
                pub const SPI_MEM_SRAM_DRD_CMD = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:15] For SPI0,When cache mode is enable it is the read command value of command phase for sram.
                    SPI_MEM_CACHE_SRAM_USR_RD_CMD_VALUE:  u16, 
                    
                    /// [16:27] 
                    res0:  u0, 
                    
                    /// [28:31] For SPI0,When cache mode is enable it is the length in bits of command phase for sram. The register value shall be (bit_num-1).
                    SPI_MEM_CACHE_SRAM_USR_RD_CMD_BITLEN:  u4, 
                    
                }), @ptrFromInt(0x60002048));
                
                /// SPI0 external RAM DDR write command control register
                pub const SPI_MEM_SRAM_DWR_CMD = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:15] For SPI0,When cache mode is enable it is the write command value of command phase for sram.
                    SPI_MEM_CACHE_SRAM_USR_WR_CMD_VALUE:  u16, 
                    
                    /// [16:27] 
                    res0:  u0, 
                    
                    /// [28:31] For SPI0,When cache mode is enable it is the in bits of command phasefor sram. The register value shall be (bit_num-1).
                    SPI_MEM_CACHE_SRAM_USR_WR_CMD_BITLEN:  u4, 
                    
                }), @ptrFromInt(0x6000204c));
                
                /// SPI0 external RAM clock control register
                pub const SPI_MEM_SRAM_CLK = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] For SPI0 external RAMinterface, it must be equal to spi_mem_clkcnt_N.
                    SPI_MEM_SCLKCNT_L:  u8, 
                    
                    /// [8:15] For SPI0 external RAMinterface, it must be floor((spi_mem_clkcnt_N+1)/2-1).
                    SPI_MEM_SCLKCNT_H:  u8, 
                    
                    /// [16:23] For SPI0 external RAMinterface, it is the divider of spi_mem_clk. So spi_mem_clk frequency is system/(spi_mem_clkcnt_N+1)
                    SPI_MEM_SCLKCNT_N:  u8, 
                    
                    /// [24:30] 
                    res0:  u0, 
                    
                    /// [31:31] For SPI0 external RAMinterface, 1: spi_mem_clk is eqaul to system 0: spi_mem_clk is divided from system clock.
                    SPI_MEM_SCLK_EQU_SYSCLK:  u1, 
                    
                }), @ptrFromInt(0x60002050));
                
                /// SPI0 FSM status register
                pub const SPI_MEM_FSM = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:6] 
                    res0:  u0, 
                    
                    /// [7:11] The lock delay time of SPI0/1 arbiter by spi0_slv_st, after PER is sent by SPI1.
                    SPI_MEM_LOCK_DELAY_TIME:  u5, 
                    
                    /// [12:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x60002054));
                
                /// SPI0 interrupt enable register
                pub const SPI_MEM_INT_ENA = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:2] 
                    res0:  u0, 
                    
                    /// [3:3] The enable bit for SPI_MEM_SLV_ST_END_INT interrupt.
                    SPI_MEM_SLV_ST_END_INT_ENA:  u1, 
                    
                    /// [4:4] The enable bit for SPI_MEM_MST_ST_END_INT interrupt.
                    SPI_MEM_MST_ST_END_INT_ENA:  u1, 
                    
                    /// [5:5] The enable bit for SPI_MEM_ECC_ERR_INT interrupt.
                    SPI_MEM_ECC_ERR_INT_ENA:  u1, 
                    
                    /// [6:6] The enable bit for SPI_MEM_PMS_REJECT_INT interrupt.
                    SPI_MEM_PMS_REJECT_INT_ENA:  u1, 
                    
                    /// [7:7] The enable bit for SPI_MEM_AXI_RADDR_ERR_INT interrupt.
                    SPI_MEM_AXI_RADDR_ERR_INT_ENA:  u1, 
                    
                    /// [8:8] The enable bit for SPI_MEM_AXI_WR_FALSH_ERR_INT interrupt.
                    SPI_MEM_AXI_WR_FLASH_ERR_INT_ENA:  u1, 
                    
                    /// [9:9] The enable bit for SPI_MEM_AXI_WADDR_ERR_INT interrupt.
                    SPI_MEM_AXI_WADDR_ERR_INT__ENA:  u1, 
                    
                    /// [10:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x600020c0));
                
                /// SPI0 interrupt clear register
                pub const SPI_MEM_INT_CLR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:2] 
                    res0:  u0, 
                    
                    /// [3:3] The clear bit for SPI_MEM_SLV_ST_END_INT interrupt.
                    SPI_MEM_SLV_ST_END_INT_CLR:  u1, 
                    
                    /// [4:4] The clear bit for SPI_MEM_MST_ST_END_INT interrupt.
                    SPI_MEM_MST_ST_END_INT_CLR:  u1, 
                    
                    /// [5:5] The clear bit for SPI_MEM_ECC_ERR_INT interrupt.
                    SPI_MEM_ECC_ERR_INT_CLR:  u1, 
                    
                    /// [6:6] The clear bit for SPI_MEM_PMS_REJECT_INT interrupt.
                    SPI_MEM_PMS_REJECT_INT_CLR:  u1, 
                    
                    /// [7:7] The clear bit for SPI_MEM_AXI_RADDR_ERR_INT interrupt.
                    SPI_MEM_AXI_RADDR_ERR_INT_CLR:  u1, 
                    
                    /// [8:8] The clear bit for SPI_MEM_AXI_WR_FALSH_ERR_INT interrupt.
                    SPI_MEM_AXI_WR_FLASH_ERR_INT_CLR:  u1, 
                    
                    /// [9:9] The clear bit for SPI_MEM_AXI_WADDR_ERR_INT interrupt.
                    SPI_MEM_AXI_WADDR_ERR_INT_CLR:  u1, 
                    
                    /// [10:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x600020c4));
                
                /// SPI0 interrupt raw register
                pub const SPI_MEM_INT_RAW = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:2] 
                    res0:  u0, 
                    
                    /// [3:3] The raw bit for SPI_MEM_SLV_ST_END_INT interrupt. 1: Triggered when spi0_slv_st is changed from non idle state to idle state. It means that SPI_CS raises high. 0: Others
                    SPI_MEM_SLV_ST_END_INT_RAW:  u1, 
                    
                    /// [4:4] The raw bit for SPI_MEM_MST_ST_END_INT interrupt. 1: Triggered when spi0_mst_st is changed from non idle state to idle state. 0: Others.
                    SPI_MEM_MST_ST_END_INT_RAW:  u1, 
                    
                    /// [5:5] The raw bit for SPI_MEM_ECC_ERR_INT interrupt. When SPI_FMEM_ECC_ERR_INT_EN is set andSPI_SMEM_ECC_ERR_INT_EN is cleared, this bit is triggered when the error times of SPI0/1 ECC read flash are equal or bigger than SPI_MEM_ECC_ERR_INT_NUM. When SPI_FMEM_ECC_ERR_INT_EN is cleared andSPI_SMEM_ECC_ERR_INT_EN is set, this bit is triggered when the error times of SPI0/1 ECC read external RAM are equal or bigger than SPI_MEM_ECC_ERR_INT_NUM. When SPI_FMEM_ECC_ERR_INT_EN andSPI_SMEM_ECC_ERR_INT_EN are set, this bit is triggered when the total error times of SPI0/1 ECC read external RAM and flash are equal or bigger than SPI_MEM_ECC_ERR_INT_NUM. When SPI_FMEM_ECC_ERR_INT_EN andSPI_SMEM_ECC_ERR_INT_EN are cleared, this bit will not be triggered.
                    SPI_MEM_ECC_ERR_INT_RAW:  u1, 
                    
                    /// [6:6] The raw bit for SPI_MEM_PMS_REJECT_INT interrupt. 1: Triggered when SPI1 access is rejected. 0: Others.
                    SPI_MEM_PMS_REJECT_INT_RAW:  u1, 
                    
                    /// [7:7] The raw bit for SPI_MEM_AXI_RADDR_ERR_INT interrupt. 1: Triggered when AXI read address is invalid by compared to MMU configuration. 0: Others.
                    SPI_MEM_AXI_RADDR_ERR_INT_RAW:  u1, 
                    
                    /// [8:8] The raw bit for SPI_MEM_AXI_WR_FALSH_ERR_INT interrupt. 1: Triggered when AXI write flash request is received. 0: Others.
                    SPI_MEM_AXI_WR_FLASH_ERR_INT_RAW:  u1, 
                    
                    /// [9:9] The raw bit for SPI_MEM_AXI_WADDR_ERR_INT interrupt. 1: Triggered when AXI write address is invalid by compared to MMU configuration. 0: Others.
                    SPI_MEM_AXI_WADDR_ERR_INT_RAW:  u1, 
                    
                    /// [10:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x600020c8));
                
                /// SPI0 interrupt status register
                pub const SPI_MEM_INT_ST = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:2] 
                    res0:  u0, 
                    
                    /// [3:3] The status bit for SPI_MEM_SLV_ST_END_INT interrupt.
                    SPI_MEM_SLV_ST_END_INT_ST:  u1, 
                    
                    /// [4:4] The status bit for SPI_MEM_MST_ST_END_INT interrupt.
                    SPI_MEM_MST_ST_END_INT_ST:  u1, 
                    
                    /// [5:5] The status bit for SPI_MEM_ECC_ERR_INT interrupt.
                    SPI_MEM_ECC_ERR_INT_ST:  u1, 
                    
                    /// [6:6] The status bit for SPI_MEM_PMS_REJECT_INT interrupt.
                    SPI_MEM_PMS_REJECT_INT_ST:  u1, 
                    
                    /// [7:7] The enable bit for SPI_MEM_AXI_RADDR_ERR_INT interrupt.
                    SPI_MEM_AXI_RADDR_ERR_INT_ST:  u1, 
                    
                    /// [8:8] The enable bit for SPI_MEM_AXI_WR_FALSH_ERR_INT interrupt.
                    SPI_MEM_AXI_WR_FLASH_ERR_INT_ST:  u1, 
                    
                    /// [9:9] The enable bit for SPI_MEM_AXI_WADDR_ERR_INT interrupt.
                    SPI_MEM_AXI_WADDR_ERR_INT_ST:  u1, 
                    
                    /// [10:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x600020cc));
                
                /// SPI0 flash DDR mode control register
                pub const SPI_MEM_DDR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] 1: in DDR mode,0 in SDR mode
                    SPI_FMEM_DDR_EN:  u1, 
                    
                    /// [1:1] Set the bit to enable variable dummy cycle in spi DDR mode.
                    SPI_FMEM_VAR_DUMMY:  u1, 
                    
                    /// [2:2] Set the bit to reorder rx data of the word in spi DDR mode.
                    SPI_FMEM_DDR_RDAT_SWP:  u1, 
                    
                    /// [3:3] Set the bit to reorder tx data of the word in spi DDR mode.
                    SPI_FMEM_DDR_WDAT_SWP:  u1, 
                    
                    /// [4:4] the bit is used to disable dual edge in command phase when DDR mode.
                    SPI_FMEM_DDR_CMD_DIS:  u1, 
                    
                    /// [5:11] It is the minimum output data length in the panda device.
                    SPI_FMEM_OUTMINBYTELEN:  u7, 
                    
                    /// [12:12] Set this bit to mask the first or the last byte in SPI0 ECC DDR write mode, when accesses to flash.
                    SPI_FMEM_TX_DDR_MSK_EN:  u1, 
                    
                    /// [13:13] Set this bit to mask the first or the last byte in SPI0 ECC DDR read mode, when accesses to flash.
                    SPI_FMEM_RX_DDR_MSK_EN:  u1, 
                    
                    /// [14:20] The delay number of data strobe which from memory based on SPI clock.
                    SPI_FMEM_USR_DDR_DQS_THD:  u7, 
                    
                    /// [21:21] 1: Do not need the input of SPI_DQS signal, SPI0 starts to receive data when spi0_slv_st is in SPI_MEM_DIN state. It is used when there is no SPI_DQS signal or SPI_DQS signal is not stable. 0: SPI0 starts to store data at the positive and negative edge of SPI_DQS.
                    SPI_FMEM_DDR_DQS_LOOP:  u1, 
                    
                    /// [22:23] 
                    res0:  u0, 
                    
                    /// [24:24] Set this bit to enable the differential SPI_CLK#.
                    SPI_FMEM_CLK_DIFF_EN:  u1, 
                    
                    /// [25:25] 
                    res1:  u0, 
                    
                    /// [26:26] Set this bit to enable the input of SPI_DQS signal in SPI phases of CMD and ADDR.
                    SPI_FMEM_DQS_CA_IN:  u1, 
                    
                    /// [27:27] Set this bit to enable the vary dummy function in SPI HyperBus mode, when SPI0 accesses flash or SPI1 accesses flash or sram.
                    SPI_FMEM_HYPERBUS_DUMMY_2X:  u1, 
                    
                    /// [28:28] Set this bit to invert SPI_DIFF when accesses to flash. .
                    SPI_FMEM_CLK_DIFF_INV:  u1, 
                    
                    /// [29:29] Set this bit to enable octa_ram address out when accesses to flash, which means ADDR_OUT[31:0] = {spi_usr_addr_value[25:4], 6'd0, spi_usr_addr_value[3:1], 1'b0}.
                    SPI_FMEM_OCTA_RAM_ADDR:  u1, 
                    
                    /// [30:30] Set this bit to enable HyperRAM address out when accesses to flash, which means ADDR_OUT[31:0] = {spi_usr_addr_value[19:4], 13'd0, spi_usr_addr_value[3:1]}.
                    SPI_FMEM_HYPERBUS_CA:  u1, 
                    
                    /// [31:31] 
                    res2:  u0, 
                    
                }), @ptrFromInt(0x600020d4));
                
                /// SPI0 external RAM DDR mode control register
                pub const SPI_SMEM_DDR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] 1: in DDR mode,0 in SDR mode
                    EN:  u1, 
                    
                    /// [1:1] Set the bit to enable variable dummy cycle in spi DDR mode.
                    SPI_SMEM_VAR_DUMMY:  u1, 
                    
                    /// [2:2] Set the bit to reorder rx data of the word in spi DDR mode.
                    RDAT_SWP:  u1, 
                    
                    /// [3:3] Set the bit to reorder tx data of the word in spi DDR mode.
                    WDAT_SWP:  u1, 
                    
                    /// [4:4] the bit is used to disable dual edge in command phase when DDR mode.
                    CMD_DIS:  u1, 
                    
                    /// [5:11] It is the minimum output data length in the DDR psram.
                    SPI_SMEM_OUTMINBYTELEN:  u7, 
                    
                    /// [12:12] Set this bit to mask the first or the last byte in SPI0 ECC DDR write mode, when accesses to external RAM.
                    SPI_SMEM_TX_DDR_MSK_EN:  u1, 
                    
                    /// [13:13] Set this bit to mask the first or the last byte in SPI0 ECC DDR read mode, when accesses to external RAM.
                    SPI_SMEM_RX_DDR_MSK_EN:  u1, 
                    
                    /// [14:20] The delay number of data strobe which from memory based on SPI clock.
                    SPI_SMEM_USR_DDR_DQS_THD:  u7, 
                    
                    /// [21:21] 1: Do not need the input of SPI_DQS signal, SPI0 starts to receive data when spi0_slv_st is in SPI_MEM_DIN state. It is used when there is no SPI_DQS signal or SPI_DQS signal is not stable. 0: SPI0 starts to store data at the positive and negative edge of SPI_DQS.
                    DQS_LOOP:  u1, 
                    
                    /// [22:23] 
                    res0:  u0, 
                    
                    /// [24:24] Set this bit to enable the differential SPI_CLK#.
                    SPI_SMEM_CLK_DIFF_EN:  u1, 
                    
                    /// [25:25] 
                    res1:  u0, 
                    
                    /// [26:26] Set this bit to enable the input of SPI_DQS signal in SPI phases of CMD and ADDR.
                    SPI_SMEM_DQS_CA_IN:  u1, 
                    
                    /// [27:27] Set this bit to enable the vary dummy function in SPI HyperBus mode, when SPI0 accesses flash or SPI1 accesses flash or sram.
                    SPI_SMEM_HYPERBUS_DUMMY_2X:  u1, 
                    
                    /// [28:28] Set this bit to invert SPI_DIFF when accesses to external RAM. .
                    SPI_SMEM_CLK_DIFF_INV:  u1, 
                    
                    /// [29:29] Set this bit to enable octa_ram address out when accesses to external RAM, which means ADDR_OUT[31:0] = {spi_usr_addr_value[25:4], 6'd0, spi_usr_addr_value[3:1], 1'b0}.
                    SPI_SMEM_OCTA_RAM_ADDR:  u1, 
                    
                    /// [30:30] Set this bit to enable HyperRAM address out when accesses to external RAM, which means ADDR_OUT[31:0] = {spi_usr_addr_value[19:4], 13'd0, spi_usr_addr_value[3:1]}.
                    SPI_SMEM_HYPERBUS_CA:  u1, 
                    
                    /// [31:31] 
                    res2:  u0, 
                    
                }), @ptrFromInt(0x600020d8));
                
                /// MSPI flash ACE section %s attribute register
                pub const SPI_FMEM_PMS0_ATTR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] 1: SPI1 flash ACE section %s read accessible. 0: Not allowed.
                    SPI_FMEM_PMS_RD_ATTR:  u1, 
                    
                    /// [1:1] 1: SPI1 flash ACE section %s write accessible. 0: Not allowed.
                    SPI_FMEM_PMS_WR_ATTR:  u1, 
                    
                    /// [2:2] SPI1 flash ACE section %s ECC mode, 1: enable ECC mode. 0: Disable it. The flash ACE section %s is configured by registers SPI_FMEM_PMS%s_ADDR_REG and SPI_FMEM_PMS%s_SIZE_REG.
                    SPI_FMEM_PMS_ECC:  u1, 
                    
                    /// [3:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60002100));
                
                /// MSPI flash ACE section %s attribute register
                pub const SPI_FMEM_PMS0_ATTR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] 1: SPI1 flash ACE section %s read accessible. 0: Not allowed.
                    SPI_FMEM_PMS_RD_ATTR:  u1, 
                    
                    /// [1:1] 1: SPI1 flash ACE section %s write accessible. 0: Not allowed.
                    SPI_FMEM_PMS_WR_ATTR:  u1, 
                    
                    /// [2:2] SPI1 flash ACE section %s ECC mode, 1: enable ECC mode. 0: Disable it. The flash ACE section %s is configured by registers SPI_FMEM_PMS%s_ADDR_REG and SPI_FMEM_PMS%s_SIZE_REG.
                    SPI_FMEM_PMS_ECC:  u1, 
                    
                    /// [3:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60002104));
                
                /// MSPI flash ACE section %s attribute register
                pub const SPI_FMEM_PMS0_ATTR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] 1: SPI1 flash ACE section %s read accessible. 0: Not allowed.
                    SPI_FMEM_PMS_RD_ATTR:  u1, 
                    
                    /// [1:1] 1: SPI1 flash ACE section %s write accessible. 0: Not allowed.
                    SPI_FMEM_PMS_WR_ATTR:  u1, 
                    
                    /// [2:2] SPI1 flash ACE section %s ECC mode, 1: enable ECC mode. 0: Disable it. The flash ACE section %s is configured by registers SPI_FMEM_PMS%s_ADDR_REG and SPI_FMEM_PMS%s_SIZE_REG.
                    SPI_FMEM_PMS_ECC:  u1, 
                    
                    /// [3:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60002108));
                
                /// MSPI flash ACE section %s attribute register
                pub const SPI_FMEM_PMS0_ATTR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] 1: SPI1 flash ACE section %s read accessible. 0: Not allowed.
                    SPI_FMEM_PMS_RD_ATTR:  u1, 
                    
                    /// [1:1] 1: SPI1 flash ACE section %s write accessible. 0: Not allowed.
                    SPI_FMEM_PMS_WR_ATTR:  u1, 
                    
                    /// [2:2] SPI1 flash ACE section %s ECC mode, 1: enable ECC mode. 0: Disable it. The flash ACE section %s is configured by registers SPI_FMEM_PMS%s_ADDR_REG and SPI_FMEM_PMS%s_SIZE_REG.
                    SPI_FMEM_PMS_ECC:  u1, 
                    
                    /// [3:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000210c));
                
                /// SPI1 flash ACE section %s start address register
                pub const SPI_FMEM_PMS0_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:25] SPI1 flash ACE section %s start address value
                    S:  u26, 
                    
                    /// [26:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60002110));
                
                /// SPI1 flash ACE section %s start address register
                pub const SPI_FMEM_PMS0_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:25] SPI1 flash ACE section %s start address value
                    S:  u26, 
                    
                    /// [26:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60002114));
                
                /// SPI1 flash ACE section %s start address register
                pub const SPI_FMEM_PMS0_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:25] SPI1 flash ACE section %s start address value
                    S:  u26, 
                    
                    /// [26:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60002118));
                
                /// SPI1 flash ACE section %s start address register
                pub const SPI_FMEM_PMS0_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:25] SPI1 flash ACE section %s start address value
                    S:  u26, 
                    
                    /// [26:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000211c));
                
                /// SPI1 flash ACE section %s start address register
                pub const SPI_FMEM_PMS0_SIZE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:13] SPI1 flash ACE section %s address region is (SPI_FMEM_PMS%s_ADDR_S, SPI_FMEM_PMS%s_ADDR_S + SPI_FMEM_PMS%s_SIZE)
                    SPI_FMEM_PMS_SIZE:  u14, 
                    
                    /// [14:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60002120));
                
                /// SPI1 flash ACE section %s start address register
                pub const SPI_FMEM_PMS0_SIZE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:13] SPI1 flash ACE section %s address region is (SPI_FMEM_PMS%s_ADDR_S, SPI_FMEM_PMS%s_ADDR_S + SPI_FMEM_PMS%s_SIZE)
                    SPI_FMEM_PMS_SIZE:  u14, 
                    
                    /// [14:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60002124));
                
                /// SPI1 flash ACE section %s start address register
                pub const SPI_FMEM_PMS0_SIZE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:13] SPI1 flash ACE section %s address region is (SPI_FMEM_PMS%s_ADDR_S, SPI_FMEM_PMS%s_ADDR_S + SPI_FMEM_PMS%s_SIZE)
                    SPI_FMEM_PMS_SIZE:  u14, 
                    
                    /// [14:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60002128));
                
                /// SPI1 flash ACE section %s start address register
                pub const SPI_FMEM_PMS0_SIZE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:13] SPI1 flash ACE section %s address region is (SPI_FMEM_PMS%s_ADDR_S, SPI_FMEM_PMS%s_ADDR_S + SPI_FMEM_PMS%s_SIZE)
                    SPI_FMEM_PMS_SIZE:  u14, 
                    
                    /// [14:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000212c));
                
                /// SPI1 flash ACE section %s start address register
                pub const SPI_SMEM_PMS0_ATTR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] 1: SPI1 external RAM ACE section %s read accessible. 0: Not allowed.
                    SPI_SMEM_PMS_RD_ATTR:  u1, 
                    
                    /// [1:1] 1: SPI1 external RAM ACE section %s write accessible. 0: Not allowed.
                    SPI_SMEM_PMS_WR_ATTR:  u1, 
                    
                    /// [2:2] SPI1 external RAM ACE section %s ECC mode, 1: enable ECC mode. 0: Disable it. The external RAM ACE section %s is configured by registers SPI_SMEM_PMS%s_ADDR_REG and SPI_SMEM_PMS%s_SIZE_REG.
                    SPI_SMEM_PMS_ECC:  u1, 
                    
                    /// [3:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60002130));
                
                /// SPI1 flash ACE section %s start address register
                pub const SPI_SMEM_PMS0_ATTR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] 1: SPI1 external RAM ACE section %s read accessible. 0: Not allowed.
                    SPI_SMEM_PMS_RD_ATTR:  u1, 
                    
                    /// [1:1] 1: SPI1 external RAM ACE section %s write accessible. 0: Not allowed.
                    SPI_SMEM_PMS_WR_ATTR:  u1, 
                    
                    /// [2:2] SPI1 external RAM ACE section %s ECC mode, 1: enable ECC mode. 0: Disable it. The external RAM ACE section %s is configured by registers SPI_SMEM_PMS%s_ADDR_REG and SPI_SMEM_PMS%s_SIZE_REG.
                    SPI_SMEM_PMS_ECC:  u1, 
                    
                    /// [3:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60002134));
                
                /// SPI1 flash ACE section %s start address register
                pub const SPI_SMEM_PMS0_ATTR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] 1: SPI1 external RAM ACE section %s read accessible. 0: Not allowed.
                    SPI_SMEM_PMS_RD_ATTR:  u1, 
                    
                    /// [1:1] 1: SPI1 external RAM ACE section %s write accessible. 0: Not allowed.
                    SPI_SMEM_PMS_WR_ATTR:  u1, 
                    
                    /// [2:2] SPI1 external RAM ACE section %s ECC mode, 1: enable ECC mode. 0: Disable it. The external RAM ACE section %s is configured by registers SPI_SMEM_PMS%s_ADDR_REG and SPI_SMEM_PMS%s_SIZE_REG.
                    SPI_SMEM_PMS_ECC:  u1, 
                    
                    /// [3:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60002138));
                
                /// SPI1 flash ACE section %s start address register
                pub const SPI_SMEM_PMS0_ATTR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] 1: SPI1 external RAM ACE section %s read accessible. 0: Not allowed.
                    SPI_SMEM_PMS_RD_ATTR:  u1, 
                    
                    /// [1:1] 1: SPI1 external RAM ACE section %s write accessible. 0: Not allowed.
                    SPI_SMEM_PMS_WR_ATTR:  u1, 
                    
                    /// [2:2] SPI1 external RAM ACE section %s ECC mode, 1: enable ECC mode. 0: Disable it. The external RAM ACE section %s is configured by registers SPI_SMEM_PMS%s_ADDR_REG and SPI_SMEM_PMS%s_SIZE_REG.
                    SPI_SMEM_PMS_ECC:  u1, 
                    
                    /// [3:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000213c));
                
                /// SPI1 external RAM ACE section %s start address register
                pub const SPI_SMEM_PMS0_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:25] SPI1 external RAM ACE section %s start address value
                    S:  u26, 
                    
                    /// [26:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60002140));
                
                /// SPI1 external RAM ACE section %s start address register
                pub const SPI_SMEM_PMS0_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:25] SPI1 external RAM ACE section %s start address value
                    S:  u26, 
                    
                    /// [26:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60002144));
                
                /// SPI1 external RAM ACE section %s start address register
                pub const SPI_SMEM_PMS0_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:25] SPI1 external RAM ACE section %s start address value
                    S:  u26, 
                    
                    /// [26:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60002148));
                
                /// SPI1 external RAM ACE section %s start address register
                pub const SPI_SMEM_PMS0_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:25] SPI1 external RAM ACE section %s start address value
                    S:  u26, 
                    
                    /// [26:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000214c));
                
                /// SPI1 external RAM ACE section %s start address register
                pub const SPI_SMEM_PMS0_SIZE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:13] SPI1 external RAM ACE section %s address region is (SPI_SMEM_PMS%s_ADDR_S, SPI_SMEM_PMS%s_ADDR_S + SPI_SMEM_PMS%s_SIZE)
                    SPI_SMEM_PMS_SIZE:  u14, 
                    
                    /// [14:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60002150));
                
                /// SPI1 external RAM ACE section %s start address register
                pub const SPI_SMEM_PMS0_SIZE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:13] SPI1 external RAM ACE section %s address region is (SPI_SMEM_PMS%s_ADDR_S, SPI_SMEM_PMS%s_ADDR_S + SPI_SMEM_PMS%s_SIZE)
                    SPI_SMEM_PMS_SIZE:  u14, 
                    
                    /// [14:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60002154));
                
                /// SPI1 external RAM ACE section %s start address register
                pub const SPI_SMEM_PMS0_SIZE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:13] SPI1 external RAM ACE section %s address region is (SPI_SMEM_PMS%s_ADDR_S, SPI_SMEM_PMS%s_ADDR_S + SPI_SMEM_PMS%s_SIZE)
                    SPI_SMEM_PMS_SIZE:  u14, 
                    
                    /// [14:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60002158));
                
                /// SPI1 external RAM ACE section %s start address register
                pub const SPI_SMEM_PMS0_SIZE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:13] SPI1 external RAM ACE section %s address region is (SPI_SMEM_PMS%s_ADDR_S, SPI_SMEM_PMS%s_ADDR_S + SPI_SMEM_PMS%s_SIZE)
                    SPI_SMEM_PMS_SIZE:  u14, 
                    
                    /// [14:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000215c));
                
                /// SPI1 access reject register
                pub const SPI_MEM_PMS_REJECT = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:25] This bits show the first SPI1 access error address. It is cleared by whenSPI_MEM_PMS_REJECT_INT_CLR bit is set.
                    SPI_MEM_REJECT_ADDR:  u26, 
                    
                    /// [26:26] Set this bit to enable SPI0/1 transfer permission control function.
                    SPI_MEM_PM_EN:  u1, 
                    
                    /// [27:27] 
                    res0:  u0, 
                    
                    /// [28:28] 1: SPI1 write access error. 0: No write access error. It is cleared by whenSPI_MEM_PMS_REJECT_INT_CLR bit is set.
                    SPI_MEM_PMS_LD:  u1, 
                    
                    /// [29:29] 1: SPI1 read access error. 0: No read access error. It is cleared by whenSPI_MEM_PMS_REJECT_INT_CLR bit is set.
                    SPI_MEM_PMS_ST:  u1, 
                    
                    /// [30:30] 1: SPI1 access is rejected because of address miss. 0: No address miss error. It is cleared by whenSPI_MEM_PMS_REJECT_INT_CLR bit is set.
                    SPI_MEM_PMS_MULTI_HIT:  u1, 
                    
                    /// [31:31] 1: SPI1 access is rejected because of address multi-hit. 0: No address multi-hit error. It is cleared by whenSPI_MEM_PMS_REJECT_INT_CLR bit is set.
                    SPI_MEM_PMS_IVD:  u1, 
                    
                }), @ptrFromInt(0x60002164));
                
                /// MSPI ECC control register
                pub const SPI_MEM_ECC_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:10] 
                    res0:  u0, 
                    
                    /// [11:16] Set the error times of MSPI ECC read to generate MSPI SPI_MEM_ECC_ERR_INT interrupt.
                    SPI_FMEM_ECC_ERR_INT_NUM:  u6, 
                    
                    /// [17:17] Set this bit to calculate the error times of MSPI ECC read when accesses to flash.
                    SPI_FMEM_ECC_ERR_INT_EN:  u1, 
                    
                    /// [18:19] Set the page size of the flash accessed by MSPI. 0: 256 bytes. 1: 512 bytes. 2: 1024 bytes. 3: 2048 bytes.
                    SPI_FMEM_PAGE_SIZE:  u2, 
                    
                    /// [20:20] Set this bit to enable MSPI ECC address conversion, no matter MSPI accesses to the ECC region or non-ECC region of flash. If there is no ECC region in flash, this bit should be 0. Otherwise, this bit should be 1.
                    SPI_FMEM_ECC_ADDR_EN:  u1, 
                    
                    /// [21:21] Set this bit to enable ECC address convert in SPI0/1 USR_CMD transfer.
                    SPI_MEM_USR_ECC_ADDR_EN:  u1, 
                    
                    /// [22:23] 
                    res1:  u0, 
                    
                    /// [24:24] 1: The error information in SPI_MEM_ECC_ERR_BITS and SPI_MEM_ECC_ERR_ADDR is updated when there is an ECC error. 0: SPI_MEM_ECC_ERR_BITS and SPI_MEM_ECC_ERR_ADDR record the first ECC error information.
                    SPI_MEM_ECC_CONTINUE_RECORD_ERR_EN:  u1, 
                    
                    /// [25:31] Records the first ECC error bit number in the 16 bytes(From 0~127, corresponding to byte 0 bit 0 to byte 15 bit 7)
                    SPI_MEM_ECC_ERR_BITS:  u7, 
                    
                }), @ptrFromInt(0x60002168));
                
                /// MSPI ECC error address register
                pub const SPI_MEM_ECC_ERR_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:25] This bits show the first MSPI ECC error address. It is cleared by whenSPI_MEM_ECC_ERR_INT_CLR bit is set.
                    SPI_MEM_ECC_ERR_ADDR:  u26, 
                    
                    /// [26:31] This bits show the error times of MSPI ECC read. It is cleared by whenSPI_MEM_ECC_ERR_INT_CLR bit is set.
                    SPI_MEM_ECC_ERR_CNT:  u6, 
                    
                }), @ptrFromInt(0x6000216c));
                
                /// SPI0 AXI request error address.
                pub const SPI_MEM_AXI_ERR_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:25] This bits show the first AXI write/read invalid error or AXI write flash error address. It is cleared by when SPI_MEM_AXI_WADDR_ERR_INT_CLR, SPI_MEM_AXI_WR_FLASH_ERR_IN_CLR or SPI_MEM_AXI_RADDR_ERR_IN_CLR bit is set.
                    SPI_MEM_AXI_ERR_ADDR:  u26, 
                    
                    /// [26:26] The empty status of all AFIFO and SYNC_FIFO in MSPI module. 1: All AXI transfers and SPI0 transfers are done. 0: Others.
                    SPI_MEM_ALL_FIFO_EMPTY:  u1, 
                    
                    /// [27:27] 1: RDATA_AFIFO is empty. 0: At least one AXI read transfer is pending.
                    SPI_RDATA_AFIFO_REMPTY:  u1, 
                    
                    /// [28:28] 1: AXI_RADDR_CTL_AFIFO is empty. 0: At least one AXI read transfer is pending.
                    SPI_RADDR_AFIFO_REMPTY:  u1, 
                    
                    /// [29:29] 1: WDATA_AFIFO is empty. 0: At least one AXI write transfer is pending.
                    SPI_WDATA_AFIFO_REMPTY:  u1, 
                    
                    /// [30:30] 1: WBLEN_AFIFO is empty. 0: At least one AXI write transfer is pending.
                    SPI_WBLEN_AFIFO_REMPTY:  u1, 
                    
                    /// [31:31] This bit is set when WADDR_AFIFO, WBLEN_AFIFO, WDATA_AFIFO, AXI_RADDR_CTL_AFIFO and RDATA_AFIFO are empty and spi0_mst_st is IDLE.
                    SPI_ALL_AXI_TRANS_AFIFO_EMPTY:  u1, 
                    
                }), @ptrFromInt(0x60002170));
                
                /// MSPI ECC control register
                pub const SPI_SMEM_ECC_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:16] 
                    res0:  u0, 
                    
                    /// [17:17] Set this bit to calculate the error times of MSPI ECC read when accesses to external RAM.
                    SPI_SMEM_ECC_ERR_INT_EN:  u1, 
                    
                    /// [18:19] Set the page size of the external RAM accessed by MSPI. 0: 256 bytes. 1: 512 bytes. 2: 1024 bytes. 3: 2048 bytes.
                    SPI_SMEM_PAGE_SIZE:  u2, 
                    
                    /// [20:20] Set this bit to enable MSPI ECC address conversion, no matter MSPI accesses to the ECC region or non-ECC region of external RAM. If there is no ECC region in external RAM, this bit should be 0. Otherwise, this bit should be 1.
                    SPI_SMEM_ECC_ADDR_EN:  u1, 
                    
                    /// [21:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x60002174));
                
                /// SPI0 flash timing calibration register
                pub const SPI_MEM_TIMING_CALI = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] The bit is used to enable timing adjust clock for all reading operations.
                    SPI_MEM_TIMING_CLK_ENA:  u1, 
                    
                    /// [1:1] The bit is used to enable timing auto-calibration for all reading operations.
                    SPI_MEM_TIMING_CALI:  u1, 
                    
                    /// [2:4] add extra dummy spi clock cycle length for spi clock calibration.
                    SPI_MEM_EXTRA_DUMMY_CYCLELEN:  u3, 
                    
                    /// [5:5] Set this bit to enable DLL for timing calibration in DDR mode when accessed to flash.
                    SPI_MEM_DLL_TIMING_CALI:  u1, 
                    
                    /// [6:6] Set this bit to update delay mode, delay num and extra dummy in MSPI.
                    UPDATE:  u1, 
                    
                    /// [7:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60002180));
                
                /// MSPI flash input timing delay mode control register
                pub const SPI_MEM_DIN_MODE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:2] the input signals are delayed by system clock cycles, 0: input without delayed, 1: input with the posedge of clk_apb,2 input with the negedge of clk_apb,3: input with the posedge of clk_160, 4 input with the negedge of clk_160, 5: input with the spi_clk high edge,6: input with the spi_clk low edge
                    SPI_MEM_DIN0_MODE:  u3, 
                    
                    /// [3:5] the input signals are delayed by system clock cycles, 0: input without delayed, 1: input with the posedge of clk_apb,2 input with the negedge of clk_apb,3: input with the posedge of clk_160, 4 input with the negedge of clk_160, 5: input with the spi_clk high edge,6: input with the spi_clk low edge
                    SPI_MEM_DIN1_MODE:  u3, 
                    
                    /// [6:8] the input signals are delayed by system clock cycles, 0: input without delayed, 1: input with the posedge of clk_apb,2 input with the negedge of clk_apb,3: input with the posedge of clk_160, 4 input with the negedge of clk_160, 5: input with the spi_clk high edge,6: input with the spi_clk low edge
                    SPI_MEM_DIN2_MODE:  u3, 
                    
                    /// [9:11] the input signals are delayed by system clock cycles, 0: input without delayed, 1: input with the posedge of clk_apb,2 input with the negedge of clk_apb,3: input with the posedge of clk_160, 4 input with the negedge of clk_160, 5: input with the spi_clk high edge,6: input with the spi_clk low edge
                    SPI_MEM_DIN3_MODE:  u3, 
                    
                    /// [12:14] the input signals are delayed by system clock cycles, 0: input without delayed, 1: input with the posedge of clk_apb,2 input with the negedge of clk_apb, 3: input with the spi_clk
                    SPI_MEM_DIN4_MODE:  u3, 
                    
                    /// [15:17] the input signals are delayed by system clock cycles, 0: input without delayed, 1: input with the posedge of clk_apb,2 input with the negedge of clk_apb, 3: input with the spi_clk
                    SPI_MEM_DIN5_MODE:  u3, 
                    
                    /// [18:20] the input signals are delayed by system clock cycles, 0: input without delayed, 1: input with the posedge of clk_apb,2 input with the negedge of clk_apb, 3: input with the spi_clk
                    SPI_MEM_DIN6_MODE:  u3, 
                    
                    /// [21:23] the input signals are delayed by system clock cycles, 0: input without delayed, 1: input with the posedge of clk_apb,2 input with the negedge of clk_apb, 3: input with the spi_clk
                    SPI_MEM_DIN7_MODE:  u3, 
                    
                    /// [24:26] the input signals are delayed by system clock cycles, 0: input without delayed, 1: input with the posedge of clk_apb,2 input with the negedge of clk_apb, 3: input with the spi_clk
                    SPI_MEM_DINS_MODE:  u3, 
                    
                    /// [27:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60002184));
                
                /// MSPI flash input timing delay number control register
                pub const SPI_MEM_DIN_NUM = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:1] the input signals are delayed by system clock cycles, 0: delayed by 1 cycle, 1: delayed by 2 cycles,...
                    SPI_MEM_DIN0_NUM:  u2, 
                    
                    /// [2:3] the input signals are delayed by system clock cycles, 0: delayed by 1 cycle, 1: delayed by 2 cycles,...
                    SPI_MEM_DIN1_NUM:  u2, 
                    
                    /// [4:5] the input signals are delayed by system clock cycles, 0: delayed by 1 cycle, 1: delayed by 2 cycles,...
                    SPI_MEM_DIN2_NUM:  u2, 
                    
                    /// [6:7] the input signals are delayed by system clock cycles, 0: delayed by 1 cycle, 1: delayed by 2 cycles,...
                    SPI_MEM_DIN3_NUM:  u2, 
                    
                    /// [8:9] the input signals are delayed by system clock cycles, 0: delayed by 1 cycle, 1: delayed by 2 cycles,...
                    SPI_MEM_DIN4_NUM:  u2, 
                    
                    /// [10:11] the input signals are delayed by system clock cycles, 0: delayed by 1 cycle, 1: delayed by 2 cycles,...
                    SPI_MEM_DIN5_NUM:  u2, 
                    
                    /// [12:13] the input signals are delayed by system clock cycles, 0: delayed by 1 cycle, 1: delayed by 2 cycles,...
                    SPI_MEM_DIN6_NUM:  u2, 
                    
                    /// [14:15] the input signals are delayed by system clock cycles, 0: delayed by 1 cycle, 1: delayed by 2 cycles,...
                    SPI_MEM_DIN7_NUM:  u2, 
                    
                    /// [16:17] the input signals are delayed by system clock cycles, 0: delayed by 1 cycle, 1: delayed by 2 cycles,...
                    SPI_MEM_DINS_NUM:  u2, 
                    
                    /// [18:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60002188));
                
                /// MSPI flash output timing adjustment control register
                pub const SPI_MEM_DOUT_MODE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] the output signals are delayed by system clock cycles, 0: output without delayed, 1: output with the posedge of clk_apb,2 output with the negedge of clk_apb, 3: output with the posedge of clk_160,4 output with the negedge of clk_160,5: output with the spi_clk high edge ,6: output with the spi_clk low edge
                    SPI_MEM_DOUT0_MODE:  u1, 
                    
                    /// [1:1] the output signals are delayed by system clock cycles, 0: output without delayed, 1: output with the posedge of clk_apb,2 output with the negedge of clk_apb, 3: output with the posedge of clk_160,4 output with the negedge of clk_160,5: output with the spi_clk high edge ,6: output with the spi_clk low edge
                    SPI_MEM_DOUT1_MODE:  u1, 
                    
                    /// [2:2] the output signals are delayed by system clock cycles, 0: output without delayed, 1: output with the posedge of clk_apb,2 output with the negedge of clk_apb, 3: output with the posedge of clk_160,4 output with the negedge of clk_160,5: output with the spi_clk high edge ,6: output with the spi_clk low edge
                    SPI_MEM_DOUT2_MODE:  u1, 
                    
                    /// [3:3] the output signals are delayed by system clock cycles, 0: output without delayed, 1: output with the posedge of clk_apb,2 output with the negedge of clk_apb, 3: output with the posedge of clk_160,4 output with the negedge of clk_160,5: output with the spi_clk high edge ,6: output with the spi_clk low edge
                    SPI_MEM_DOUT3_MODE:  u1, 
                    
                    /// [4:4] the output signals are delayed by system clock cycles, 0: output without delayed, 1: output with the posedge of clk_apb,2 output with the negedge of clk_apb, 3: output with the spi_clk
                    SPI_MEM_DOUT4_MODE:  u1, 
                    
                    /// [5:5] the output signals are delayed by system clock cycles, 0: output without delayed, 1: output with the posedge of clk_apb,2 output with the negedge of clk_apb, 3: output with the spi_clk
                    SPI_MEM_DOUT5_MODE:  u1, 
                    
                    /// [6:6] the output signals are delayed by system clock cycles, 0: output without delayed, 1: output with the posedge of clk_apb,2 output with the negedge of clk_apb, 3: output with the spi_clk
                    SPI_MEM_DOUT6_MODE:  u1, 
                    
                    /// [7:7] the output signals are delayed by system clock cycles, 0: output without delayed, 1: output with the posedge of clk_apb,2 output with the negedge of clk_apb, 3: output with the spi_clk
                    SPI_MEM_DOUT7_MODE:  u1, 
                    
                    /// [8:8] the output signals are delayed by system clock cycles, 0: output without delayed, 1: output with the posedge of clk_apb,2 output with the negedge of clk_apb, 3: output with the spi_clk
                    SPI_MEM_DOUTS_MODE:  u1, 
                    
                    /// [9:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000218c));
                
                /// MSPI external RAM timing calibration register
                pub const SPI_SMEM_TIMING_CALI = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] For sram, the bit is used to enable timing adjust clock for all reading operations.
                    SPI_SMEM_TIMING_CLK_ENA:  u1, 
                    
                    /// [1:1] For sram, the bit is used to enable timing auto-calibration for all reading operations.
                    SPI_SMEM_TIMING_CALI:  u1, 
                    
                    /// [2:4] For sram, add extra dummy spi clock cycle length for spi clock calibration.
                    SPI_SMEM_EXTRA_DUMMY_CYCLELEN:  u3, 
                    
                    /// [5:5] Set this bit to enable DLL for timing calibration in DDR mode when accessed to EXT_RAM.
                    SPI_SMEM_DLL_TIMING_CALI:  u1, 
                    
                    /// [6:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60002190));
                
                /// MSPI external RAM input timing delay mode control register
                pub const SPI_SMEM_DIN_MODE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:2] the input signals are delayed by system clock cycles, 0: input without delayed, 1: input with the posedge of clk_apb,2 input with the negedge of clk_apb,3: input with the posedge of clk_160, 4 input with the negedge of clk_160, 5: input with the spi_clk high edge,6: input with the spi_clk low edge
                    SPI_SMEM_DIN0_MODE:  u3, 
                    
                    /// [3:5] the input signals are delayed by system clock cycles, 0: input without delayed, 1: input with the posedge of clk_apb,2 input with the negedge of clk_apb,3: input with the posedge of clk_160, 4 input with the negedge of clk_160, 5: input with the spi_clk high edge,6: input with the spi_clk low edge
                    SPI_SMEM_DIN1_MODE:  u3, 
                    
                    /// [6:8] the input signals are delayed by system clock cycles, 0: input without delayed, 1: input with the posedge of clk_apb,2 input with the negedge of clk_apb,3: input with the posedge of clk_160, 4 input with the negedge of clk_160, 5: input with the spi_clk high edge,6: input with the spi_clk low edge
                    SPI_SMEM_DIN2_MODE:  u3, 
                    
                    /// [9:11] the input signals are delayed by system clock cycles, 0: input without delayed, 1: input with the posedge of clk_apb,2 input with the negedge of clk_apb,3: input with the posedge of clk_160, 4 input with the negedge of clk_160, 5: input with the spi_clk high edge,6: input with the spi_clk low edge
                    SPI_SMEM_DIN3_MODE:  u3, 
                    
                    /// [12:14] the input signals are delayed by system clock cycles, 0: input without delayed, 1: input with the posedge of clk_apb,2 input with the negedge of clk_apb,3: input with the posedge of clk_160, 4 input with the negedge of clk_160, 5: input with the spi_clk high edge,6: input with the spi_clk low edge
                    SPI_SMEM_DIN4_MODE:  u3, 
                    
                    /// [15:17] the input signals are delayed by system clock cycles, 0: input without delayed, 1: input with the posedge of clk_apb,2 input with the negedge of clk_apb,3: input with the posedge of clk_160, 4 input with the negedge of clk_160, 5: input with the spi_clk high edge,6: input with the spi_clk low edge
                    SPI_SMEM_DIN5_MODE:  u3, 
                    
                    /// [18:20] the input signals are delayed by system clock cycles, 0: input without delayed, 1: input with the posedge of clk_apb,2 input with the negedge of clk_apb,3: input with the posedge of clk_160, 4 input with the negedge of clk_160, 5: input with the spi_clk high edge,6: input with the spi_clk low edge
                    SPI_SMEM_DIN6_MODE:  u3, 
                    
                    /// [21:23] the input signals are delayed by system clock cycles, 0: input without delayed, 1: input with the posedge of clk_apb,2 input with the negedge of clk_apb,3: input with the posedge of clk_160, 4 input with the negedge of clk_160, 5: input with the spi_clk high edge,6: input with the spi_clk low edge
                    SPI_SMEM_DIN7_MODE:  u3, 
                    
                    /// [24:26] the input signals are delayed by system clock cycles, 0: input without delayed, 1: input with the posedge of clk_apb,2 input with the negedge of clk_apb,3: input with the posedge of clk_160, 4 input with the negedge of clk_160, 5: input with the spi_clk high edge,6: input with the spi_clk low edge
                    SPI_SMEM_DINS_MODE:  u3, 
                    
                    /// [27:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60002194));
                
                /// MSPI external RAM input timing delay number control register
                pub const SPI_SMEM_DIN_NUM = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:1] the input signals are delayed by system clock cycles, 0: delayed by 1 cycle, 1: delayed by 2 cycles,...
                    SPI_SMEM_DIN0_NUM:  u2, 
                    
                    /// [2:3] the input signals are delayed by system clock cycles, 0: delayed by 1 cycle, 1: delayed by 2 cycles,...
                    SPI_SMEM_DIN1_NUM:  u2, 
                    
                    /// [4:5] the input signals are delayed by system clock cycles, 0: delayed by 1 cycle, 1: delayed by 2 cycles,...
                    SPI_SMEM_DIN2_NUM:  u2, 
                    
                    /// [6:7] the input signals are delayed by system clock cycles, 0: delayed by 1 cycle, 1: delayed by 2 cycles,...
                    SPI_SMEM_DIN3_NUM:  u2, 
                    
                    /// [8:9] the input signals are delayed by system clock cycles, 0: delayed by 1 cycle, 1: delayed by 2 cycles,...
                    SPI_SMEM_DIN4_NUM:  u2, 
                    
                    /// [10:11] the input signals are delayed by system clock cycles, 0: delayed by 1 cycle, 1: delayed by 2 cycles,...
                    SPI_SMEM_DIN5_NUM:  u2, 
                    
                    /// [12:13] the input signals are delayed by system clock cycles, 0: delayed by 1 cycle, 1: delayed by 2 cycles,...
                    SPI_SMEM_DIN6_NUM:  u2, 
                    
                    /// [14:15] the input signals are delayed by system clock cycles, 0: delayed by 1 cycle, 1: delayed by 2 cycles,...
                    SPI_SMEM_DIN7_NUM:  u2, 
                    
                    /// [16:17] the input signals are delayed by system clock cycles, 0: input without delayed, 1: input with the posedge of clk_apb,2 input with the negedge of clk_apb,3: input with the posedge of clk_160, 4 input with the negedge of clk_160, 5: input with the spi_clk high edge,6: input with the spi_clk low edge
                    SPI_SMEM_DINS_NUM:  u2, 
                    
                    /// [18:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60002198));
                
                /// MSPI external RAM output timing adjustment control register
                pub const SPI_SMEM_DOUT_MODE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] the output signals are delayed by system clock cycles, 0: output without delayed, 1: output with the posedge of clk_apb,2 output with the negedge of clk_apb, 3: output with the posedge of clk_160,4 output with the negedge of clk_160,5: output with the spi_clk high edge ,6: output with the spi_clk low edge
                    SPI_SMEM_DOUT0_MODE:  u1, 
                    
                    /// [1:1] the output signals are delayed by system clock cycles, 0: output without delayed, 1: output with the posedge of clk_apb,2 output with the negedge of clk_apb, 3: output with the posedge of clk_160,4 output with the negedge of clk_160,5: output with the spi_clk high edge ,6: output with the spi_clk low edge
                    SPI_SMEM_DOUT1_MODE:  u1, 
                    
                    /// [2:2] the output signals are delayed by system clock cycles, 0: output without delayed, 1: output with the posedge of clk_apb,2 output with the negedge of clk_apb, 3: output with the posedge of clk_160,4 output with the negedge of clk_160,5: output with the spi_clk high edge ,6: output with the spi_clk low edge
                    SPI_SMEM_DOUT2_MODE:  u1, 
                    
                    /// [3:3] the output signals are delayed by system clock cycles, 0: output without delayed, 1: output with the posedge of clk_apb,2 output with the negedge of clk_apb, 3: output with the posedge of clk_160,4 output with the negedge of clk_160,5: output with the spi_clk high edge ,6: output with the spi_clk low edge
                    SPI_SMEM_DOUT3_MODE:  u1, 
                    
                    /// [4:4] the output signals are delayed by system clock cycles, 0: output without delayed, 1: output with the posedge of clk_apb,2 output with the negedge of clk_apb, 3: output with the posedge of clk_160,4 output with the negedge of clk_160,5: output with the spi_clk high edge ,6: output with the spi_clk low edge
                    SPI_SMEM_DOUT4_MODE:  u1, 
                    
                    /// [5:5] the output signals are delayed by system clock cycles, 0: output without delayed, 1: output with the posedge of clk_apb,2 output with the negedge of clk_apb, 3: output with the posedge of clk_160,4 output with the negedge of clk_160,5: output with the spi_clk high edge ,6: output with the spi_clk low edge
                    SPI_SMEM_DOUT5_MODE:  u1, 
                    
                    /// [6:6] the output signals are delayed by system clock cycles, 0: output without delayed, 1: output with the posedge of clk_apb,2 output with the negedge of clk_apb, 3: output with the posedge of clk_160,4 output with the negedge of clk_160,5: output with the spi_clk high edge ,6: output with the spi_clk low edge
                    SPI_SMEM_DOUT6_MODE:  u1, 
                    
                    /// [7:7] the output signals are delayed by system clock cycles, 0: output without delayed, 1: output with the posedge of clk_apb,2 output with the negedge of clk_apb, 3: output with the posedge of clk_160,4 output with the negedge of clk_160,5: output with the spi_clk high edge ,6: output with the spi_clk low edge
                    SPI_SMEM_DOUT7_MODE:  u1, 
                    
                    /// [8:8] the output signals are delayed by system clock cycles, 0: output without delayed, 1: output with the posedge of clk_apb,2 output with the negedge of clk_apb, 3: output with the posedge of clk_160,4 output with the negedge of clk_160,5: output with the spi_clk high edge ,6: output with the spi_clk low edge
                    SPI_SMEM_DOUTS_MODE:  u1, 
                    
                    /// [9:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000219c));
                
                /// MSPI external RAM ECC and SPI CS timing control register
                pub const SPI_SMEM_AC = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] For SPI0 and SPI1, spi cs is enable when spi is in prepare phase. 1: enable 0: disable.
                    SPI_SMEM_CS_SETUP:  u1, 
                    
                    /// [1:1] For SPI0 and SPI1, spi cs keep low when spi is in done phase. 1: enable 0: disable.
                    SPI_SMEM_CS_HOLD:  u1, 
                    
                    /// [2:6] For spi0, (cycles-1) of prepare phase by spi clock this bits are combined with spi_mem_cs_setup bit.
                    SPI_SMEM_CS_SETUP_TIME:  u5, 
                    
                    /// [7:11] For SPI0 and SPI1, spi cs signal is delayed to inactive by spi clock this bits are combined with spi_mem_cs_hold bit.
                    SPI_SMEM_CS_HOLD_TIME:  u5, 
                    
                    /// [12:14] SPI_SMEM_CS_HOLD_TIME + SPI_SMEM_ECC_CS_HOLD_TIME is the SPI0 and SPI1 CS hold cycles in ECC mode when accessed external RAM.
                    SPI_SMEM_ECC_CS_HOLD_TIME:  u3, 
                    
                    /// [15:15] 1: SPI0 skips page corner when accesses external RAM. 0: Not skip page corner when accesses external RAM.
                    SPI_SMEM_ECC_SKIP_PAGE_CORNER:  u1, 
                    
                    /// [16:16] Set this bit to enable SPI0 and SPI1 ECC 16 bytes data with 2 ECC bytes mode when accesses external RAM.
                    SPI_SMEM_ECC_16TO18_BYTE_EN:  u1, 
                    
                    /// [17:24] 
                    res0:  u0, 
                    
                    /// [25:30] These bits are used to set the minimum CS high time tSHSL between SPI burst transfer when accesses to external RAM. tSHSL is (SPI_SMEM_CS_HOLD_DELAY[5:0] + 1) MSPI core clock cycles.
                    SPI_SMEM_CS_HOLD_DELAY:  u6, 
                    
                    /// [31:31] Set this bit to enable SPI0 split one AXI accesses EXT_RAM transfer into two SPI transfers when one transfer will cross flash/EXT_RAM page corner, valid no matter whether there is an ECC region or not.
                    SPI_SMEM_SPLIT_TRANS_EN:  u1, 
                    
                }), @ptrFromInt(0x600021a0));
                
                /// SPI0 clock gate register
                pub const SPI_MEM_CLOCK_GATE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Register clock gate enable signal. 1: Enable. 0: Disable.
                    SPI_CLK_EN:  u1, 
                    
                    /// [1:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60002200));
                
                /// The base address of the memory that stores plaintext in Manual Encryption
                pub const SPI_MEM_XTS_PLAIN_BASE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] This field is only used to generate include file in c case. This field is useless. Please do not use this field.
                    SPI_XTS_PLAIN:  u32, 
                    
                }), @ptrFromInt(0x60002300));
                
                /// Manual Encryption Line-Size register
                pub const SPI_MEM_XTS_LINESIZE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:1] This bits stores the line-size parameter which will be used in manual encryption calculation. It decides how many bytes will be encrypted one time. 0: 16-bytes, 1: 32-bytes, 2: 64-bytes, 3:reserved.
                    SPI_XTS_LINESIZE:  u2, 
                    
                    /// [2:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60002340));
                
                /// Manual Encryption destination register
                pub const SPI_MEM_XTS_DESTINATION = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] This bit stores the destination parameter which will be used in manual encryption calculation. 0: flash(default), 1: psram(reserved). Only default value can be used.
                    SPI_XTS_DESTINATION:  u1, 
                    
                    /// [1:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60002344));
                
                /// Manual Encryption physical address register
                pub const SPI_MEM_XTS_PHYSICAL_ADDRESS = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:25] This bits stores the physical-address parameter which will be used in manual encryption calculation. This value should aligned with byte number decided by line-size parameter.
                    SPI_XTS_PHYSICAL_ADDRESS:  u26, 
                    
                    /// [26:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60002348));
                
                /// Manual Encryption physical address register
                pub const SPI_MEM_XTS_TRIGGER = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Set this bit to trigger the process of manual encryption calculation. This action should only be asserted when manual encryption status is 0. After this action, manual encryption status becomes 1. After calculation is done, manual encryption status becomes 2.
                    SPI_XTS_TRIGGER:  u1, 
                    
                    /// [1:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000234c));
                
                /// Manual Encryption physical address register
                pub const SPI_MEM_XTS_RELEASE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Set this bit to release encrypted result to mspi. This action should only be asserted when manual encryption status is 2. After this action, manual encryption status will become 3.
                    SPI_XTS_RELEASE:  u1, 
                    
                    /// [1:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60002350));
                
                /// Manual Encryption physical address register
                pub const SPI_MEM_XTS_DESTROY = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Set this bit to destroy encrypted result. This action should be asserted only when manual encryption status is 3. After this action, manual encryption status will become 0.
                    SPI_XTS_DESTROY:  u1, 
                    
                    /// [1:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60002354));
                
                /// Manual Encryption physical address register
                pub const SPI_MEM_XTS_STATE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:1] This bits stores the status of manual encryption. 0: idle, 1: busy of encryption calculation, 2: encryption calculation is done but the encrypted result is invisible to mspi, 3: the encrypted result is visible to mspi.
                    SPI_XTS_STATE:  u2, 
                    
                    /// [2:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60002358));
                
                /// Manual Encryption version register
                pub const SPI_MEM_XTS_DATE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:29] This bits stores the last modified-time of manual encryption feature.
                    SPI_XTS_DATE:  u30, 
                    
                    /// [30:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000235c));
                
                /// MSPI-MMU item content register
                pub const SPI_MEM_MMU_ITEM_CONTENT = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] MSPI-MMU item content
                    SPI_MMU_ITEM_CONTENT:  u32, 
                    
                }), @ptrFromInt(0x6000237c));
                
                /// MSPI-MMU item index register
                pub const SPI_MEM_MMU_ITEM_INDEX = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] MSPI-MMU item index
                    SPI_MMU_ITEM_INDEX:  u32, 
                    
                }), @ptrFromInt(0x60002380));
                
                /// MSPI MMU power control register
                pub const SPI_MEM_MMU_POWER_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Set this bit to enable mmu-memory clock force on
                    SPI_MMU_MEM_FORCE_ON:  u1, 
                    
                    /// [1:1] Set this bit to force mmu-memory powerdown
                    SPI_MMU_MEM_FORCE_PD:  u1, 
                    
                    /// [2:2] Set this bit to force mmu-memory powerup, in this case, the power should also be controlled by rtc.
                    SPI_MMU_MEM_FORCE_PU:  u1, 
                    
                    /// [3:4] 0: Max page size , 1: Max page size/2 , 2: Max page size/4, 3: Max page size/8
                    SPI_MMU_PAGE_SIZE:  u2, 
                    
                    /// [5:15] 
                    res0:  u0, 
                    
                    /// [16:29] MMU PSRAM aux control register
                    SPI_MEM_AUX_CTRL:  u14, 
                    
                    /// [30:30] ECO register enable bit
                    SPI_MEM_RDN_ENA:  u1, 
                    
                    /// [31:31] MSPI module clock domain and AXI clock domain ECO register result register
                    SPI_MEM_RDN_RESULT:  u1, 
                    
                }), @ptrFromInt(0x60002384));
                
                /// SPI memory cryption DPA register
                pub const SPI_MEM_DPA_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:2] Set the security level of spi mem cryption. 0: Shut off cryption DPA funtion. 1-7: The bigger the number is, the more secure the cryption is. (Note that the performance of cryption will decrease together with this number increasing)
                    SPI_CRYPT_SECURITY_LEVEL:  u3, 
                    
                    /// [3:3] Only available when SPI_CRYPT_SECURITY_LEVEL is not 0. 1: Enable DPA in the calculation that using key 1 or key 2. 0: Enable DPA only in the calculation that using key 1.
                    SPI_CRYPT_CALC_D_DPA_EN:  u1, 
                    
                    /// [4:4] 1: MSPI XTS DPA clock gate is controlled by SPI_CRYPT_CALC_D_DPA_EN and SPI_CRYPT_SECURITY_LEVEL. 0: Controlled by efuse bits.
                    SPI_CRYPT_DPA_SELECT_REGISTER:  u1, 
                    
                    /// [5:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60002388));
                
                /// MSPI ECO high register
                pub const SPI_MEM_REGISTERRND_ECO_HIGH = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] ECO high register
                    SPI_MEM_REGISTERRND_ECO_HIGH:  u32, 
                    
                }), @ptrFromInt(0x600023f0));
                
                /// MSPI ECO low register
                pub const SPI_MEM_REGISTERRND_ECO_LOW = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] ECO low register
                    SPI_MEM_REGISTERRND_ECO_LOW:  u32, 
                    
                }), @ptrFromInt(0x600023f4));
                
                /// SPI0 version control register
                pub const SPI_MEM_DATE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:27] SPI0 register version.
                    SPI_MEM_DATE:  u28, 
                    
                    /// [28:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600023fc));
                
            };
            
            /// SPI (Serial Peripheral Interface) Controller 1
            pub const SPI1 = struct {
                
                /// SPI1 memory command register
                pub const SPI_MEM_CMD = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:3] The current status of SPI1 master FSM.
                    SPI_MEM_MST_ST:  u4, 
                    
                    /// [4:7] The current status of SPI1 slave FSM: mspi_st. 0: idle state, 1: preparation state, 2: send command state, 3: send address state, 4: wait state, 5: read data state, 6:write data state, 7: done state, 8: read data end state.
                    SPI_MEM_SLV_ST:  u4, 
                    
                    /// [8:16] 
                    res0:  u0, 
                    
                    /// [17:17] In user mode, it is set to indicate that program/erase operation will be triggered. The bit is combined with spi_mem_usr bit. The bit will be cleared once the operation done.1: enable 0: disable.
                    SPI_MEM_FLASH_PE:  u1, 
                    
                    /// [18:18] User define command enable.An operation will be triggered when the bit is set. The bit will be cleared once the operation done.1: enable 0: disable.
                    SPI_MEM_USR:  u1, 
                    
                    /// [19:19] Drive Flash into high performance mode.The bit will be cleared once the operation done.1: enable 0: disable.
                    SPI_MEM_FLASH_HPM:  u1, 
                    
                    /// [20:20] This bit combined with reg_resandres bit releases Flash from the power-down state or high performance mode and obtains the devices ID. The bit will be cleared once the operation done.1: enable 0: disable.
                    SPI_MEM_FLASH_RES:  u1, 
                    
                    /// [21:21] Drive Flash into power down.An operation will be triggered when the bit is set. The bit will be cleared once the operation done.1: enable 0: disable.
                    SPI_MEM_FLASH_DP:  u1, 
                    
                    /// [22:22] Chip erase enable. Chip erase operation will be triggered when the bit is set. The bit will be cleared once the operation done.1: enable 0: disable.
                    SPI_MEM_FLASH_CE:  u1, 
                    
                    /// [23:23] Block erase enable(32KB) .Block erase operation will be triggered when the bit is set. The bit will be cleared once the operation done.1: enable 0: disable.
                    SPI_MEM_FLASH_BE:  u1, 
                    
                    /// [24:24] Sector erase enable(4KB). Sector erase operation will be triggered when the bit is set. The bit will be cleared once the operation done.1: enable 0: disable.
                    SPI_MEM_FLASH_SE:  u1, 
                    
                    /// [25:25] Page program enable(1 byte ~256 bytes data to be programmed). Page program operationwill be triggered when the bit is set. The bit will be cleared once the operation done .1: enable 0: disable.
                    SPI_MEM_FLASH_PP:  u1, 
                    
                    /// [26:26] Write status register enable. Write status operationwill be triggered when the bit is set. The bit will be cleared once the operation done.1: enable 0: disable.
                    SPI_MEM_FLASH_WRSR:  u1, 
                    
                    /// [27:27] Read status register-1.Read status operation will be triggered when the bit is set. The bit will be cleared once the operation done.1: enable 0: disable.
                    SPI_MEM_FLASH_RDSR:  u1, 
                    
                    /// [28:28] Read JEDEC ID . Read ID command will be sent when the bit is set. The bit will be cleared once the operation done. 1: enable 0: disable.
                    SPI_MEM_FLASH_RDID:  u1, 
                    
                    /// [29:29] Write flash disable. Write disable command will be sent when the bit is set. The bit will be cleared once the operation done. 1: enable 0: disable.
                    SPI_MEM_FLASH_WRDI:  u1, 
                    
                    /// [30:30] Write flash enable.Write enable command will be sent when the bit is set. The bit will be cleared once the operation done. 1: enable 0: disable.
                    SPI_MEM_FLASH_WREN:  u1, 
                    
                    /// [31:31] Read flash enable. Read flash operation will be triggered when the bit is set. The bit will be cleared once the operation done. 1: enable 0: disable.
                    SPI_MEM_FLASH_READ:  u1, 
                    
                }), @ptrFromInt(0x60003000));
                
                /// SPI1 address register
                pub const SPI_MEM_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] In user mode, it is the memory address. other then the bit0-bit23 is the memory address, the bit24-bit31 are the byte length of a transfer.
                    SPI_MEM_USR_ADDR_VALUE:  u32, 
                    
                }), @ptrFromInt(0x60003004));
                
                /// SPI1 control register.
                pub const SPI_MEM_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:1] 
                    res0:  u0, 
                    
                    /// [2:2] In the dummy phase of a MSPI read data transfer when accesses to flash, the signal level of SPI bus is output by the MSPI controller.
                    SPI_MEM_FDUMMY_RIN:  u1, 
                    
                    /// [3:3] In the dummy phase of a MSPI write data transfer when accesses to flash, the signal level of SPI bus is output by the MSPI controller.
                    SPI_MEM_FDUMMY_WOUT:  u1, 
                    
                    /// [4:4] Apply 8 signals during write-data phase 1:enable 0: disable
                    SPI_MEM_FDOUT_OCT:  u1, 
                    
                    /// [5:5] Apply 8 signals during read-data phase 1:enable 0: disable
                    SPI_MEM_FDIN_OCT:  u1, 
                    
                    /// [6:6] Apply 8 signals during address phase 1:enable 0: disable
                    SPI_MEM_FADDR_OCT:  u1, 
                    
                    /// [7:7] 
                    res1:  u0, 
                    
                    /// [8:8] Apply 4 signals during command phase 1:enable 0: disable
                    SPI_MEM_FCMD_QUAD:  u1, 
                    
                    /// [9:9] Apply 8 signals during command phase 1:enable 0: disable
                    SPI_MEM_FCMD_OCT:  u1, 
                    
                    /// [10:10] For SPI1,initialize crc32 module before writing encrypted data to flash. Active low.
                    SPI_MEM_FCS_CRC_EN:  u1, 
                    
                    /// [11:11] For SPI1,enable crc32 when writing encrypted data to flash. 1: enable 0:disable
                    SPI_MEM_TX_CRC_EN:  u1, 
                    
                    /// [12:12] 
                    res2:  u0, 
                    
                    /// [13:13] This bit enable the bits: spi_mem_fread_qio, spi_mem_fread_dio, spi_mem_fread_qout and spi_mem_fread_dout. 1: enable 0: disable.
                    SPI_MEM_FASTRD_MODE:  u1, 
                    
                    /// [14:14] In the read operations, read-data phase apply 2 signals. 1: enable 0: disable.
                    SPI_MEM_FREAD_DUAL:  u1, 
                    
                    /// [15:15] The Device ID is read out to SPI_MEM_RD_STATUS register,this bit combine with spi_mem_flash_res bit. 1: enable 0: disable.
                    SPI_MEM_RESANDRES:  u1, 
                    
                    /// [16:17] 
                    res3:  u0, 
                    
                    /// [18:18] The bit is used to set MISO line polarity, 1: high 0, low
                    SPI_MEM_Q_POL:  u1, 
                    
                    /// [19:19] The bit is used to set MOSI line polarity, 1: high 0, low
                    SPI_MEM_D_POL:  u1, 
                    
                    /// [20:20] In the read operations read-data phase apply 4 signals. 1: enable 0: disable.
                    SPI_MEM_FREAD_QUAD:  u1, 
                    
                    /// [21:21] Write protect signal output when SPI is idle.1: output high, 0: output low.
                    SPI_MEM_WP:  u1, 
                    
                    /// [22:22] two bytes data will be written to status register when it is set. 1: enable 0: disable.
                    SPI_MEM_WRSR_2B:  u1, 
                    
                    /// [23:23] In the read operations address phase and read-data phase apply 2 signals. 1: enable 0: disable.
                    SPI_MEM_FREAD_DIO:  u1, 
                    
                    /// [24:24] In the read operations address phase and read-data phase apply 4 signals. 1: enable 0: disable.
                    SPI_MEM_FREAD_QIO:  u1, 
                    
                    /// [25:31] 
                    res4:  u0, 
                    
                }), @ptrFromInt(0x60003008));
                
                /// SPI1 control1 register.
                pub const SPI_MEM_CTRL1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:1] SPI clock mode bits. 0: SPI clock is off when CS inactive 1: SPI clock is delayed one cycle after CS inactive 2: SPI clock is delayed two cycles after CS inactive 3: SPI clock is alwasy on.
                    SPI_MEM_CLK_MODE:  u2, 
                    
                    /// [2:11] After RES/DP/HPM command is sent, SPI1 waits (SPI_MEM_CS_HOLD_DELAY_RES[9:0] * 512) SPI_CLK cycles.
                    SPI_MEM_CS_HOLD_DLY_RES:  u10, 
                    
                    /// [12:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000300c));
                
                /// SPI1 control2 register.
                pub const SPI_MEM_CTRL2 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:30] 
                    res0:  u0, 
                    
                    /// [31:31] The FSM will be reset.
                    SPI_MEM_SYNC_RESET:  u1, 
                    
                }), @ptrFromInt(0x60003010));
                
                /// SPI1 clock division control register.
                pub const SPI_MEM_CLOCK = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] In the master mode it must be equal to spi_mem_clkcnt_N.
                    SPI_MEM_CLKCNT_L:  u8, 
                    
                    /// [8:15] In the master mode it must be floor((spi_mem_clkcnt_N+1)/2-1).
                    SPI_MEM_CLKCNT_H:  u8, 
                    
                    /// [16:23] In the master mode it is the divider of spi_mem_clk. So spi_mem_clk frequency is system/(spi_mem_clkcnt_N+1)
                    SPI_MEM_CLKCNT_N:  u8, 
                    
                    /// [24:30] 
                    res0:  u0, 
                    
                    /// [31:31] reserved
                    SPI_MEM_CLK_EQU_SYSCLK:  u1, 
                    
                }), @ptrFromInt(0x60003014));
                
                /// SPI1 user register.
                pub const SPI_MEM_USER = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:8] 
                    res0:  u0, 
                    
                    /// [9:9] the bit combined with spi_mem_mosi_delay_mode bits to set mosi signal delay mode.
                    SPI_MEM_CK_OUT_EDGE:  u1, 
                    
                    /// [10:11] 
                    res1:  u0, 
                    
                    /// [12:12] In the write operations read-data phase apply 2 signals
                    SPI_MEM_FWRITE_DUAL:  u1, 
                    
                    /// [13:13] In the write operations read-data phase apply 4 signals
                    SPI_MEM_FWRITE_QUAD:  u1, 
                    
                    /// [14:14] In the write operations address phase and read-data phase apply 2 signals.
                    SPI_MEM_FWRITE_DIO:  u1, 
                    
                    /// [15:15] In the write operations address phase and read-data phase apply 4 signals.
                    SPI_MEM_FWRITE_QIO:  u1, 
                    
                    /// [16:23] 
                    res2:  u0, 
                    
                    /// [24:24] read-data phase only access to high-part of the buffer spi_mem_w8~spi_mem_w15. 1: enable 0: disable.
                    SPI_MEM_USR_MISO_HIGHPART:  u1, 
                    
                    /// [25:25] write-data phase only access to high-part of the buffer spi_mem_w8~spi_mem_w15. 1: enable 0: disable.
                    SPI_MEM_USR_MOSI_HIGHPART:  u1, 
                    
                    /// [26:26] SPI clock is disable in dummy phase when the bit is enable.
                    SPI_MEM_USR_DUMMY_IDLE:  u1, 
                    
                    /// [27:27] This bit enable the write-data phase of an operation.
                    SPI_MEM_USR_MOSI:  u1, 
                    
                    /// [28:28] This bit enable the read-data phase of an operation.
                    SPI_MEM_USR_MISO:  u1, 
                    
                    /// [29:29] This bit enable the dummy phase of an operation.
                    SPI_MEM_USR_DUMMY:  u1, 
                    
                    /// [30:30] This bit enable the address phase of an operation.
                    SPI_MEM_USR_ADDR:  u1, 
                    
                    /// [31:31] This bit enable the command phase of an operation.
                    SPI_MEM_USR_COMMAND:  u1, 
                    
                }), @ptrFromInt(0x60003018));
                
                /// SPI1 user1 register.
                pub const SPI_MEM_USER1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] The length in spi_mem_clk cycles of dummy phase. The register value shall be (cycle_num-1).
                    SPI_MEM_USR_DUMMY_CYCLELEN:  u6, 
                    
                    /// [6:25] 
                    res0:  u0, 
                    
                    /// [26:31] The length in bits of address phase. The register value shall be (bit_num-1).
                    SPI_MEM_USR_ADDR_BITLEN:  u6, 
                    
                }), @ptrFromInt(0x6000301c));
                
                /// SPI1 user2 register.
                pub const SPI_MEM_USER2 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:15] The value ofcommand.
                    SPI_MEM_USR_COMMAND_VALUE:  u16, 
                    
                    /// [16:27] 
                    res0:  u0, 
                    
                    /// [28:31] The length in bits of command phase. The register value shall be (bit_num-1)
                    SPI_MEM_USR_COMMAND_BITLEN:  u4, 
                    
                }), @ptrFromInt(0x60003020));
                
                /// SPI1 send data bit length control register.
                pub const SPI_MEM_MOSI_DLEN = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:9] The length in bits of write-data. The register value shall be (bit_num-1).
                    SPI_MEM_USR_MOSI_DBITLEN:  u10, 
                    
                    /// [10:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60003024));
                
                /// SPI1 receive data bit length control register.
                pub const SPI_MEM_MISO_DLEN = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:9] The length in bits ofread-data. The register value shall be (bit_num-1).
                    SPI_MEM_USR_MISO_DBITLEN:  u10, 
                    
                    /// [10:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60003028));
                
                /// SPI1 status register.
                pub const SPI_MEM_RD_STATUS = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:15] The value is stored when set spi_mem_flash_rdsr bit and spi_mem_flash_res bit.
                    SPI_MEM_STATUS:  u16, 
                    
                    /// [16:23] Mode bits in the flash fast read modeit is combined with spi_mem_fastrd_mode bit.
                    SPI_MEM_WB_MODE:  u8, 
                    
                    /// [24:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000302c));
                
                /// SPI1 misc register
                pub const SPI_MEM_MISC = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] SPI_CS0 pin enable, 1: disable SPI_CS0, 0: SPI_CS0 pin is active to select SPI device, such as flash, external RAM and so on.
                    SPI_MEM_CS0_DIS:  u1, 
                    
                    /// [1:1] SPI_CS1 pin enable, 1: disable SPI_CS1, 0: SPI_CS1 pin is active to select SPI device, such as flash, external RAM and so on.
                    SPI_MEM_CS1_DIS:  u1, 
                    
                    /// [2:8] 
                    res0:  u0, 
                    
                    /// [9:9] 1: spi clk line is high when idle 0: spi clk line is low when idle
                    SPI_MEM_CK_IDLE_EDGE:  u1, 
                    
                    /// [10:10] spi cs line keep low when the bit is set.
                    SPI_MEM_CS_KEEP_ACTIVE:  u1, 
                    
                    /// [11:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x60003034));
                
                /// SPI1 TX CRC data register.
                pub const SPI_MEM_TX_CRC = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] For SPI1, the value of crc32.
                    DATA:  u32, 
                    
                }), @ptrFromInt(0x60003038));
                
                /// SPI1 bit mode control register.
                pub const SPI_MEM_CACHE_FCTRL = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] 
                    res0:  u0, 
                    
                    /// [1:1] For SPI1,cacheread flash with 4 bytes address, 1: enable, 0:disable.
                    SPI_MEM_CACHE_USR_ADDR_4BYTE:  u1, 
                    
                    /// [2:2] 
                    res1:  u0, 
                    
                    /// [3:3] For SPI1, din phase apply 2 signals. 1: enable 0: disable. The bit is the same with spi_mem_fread_dio.
                    SPI_MEM_FDIN_DUAL:  u1, 
                    
                    /// [4:4] For SPI1, dout phase apply 2 signals. 1: enable 0: disable. The bit is the same with spi_mem_fread_dio.
                    SPI_MEM_FDOUT_DUAL:  u1, 
                    
                    /// [5:5] For SPI1, address phase apply 2 signals. 1: enable 0: disable.The bit is the same with spi_mem_fread_dio.
                    SPI_MEM_FADDR_DUAL:  u1, 
                    
                    /// [6:6] For SPI1, din phase apply 4 signals. 1: enable 0: disable.The bit is the same with spi_mem_fread_qio.
                    SPI_MEM_FDIN_QUAD:  u1, 
                    
                    /// [7:7] For SPI1, dout phase apply 4 signals. 1: enable 0: disable.The bit is the same with spi_mem_fread_qio.
                    SPI_MEM_FDOUT_QUAD:  u1, 
                    
                    /// [8:8] For SPI1, address phase apply 4 signals. 1: enable 0: disable.The bit is the same with spi_mem_fread_qio.
                    SPI_MEM_FADDR_QUAD:  u1, 
                    
                    /// [9:31] 
                    res2:  u0, 
                    
                }), @ptrFromInt(0x6000303c));
                
                /// SPI1 memory data buffer0
                pub const SPI_MEM_W0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] data buffer
                    SPI_MEM_BUF0:  u32, 
                    
                }), @ptrFromInt(0x60003058));
                
                /// SPI1 memory data buffer1
                pub const SPI_MEM_W1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] data buffer
                    SPI_MEM_BUF1:  u32, 
                    
                }), @ptrFromInt(0x6000305c));
                
                /// SPI1 memory data buffer2
                pub const SPI_MEM_W2 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] data buffer
                    SPI_MEM_BUF2:  u32, 
                    
                }), @ptrFromInt(0x60003060));
                
                /// SPI1 memory data buffer3
                pub const SPI_MEM_W3 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] data buffer
                    SPI_MEM_BUF3:  u32, 
                    
                }), @ptrFromInt(0x60003064));
                
                /// SPI1 memory data buffer4
                pub const SPI_MEM_W4 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] data buffer
                    SPI_MEM_BUF4:  u32, 
                    
                }), @ptrFromInt(0x60003068));
                
                /// SPI1 memory data buffer5
                pub const SPI_MEM_W5 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] data buffer
                    SPI_MEM_BUF5:  u32, 
                    
                }), @ptrFromInt(0x6000306c));
                
                /// SPI1 memory data buffer6
                pub const SPI_MEM_W6 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] data buffer
                    SPI_MEM_BUF6:  u32, 
                    
                }), @ptrFromInt(0x60003070));
                
                /// SPI1 memory data buffer7
                pub const SPI_MEM_W7 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] data buffer
                    SPI_MEM_BUF7:  u32, 
                    
                }), @ptrFromInt(0x60003074));
                
                /// SPI1 memory data buffer8
                pub const SPI_MEM_W8 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] data buffer
                    SPI_MEM_BUF8:  u32, 
                    
                }), @ptrFromInt(0x60003078));
                
                /// SPI1 memory data buffer9
                pub const SPI_MEM_W9 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] data buffer
                    SPI_MEM_BUF9:  u32, 
                    
                }), @ptrFromInt(0x6000307c));
                
                /// SPI1 memory data buffer10
                pub const SPI_MEM_W10 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] data buffer
                    SPI_MEM_BUF10:  u32, 
                    
                }), @ptrFromInt(0x60003080));
                
                /// SPI1 memory data buffer11
                pub const SPI_MEM_W11 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] data buffer
                    SPI_MEM_BUF11:  u32, 
                    
                }), @ptrFromInt(0x60003084));
                
                /// SPI1 memory data buffer12
                pub const SPI_MEM_W12 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] data buffer
                    SPI_MEM_BUF12:  u32, 
                    
                }), @ptrFromInt(0x60003088));
                
                /// SPI1 memory data buffer13
                pub const SPI_MEM_W13 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] data buffer
                    SPI_MEM_BUF13:  u32, 
                    
                }), @ptrFromInt(0x6000308c));
                
                /// SPI1 memory data buffer14
                pub const SPI_MEM_W14 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] data buffer
                    SPI_MEM_BUF14:  u32, 
                    
                }), @ptrFromInt(0x60003090));
                
                /// SPI1 memory data buffer15
                pub const SPI_MEM_W15 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] data buffer
                    SPI_MEM_BUF15:  u32, 
                    
                }), @ptrFromInt(0x60003094));
                
                /// SPI1 wait idle control register
                pub const SPI_MEM_FLASH_WAITI_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] 1: The hardware will wait idle after SE/PP/WRSR automatically, and hardware auto Suspend/Resume can be enabled. 0: The functions of hardware wait idle and auto Suspend/Resume are not supported.
                    SPI_MEM_WAITI_EN:  u1, 
                    
                    /// [1:1] The dummy phase enable when wait flash idle (RDSR)
                    SPI_MEM_WAITI_DUMMY:  u1, 
                    
                    /// [2:2] 1: Outputaddress 0 in RDSR or read SUS command transfer. 0: Do not send out address in RDSR or read SUS command transfer.
                    SPI_MEM_WAITI_ADDR_EN:  u1, 
                    
                    /// [3:4] When SPI_MEM_WAITI_ADDR_EN is set, thecycle length of sent out address is (SPI_MEM_WAITI_ADDR_CYCLELEN[1:0] + 1) SPIbus clock cycles. It is not active when SPI_MEM_WAITI_ADDR_EN is cleared.
                    SPI_MEM_WAITI_ADDR_CYCLELEN:  u2, 
                    
                    /// [5:8] 
                    res0:  u0, 
                    
                    /// [9:9] 1:The wait idle command bit length is 16. 0: The wait idle command bit length is 8.
                    SPI_MEM_WAITI_CMD_2B:  u1, 
                    
                    /// [10:15] The dummy cycle length when wait flash idle(RDSR).
                    SPI_MEM_WAITI_DUMMY_CYCLELEN:  u6, 
                    
                    /// [16:31] The command value to wait flash idle(RDSR).
                    SPI_MEM_WAITI_CMD:  u16, 
                    
                }), @ptrFromInt(0x60003098));
                
                /// SPI1 flash suspend control register
                pub const SPI_MEM_FLASH_SUS_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] program erase resume bit, program erase suspend operation will be triggered when the bit is set. The bit will be cleared once the operation done.1: enable 0: disable.
                    SPI_MEM_FLASH_PER:  u1, 
                    
                    /// [1:1] program erase suspend bit, program erase suspend operation will be triggered when the bit is set. The bit will be cleared once the operation done.1: enable 0: disable.
                    SPI_MEM_FLASH_PES:  u1, 
                    
                    /// [2:2] 1: SPI1 waits (SPI_MEM_CS_HOLD_DELAY_RES[9:0] * 4 or *128) SPI_CLK cycles after program erase resume command is sent. 0: SPI1 does not wait after program erase resume command is sent.
                    SPI_MEM_FLASH_PER_WAIT_EN:  u1, 
                    
                    /// [3:3] 1: SPI1 waits (SPI_MEM_CS_HOLD_DELAY_RES[9:0] * 4 or *128) SPI_CLK cycles after program erase suspend command is sent. 0: SPI1 does not wait after program erase suspend command is sent.
                    SPI_MEM_FLASH_PES_WAIT_EN:  u1, 
                    
                    /// [4:4] Set this bit to enable PES end triggers PER transfer option. If this bit is 0, application should send PER after PES is done.
                    SPI_MEM_PES_PER_EN:  u1, 
                    
                    /// [5:5] Set this bit to enable Auto-suspending function.
                    SPI_MEM_FLASH_PES_EN:  u1, 
                    
                    /// [6:21] The mask value when check SUS/SUS1/SUS2 status bit. If the read status value is status_in[15:0](only status_in[7:0] is valid when only one byte of data is read out, status_in[15:0] is valid when two bytes of data are read out), SUS/SUS1/SUS2 = status_in[15:0]^ SPI_MEM_PESR_END_MSK[15:0].
                    SPI_MEM_PESR_END_MSK:  u16, 
                    
                    /// [22:22] 1: Read two bytes when check flash SUS/SUS1/SUS2 status bit. 0:Read one byte when check flash SUS/SUS1/SUS2 status bit
                    SPI_FMEM_RD_SUS_2B:  u1, 
                    
                    /// [23:23] 1: Both WIP and SUS/SUS1/SUS2 bits should be checked to insure the resume status of flash. 0: Only need to check WIP is 0.
                    SPI_MEM_PER_END_EN:  u1, 
                    
                    /// [24:24] 1: Both WIP and SUS/SUS1/SUS2 bits should be checked to insure the suspend status of flash. 0: Only need to check WIP is 0.
                    SPI_MEM_PES_END_EN:  u1, 
                    
                    /// [25:31] When SPI1 checks SUS/SUS1/SUS2 bits fail for SPI_MEM_SUS_TIMEOUT_CNT[6:0] times, it will be treated as check pass.
                    SPI_MEM_SUS_TIMEOUT_CNT:  u7, 
                    
                }), @ptrFromInt(0x6000309c));
                
                /// SPI1 flash suspend command register
                pub const SPI_MEM_FLASH_SUS_CMD = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:15] Program/Erase suspend command.
                    SPI_MEM_FLASH_PES_COMMAND:  u16, 
                    
                    /// [16:31] Flash SUS/SUS1/SUS2 status bit read command. The command should be sent when SUS/SUS1/SUS2 bit should be checked to insure the suspend or resume status of flash.
                    SPI_MEM_WAIT_PESR_COMMAND:  u16, 
                    
                }), @ptrFromInt(0x600030a0));
                
                /// SPI1 flash suspend status register
                pub const SPI_MEM_SUS_STATUS = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] The status of flash suspend, only used in SPI1.
                    SPI_MEM_FLASH_SUS:  u1, 
                    
                    /// [1:1] 1: SPI1 sends out SPI_MEM_WAIT_PESR_COMMAND[15:0] to check SUS/SUS1/SUS2 bit. 0: SPI1 sends out SPI_MEM_WAIT_PESR_COMMAND[7:0] to check SUS/SUS1/SUS2 bit.
                    SPI_MEM_WAIT_PESR_CMD_2B:  u1, 
                    
                    /// [2:2] 1: SPI1 waits (SPI_MEM_CS_HOLD_DELAY_RES[9:0] * 128) SPI_CLK cycles after HPM command is sent. 0: SPI1 waits (SPI_MEM_CS_HOLD_DELAY_RES[9:0] * 4) SPI_CLK cycles after HPM command is sent.
                    SPI_MEM_FLASH_HPM_DLY_128:  u1, 
                    
                    /// [3:3] 1: SPI1 waits (SPI_MEM_CS_HOLD_DELAY_RES[9:0] * 128) SPI_CLK cycles after RES command is sent. 0: SPI1 waits (SPI_MEM_CS_HOLD_DELAY_RES[9:0] * 4) SPI_CLK cycles after RES command is sent.
                    SPI_MEM_FLASH_RES_DLY_128:  u1, 
                    
                    /// [4:4] 1: SPI1 waits (SPI_MEM_CS_HOLD_DELAY_RES[9:0] * 128) SPI_CLK cycles after DP command is sent. 0: SPI1 waits (SPI_MEM_CS_HOLD_DELAY_RES[9:0] * 4) SPI_CLK cycles after DP command is sent.
                    SPI_MEM_FLASH_DP_DLY_128:  u1, 
                    
                    /// [5:5] Valid when SPI_MEM_FLASH_PER_WAIT_EN is 1. 1: SPI1 waits (SPI_MEM_CS_HOLD_DELAY_RES[9:0] * 128) SPI_CLK cycles after PER command is sent. 0: SPI1 waits (SPI_MEM_CS_HOLD_DELAY_RES[9:0] * 4) SPI_CLK cycles after PER command is sent.
                    SPI_MEM_FLASH_PER_DLY_128:  u1, 
                    
                    /// [6:6] Valid when SPI_MEM_FLASH_PES_WAIT_EN is 1. 1: SPI1 waits (SPI_MEM_CS_HOLD_DELAY_RES[9:0] * 128) SPI_CLK cycles after PES command is sent. 0: SPI1 waits (SPI_MEM_CS_HOLD_DELAY_RES[9:0] * 4) SPI_CLK cycles after PES command is sent.
                    SPI_MEM_FLASH_PES_DLY_128:  u1, 
                    
                    /// [7:7] 1: Enable SPI0 lock SPI0/1 arbiter option. 0: Disable it.
                    SPI_MEM_SPI0_LOCK_EN:  u1, 
                    
                    /// [8:14] 
                    res0:  u0, 
                    
                    /// [15:15] 1: The bit length of Program/Erase Suspend/Resume command is 16. 0: The bit length of Program/Erase Suspend/Resume command is 8.
                    SPI_MEM_FLASH_PESR_CMD_2B:  u1, 
                    
                    /// [16:31] Program/Erase resume command.
                    SPI_MEM_FLASH_PER_COMMAND:  u16, 
                    
                }), @ptrFromInt(0x600030a4));
                
                /// SPI1 interrupt enable register
                pub const SPI_MEM_INT_ENA = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] The enable bit for SPI_MEM_PER_END_INT interrupt.
                    SPI_MEM_PER_END_INT_ENA:  u1, 
                    
                    /// [1:1] The enable bit for SPI_MEM_PES_END_INT interrupt.
                    SPI_MEM_PES_END_INT_ENA:  u1, 
                    
                    /// [2:2] The enable bit for SPI_MEM_WPE_END_INT interrupt.
                    SPI_MEM_WPE_END_INT_ENA:  u1, 
                    
                    /// [3:3] The enable bit for SPI_MEM_SLV_ST_END_INT interrupt.
                    SPI_MEM_SLV_ST_END_INT_ENA:  u1, 
                    
                    /// [4:4] The enable bit for SPI_MEM_MST_ST_END_INT interrupt.
                    SPI_MEM_MST_ST_END_INT_ENA:  u1, 
                    
                    /// [5:9] 
                    res0:  u0, 
                    
                    /// [10:10] The enable bit for SPI_MEM_BROWN_OUT_INT interrupt.
                    SPI_MEM_BROWN_OUT_INT_ENA:  u1, 
                    
                    /// [11:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x600030c0));
                
                /// SPI1 interrupt clear register
                pub const SPI_MEM_INT_CLR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] The clear bit for SPI_MEM_PER_END_INT interrupt.
                    SPI_MEM_PER_END_INT_CLR:  u1, 
                    
                    /// [1:1] The clear bit for SPI_MEM_PES_END_INT interrupt.
                    SPI_MEM_PES_END_INT_CLR:  u1, 
                    
                    /// [2:2] The clear bit for SPI_MEM_WPE_END_INT interrupt.
                    SPI_MEM_WPE_END_INT_CLR:  u1, 
                    
                    /// [3:3] The clear bit for SPI_MEM_SLV_ST_END_INT interrupt.
                    SPI_MEM_SLV_ST_END_INT_CLR:  u1, 
                    
                    /// [4:4] The clear bit for SPI_MEM_MST_ST_END_INT interrupt.
                    SPI_MEM_MST_ST_END_INT_CLR:  u1, 
                    
                    /// [5:9] 
                    res0:  u0, 
                    
                    /// [10:10] The status bit for SPI_MEM_BROWN_OUT_INT interrupt.
                    SPI_MEM_BROWN_OUT_INT_CLR:  u1, 
                    
                    /// [11:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x600030c4));
                
                /// SPI1 interrupt raw register
                pub const SPI_MEM_INT_RAW = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] The raw bit for SPI_MEM_PER_END_INT interrupt. 1: Triggered when Auto Resume command (0x7A) is sent and flash is resumed successfully. 0: Others.
                    SPI_MEM_PER_END_INT_RAW:  u1, 
                    
                    /// [1:1] The raw bit for SPI_MEM_PES_END_INT interrupt.1: Triggered when Auto Suspend command (0x75) is sent and flash is suspended successfully. 0: Others.
                    SPI_MEM_PES_END_INT_RAW:  u1, 
                    
                    /// [2:2] The raw bit for SPI_MEM_WPE_END_INT interrupt. 1: Triggered when WRSR/PP/SE/BE/CE is sent and flash is already idle. 0: Others.
                    SPI_MEM_WPE_END_INT_RAW:  u1, 
                    
                    /// [3:3] The raw bit for SPI_MEM_SLV_ST_END_INT interrupt. 1: Triggered when spi1_slv_st is changed from non idle state to idle state. It means that SPI_CS raises high. 0: Others
                    SPI_MEM_SLV_ST_END_INT_RAW:  u1, 
                    
                    /// [4:4] The raw bit for SPI_MEM_MST_ST_END_INT interrupt. 1: Triggered when spi1_mst_st is changed from non idle state to idle state. 0: Others.
                    SPI_MEM_MST_ST_END_INT_RAW:  u1, 
                    
                    /// [5:9] 
                    res0:  u0, 
                    
                    /// [10:10] The raw bit for SPI_MEM_BROWN_OUT_INT interrupt. 1: Triggered condition is that chip is loosing power and RTC module sends out brown out close flash request to SPI1. After SPI1 sends out suspend command to flash, this interrupt is triggered and MSPI returns to idle state. 0: Others.
                    SPI_MEM_BROWN_OUT_INT_RAW:  u1, 
                    
                    /// [11:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x600030c8));
                
                /// SPI1 interrupt status register
                pub const SPI_MEM_INT_ST = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] The status bit for SPI_MEM_PER_END_INT interrupt.
                    SPI_MEM_PER_END_INT_ST:  u1, 
                    
                    /// [1:1] The status bit for SPI_MEM_PES_END_INT interrupt.
                    SPI_MEM_PES_END_INT_ST:  u1, 
                    
                    /// [2:2] The status bit for SPI_MEM_WPE_END_INT interrupt.
                    SPI_MEM_WPE_END_INT_ST:  u1, 
                    
                    /// [3:3] The status bit for SPI_MEM_SLV_ST_END_INT interrupt.
                    SPI_MEM_SLV_ST_END_INT_ST:  u1, 
                    
                    /// [4:4] The status bit for SPI_MEM_MST_ST_END_INT interrupt.
                    SPI_MEM_MST_ST_END_INT_ST:  u1, 
                    
                    /// [5:9] 
                    res0:  u0, 
                    
                    /// [10:10] The status bit for SPI_MEM_BROWN_OUT_INT interrupt.
                    SPI_MEM_BROWN_OUT_INT_ST:  u1, 
                    
                    /// [11:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x600030cc));
                
                /// SPI1 DDR control register
                pub const SPI_MEM_DDR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] 1: in ddr mode,0 in sdr mode
                    SPI_FMEM_DDR_EN:  u1, 
                    
                    /// [1:1] Set the bit to enable variable dummy cycle in spi ddr mode.
                    SPI_FMEM_VAR_DUMMY:  u1, 
                    
                    /// [2:2] Set the bit to reorder rx data of the word in spi ddr mode.
                    SPI_FMEM_DDR_RDAT_SWP:  u1, 
                    
                    /// [3:3] Set the bit to reorder tx data of the word in spi ddr mode.
                    SPI_FMEM_DDR_WDAT_SWP:  u1, 
                    
                    /// [4:4] the bit is used to disable dual edge in command phase when ddr mode.
                    SPI_FMEM_DDR_CMD_DIS:  u1, 
                    
                    /// [5:11] It is the minimum output data length in the panda device.
                    SPI_FMEM_OUTMINBYTELEN:  u7, 
                    
                    /// [12:13] 
                    res0:  u0, 
                    
                    /// [14:20] The delay number of data strobe which from memory based on SPI clock.
                    SPI_FMEM_USR_DDR_DQS_THD:  u7, 
                    
                    /// [21:21] 1: Do not need the input of SPI_DQS signal, SPI0 starts to receive data when spi0_slv_st is in SPI_MEM_DIN state. It is used when there is no SPI_DQS signal or SPI_DQS signal is not stable. 0: SPI0 starts to store data at the positive and negative edge of SPI_DQS.
                    SPI_FMEM_DDR_DQS_LOOP:  u1, 
                    
                    /// [22:23] 
                    res1:  u0, 
                    
                    /// [24:24] Set this bit to enable the differential SPI_CLK#.
                    SPI_FMEM_CLK_DIFF_EN:  u1, 
                    
                    /// [25:25] 
                    res2:  u0, 
                    
                    /// [26:26] Set this bit to enable the input of SPI_DQS signal in SPI phases of CMD and ADDR.
                    SPI_FMEM_DQS_CA_IN:  u1, 
                    
                    /// [27:27] Set this bit to enable the vary dummy function in SPI HyperBus mode, when SPI0 accesses flash or SPI1 accesses flash or sram.
                    SPI_FMEM_HYPERBUS_DUMMY_2X:  u1, 
                    
                    /// [28:28] Set this bit to invert SPI_DIFF when accesses to flash. .
                    SPI_FMEM_CLK_DIFF_INV:  u1, 
                    
                    /// [29:29] Set this bit to enable octa_ram address out when accesses to flash, which means ADDR_OUT[31:0] = {spi_usr_addr_value[25:4], 6'd0, spi_usr_addr_value[3:1], 1'b0}.
                    SPI_FMEM_OCTA_RAM_ADDR:  u1, 
                    
                    /// [30:30] Set this bit to enable HyperRAM address out when accesses to flash, which means ADDR_OUT[31:0] = {spi_usr_addr_value[19:4], 13'd0, spi_usr_addr_value[3:1]}.
                    SPI_FMEM_HYPERBUS_CA:  u1, 
                    
                    /// [31:31] 
                    res3:  u0, 
                    
                }), @ptrFromInt(0x600030d4));
                
                /// SPI1 timing control register
                pub const SPI_MEM_TIMING_CALI = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] 
                    res0:  u0, 
                    
                    /// [1:1] The bit is used to enable timing auto-calibration for all reading operations.
                    SPI_MEM_TIMING_CALI:  u1, 
                    
                    /// [2:4] add extra dummy spi clock cycle length for spi clock calibration.
                    SPI_MEM_EXTRA_DUMMY_CYCLELEN:  u3, 
                    
                    /// [5:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x60003180));
                
                /// SPI1 clk_gate register
                pub const SPI_MEM_CLOCK_GATE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Register clock gate enable signal. 1: Enable. 0: Disable.
                    SPI_MEM_CLK_EN:  u1, 
                    
                    /// [1:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60003200));
                
                /// Version control register
                pub const SPI_MEM_DATE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:27] Version control register
                    SPI_MEM_DATE:  u28, 
                    
                    /// [28:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600033fc));
                
            };
            
            /// SPI (Serial Peripheral Interface) Controller 2
            pub const SPI2 = struct {
                
                /// Command control register
                pub const CMD = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:17] Define the APB cycles ofSPI_CONF state. Can be configured in CONF state.
                    CONF_BITLEN:  u18, 
                    
                    /// [18:22] 
                    res0:  u0, 
                    
                    /// [23:23] Set this bit to synchronize SPI registers from APB clock domain into SPI module clock domain, which is only used in SPI master mode.
                    UPDATE:  u1, 
                    
                    /// [24:24] User define command enable.An operation will be triggered when the bit is set. The bit will be cleared once the operation done.1: enable 0: disable. Can not be changed by CONF_buf.
                    USR:  u1, 
                    
                    /// [25:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x60081000));
                
                /// Address value register
                pub const ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Address to slave. Can be configured in CONF state.
                    USR_ADDR_VALUE:  u32, 
                    
                }), @ptrFromInt(0x60081004));
                
                /// SPI control register
                pub const CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:2] 
                    res0:  u0, 
                    
                    /// [3:3] 0: In the dummy phase, the FSPI bus signals are not output. 1: In the dummy phase, the FSPI bus signals are output. Can be configured in CONF state.
                    DUMMY_OUT:  u1, 
                    
                    /// [4:4] 
                    res1:  u0, 
                    
                    /// [5:5] Apply 2 signals during addr phase 1:enable 0: disable. Can be configured in CONF state.
                    FADDR_DUAL:  u1, 
                    
                    /// [6:6] Apply 4 signals during addr phase 1:enable 0: disable. Can be configured in CONF state.
                    FADDR_QUAD:  u1, 
                    
                    /// [7:7] Apply 8 signals during addr phase 1:enable 0: disable. Can be configured in CONF state.
                    FADDR_OCT:  u1, 
                    
                    /// [8:8] Apply 2 signals during command phase 1:enable 0: disable. Can be configured in CONF state.
                    FCMD_DUAL:  u1, 
                    
                    /// [9:9] Apply 4 signals during command phase 1:enable 0: disable. Can be configured in CONF state.
                    FCMD_QUAD:  u1, 
                    
                    /// [10:10] Apply 8 signals during command phase 1:enable 0: disable. Can be configured in CONF state.
                    FCMD_OCT:  u1, 
                    
                    /// [11:13] 
                    res2:  u0, 
                    
                    /// [14:14] In the read operations, read-data phase apply 2 signals. 1: enable 0: disable. Can be configured in CONF state.
                    FREAD_DUAL:  u1, 
                    
                    /// [15:15] In the read operations read-data phase apply 4 signals. 1: enable 0: disable.Can be configured in CONF state.
                    FREAD_QUAD:  u1, 
                    
                    /// [16:16] In the read operations read-data phase apply 8 signals. 1: enable 0: disable.Can be configured in CONF state.
                    FREAD_OCT:  u1, 
                    
                    /// [17:17] 
                    res3:  u0, 
                    
                    /// [18:18] The bit is used to set MISO line polarity, 1: high 0, low. Can be configured in CONF state.
                    Q_POL:  u1, 
                    
                    /// [19:19] The bit is used to set MOSI line polarity, 1: high 0, low. Can be configured in CONF state.
                    D_POL:  u1, 
                    
                    /// [20:20] SPI_HOLD output value when SPI is idle. 1: output high, 0: output low. Can be configured in CONF state.
                    HOLD_POL:  u1, 
                    
                    /// [21:21] Write protect signal output when SPI is idle.1: output high, 0: output low.Can be configured in CONF state.
                    WP_POL:  u1, 
                    
                    /// [22:22] 
                    res4:  u0, 
                    
                    /// [23:24] In read-data (MISO) phase 1: LSB first 0: MSB first. Can be configured in CONF state.
                    RD_BIT_ORDER:  u2, 
                    
                    /// [25:26] In command address write-data (MOSI) phases 1: LSB firs 0: MSB first. Can be configured in CONF state.
                    WR_BIT_ORDER:  u2, 
                    
                    /// [27:31] 
                    res5:  u0, 
                    
                }), @ptrFromInt(0x60081008));
                
                /// SPI clock control register
                pub const CLOCK = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] In the master mode it must be equal to spi_clkcnt_N. In the slave mode it must be 0. Can be configured in CONF state.
                    CLKCNT_L:  u6, 
                    
                    /// [6:11] In the master mode it must be floor((spi_clkcnt_N+1)/2-1). In the slave mode it must be 0. Can be configured in CONF state.
                    CLKCNT_H:  u6, 
                    
                    /// [12:17] In the master mode it is the divider of spi_clk. So spi_clk frequency is system/(spi_clkdiv_pre+1)/(spi_clkcnt_N+1). Can be configured in CONF state.
                    CLKCNT_N:  u6, 
                    
                    /// [18:21] In the master mode it is pre-divider of spi_clk.Can be configured in CONF state.
                    CLKDIV_PRE:  u4, 
                    
                    /// [22:30] 
                    res0:  u0, 
                    
                    /// [31:31] In the master mode 1: spi_clk is eqaul to system 0: spi_clk is divided from system clock. Can be configured in CONF state.
                    CLK_EQU_SYSCLK:  u1, 
                    
                }), @ptrFromInt(0x6008100c));
                
                /// SPI USER control register
                pub const USER = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Set the bit to enable full duplex communication. 1: enable 0: disable. Can be configured in CONF state.
                    DOUTDIN:  u1, 
                    
                    /// [1:2] 
                    res0:  u0, 
                    
                    /// [3:3] Both for master mode and slave mode. 1: spi controller is in QPI mode. 0: others. Can be configured in CONF state.
                    QPI_MODE:  u1, 
                    
                    /// [4:4] Just for master mode. 1: spi controller is in OPI mode (all in 8-b-m). 0: others. Can be configured in CONF state.
                    OPI_MODE:  u1, 
                    
                    /// [5:5] In the slave mode, this bit can be used to change the polarity of tsck. 0: tsck = spi_ck_i. 1:tsck = !spi_ck_i.
                    TSCK_I_EDGE:  u1, 
                    
                    /// [6:6] spi cs keep low when spi is indonephase. 1: enable 0: disable. Can be configured in CONF state.
                    CS_HOLD:  u1, 
                    
                    /// [7:7] spi cs is enable when spi is inpreparephase. 1: enable 0: disable. Can be configured in CONF state.
                    CS_SETUP:  u1, 
                    
                    /// [8:8] In the slave mode, this bit can be used to change the polarity of rsck. 0: rsck = !spi_ck_i. 1:rsck = spi_ck_i.
                    RSCK_I_EDGE:  u1, 
                    
                    /// [9:9] the bit combined with spi_mosi_delay_mode bits to set mosi signal delay mode. Can be configured in CONF state.
                    CK_OUT_EDGE:  u1, 
                    
                    /// [10:11] 
                    res1:  u0, 
                    
                    /// [12:12] In the write operations read-data phase apply 2 signals. Can be configured in CONF state.
                    FWRITE_DUAL:  u1, 
                    
                    /// [13:13] In the write operations read-data phase apply 4 signals. Can be configured in CONF state.
                    FWRITE_QUAD:  u1, 
                    
                    /// [14:14] In the write operations read-data phase apply 8 signals. Can be configured in CONF state.
                    FWRITE_OCT:  u1, 
                    
                    /// [15:15] 1: Enable the DMA CONF phase of next seg-trans operation, which means seg-trans will continue. 0: The seg-trans will end after the current SPI seg-trans or this is not seg-trans mode. Can be configured in CONF state.
                    USR_CONF_NXT:  u1, 
                    
                    /// [16:16] 
                    res2:  u0, 
                    
                    /// [17:17] Set the bit to enable 3-line half duplex communication mosi and miso signals share the same pin. 1: enable 0: disable. Can be configured in CONF state.
                    SIO:  u1, 
                    
                    /// [18:23] 
                    res3:  u0, 
                    
                    /// [24:24] read-data phase only access to high-part of the buffer spi_w8~spi_w15. 1: enable 0: disable. Can be configured in CONF state.
                    USR_MISO_HIGHPART:  u1, 
                    
                    /// [25:25] write-data phase only access to high-part of the buffer spi_w8~spi_w15. 1: enable 0: disable.Can be configured in CONF state.
                    USR_MOSI_HIGHPART:  u1, 
                    
                    /// [26:26] spi clock is disable in dummy phase when the bit is enable. Can be configured in CONF state.
                    USR_DUMMY_IDLE:  u1, 
                    
                    /// [27:27] This bit enable the write-data phase of an operation. Can be configured in CONF state.
                    USR_MOSI:  u1, 
                    
                    /// [28:28] This bit enable the read-data phase of an operation. Can be configured in CONF state.
                    USR_MISO:  u1, 
                    
                    /// [29:29] This bit enable the dummy phase of an operation. Can be configured in CONF state.
                    USR_DUMMY:  u1, 
                    
                    /// [30:30] This bit enable the address phase of an operation. Can be configured in CONF state.
                    USR_ADDR:  u1, 
                    
                    /// [31:31] This bit enable the command phase of an operation. Can be configured in CONF state.
                    USR_COMMAND:  u1, 
                    
                }), @ptrFromInt(0x60081010));
                
                /// SPI USER control register 1
                pub const USER1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] The length in spi_clk cycles of dummy phase. The register value shall be (cycle_num-1). Can be configured in CONF state.
                    USR_DUMMY_CYCLELEN:  u8, 
                    
                    /// [8:15] 
                    res0:  u0, 
                    
                    /// [16:16] 1: SPI transfer is ended when SPI RX AFIFO wfull error is valid in GP-SPI master FD/HD-mode. 0: SPI transfer is not ended when SPI RX AFIFO wfull error is valid in GP-SPI master FD/HD-mode.
                    MST_WFULL_ERR_END_EN:  u1, 
                    
                    /// [17:21] (cycles+1) of prepare phase by spi clock this bits are combined with spi_cs_setup bit. Can be configured in CONF state.
                    CS_SETUP_TIME:  u5, 
                    
                    /// [22:26] delay cycles of cs pin by spi clock this bits are combined with spi_cs_hold bit. Can be configured in CONF state.
                    CS_HOLD_TIME:  u5, 
                    
                    /// [27:31] The length in bits of address phase. The register value shall be (bit_num-1). Can be configured in CONF state.
                    USR_ADDR_BITLEN:  u5, 
                    
                }), @ptrFromInt(0x60081014));
                
                /// SPI USER control register 2
                pub const USER2 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:15] The value ofcommand. Can be configured in CONF state.
                    USR_COMMAND_VALUE:  u16, 
                    
                    /// [16:26] 
                    res0:  u0, 
                    
                    /// [27:27] 1: SPI transfer is ended when SPI TX AFIFO read empty error is valid in GP-SPI master FD/HD-mode. 0: SPI transfer is not ended when SPI TX AFIFO read empty error is valid in GP-SPI master FD/HD-mode.
                    MST_REMPTY_ERR_END_EN:  u1, 
                    
                    /// [28:31] The length in bits of command phase. The register value shall be (bit_num-1). Can be configured in CONF state.
                    USR_COMMAND_BITLEN:  u4, 
                    
                }), @ptrFromInt(0x60081018));
                
                /// SPI data bit length control register
                pub const MS_DLEN = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:17] The value of these bits is the configured SPI transmission data bit length in master mode DMA controlled transfer or CPU controlled transfer. The value is also the configured bit length in slave mode DMA RX controlled transfer. The register value shall be (bit_num-1). Can be configured in CONF state.
                    MS_DATA_BITLEN:  u18, 
                    
                    /// [18:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6008101c));
                
                /// SPI misc register
                pub const MISC = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] SPI CS0 pin enable, 1: disable CS0, 0: spi_cs0 signal is from/to CS0 pin. Can be configured in CONF state.
                    CS0_DIS:  u1, 
                    
                    /// [1:1] SPI CS1 pin enable, 1: disable CS1, 0: spi_cs1 signal is from/to CS1 pin. Can be configured in CONF state.
                    CS1_DIS:  u1, 
                    
                    /// [2:2] SPI CS2 pin enable, 1: disable CS2, 0: spi_cs2 signal is from/to CS2 pin. Can be configured in CONF state.
                    CS2_DIS:  u1, 
                    
                    /// [3:3] SPI CS3 pin enable, 1: disable CS3, 0: spi_cs3 signal is from/to CS3 pin. Can be configured in CONF state.
                    CS3_DIS:  u1, 
                    
                    /// [4:4] SPI CS4 pin enable, 1: disable CS4, 0: spi_cs4 signal is from/to CS4 pin. Can be configured in CONF state.
                    CS4_DIS:  u1, 
                    
                    /// [5:5] SPI CS5 pin enable, 1: disable CS5, 0: spi_cs5 signal is from/to CS5 pin. Can be configured in CONF state.
                    CS5_DIS:  u1, 
                    
                    /// [6:6] 1: spi clk out disable,0: spi clk out enable. Can be configured in CONF state.
                    CK_DIS:  u1, 
                    
                    /// [7:12] In the master mode the bits are the polarity of spi cs line, the value is equivalent to spi_cs ^ spi_master_cs_pol. Can be configured in CONF state.
                    MASTER_CS_POL:  u6, 
                    
                    /// [13:15] 
                    res0:  u0, 
                    
                    /// [16:16] 1: SPI master DTR mode is applied to SPI clk, data and spi_dqs.0: SPI master DTR mode isonly applied to spi_dqs. This bit should be used with bit 17/18/19.
                    CLK_DATA_DTR_EN:  u1, 
                    
                    /// [17:17] 1: SPI clk and data of SPI_DOUT and SPI_DIN state are in DTR mode, including master 1/2/4/8-bm.0:SPI clk and data of SPI_DOUT and SPI_DIN state are in STR mode. Can be configured in CONF state.
                    DATA_DTR_EN:  u1, 
                    
                    /// [18:18] 1: SPI clk and data of SPI_SEND_ADDR state are in DTR mode, including master 1/2/4/8-bm.0:SPI clk and data of SPI_SEND_ADDR state are in STR mode. Can be configured in CONF state.
                    ADDR_DTR_EN:  u1, 
                    
                    /// [19:19] 1: SPI clk and data of SPI_SEND_CMD state are in DTR mode, including master 1/2/4/8-bm. 0:SPI clk and data of SPI_SEND_CMD state are in STR mode. Can be configured in CONF state.
                    CMD_DTR_EN:  u1, 
                    
                    /// [20:22] 
                    res1:  u0, 
                    
                    /// [23:23] spi slave input cs polarity select. 1: inv0: not change. Can be configured in CONF state.
                    SLAVE_CS_POL:  u1, 
                    
                    /// [24:24] The default value of spi_dqs. Can be configured in CONF state.
                    DQS_IDLE_EDGE:  u1, 
                    
                    /// [25:28] 
                    res2:  u0, 
                    
                    /// [29:29] 1: spi clk line is high when idle 0: spi clk line is low when idle. Can be configured in CONF state.
                    CK_IDLE_EDGE:  u1, 
                    
                    /// [30:30] spi cs line keep low when the bit is set. Can be configured in CONF state.
                    CS_KEEP_ACTIVE:  u1, 
                    
                    /// [31:31] 1: SPI quad input swap enable, swap FSPID with FSPIQ, swap FSPIWP with FSPIHD. 0:spi quad input swap disable. Can be configured in CONF state.
                    QUAD_DIN_PIN_SWAP:  u1, 
                    
                }), @ptrFromInt(0x60081020));
                
                /// SPI input delay mode configuration
                pub const DIN_MODE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:1] the input signals are delayed by SPI module clock cycles, 0: input without delayed, 1: input with the posedge of clk_apb,2 input with the negedge of clk_apb, 3: input with the spi_clk. Can be configured in CONF state.
                    DIN0_MODE:  u2, 
                    
                    /// [2:3] the input signals are delayed by SPI module clock cycles, 0: input without delayed, 1: input with the posedge of clk_apb,2 input with the negedge of clk_apb, 3: input with the spi_clk. Can be configured in CONF state.
                    DIN1_MODE:  u2, 
                    
                    /// [4:5] the input signals are delayed by SPI module clock cycles, 0: input without delayed, 1: input with the posedge of clk_apb,2 input with the negedge of clk_apb, 3: input with the spi_clk. Can be configured in CONF state.
                    DIN2_MODE:  u2, 
                    
                    /// [6:7] the input signals are delayed by SPI module clock cycles, 0: input without delayed, 1: input with the posedge of clk_apb,2 input with the negedge of clk_apb, 3: input with the spi_clk. Can be configured in CONF state.
                    DIN3_MODE:  u2, 
                    
                    /// [8:9] the input signals are delayed by SPI module clock cycles, 0: input without delayed, 1: input with the posedge of clk_apb,2 input with the negedge of clk_apb, 3: input with the spi_clk. Can be configured in CONF state.
                    DIN4_MODE:  u2, 
                    
                    /// [10:11] the input signals are delayed by SPI module clock cycles, 0: input without delayed, 1: input with the posedge of clk_apb,2 input with the negedge of clk_apb, 3: input with the spi_clk. Can be configured in CONF state.
                    DIN5_MODE:  u2, 
                    
                    /// [12:13] the input signals are delayed by SPI module clock cycles, 0: input without delayed, 1: input with the posedge of clk_apb,2 input with the negedge of clk_apb, 3: input with the spi_clk. Can be configured in CONF state.
                    DIN6_MODE:  u2, 
                    
                    /// [14:15] the input signals are delayed by SPI module clock cycles, 0: input without delayed, 1: input with the posedge of clk_apb,2 input with the negedge of clk_apb, 3: input with the spi_clk. Can be configured in CONF state.
                    DIN7_MODE:  u2, 
                    
                    /// [16:16] 1:enable hclk in SPI input timing module.0: disable it. Can be configured in CONF state.
                    TIMING_HCLK_ACTIVE:  u1, 
                    
                    /// [17:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60081024));
                
                /// SPI input delay number configuration
                pub const DIN_NUM = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:1] the input signals are delayed by SPI module clock cycles, 0: delayed by 1 cycle, 1: delayed by 2 cycles,...Can be configured in CONF state.
                    DIN0_NUM:  u2, 
                    
                    /// [2:3] the input signals are delayed by SPI module clock cycles, 0: delayed by 1 cycle, 1: delayed by 2 cycles,...Can be configured in CONF state.
                    DIN1_NUM:  u2, 
                    
                    /// [4:5] the input signals are delayed by SPI module clock cycles, 0: delayed by 1 cycle, 1: delayed by 2 cycles,...Can be configured in CONF state.
                    DIN2_NUM:  u2, 
                    
                    /// [6:7] the input signals are delayed by SPI module clock cycles, 0: delayed by 1 cycle, 1: delayed by 2 cycles,...Can be configured in CONF state.
                    DIN3_NUM:  u2, 
                    
                    /// [8:9] the input signals are delayed by SPI module clock cycles, 0: delayed by 1 cycle, 1: delayed by 2 cycles,...Can be configured in CONF state.
                    DIN4_NUM:  u2, 
                    
                    /// [10:11] the input signals are delayed by SPI module clock cycles, 0: delayed by 1 cycle, 1: delayed by 2 cycles,...Can be configured in CONF state.
                    DIN5_NUM:  u2, 
                    
                    /// [12:13] the input signals are delayed by SPI module clock cycles, 0: delayed by 1 cycle, 1: delayed by 2 cycles,...Can be configured in CONF state.
                    DIN6_NUM:  u2, 
                    
                    /// [14:15] the input signals are delayed by SPI module clock cycles, 0: delayed by 1 cycle, 1: delayed by 2 cycles,...Can be configured in CONF state.
                    DIN7_NUM:  u2, 
                    
                    /// [16:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60081028));
                
                /// SPI output delay mode configuration
                pub const DOUT_MODE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] The output signal 0 is delayed by the SPI module clock, 0: output without delayed, 1: output delay for a SPI module clock cycle at its negative edge. Can be configured in CONF state.
                    DOUT0_MODE:  u1, 
                    
                    /// [1:1] The output signal 1 is delayed by the SPI module clock, 0: output without delayed, 1: output delay for a SPI module clock cycle at its negative edge. Can be configured in CONF state.
                    DOUT1_MODE:  u1, 
                    
                    /// [2:2] The output signal 2 is delayed by the SPI module clock, 0: output without delayed, 1: output delay for a SPI module clock cycle at its negative edge. Can be configured in CONF state.
                    DOUT2_MODE:  u1, 
                    
                    /// [3:3] The output signal 3 is delayed by the SPI module clock, 0: output without delayed, 1: output delay for a SPI module clock cycle at its negative edge. Can be configured in CONF state.
                    DOUT3_MODE:  u1, 
                    
                    /// [4:4] The output signal 4 is delayed by the SPI module clock, 0: output without delayed, 1: output delay for a SPI module clock cycle at its negative edge. Can be configured in CONF state.
                    DOUT4_MODE:  u1, 
                    
                    /// [5:5] The output signal 5 is delayed by the SPI module clock, 0: output without delayed, 1: output delay for a SPI module clock cycle at its negative edge. Can be configured in CONF state.
                    DOUT5_MODE:  u1, 
                    
                    /// [6:6] The output signal 6 is delayed by the SPI module clock, 0: output without delayed, 1: output delay for a SPI module clock cycle at its negative edge. Can be configured in CONF state.
                    DOUT6_MODE:  u1, 
                    
                    /// [7:7] The output signal 7 is delayed by the SPI module clock, 0: output without delayed, 1: output delay for a SPI module clock cycle at its negative edge. Can be configured in CONF state.
                    DOUT7_MODE:  u1, 
                    
                    /// [8:8] The output signal SPI_DQS is delayed by the SPI module clock, 0: output without delayed, 1: output delay for a SPI module clock cycle at its negative edge. Can be configured in CONF state.
                    D_DQS_MODE:  u1, 
                    
                    /// [9:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6008102c));
                
                /// SPI DMA control register
                pub const DMA_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Records the status of DMA TX FIFO. 1: DMA TX FIFO is not ready for sending data. 0: DMA TX FIFO is ready for sending data.
                    DMA_OUTFIFO_EMPTY:  u1, 
                    
                    /// [1:1] Records the status of DMA RX FIFO. 1: DMA RX FIFO is not ready for receiving data. 0: DMA RX FIFO is ready for receiving data.
                    DMA_INFIFO_FULL:  u1, 
                    
                    /// [2:17] 
                    res0:  u0, 
                    
                    /// [18:18] Enable dma segment transfer in spi dma half slave mode. 1: enable. 0: disable.
                    DMA_SLV_SEG_TRANS_EN:  u1, 
                    
                    /// [19:19] 1: spi_dma_infifo_full_vld is cleared by spi slave cmd 5. 0: spi_dma_infifo_full_vld is cleared by spi_trans_done.
                    SLV_RX_SEG_TRANS_CLR_EN:  u1, 
                    
                    /// [20:20] 1: spi_dma_outfifo_empty_vld is cleared by spi slave cmd 6. 0: spi_dma_outfifo_empty_vld is cleared by spi_trans_done.
                    SLV_TX_SEG_TRANS_CLR_EN:  u1, 
                    
                    /// [21:21] 1: spi_dma_inlink_eof is set when the number of dma pushed data bytes is equal to the value of spi_slv/mst_dma_rd_bytelen[19:0] in spi dma transition.0: spi_dma_inlink_eof is set by spi_trans_done in non-seg-trans or spi_dma_seg_trans_done in seg-trans.
                    RX_EOF_EN:  u1, 
                    
                    /// [22:26] 
                    res1:  u0, 
                    
                    /// [27:27] Set this bit to enable SPI DMA controlled receive data mode.
                    DMA_RX_ENA:  u1, 
                    
                    /// [28:28] Set this bit to enable SPI DMA controlled send data mode.
                    DMA_TX_ENA:  u1, 
                    
                    /// [29:29] Set this bit to reset RX AFIFO, which is used to receive data in SPI master and slave mode transfer.
                    RX_AFIFO_RST:  u1, 
                    
                    /// [30:30] Set this bit to reset BUF TX AFIFO, which is used send data out in SPI slave CPU controlled mode transfer and master mode transfer.
                    BUF_AFIFO_RST:  u1, 
                    
                    /// [31:31] Set this bit to reset DMA TX AFIFO, which is used to send data out in SPI slave DMA controlled mode transfer.
                    DMA_AFIFO_RST:  u1, 
                    
                }), @ptrFromInt(0x60081030));
                
                /// SPI interrupt enable register
                pub const DMA_INT_ENA = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] The enable bit for SPI_DMA_INFIFO_FULL_ERR_INT interrupt.
                    DMA_INFIFO_FULL_ERR_INT_ENA:  u1, 
                    
                    /// [1:1] The enable bit for SPI_DMA_OUTFIFO_EMPTY_ERR_INT interrupt.
                    DMA_OUTFIFO_EMPTY_ERR_INT_ENA:  u1, 
                    
                    /// [2:2] The enable bit for SPI slave Ex_QPI interrupt.
                    SLV_EX_QPI_INT_ENA:  u1, 
                    
                    /// [3:3] The enable bit for SPI slave En_QPI interrupt.
                    SLV_EN_QPI_INT_ENA:  u1, 
                    
                    /// [4:4] The enable bit for SPI slave CMD7 interrupt.
                    SLV_CMD7_INT_ENA:  u1, 
                    
                    /// [5:5] The enable bit for SPI slave CMD8 interrupt.
                    SLV_CMD8_INT_ENA:  u1, 
                    
                    /// [6:6] The enable bit for SPI slave CMD9 interrupt.
                    SLV_CMD9_INT_ENA:  u1, 
                    
                    /// [7:7] The enable bit for SPI slave CMDA interrupt.
                    SLV_CMDA_INT_ENA:  u1, 
                    
                    /// [8:8] The enable bit for SPI_SLV_RD_DMA_DONE_INT interrupt.
                    SLV_RD_DMA_DONE_INT_ENA:  u1, 
                    
                    /// [9:9] The enable bit for SPI_SLV_WR_DMA_DONE_INT interrupt.
                    SLV_WR_DMA_DONE_INT_ENA:  u1, 
                    
                    /// [10:10] The enable bit for SPI_SLV_RD_BUF_DONE_INT interrupt.
                    SLV_RD_BUF_DONE_INT_ENA:  u1, 
                    
                    /// [11:11] The enable bit for SPI_SLV_WR_BUF_DONE_INT interrupt.
                    SLV_WR_BUF_DONE_INT_ENA:  u1, 
                    
                    /// [12:12] The enable bit for SPI_TRANS_DONE_INT interrupt.
                    TRANS_DONE_INT_ENA:  u1, 
                    
                    /// [13:13] The enable bit for SPI_DMA_SEG_TRANS_DONE_INT interrupt.
                    DMA_SEG_TRANS_DONE_INT_ENA:  u1, 
                    
                    /// [14:14] The enable bit for SPI_SEG_MAGIC_ERR_INT interrupt.
                    SEG_MAGIC_ERR_INT_ENA:  u1, 
                    
                    /// [15:15] The enable bit for SPI_SLV_BUF_ADDR_ERR_INT interrupt.
                    SLV_BUF_ADDR_ERR_INT_ENA:  u1, 
                    
                    /// [16:16] The enable bit for SPI_SLV_CMD_ERR_INT interrupt.
                    SLV_CMD_ERR_INT_ENA:  u1, 
                    
                    /// [17:17] The enable bit for SPI_MST_RX_AFIFO_WFULL_ERR_INT interrupt.
                    MST_RX_AFIFO_WFULL_ERR_INT_ENA:  u1, 
                    
                    /// [18:18] The enable bit for SPI_MST_TX_AFIFO_REMPTY_ERR_INT interrupt.
                    MST_TX_AFIFO_REMPTY_ERR_INT_ENA:  u1, 
                    
                    /// [19:19] The enable bit for SPI_APP2_INT interrupt.
                    APP2_INT_ENA:  u1, 
                    
                    /// [20:20] The enable bit for SPI_APP1_INT interrupt.
                    APP1_INT_ENA:  u1, 
                    
                    /// [21:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60081034));
                
                /// SPI interrupt clear register
                pub const DMA_INT_CLR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] The clear bit for SPI_DMA_INFIFO_FULL_ERR_INT interrupt.
                    DMA_INFIFO_FULL_ERR_INT_CLR:  u1, 
                    
                    /// [1:1] The clear bit for SPI_DMA_OUTFIFO_EMPTY_ERR_INT interrupt.
                    DMA_OUTFIFO_EMPTY_ERR_INT_CLR:  u1, 
                    
                    /// [2:2] The clear bit for SPI slave Ex_QPI interrupt.
                    SLV_EX_QPI_INT_CLR:  u1, 
                    
                    /// [3:3] The clear bit for SPI slave En_QPI interrupt.
                    SLV_EN_QPI_INT_CLR:  u1, 
                    
                    /// [4:4] The clear bit for SPI slave CMD7 interrupt.
                    SLV_CMD7_INT_CLR:  u1, 
                    
                    /// [5:5] The clear bit for SPI slave CMD8 interrupt.
                    SLV_CMD8_INT_CLR:  u1, 
                    
                    /// [6:6] The clear bit for SPI slave CMD9 interrupt.
                    SLV_CMD9_INT_CLR:  u1, 
                    
                    /// [7:7] The clear bit for SPI slave CMDA interrupt.
                    SLV_CMDA_INT_CLR:  u1, 
                    
                    /// [8:8] The clear bit for SPI_SLV_RD_DMA_DONE_INT interrupt.
                    SLV_RD_DMA_DONE_INT_CLR:  u1, 
                    
                    /// [9:9] The clear bit for SPI_SLV_WR_DMA_DONE_INT interrupt.
                    SLV_WR_DMA_DONE_INT_CLR:  u1, 
                    
                    /// [10:10] The clear bit for SPI_SLV_RD_BUF_DONE_INT interrupt.
                    SLV_RD_BUF_DONE_INT_CLR:  u1, 
                    
                    /// [11:11] The clear bit for SPI_SLV_WR_BUF_DONE_INT interrupt.
                    SLV_WR_BUF_DONE_INT_CLR:  u1, 
                    
                    /// [12:12] The clear bit for SPI_TRANS_DONE_INT interrupt.
                    TRANS_DONE_INT_CLR:  u1, 
                    
                    /// [13:13] The clear bit for SPI_DMA_SEG_TRANS_DONE_INT interrupt.
                    DMA_SEG_TRANS_DONE_INT_CLR:  u1, 
                    
                    /// [14:14] The clear bit for SPI_SEG_MAGIC_ERR_INT interrupt.
                    SEG_MAGIC_ERR_INT_CLR:  u1, 
                    
                    /// [15:15] The clear bit for SPI_SLV_BUF_ADDR_ERR_INT interrupt.
                    SLV_BUF_ADDR_ERR_INT_CLR:  u1, 
                    
                    /// [16:16] The clear bit for SPI_SLV_CMD_ERR_INT interrupt.
                    SLV_CMD_ERR_INT_CLR:  u1, 
                    
                    /// [17:17] The clear bit for SPI_MST_RX_AFIFO_WFULL_ERR_INT interrupt.
                    MST_RX_AFIFO_WFULL_ERR_INT_CLR:  u1, 
                    
                    /// [18:18] The clear bit for SPI_MST_TX_AFIFO_REMPTY_ERR_INT interrupt.
                    MST_TX_AFIFO_REMPTY_ERR_INT_CLR:  u1, 
                    
                    /// [19:19] The clear bit for SPI_APP2_INT interrupt.
                    APP2_INT_CLR:  u1, 
                    
                    /// [20:20] The clear bit for SPI_APP1_INT interrupt.
                    APP1_INT_CLR:  u1, 
                    
                    /// [21:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60081038));
                
                /// SPI interrupt raw register
                pub const DMA_INT_RAW = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] 1: The current data rate of DMA Rx is smaller than that of SPI, which will lose the receive data.0: Others.
                    DMA_INFIFO_FULL_ERR_INT_RAW:  u1, 
                    
                    /// [1:1] 1: The current data rate of DMA TX is smaller than that of SPI. SPI will stop in master mode and send out all 0 in slave mode.0: Others.
                    DMA_OUTFIFO_EMPTY_ERR_INT_RAW:  u1, 
                    
                    /// [2:2] The raw bit for SPI slave Ex_QPI interrupt. 1: SPI slave mode Ex_QPI transmission is ended. 0: Others.
                    SLV_EX_QPI_INT_RAW:  u1, 
                    
                    /// [3:3] The raw bit for SPI slave En_QPI interrupt. 1: SPI slave mode En_QPI transmission is ended. 0: Others.
                    SLV_EN_QPI_INT_RAW:  u1, 
                    
                    /// [4:4] The raw bit for SPI slave CMD7 interrupt. 1: SPI slave mode CMD7 transmission is ended. 0: Others.
                    SLV_CMD7_INT_RAW:  u1, 
                    
                    /// [5:5] The raw bit for SPI slave CMD8 interrupt. 1: SPI slave mode CMD8 transmission is ended. 0: Others.
                    SLV_CMD8_INT_RAW:  u1, 
                    
                    /// [6:6] The raw bit for SPI slave CMD9 interrupt. 1: SPI slave mode CMD9 transmission is ended. 0: Others.
                    SLV_CMD9_INT_RAW:  u1, 
                    
                    /// [7:7] The raw bit for SPI slave CMDA interrupt. 1: SPI slave mode CMDA transmission is ended. 0: Others.
                    SLV_CMDA_INT_RAW:  u1, 
                    
                    /// [8:8] The raw bit for SPI_SLV_RD_DMA_DONE_INT interrupt. 1: SPI slave mode Rd_DMA transmission is ended. 0: Others.
                    SLV_RD_DMA_DONE_INT_RAW:  u1, 
                    
                    /// [9:9] The raw bit for SPI_SLV_WR_DMA_DONE_INT interrupt. 1: SPI slave mode Wr_DMA transmission is ended. 0: Others.
                    SLV_WR_DMA_DONE_INT_RAW:  u1, 
                    
                    /// [10:10] The raw bit for SPI_SLV_RD_BUF_DONE_INT interrupt. 1: SPI slave mode Rd_BUF transmission is ended. 0: Others.
                    SLV_RD_BUF_DONE_INT_RAW:  u1, 
                    
                    /// [11:11] The raw bit for SPI_SLV_WR_BUF_DONE_INT interrupt. 1: SPI slave mode Wr_BUF transmission is ended. 0: Others.
                    SLV_WR_BUF_DONE_INT_RAW:  u1, 
                    
                    /// [12:12] The raw bit for SPI_TRANS_DONE_INT interrupt. 1: SPI master mode transmission is ended. 0: others.
                    TRANS_DONE_INT_RAW:  u1, 
                    
                    /// [13:13] The raw bit for SPI_DMA_SEG_TRANS_DONE_INT interrupt. 1:spi master DMA full-duplex/half-duplex seg-conf-trans ends or slave half-duplex seg-trans ends. And data has been pushed to corresponding memory.0:seg-conf-trans or seg-trans is not ended or not occurred.
                    DMA_SEG_TRANS_DONE_INT_RAW:  u1, 
                    
                    /// [14:14] The raw bit for SPI_SEG_MAGIC_ERR_INT interrupt. 1: The magic value in CONF buffer is error in the DMA seg-conf-trans. 0: others.
                    SEG_MAGIC_ERR_INT_RAW:  u1, 
                    
                    /// [15:15] The raw bit for SPI_SLV_BUF_ADDR_ERR_INT interrupt. 1: The accessing data address of the current SPI slave mode CPU controlled FD, Wr_BUF or Rd_BUF transmission is bigger than 63. 0: Others.
                    SLV_BUF_ADDR_ERR_INT_RAW:  u1, 
                    
                    /// [16:16] The raw bit for SPI_SLV_CMD_ERR_INT interrupt. 1: The slave command value in the current SPI slave HD mode transmission is not supported. 0: Others.
                    SLV_CMD_ERR_INT_RAW:  u1, 
                    
                    /// [17:17] The raw bit for SPI_MST_RX_AFIFO_WFULL_ERR_INT interrupt. 1: There is a RX AFIFO write-full error when SPI inputs data in master mode. 0: Others.
                    MST_RX_AFIFO_WFULL_ERR_INT_RAW:  u1, 
                    
                    /// [18:18] The raw bit for SPI_MST_TX_AFIFO_REMPTY_ERR_INT interrupt. 1: There is a TX BUF AFIFO read-empty error when SPI outputs data in master mode. 0: Others.
                    MST_TX_AFIFO_REMPTY_ERR_INT_RAW:  u1, 
                    
                    /// [19:19] The raw bit for SPI_APP2_INT interrupt. The value is only controlled by software.
                    APP2_INT_RAW:  u1, 
                    
                    /// [20:20] The raw bit for SPI_APP1_INT interrupt. The value is only controlled by software.
                    APP1_INT_RAW:  u1, 
                    
                    /// [21:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6008103c));
                
                /// SPI interrupt status register
                pub const DMA_INT_ST = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] The status bit for SPI_DMA_INFIFO_FULL_ERR_INT interrupt.
                    DMA_INFIFO_FULL_ERR_INT_ST:  u1, 
                    
                    /// [1:1] The status bit for SPI_DMA_OUTFIFO_EMPTY_ERR_INT interrupt.
                    DMA_OUTFIFO_EMPTY_ERR_INT_ST:  u1, 
                    
                    /// [2:2] The status bit for SPI slave Ex_QPI interrupt.
                    SLV_EX_QPI_INT_ST:  u1, 
                    
                    /// [3:3] The status bit for SPI slave En_QPI interrupt.
                    SLV_EN_QPI_INT_ST:  u1, 
                    
                    /// [4:4] The status bit for SPI slave CMD7 interrupt.
                    SLV_CMD7_INT_ST:  u1, 
                    
                    /// [5:5] The status bit for SPI slave CMD8 interrupt.
                    SLV_CMD8_INT_ST:  u1, 
                    
                    /// [6:6] The status bit for SPI slave CMD9 interrupt.
                    SLV_CMD9_INT_ST:  u1, 
                    
                    /// [7:7] The status bit for SPI slave CMDA interrupt.
                    SLV_CMDA_INT_ST:  u1, 
                    
                    /// [8:8] The status bit for SPI_SLV_RD_DMA_DONE_INT interrupt.
                    SLV_RD_DMA_DONE_INT_ST:  u1, 
                    
                    /// [9:9] The status bit for SPI_SLV_WR_DMA_DONE_INT interrupt.
                    SLV_WR_DMA_DONE_INT_ST:  u1, 
                    
                    /// [10:10] The status bit for SPI_SLV_RD_BUF_DONE_INT interrupt.
                    SLV_RD_BUF_DONE_INT_ST:  u1, 
                    
                    /// [11:11] The status bit for SPI_SLV_WR_BUF_DONE_INT interrupt.
                    SLV_WR_BUF_DONE_INT_ST:  u1, 
                    
                    /// [12:12] The status bit for SPI_TRANS_DONE_INT interrupt.
                    TRANS_DONE_INT_ST:  u1, 
                    
                    /// [13:13] The status bit for SPI_DMA_SEG_TRANS_DONE_INT interrupt.
                    DMA_SEG_TRANS_DONE_INT_ST:  u1, 
                    
                    /// [14:14] The status bit for SPI_SEG_MAGIC_ERR_INT interrupt.
                    SEG_MAGIC_ERR_INT_ST:  u1, 
                    
                    /// [15:15] The status bit for SPI_SLV_BUF_ADDR_ERR_INT interrupt.
                    SLV_BUF_ADDR_ERR_INT_ST:  u1, 
                    
                    /// [16:16] The status bit for SPI_SLV_CMD_ERR_INT interrupt.
                    SLV_CMD_ERR_INT_ST:  u1, 
                    
                    /// [17:17] The status bit for SPI_MST_RX_AFIFO_WFULL_ERR_INT interrupt.
                    MST_RX_AFIFO_WFULL_ERR_INT_ST:  u1, 
                    
                    /// [18:18] The status bit for SPI_MST_TX_AFIFO_REMPTY_ERR_INT interrupt.
                    MST_TX_AFIFO_REMPTY_ERR_INT_ST:  u1, 
                    
                    /// [19:19] The status bit for SPI_APP2_INT interrupt.
                    APP2_INT_ST:  u1, 
                    
                    /// [20:20] The status bit for SPI_APP1_INT interrupt.
                    APP1_INT_ST:  u1, 
                    
                    /// [21:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60081040));
                
                /// SPI interrupt software set register
                pub const DMA_INT_SET = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] The software set bit for SPI_DMA_INFIFO_FULL_ERR_INT interrupt.
                    DMA_INFIFO_FULL_ERR_INT_SET:  u1, 
                    
                    /// [1:1] The software set bit for SPI_DMA_OUTFIFO_EMPTY_ERR_INT interrupt.
                    DMA_OUTFIFO_EMPTY_ERR_INT_SET:  u1, 
                    
                    /// [2:2] The software set bit for SPI slave Ex_QPI interrupt.
                    SLV_EX_QPI_INT_SET:  u1, 
                    
                    /// [3:3] The software set bit for SPI slave En_QPI interrupt.
                    SLV_EN_QPI_INT_SET:  u1, 
                    
                    /// [4:4] The software set bit for SPI slave CMD7 interrupt.
                    SLV_CMD7_INT_SET:  u1, 
                    
                    /// [5:5] The software set bit for SPI slave CMD8 interrupt.
                    SLV_CMD8_INT_SET:  u1, 
                    
                    /// [6:6] The software set bit for SPI slave CMD9 interrupt.
                    SLV_CMD9_INT_SET:  u1, 
                    
                    /// [7:7] The software set bit for SPI slave CMDA interrupt.
                    SLV_CMDA_INT_SET:  u1, 
                    
                    /// [8:8] The software set bit for SPI_SLV_RD_DMA_DONE_INT interrupt.
                    SLV_RD_DMA_DONE_INT_SET:  u1, 
                    
                    /// [9:9] The software set bit for SPI_SLV_WR_DMA_DONE_INT interrupt.
                    SLV_WR_DMA_DONE_INT_SET:  u1, 
                    
                    /// [10:10] The software set bit for SPI_SLV_RD_BUF_DONE_INT interrupt.
                    SLV_RD_BUF_DONE_INT_SET:  u1, 
                    
                    /// [11:11] The software set bit for SPI_SLV_WR_BUF_DONE_INT interrupt.
                    SLV_WR_BUF_DONE_INT_SET:  u1, 
                    
                    /// [12:12] The software set bit for SPI_TRANS_DONE_INT interrupt.
                    TRANS_DONE_INT_SET:  u1, 
                    
                    /// [13:13] The software set bit for SPI_DMA_SEG_TRANS_DONE_INT interrupt.
                    DMA_SEG_TRANS_DONE_INT_SET:  u1, 
                    
                    /// [14:14] The software set bit for SPI_SEG_MAGIC_ERR_INT interrupt.
                    SEG_MAGIC_ERR_INT_SET:  u1, 
                    
                    /// [15:15] The software set bit for SPI_SLV_BUF_ADDR_ERR_INT interrupt.
                    SLV_BUF_ADDR_ERR_INT_SET:  u1, 
                    
                    /// [16:16] The software set bit for SPI_SLV_CMD_ERR_INT interrupt.
                    SLV_CMD_ERR_INT_SET:  u1, 
                    
                    /// [17:17] The software set bit for SPI_MST_RX_AFIFO_WFULL_ERR_INT interrupt.
                    MST_RX_AFIFO_WFULL_ERR_INT_SET:  u1, 
                    
                    /// [18:18] The software set bit for SPI_MST_TX_AFIFO_REMPTY_ERR_INT interrupt.
                    MST_TX_AFIFO_REMPTY_ERR_INT_SET:  u1, 
                    
                    /// [19:19] The software set bit for SPI_APP2_INT interrupt.
                    APP2_INT_SET:  u1, 
                    
                    /// [20:20] The software set bit for SPI_APP1_INT interrupt.
                    APP1_INT_SET:  u1, 
                    
                    /// [21:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60081044));
                
                /// SPI CPU-controlled buffer0
                pub const W0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] data buffer
                    BUF0:  u32, 
                    
                }), @ptrFromInt(0x60081098));
                
                /// SPI CPU-controlled buffer1
                pub const W1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] data buffer
                    BUF1:  u32, 
                    
                }), @ptrFromInt(0x6008109c));
                
                /// SPI CPU-controlled buffer2
                pub const W2 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] data buffer
                    BUF2:  u32, 
                    
                }), @ptrFromInt(0x600810a0));
                
                /// SPI CPU-controlled buffer3
                pub const W3 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] data buffer
                    BUF3:  u32, 
                    
                }), @ptrFromInt(0x600810a4));
                
                /// SPI CPU-controlled buffer4
                pub const W4 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] data buffer
                    BUF4:  u32, 
                    
                }), @ptrFromInt(0x600810a8));
                
                /// SPI CPU-controlled buffer5
                pub const W5 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] data buffer
                    BUF5:  u32, 
                    
                }), @ptrFromInt(0x600810ac));
                
                /// SPI CPU-controlled buffer6
                pub const W6 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] data buffer
                    BUF6:  u32, 
                    
                }), @ptrFromInt(0x600810b0));
                
                /// SPI CPU-controlled buffer7
                pub const W7 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] data buffer
                    BUF7:  u32, 
                    
                }), @ptrFromInt(0x600810b4));
                
                /// SPI CPU-controlled buffer8
                pub const W8 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] data buffer
                    BUF8:  u32, 
                    
                }), @ptrFromInt(0x600810b8));
                
                /// SPI CPU-controlled buffer9
                pub const W9 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] data buffer
                    BUF9:  u32, 
                    
                }), @ptrFromInt(0x600810bc));
                
                /// SPI CPU-controlled buffer10
                pub const W10 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] data buffer
                    BUF10:  u32, 
                    
                }), @ptrFromInt(0x600810c0));
                
                /// SPI CPU-controlled buffer11
                pub const W11 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] data buffer
                    BUF11:  u32, 
                    
                }), @ptrFromInt(0x600810c4));
                
                /// SPI CPU-controlled buffer12
                pub const W12 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] data buffer
                    BUF12:  u32, 
                    
                }), @ptrFromInt(0x600810c8));
                
                /// SPI CPU-controlled buffer13
                pub const W13 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] data buffer
                    BUF13:  u32, 
                    
                }), @ptrFromInt(0x600810cc));
                
                /// SPI CPU-controlled buffer14
                pub const W14 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] data buffer
                    BUF14:  u32, 
                    
                }), @ptrFromInt(0x600810d0));
                
                /// SPI CPU-controlled buffer15
                pub const W15 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] data buffer
                    BUF15:  u32, 
                    
                }), @ptrFromInt(0x600810d4));
                
                /// SPI slave control register
                pub const SLAVE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:1] SPI clock mode bits. 0: SPI clock is off when CS inactive 1: SPI clock is delayed one cycle after CS inactive 2: SPI clock is delayed two cycles after CS inactive 3: SPI clock is alwasy on. Can be configured in CONF state.
                    CLK_MODE:  u2, 
                    
                    /// [2:2] {CPOL, CPHA},1: support spi clk mode 1 and 3, first edge output data B[0]/B[7].0: support spi clk mode 0 and 2, first edge output data B[1]/B[6].
                    CLK_MODE_13:  u1, 
                    
                    /// [3:3] It saves half a cycle when tsck is the same as rsck. 1: output data at rsck posedge 0: output data at tsck posedge
                    RSCK_DATA_OUT:  u1, 
                    
                    /// [4:7] 
                    res0:  u0, 
                    
                    /// [8:8] 1: SPI_SLV_DATA_BITLEN stores data bit length of master-read-slave data length in DMA controlled mode(Rd_DMA). 0: others
                    SLV_RDDMA_BITLEN_EN:  u1, 
                    
                    /// [9:9] 1: SPI_SLV_DATA_BITLEN stores data bit length of master-write-to-slave data length in DMA controlled mode(Wr_DMA). 0: others
                    SLV_WRDMA_BITLEN_EN:  u1, 
                    
                    /// [10:10] 1: SPI_SLV_DATA_BITLEN stores data bit length of master-read-slave data length in CPU controlled mode(Rd_BUF). 0: others
                    SLV_RDBUF_BITLEN_EN:  u1, 
                    
                    /// [11:11] 1: SPI_SLV_DATA_BITLEN stores data bit length of master-write-to-slave data length in CPU controlled mode(Wr_BUF). 0: others
                    SLV_WRBUF_BITLEN_EN:  u1, 
                    
                    /// [12:21] 
                    res1:  u0, 
                    
                    /// [22:25] The magic value of BM table in master DMA seg-trans.
                    DMA_SEG_MAGIC_VALUE:  u4, 
                    
                    /// [26:26] Set SPI work mode. 1: slave mode 0: master mode.
                    MODE:  u1, 
                    
                    /// [27:27] Software reset enable, reset the spi clock line cs line and data lines. Can be configured in CONF state.
                    SOFT_RESET:  u1, 
                    
                    /// [28:28] 1: Enable the DMA CONF phase of current seg-trans operation, which means seg-trans will start. 0: This is not seg-trans mode.
                    USR_CONF:  u1, 
                    
                    /// [29:29] In master full-duplex mode, 1: GP-SPI will wait DMA TX data is ready before starting SPI transfer. 0: GP-SPI does not wait DMA TX data before starting SPI transfer.
                    MST_FD_WAIT_DMA_TX_DATA:  u1, 
                    
                    /// [30:31] 
                    res2:  u0, 
                    
                }), @ptrFromInt(0x600810e0));
                
                /// SPI slave control register 1
                pub const SLAVE1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:17] The transferred data bit length in SPI slave FD and HD mode.
                    SLV_DATA_BITLEN:  u18, 
                    
                    /// [18:25] In the slave mode it is the value of command.
                    SLV_LAST_COMMAND:  u8, 
                    
                    /// [26:31] In the slave mode it is the value of address.
                    SLV_LAST_ADDR:  u6, 
                    
                }), @ptrFromInt(0x600810e4));
                
                /// SPI module clock and register clock control
                pub const CLK_GATE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Set this bit to enable clk gate
                    CLK_EN:  u1, 
                    
                    /// [1:1] Set this bit to power on the SPI module clock.
                    MST_CLK_ACTIVE:  u1, 
                    
                    /// [2:2] This bit is used to select SPI module clock source in master mode. 1: PLL_CLK_80M. 0: XTAL CLK.
                    MST_CLK_SEL:  u1, 
                    
                    /// [3:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600810e8));
                
                /// Version control
                pub const DATE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:27] SPI register version.
                    DATE:  u28, 
                    
                    /// [28:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600810f0));
                
            };
            
            /// System Timer
            pub const SYSTIMER = struct {
                
                /// Configure system timer clock
                pub const CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] systimer clock force on
                    SYSTIMER_CLK_FO:  u1, 
                    
                    /// [1:1] enable systimer's etm task and event
                    ETM_EN:  u1, 
                    
                    /// [2:21] 
                    res0:  u0, 
                    
                    /// [22:22] target2 work enable
                    TARGET2_WORK_EN:  u1, 
                    
                    /// [23:23] target1 work enable
                    TARGET1_WORK_EN:  u1, 
                    
                    /// [24:24] target0 work enable
                    TARGET0_WORK_EN:  u1, 
                    
                    /// [25:25] If timer unit1 is stalled when core1 stalled
                    TIMER_UNIT1_CORE1_STALL_EN:  u1, 
                    
                    /// [26:26] If timer unit1 is stalled when core0 stalled
                    TIMER_UNIT1_CORE0_STALL_EN:  u1, 
                    
                    /// [27:27] If timer unit0 is stalled when core1 stalled
                    TIMER_UNIT0_CORE1_STALL_EN:  u1, 
                    
                    /// [28:28] If timer unit0 is stalled when core0 stalled
                    TIMER_UNIT0_CORE0_STALL_EN:  u1, 
                    
                    /// [29:29] timer unit1 work enable
                    TIMER_UNIT1_WORK_EN:  u1, 
                    
                    /// [30:30] timer unit0 work enable
                    TIMER_UNIT0_WORK_EN:  u1, 
                    
                    /// [31:31] register file clk gating
                    CLK_EN:  u1, 
                    
                }), @ptrFromInt(0x6000a000));
                
                /// system timer unit0 value update register
                pub const UNIT0_OP = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:28] 
                    res0:  u0, 
                    
                    /// [29:29] timer value is sync and valid
                    TIMER_UNIT0_VALUE_VALID:  u1, 
                    
                    /// [30:30] update timer_unit0
                    TIMER_UNIT0_UPDATE:  u1, 
                    
                    /// [31:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x6000a004));
                
                /// system timer unit1 value update register
                pub const UNIT1_OP = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:28] 
                    res0:  u0, 
                    
                    /// [29:29] timer value is sync and valid
                    TIMER_UNIT1_VALUE_VALID:  u1, 
                    
                    /// [30:30] update timer unit1
                    TIMER_UNIT1_UPDATE:  u1, 
                    
                    /// [31:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x6000a008));
                
                /// system timer unit0 value high load register
                pub const UNIT0_LOAD_HI = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:19] timer unit0 load high 20 bits
                    TIMER_UNIT0_LOAD_HI:  u20, 
                    
                    /// [20:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000a00c));
                
                /// system timer unit0 value low load register
                pub const UNIT0_LOAD_LO = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] timer unit0 load low 32 bits
                    TIMER_UNIT0_LOAD_LO:  u32, 
                    
                }), @ptrFromInt(0x6000a010));
                
                /// system timer unit1 value high load register
                pub const UNIT1_LOAD_HI = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:19] timer unit1 load high 20 bits
                    TIMER_UNIT1_LOAD_HI:  u20, 
                    
                    /// [20:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000a014));
                
                /// system timer unit1 value low load register
                pub const UNIT1_LOAD_LO = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] timer unit1 load low 32 bits
                    TIMER_UNIT1_LOAD_LO:  u32, 
                    
                }), @ptrFromInt(0x6000a018));
                
                /// system timer comp0 value high register
                pub const TARGET0_HI = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:19] timer taget0 high 20 bits
                    TIMER_TARGET0_HI:  u20, 
                    
                    /// [20:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000a01c));
                
                /// system timer comp0 value low register
                pub const TARGET0_LO = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] timer taget0 low 32 bits
                    TIMER_TARGET0_LO:  u32, 
                    
                }), @ptrFromInt(0x6000a020));
                
                /// system timer comp1 value high register
                pub const TARGET1_HI = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:19] timer taget1 high 20 bits
                    TIMER_TARGET1_HI:  u20, 
                    
                    /// [20:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000a024));
                
                /// system timer comp1 value low register
                pub const TARGET1_LO = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] timer taget1 low 32 bits
                    TIMER_TARGET1_LO:  u32, 
                    
                }), @ptrFromInt(0x6000a028));
                
                /// system timer comp2 value high register
                pub const TARGET2_HI = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:19] timer taget2 high 20 bits
                    TIMER_TARGET2_HI:  u20, 
                    
                    /// [20:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000a02c));
                
                /// system timer comp2 value low register
                pub const TARGET2_LO = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] timer taget2 low 32 bits
                    TIMER_TARGET2_LO:  u32, 
                    
                }), @ptrFromInt(0x6000a030));
                
                /// system timer comp0 target mode register
                pub const TARGET0_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:25] target0 period
                    TARGET0_PERIOD:  u26, 
                    
                    /// [26:29] 
                    res0:  u0, 
                    
                    /// [30:30] Set target0 to period mode
                    TARGET0_PERIOD_MODE:  u1, 
                    
                    /// [31:31] select which unit to compare
                    TARGET0_TIMER_UNIT_SEL:  u1, 
                    
                }), @ptrFromInt(0x6000a034));
                
                /// system timer comp1 target mode register
                pub const TARGET1_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:25] target1 period
                    TARGET1_PERIOD:  u26, 
                    
                    /// [26:29] 
                    res0:  u0, 
                    
                    /// [30:30] Set target1 to period mode
                    TARGET1_PERIOD_MODE:  u1, 
                    
                    /// [31:31] select which unit to compare
                    TARGET1_TIMER_UNIT_SEL:  u1, 
                    
                }), @ptrFromInt(0x6000a038));
                
                /// system timer comp2 target mode register
                pub const TARGET2_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:25] target2 period
                    TARGET2_PERIOD:  u26, 
                    
                    /// [26:29] 
                    res0:  u0, 
                    
                    /// [30:30] Set target2 to period mode
                    TARGET2_PERIOD_MODE:  u1, 
                    
                    /// [31:31] select which unit to compare
                    TARGET2_TIMER_UNIT_SEL:  u1, 
                    
                }), @ptrFromInt(0x6000a03c));
                
                /// system timer unit0 value high register
                pub const UNIT0_VALUE_HI = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:19] timer read value high 20bits
                    TIMER_UNIT0_VALUE_HI:  u20, 
                    
                    /// [20:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000a040));
                
                /// system timer unit0 value low register
                pub const UNIT0_VALUE_LO = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] timer read value low 32bits
                    TIMER_UNIT0_VALUE_LO:  u32, 
                    
                }), @ptrFromInt(0x6000a044));
                
                /// system timer unit1 value high register
                pub const UNIT1_VALUE_HI = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:19] timer read value high 20bits
                    TIMER_UNIT1_VALUE_HI:  u20, 
                    
                    /// [20:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000a048));
                
                /// system timer unit1 value low register
                pub const UNIT1_VALUE_LO = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] timer read value low 32bits
                    TIMER_UNIT1_VALUE_LO:  u32, 
                    
                }), @ptrFromInt(0x6000a04c));
                
                /// system timer comp0 conf sync register
                pub const COMP0_LOAD = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] timer comp0 sync enable signal
                    TIMER_COMP0_LOAD:  u1, 
                    
                    /// [1:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000a050));
                
                /// system timer comp1 conf sync register
                pub const COMP1_LOAD = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] timer comp1 sync enable signal
                    TIMER_COMP1_LOAD:  u1, 
                    
                    /// [1:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000a054));
                
                /// system timer comp2 conf sync register
                pub const COMP2_LOAD = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] timer comp2 sync enable signal
                    TIMER_COMP2_LOAD:  u1, 
                    
                    /// [1:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000a058));
                
                /// system timer unit0 conf sync register
                pub const UNIT0_LOAD = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] timer unit0 sync enable signal
                    TIMER_UNIT0_LOAD:  u1, 
                    
                    /// [1:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000a05c));
                
                /// system timer unit1 conf sync register
                pub const UNIT1_LOAD = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] timer unit1 sync enable signal
                    TIMER_UNIT1_LOAD:  u1, 
                    
                    /// [1:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000a060));
                
                /// systimer interrupt enable register
                pub const INT_ENA = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] interupt0 enable
                    TARGET0_INT_ENA:  u1, 
                    
                    /// [1:1] interupt1 enable
                    TARGET1_INT_ENA:  u1, 
                    
                    /// [2:2] interupt2 enable
                    TARGET2_INT_ENA:  u1, 
                    
                    /// [3:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000a064));
                
                /// systimer interrupt raw register
                pub const INT_RAW = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] interupt0 raw
                    TARGET0_INT_RAW:  u1, 
                    
                    /// [1:1] interupt1 raw
                    TARGET1_INT_RAW:  u1, 
                    
                    /// [2:2] interupt2 raw
                    TARGET2_INT_RAW:  u1, 
                    
                    /// [3:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000a068));
                
                /// systimer interrupt clear register
                pub const INT_CLR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] interupt0 clear
                    TARGET0_INT_CLR:  u1, 
                    
                    /// [1:1] interupt1 clear
                    TARGET1_INT_CLR:  u1, 
                    
                    /// [2:2] interupt2 clear
                    TARGET2_INT_CLR:  u1, 
                    
                    /// [3:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000a06c));
                
                /// systimer interrupt status register
                pub const INT_ST = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] interupt0 status
                    TARGET0_INT_ST:  u1, 
                    
                    /// [1:1] interupt1 status
                    TARGET1_INT_ST:  u1, 
                    
                    /// [2:2] interupt2 status
                    TARGET2_INT_ST:  u1, 
                    
                    /// [3:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000a070));
                
                /// system timer comp0 actual target value low register
                pub const REAL_TARGET0_LO = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] actual target value value low 32bits
                    TARGET0_LO_RO:  u32, 
                    
                }), @ptrFromInt(0x6000a074));
                
                /// system timer comp0 actual target value high register
                pub const REAL_TARGET0_HI = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:19] actual target value value high 20bits
                    TARGET0_HI_RO:  u20, 
                    
                    /// [20:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000a078));
                
                /// system timer comp1 actual target value low register
                pub const REAL_TARGET1_LO = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] actual target value value low 32bits
                    TARGET1_LO_RO:  u32, 
                    
                }), @ptrFromInt(0x6000a07c));
                
                /// system timer comp1 actual target value high register
                pub const REAL_TARGET1_HI = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:19] actual target value value high 20bits
                    TARGET1_HI_RO:  u20, 
                    
                    /// [20:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000a080));
                
                /// system timer comp2 actual target value low register
                pub const REAL_TARGET2_LO = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] actual target value value low 32bits
                    TARGET2_LO_RO:  u32, 
                    
                }), @ptrFromInt(0x6000a084));
                
                /// system timer comp2 actual target value high register
                pub const REAL_TARGET2_HI = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:19] actual target value value high 20bits
                    TARGET2_HI_RO:  u20, 
                    
                    /// [20:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000a088));
                
                /// system timer version control register
                pub const DATE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] systimer register version
                    DATE:  u32, 
                    
                }), @ptrFromInt(0x6000a0fc));
                
            };
            
            /// TEE Peripheral
            pub const TEE = struct {
                
                /// Tee mode control register
                pub const M0_MODE_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:1] M0 security level mode: 2'd3: ree_mode2. 2'd2: ree_mode1. 2'd1: ree_mode0. 2'd0: tee_mode
                    M0_MODE:  u2, 
                    
                    /// [2:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60098000));
                
                /// Tee mode control register
                pub const M1_MODE_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:1] M1 security level mode: 2'd3: ree_mode2. 2'd2: ree_mode1. 2'd1: ree_mode0. 2'd0: tee_mode
                    M1_MODE:  u2, 
                    
                    /// [2:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60098004));
                
                /// Tee mode control register
                pub const M2_MODE_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:1] M2 security level mode: 2'd3: ree_mode2. 2'd2: ree_mode1. 2'd1: ree_mode0. 2'd0: tee_mode
                    M2_MODE:  u2, 
                    
                    /// [2:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60098008));
                
                /// Tee mode control register
                pub const M3_MODE_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:1] M3 security level mode: 2'd3: ree_mode2. 2'd2: ree_mode1. 2'd1: ree_mode0. 2'd0: tee_mode
                    M3_MODE:  u2, 
                    
                    /// [2:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6009800c));
                
                /// Tee mode control register
                pub const M4_MODE_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:1] M4 security level mode: 2'd3: ree_mode2. 2'd2: ree_mode1. 2'd1: ree_mode0. 2'd0: tee_mode
                    M4_MODE:  u2, 
                    
                    /// [2:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60098010));
                
                /// Tee mode control register
                pub const M5_MODE_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:1] M5 security level mode: 2'd3: ree_mode2. 2'd2: ree_mode1. 2'd1: ree_mode0. 2'd0: tee_mode
                    M5_MODE:  u2, 
                    
                    /// [2:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60098014));
                
                /// Tee mode control register
                pub const M6_MODE_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:1] M6 security level mode: 2'd3: ree_mode2. 2'd2: ree_mode1. 2'd1: ree_mode0. 2'd0: tee_mode
                    M6_MODE:  u2, 
                    
                    /// [2:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60098018));
                
                /// Tee mode control register
                pub const M7_MODE_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:1] M7 security level mode: 2'd3: ree_mode2. 2'd2: ree_mode1. 2'd1: ree_mode0. 2'd0: tee_mode
                    M7_MODE:  u2, 
                    
                    /// [2:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6009801c));
                
                /// Tee mode control register
                pub const M8_MODE_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:1] M8 security level mode: 2'd3: ree_mode2. 2'd2: ree_mode1. 2'd1: ree_mode0. 2'd0: tee_mode
                    M8_MODE:  u2, 
                    
                    /// [2:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60098020));
                
                /// Tee mode control register
                pub const M9_MODE_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:1] M9 security level mode: 2'd3: ree_mode2. 2'd2: ree_mode1. 2'd1: ree_mode0. 2'd0: tee_mode
                    M9_MODE:  u2, 
                    
                    /// [2:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60098024));
                
                /// Tee mode control register
                pub const M10_MODE_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:1] M10 security level mode: 2'd3: ree_mode2. 2'd2: ree_mode1. 2'd1: ree_mode0. 2'd0: tee_mode
                    M10_MODE:  u2, 
                    
                    /// [2:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60098028));
                
                /// Tee mode control register
                pub const M11_MODE_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:1] M11 security level mode: 2'd3: ree_mode2. 2'd2: ree_mode1. 2'd1: ree_mode0. 2'd0: tee_mode
                    M11_MODE:  u2, 
                    
                    /// [2:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6009802c));
                
                /// Tee mode control register
                pub const M12_MODE_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:1] M12 security level mode: 2'd3: ree_mode2. 2'd2: ree_mode1. 2'd1: ree_mode0. 2'd0: tee_mode
                    M12_MODE:  u2, 
                    
                    /// [2:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60098030));
                
                /// Tee mode control register
                pub const M13_MODE_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:1] M13 security level mode: 2'd3: ree_mode2. 2'd2: ree_mode1. 2'd1: ree_mode0. 2'd0: tee_mode
                    M13_MODE:  u2, 
                    
                    /// [2:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60098034));
                
                /// Tee mode control register
                pub const M14_MODE_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:1] M14 security level mode: 2'd3: ree_mode2. 2'd2: ree_mode1. 2'd1: ree_mode0. 2'd0: tee_mode
                    M14_MODE:  u2, 
                    
                    /// [2:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60098038));
                
                /// Tee mode control register
                pub const M15_MODE_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:1] M15 security level mode: 2'd3: ree_mode2. 2'd2: ree_mode1. 2'd1: ree_mode0. 2'd0: tee_mode
                    M15_MODE:  u2, 
                    
                    /// [2:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6009803c));
                
                /// Tee mode control register
                pub const M16_MODE_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:1] M16 security level mode: 2'd3: ree_mode2. 2'd2: ree_mode1. 2'd1: ree_mode0. 2'd0: tee_mode
                    M16_MODE:  u2, 
                    
                    /// [2:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60098040));
                
                /// Tee mode control register
                pub const M17_MODE_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:1] M17 security level mode: 2'd3: ree_mode2. 2'd2: ree_mode1. 2'd1: ree_mode0. 2'd0: tee_mode
                    M17_MODE:  u2, 
                    
                    /// [2:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60098044));
                
                /// Tee mode control register
                pub const M18_MODE_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:1] M18 security level mode: 2'd3: ree_mode2. 2'd2: ree_mode1. 2'd1: ree_mode0. 2'd0: tee_mode
                    M18_MODE:  u2, 
                    
                    /// [2:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60098048));
                
                /// Tee mode control register
                pub const M19_MODE_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:1] M19 security level mode: 2'd3: ree_mode2. 2'd2: ree_mode1. 2'd1: ree_mode0. 2'd0: tee_mode
                    M19_MODE:  u2, 
                    
                    /// [2:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6009804c));
                
                /// Tee mode control register
                pub const M20_MODE_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:1] M20 security level mode: 2'd3: ree_mode2. 2'd2: ree_mode1. 2'd1: ree_mode0. 2'd0: tee_mode
                    M20_MODE:  u2, 
                    
                    /// [2:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60098050));
                
                /// Tee mode control register
                pub const M21_MODE_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:1] M21 security level mode: 2'd3: ree_mode2. 2'd2: ree_mode1. 2'd1: ree_mode0. 2'd0: tee_mode
                    M21_MODE:  u2, 
                    
                    /// [2:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60098054));
                
                /// Tee mode control register
                pub const M22_MODE_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:1] M22 security level mode: 2'd3: ree_mode2. 2'd2: ree_mode1. 2'd1: ree_mode0. 2'd0: tee_mode
                    M22_MODE:  u2, 
                    
                    /// [2:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60098058));
                
                /// Tee mode control register
                pub const M23_MODE_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:1] M23 security level mode: 2'd3: ree_mode2. 2'd2: ree_mode1. 2'd1: ree_mode0. 2'd0: tee_mode
                    M23_MODE:  u2, 
                    
                    /// [2:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6009805c));
                
                /// Tee mode control register
                pub const M24_MODE_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:1] M24 security level mode: 2'd3: ree_mode2. 2'd2: ree_mode1. 2'd1: ree_mode0. 2'd0: tee_mode
                    M24_MODE:  u2, 
                    
                    /// [2:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60098060));
                
                /// Tee mode control register
                pub const M25_MODE_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:1] M25 security level mode: 2'd3: ree_mode2. 2'd2: ree_mode1. 2'd1: ree_mode0. 2'd0: tee_mode
                    M25_MODE:  u2, 
                    
                    /// [2:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60098064));
                
                /// Tee mode control register
                pub const M26_MODE_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:1] M26 security level mode: 2'd3: ree_mode2. 2'd2: ree_mode1. 2'd1: ree_mode0. 2'd0: tee_mode
                    M26_MODE:  u2, 
                    
                    /// [2:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60098068));
                
                /// Tee mode control register
                pub const M27_MODE_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:1] M27 security level mode: 2'd3: ree_mode2. 2'd2: ree_mode1. 2'd1: ree_mode0. 2'd0: tee_mode
                    M27_MODE:  u2, 
                    
                    /// [2:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6009806c));
                
                /// Tee mode control register
                pub const M28_MODE_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:1] M28 security level mode: 2'd3: ree_mode2. 2'd2: ree_mode1. 2'd1: ree_mode0. 2'd0: tee_mode
                    M28_MODE:  u2, 
                    
                    /// [2:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60098070));
                
                /// Tee mode control register
                pub const M29_MODE_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:1] M29 security level mode: 2'd3: ree_mode2. 2'd2: ree_mode1. 2'd1: ree_mode0. 2'd0: tee_mode
                    M29_MODE:  u2, 
                    
                    /// [2:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60098074));
                
                /// Tee mode control register
                pub const M30_MODE_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:1] M30 security level mode: 2'd3: ree_mode2. 2'd2: ree_mode1. 2'd1: ree_mode0. 2'd0: tee_mode
                    M30_MODE:  u2, 
                    
                    /// [2:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60098078));
                
                /// Tee mode control register
                pub const M31_MODE_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:1] M31 security level mode: 2'd3: ree_mode2. 2'd2: ree_mode1. 2'd1: ree_mode0. 2'd0: tee_mode
                    M31_MODE:  u2, 
                    
                    /// [2:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6009807c));
                
                /// Clock gating register
                pub const CLOCK_GATE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] reg_clk_en
                    CLK_EN:  u1, 
                    
                    /// [1:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60098080));
                
                /// Version register
                pub const DATE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:27] reg_tee_date
                    DATE:  u28, 
                    
                    /// [28:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60098ffc));
                
            };
            
            /// Timer Group 0
            pub const TIMG0 = struct {
                
                /// Timer %s configuration register
                pub const T0CONFIG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:8] 
                    res0:  u0, 
                    
                    /// [9:9] 1: Use XTAL_CLK as the source clock of timer group. 0: Use APB_CLK as the source clock of timer group.
                    USE_XTAL:  u1, 
                    
                    /// [10:10] When set, the alarm is enabled. This bit is automatically cleared once analarm occurs.
                    ALARM_EN:  u1, 
                    
                    /// [11:11] 
                    res1:  u0, 
                    
                    /// [12:12] When set, Timer %s 's clock divider counter will be reset.
                    DIVCNT_RST:  u1, 
                    
                    /// [13:28] Timer %s clock (T%s_clk) prescaler value.
                    DIVIDER:  u16, 
                    
                    /// [29:29] When set, timer %s auto-reload at alarm is enabled.
                    AUTORELOAD:  u1, 
                    
                    /// [30:30] When set, the timer %s time-base counter will increment every clock tick. Whencleared, the timer %s time-base counter will decrement.
                    INCREASE:  u1, 
                    
                    /// [31:31] When set, the timer %s time-base counter is enabled.
                    EN:  u1, 
                    
                }), @ptrFromInt(0x60008000));
                
                /// Timer %s current value, low 32 bits
                pub const T0LO = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] After writing to TIMG_T%sUPDATE_REG, the low 32 bits of the time-base counterof timer %s can be read here.
                    LO:  u32, 
                    
                }), @ptrFromInt(0x60008004));
                
                /// Timer %s current value, high 22 bits
                pub const T0HI = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:21] After writing to TIMG_T%sUPDATE_REG, the high 22 bits of the time-base counterof timer %s can be read here.
                    HI:  u22, 
                    
                    /// [22:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60008008));
                
                /// Write to copy current timer value to TIMGn_T%s_(LO/HI)_REG
                pub const T0UPDATE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:30] 
                    res0:  u0, 
                    
                    /// [31:31] After writing 0 or 1 to TIMG_T%sUPDATE_REG, the counter value is latched.
                    UPDATE:  u1, 
                    
                }), @ptrFromInt(0x6000800c));
                
                /// Timer %s alarm value, low 32 bits
                pub const T0ALARMLO = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Timer %s alarm trigger time-base counter value, low 32 bits.
                    ALARM_LO:  u32, 
                    
                }), @ptrFromInt(0x60008010));
                
                /// Timer %s alarm value, high bits
                pub const T0ALARMHI = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:21] Timer %s alarm trigger time-base counter value, high 22 bits.
                    ALARM_HI:  u22, 
                    
                    /// [22:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60008014));
                
                /// Timer %s reload value, low 32 bits
                pub const T0LOADLO = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Low 32 bits of the value that a reload will load onto timer %s time-baseCounter.
                    LOAD_LO:  u32, 
                    
                }), @ptrFromInt(0x60008018));
                
                /// Timer %s reload value, high 22 bits
                pub const T0LOADHI = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:21] High 22 bits of the value that a reload will load onto timer %s time-basecounter.
                    LOAD_HI:  u22, 
                    
                    /// [22:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000801c));
                
                /// Write to reload timer from TIMG_T%s_(LOADLOLOADHI)_REG
                pub const T0LOAD = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Write any value to trigger a timer %s time-base counter reload.
                    LOAD:  u32, 
                    
                }), @ptrFromInt(0x60008020));
                
                /// Watchdog timer configuration register
                pub const WDTCONFIG0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:11] 
                    res0:  u0, 
                    
                    /// [12:12] WDT reset CPU enable.
                    WDT_APPCPU_RESET_EN:  u1, 
                    
                    /// [13:13] WDT reset CPU enable.
                    WDT_PROCPU_RESET_EN:  u1, 
                    
                    /// [14:14] When set, Flash boot protection is enabled.
                    WDT_FLASHBOOT_MOD_EN:  u1, 
                    
                    /// [15:17] System reset signal length selection. 0: 100 ns, 1: 200 ns,2: 300 ns, 3: 400 ns, 4: 500 ns, 5: 800 ns, 6: 1.6 us, 7: 3.2 us.
                    WDT_SYS_RESET_LENGTH:  u3, 
                    
                    /// [18:20] CPU reset signal length selection. 0: 100 ns, 1: 200 ns,2: 300 ns, 3: 400 ns, 4: 500 ns, 5: 800 ns, 6: 1.6 us, 7: 3.2 us.
                    WDT_CPU_RESET_LENGTH:  u3, 
                    
                    /// [21:21] choose WDT clock:0-apb_clk, 1-xtal_clk.
                    WDT_USE_XTAL:  u1, 
                    
                    /// [22:22] update the WDT configuration registers
                    WDT_CONF_UPDATE_EN:  u1, 
                    
                    /// [23:24] Stage 3 configuration. 0: off, 1: interrupt, 2: reset CPU, 3: reset system.
                    WDT_STG3:  u2, 
                    
                    /// [25:26] Stage 2 configuration. 0: off, 1: interrupt, 2: reset CPU, 3: reset system.
                    WDT_STG2:  u2, 
                    
                    /// [27:28] Stage 1 configuration. 0: off, 1: interrupt, 2: reset CPU, 3: reset system.
                    WDT_STG1:  u2, 
                    
                    /// [29:30] Stage 0 configuration. 0: off, 1: interrupt, 2: reset CPU, 3: reset system.
                    WDT_STG0:  u2, 
                    
                    /// [31:31] When set, MWDT is enabled.
                    WDT_EN:  u1, 
                    
                }), @ptrFromInt(0x60008048));
                
                /// Watchdog timer prescaler register
                pub const WDTCONFIG1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] When set, WDT 's clock divider counter will be reset.
                    WDT_DIVCNT_RST:  u1, 
                    
                    /// [1:15] 
                    res0:  u0, 
                    
                    /// [16:31] MWDT clock prescaler value. MWDT clock period = 12.5 ns *TIMG_WDT_CLK_PRESCALE.
                    WDT_CLK_PRESCALE:  u16, 
                    
                }), @ptrFromInt(0x6000804c));
                
                /// Watchdog timer stage 0 timeout value
                pub const WDTCONFIG2 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Stage 0 timeout value, in MWDT clock cycles.
                    WDT_STG0_HOLD:  u32, 
                    
                }), @ptrFromInt(0x60008050));
                
                /// Watchdog timer stage 1 timeout value
                pub const WDTCONFIG3 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Stage 1 timeout value, in MWDT clock cycles.
                    WDT_STG1_HOLD:  u32, 
                    
                }), @ptrFromInt(0x60008054));
                
                /// Watchdog timer stage 2 timeout value
                pub const WDTCONFIG4 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Stage 2 timeout value, in MWDT clock cycles.
                    WDT_STG2_HOLD:  u32, 
                    
                }), @ptrFromInt(0x60008058));
                
                /// Watchdog timer stage 3 timeout value
                pub const WDTCONFIG5 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Stage 3 timeout value, in MWDT clock cycles.
                    WDT_STG3_HOLD:  u32, 
                    
                }), @ptrFromInt(0x6000805c));
                
                /// Write to feed the watchdog timer
                pub const WDTFEED = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Write any value to feed the MWDT. (WO)
                    WDT_FEED:  u32, 
                    
                }), @ptrFromInt(0x60008060));
                
                /// Watchdog write protect register
                pub const WDTWPROTECT = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] If the register contains a different value than its reset value, writeprotection is enabled.
                    WDT_WKEY:  u32, 
                    
                }), @ptrFromInt(0x60008064));
                
                /// RTC calibration configure register
                pub const RTCCALICFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:11] 
                    res0:  u0, 
                    
                    /// [12:12] 0: one-shot frequency calculation,1: periodic frequency calculation,
                    RTC_CALI_START_CYCLING:  u1, 
                    
                    /// [13:14] 0:rtc slow clock. 1:clk_8m, 2:xtal_32k.
                    RTC_CALI_CLK_SEL:  u2, 
                    
                    /// [15:15] indicate one-shot frequency calculation is done.
                    RTC_CALI_RDY:  u1, 
                    
                    /// [16:30] Configure the time to calculate RTC slow clock's frequency.
                    RTC_CALI_MAX:  u15, 
                    
                    /// [31:31] Set this bit to start one-shot frequency calculation.
                    RTC_CALI_START:  u1, 
                    
                }), @ptrFromInt(0x60008068));
                
                /// RTC calibration configure1 register
                pub const RTCCALICFG1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] indicate periodic frequency calculation is done.
                    RTC_CALI_CYCLING_DATA_VLD:  u1, 
                    
                    /// [1:6] 
                    res0:  u0, 
                    
                    /// [7:31] When one-shot or periodic frequency calculation is done, read this value to calculate RTC slow clock's frequency.
                    RTC_CALI_VALUE:  u25, 
                    
                }), @ptrFromInt(0x6000806c));
                
                /// Interrupt enable bits
                pub const INT_ENA_TIMERS = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] The interrupt enable bit for the TIMG_T0_INT interrupt.
                    T0_INT_ENA:  u1, 
                    
                    /// [1:1] The interrupt enable bit for the TIMG_WDT_INT interrupt.
                    WDT_INT_ENA:  u1, 
                    
                    /// [2:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60008070));
                
                /// Raw interrupt status
                pub const INT_RAW_TIMERS = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] The raw interrupt status bit for the TIMG_T0_INT interrupt.
                    T0_INT_RAW:  u1, 
                    
                    /// [1:1] The raw interrupt status bit for the TIMG_WDT_INT interrupt.
                    WDT_INT_RAW:  u1, 
                    
                    /// [2:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60008074));
                
                /// Masked interrupt status
                pub const INT_ST_TIMERS = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] The masked interrupt status bit for the TIMG_T0_INT interrupt.
                    T0_INT_ST:  u1, 
                    
                    /// [1:1] The masked interrupt status bit for the TIMG_WDT_INT interrupt.
                    WDT_INT_ST:  u1, 
                    
                    /// [2:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60008078));
                
                /// Interrupt clear bits
                pub const INT_CLR_TIMERS = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Set this bit to clear the TIMG_T0_INT interrupt.
                    T0_INT_CLR:  u1, 
                    
                    /// [1:1] Set this bit to clear the TIMG_WDT_INT interrupt.
                    WDT_INT_CLR:  u1, 
                    
                    /// [2:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000807c));
                
                /// Timer group calibration register
                pub const RTCCALICFG2 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] RTC calibration timeout indicator
                    RTC_CALI_TIMEOUT:  u1, 
                    
                    /// [1:2] 
                    res0:  u0, 
                    
                    /// [3:6] Cycles that release calibration timeout reset
                    RTC_CALI_TIMEOUT_RST_CNT:  u4, 
                    
                    /// [7:31] Threshold value for the RTC calibration timer. If the calibration timer's value exceeds this threshold, a timeout is triggered.
                    RTC_CALI_TIMEOUT_THRES:  u25, 
                    
                }), @ptrFromInt(0x60008080));
                
                /// Timer version control register
                pub const NTIMERS_DATE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:27] Timer version control register
                    NTIMGS_DATE:  u28, 
                    
                    /// [28:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600080f8));
                
                /// Timer group clock gate register
                pub const REGCLK = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:27] 
                    res0:  u0, 
                    
                    /// [28:28] enable timer's etm task and event
                    ETM_EN:  u1, 
                    
                    /// [29:29] enable WDT's clock
                    WDT_CLK_IS_ACTIVE:  u1, 
                    
                    /// [30:30] enable Timer 30's clock
                    TIMER_CLK_IS_ACTIVE:  u1, 
                    
                    /// [31:31] Register clock gate signal. 1: Registers can be read and written to by software. 0: Registers can not be read or written to by software.
                    CLK_EN:  u1, 
                    
                }), @ptrFromInt(0x600080fc));
                
            };
            
            /// Timer Group 1
            pub const TIMG1 = struct {
                
            };
            
            /// TRACE Peripheral
            pub const TRACE = struct {
                
                /// mem start addr
                pub const MEM_START_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] The start address of trace memory
                    MEM_STAET_ADDR:  u32, 
                    
                }), @ptrFromInt(0x600c0000));
                
                /// mem end addr
                pub const MEM_END_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] The end address of trace memory
                    MEM_END_ADDR:  u32, 
                    
                }), @ptrFromInt(0x600c0004));
                
                /// mem current addr
                pub const MEM_CURRENT_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] current_mem_addr,indicate that next writing addr
                    MEM_CURRENT_ADDR:  u32, 
                    
                }), @ptrFromInt(0x600c0008));
                
                /// mem addr update
                pub const MEM_ADDR_UPDATE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] when set this reg, the current_mem_addr will update to start_addr
                    MEM_CURRENT_ADDR_UPDATE:  u1, 
                    
                    /// [1:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600c000c));
                
                /// fifo status register
                pub const FIFO_STATUS = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] 1 indicate that fifo is empty
                    FIFO_EMPTY:  u1, 
                    
                    /// [1:1] mem_full interrupt status
                    WORK_STATUS:  u1, 
                    
                    /// [2:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600c0010));
                
                /// interrupt enable register
                pub const INTR_ENA = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Set 1 enable fifo_overflow interrupt
                    FIFO_OVERFLOW_INTR_ENA:  u1, 
                    
                    /// [1:1] Set 1 enable mem_full interrupt
                    MEM_FULL_INTR_ENA:  u1, 
                    
                    /// [2:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600c0014));
                
                /// interrupt status register
                pub const INTR_RAW = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] fifo_overflow interrupt status
                    FIFO_OVERFLOW_INTR_RAW:  u1, 
                    
                    /// [1:1] mem_full interrupt status
                    MEM_FULL_INTR_RAW:  u1, 
                    
                    /// [2:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600c0018));
                
                /// interrupt clear register
                pub const INTR_CLR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Set 1 clr fifo overflow interrupt
                    FIFO_OVERFLOW_INTR_CLR:  u1, 
                    
                    /// [1:1] Set 1 clr mem full interrupt
                    MEM_FULL_INTR_CLR:  u1, 
                    
                    /// [2:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600c001c));
                
                /// trigger register
                pub const TRIGGER = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] [0] set 1 start trace.
                    ON:  u1, 
                    
                    /// [1:1] set 1 stop trace.
                    OFF:  u1, 
                    
                    /// [2:2] if this reg is 1, trace will loop wrtie trace_mem.If is 0, when mem_current_addr at mem_end_addr, it will stop at the mem_end_addr
                    MEM_LOOP:  u1, 
                    
                    /// [3:3] enable encoder auto-restart, when lost package, the encoder will end, if enable auto-restart, when fifo empty, encoder will restart and send a sync package.
                    RESTART_ENA:  u1, 
                    
                    /// [4:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600c0020));
                
                /// resync configuration register
                pub const RESYNC_PROLONGED = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:23] count number, when count to this value, send a sync package
                    RESYNC_PROLONGED:  u24, 
                    
                    /// [24:24] resyc mode sel: 0: default, cycle count 1: package num count
                    RESYNC_MODE:  u1, 
                    
                    /// [25:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600c0024));
                
                /// Clock gate control register
                pub const CLOCK_GATE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] The bit is used to enable clock gate when access all registers in this module.
                    CLK_EN:  u1, 
                    
                    /// [1:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600c0028));
                
                /// Version control register
                pub const DATE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:27] version control register. Note that this default value stored is the latest date when the hardware logic was updated.
                    DATE:  u28, 
                    
                    /// [28:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x600c03fc));
                
            };
            
            /// Two-Wire Automotive Interface
            pub const TWAI0 = struct {
                
                /// TWAI mode register.
                pub const MODE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] 1: reset, detection of a set reset mode bit results in aborting the current transmission/reception of a message and entering the reset mode. 0: normal, on the '1-to-0' transition of the reset mode bit, the TWAI controller returns to the operating mode.
                    RESET_MODE:  u1, 
                    
                    /// [1:1] 1: listen only, in this mode the TWAI controller would give no acknowledge to the TWAI-bus, even if a message is received successfully. The error counters are stopped at the current value. 0: normal.
                    LISTEN_ONLY_MODE:  u1, 
                    
                    /// [2:2] 1: self test, in this mode a full node test is possible without any other active node on the bus using the self reception request command. The TWAI controller will perform a successful transmission, even if there is no acknowledge received. 0: normal, an acknowledge is required for successful transmission.
                    SELF_TEST_MODE:  u1, 
                    
                    /// [3:3] 1:single, the single acceptance filter option is enabled (one filter with the length of 32 bit is active). 0:dual, the dual acceptance filter option is enabled (two filters, each with the length of 16 bit are active).
                    RX_FILTER_MODE:  u1, 
                    
                    /// [4:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000b000));
                
                /// TWAI command register.
                pub const CMD = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] 1: present, a message shall be transmitted. 0: absent
                    TX_REQ:  u1, 
                    
                    /// [1:1] 1: present, if not already in progress, a pending transmission request is cancelled. 0: absent
                    ABORT_TX:  u1, 
                    
                    /// [2:2] 1: released, the receive buffer, representing the message memory space in the RXFIFO is released. 0: no action
                    RELEASE_BUF:  u1, 
                    
                    /// [3:3] 1: clear, the data overrun status bit is cleared. 0: no action.
                    CLEAR_DATA_OVERRUN:  u1, 
                    
                    /// [4:4] 1: present, a message shall be transmitted and received simultaneously. 0: absent.
                    SELF_RX_REQUEST:  u1, 
                    
                    /// [5:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000b004));
                
                /// TWAI status register.
                pub const STATUS = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] 1: full, one or more complete messages are available in the RXFIFO. 0: empty, no message is available
                    RX_BUF_ST:  u1, 
                    
                    /// [1:1] 1: overrun, a message was lost because there was not enough space for that message in the RXFIFO. 0: absent, no data overrun has occurred since the last clear data overrun command was given
                    OVERRUN:  u1, 
                    
                    /// [2:2] 1: released, the CPU may write a message into the transmit buffer. 0: locked, the CPU cannot access the transmit buffer, a message is either waiting for transmission or is in the process of being transmitted
                    TX_BUF_ST:  u1, 
                    
                    /// [3:3] 1: complete, last requested transmission has been successfully completed. 0: incomplete, previously requested transmission is not yet completed
                    TRANSMISSION_COMPLETE:  u1, 
                    
                    /// [4:4] 1: receive, the TWAI controller is receiving a message. 0: idle
                    RECEIVE:  u1, 
                    
                    /// [5:5] 1: transmit, the TWAI controller is transmitting a message. 0: idle
                    TRANSMIT:  u1, 
                    
                    /// [6:6] 1: error, at least one of the error counters has reached or exceeded the CPU warning limit defined by the Error Warning Limit Register (EWLR). 0: ok, both error counters are below the warning limit
                    ERR:  u1, 
                    
                    /// [7:7] 1: bus-off, the TWAI controller is not involved in bus activities. 0: bus-on, the TWAI controller is involved in bus activities
                    BUS_OFF_ST:  u1, 
                    
                    /// [8:8] 1: current message is destroyed because of FIFO overflow.
                    MISS_ST:  u1, 
                    
                    /// [9:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000b008));
                
                /// Interrupt signals' register.
                pub const INTERRUPT = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] 1: this bit is set while the receive FIFO is not empty and the RIE bit is set within the interrupt enable register. 0: reset
                    RECEIVE_INT_ST:  u1, 
                    
                    /// [1:1] 1: this bit is set whenever the transmit buffer status changes from '0-to-1' (released) and the TIE bit is set within the interrupt enable register. 0: reset
                    TRANSMIT_INT_ST:  u1, 
                    
                    /// [2:2] 1: this bit is set on every change (set and clear) of either the error status or bus status bits and the EIE bit is set within the interrupt enable register. 0: reset
                    ERR_WARNING_INT_ST:  u1, 
                    
                    /// [3:3] 1: this bit is set on a '0-to-1' transition of the data overrun status bit and the DOIE bit is set within the interrupt enable register. 0: reset
                    DATA_OVERRUN_INT_ST:  u1, 
                    
                    /// [4:4] 
                    res0:  u0, 
                    
                    /// [5:5] 1: this bit is set whenever the TWAI controller has reached the error passive status (at least one error counter exceeds the protocol-defined level of 127) or if the TWAI controller is in the error passive status and enters the error active status again and the EPIE bit is set within the interrupt enable register. 0: reset
                    ERR_PASSIVE_INT_ST:  u1, 
                    
                    /// [6:6] 1: this bit is set when the TWAI controller lost the arbitration and becomes a receiver and the ALIE bit is set within the interrupt enable register. 0: reset
                    ARBITRATION_LOST_INT_ST:  u1, 
                    
                    /// [7:7] 1: this bit is set when the TWAI controller detects an error on the TWAI-bus and the BEIE bit is set within the interrupt enable register. 0: reset
                    BUS_ERR_INT_ST:  u1, 
                    
                    /// [8:8] 1: this bit is set when the TWAI controller detects state of TWAI become IDLE and this interrupt enable bit is set within the interrupt enable register. 0: reset
                    IDLE_INT_ST:  u1, 
                    
                    /// [9:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x6000b00c));
                
                /// Interrupt enable register.
                pub const INTERRUPT_ENABLE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] 1: enabled, when the receive buffer status is 'full' the TWAI controller requests the respective interrupt. 0: disable
                    EXT_RECEIVE_INT_ENA:  u1, 
                    
                    /// [1:1] 1: enabled, when a message has been successfully transmitted or the transmit buffer is accessible again (e.g. after an abort transmission command), the TWAI controller requests the respective interrupt. 0: disable
                    EXT_TRANSMIT_INT_ENA:  u1, 
                    
                    /// [2:2] 1: enabled, if the error or bus status change (see status register. Table 14), the TWAI controllerrequests the respective interrupt. 0: disable
                    EXT_ERR_WARNING_INT_ENA:  u1, 
                    
                    /// [3:3] 1: enabled, if the data overrun status bit is set (see status register. Table 14), the TWAI controllerrequests the respective interrupt. 0: disable
                    EXT_DATA_OVERRUN_INT_ENA:  u1, 
                    
                    /// [4:4] 
                    res0:  u0, 
                    
                    /// [5:5] 1: enabled, if the error status of the TWAI controller changes from error active to error passive or vice versa, the respective interrupt is requested. 0: disable
                    ERR_PASSIVE_INT_ENA:  u1, 
                    
                    /// [6:6] 1: enabled, if the TWAI controller has lost arbitration, the respective interrupt is requested. 0: disable
                    ARBITRATION_LOST_INT_ENA:  u1, 
                    
                    /// [7:7] 1: enabled, if an bus error has been detected, the TWAI controller requests the respective interrupt. 0: disable
                    BUS_ERR_INT_ENA:  u1, 
                    
                    /// [8:8] 1: enabled, if state of TWAI become IDLE, the TWAI controller requests the respective interrupt. 0: disable
                    IDLE_INT_ENA:  u1, 
                    
                    /// [9:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x6000b010));
                
                /// Bit timing configuration register 0.
                pub const BUS_TIMING_0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:13] The period of the TWAI system clock is programmable and determines the individual bit timing. Software has R/W permission in reset mode and RO permission in operation mode.
                    BAUD_PRESC:  u14, 
                    
                    /// [14:15] The synchronization jump width defines the maximum number of clock cycles a bit period may be shortened or lengthened. Software has R/W permission in reset mode and RO in operation mode.
                    SYNC_JUMP_WIDTH:  u2, 
                    
                    /// [16:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000b018));
                
                /// Bit timing configuration register 1.
                pub const BUS_TIMING_1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:3] The number of clock cycles in TSEG1 per bit timing. Software has R/W permission in reset mode and RO in operation mode.
                    TIME_SEG1:  u4, 
                    
                    /// [4:6] The number of clock cycles in TSEG2 per bit timing. Software has R/W permission in reset mode and RO in operation mode.
                    TIME_SEG2:  u3, 
                    
                    /// [7:7] 1: triple, the bus is sampled three times. 0: single, the bus is sampled once. Software has R/W permission in reset mode and RO in operation mode.
                    TIME_SAMP:  u1, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000b01c));
                
                /// TWAI arbiter lost capture register.
                pub const ARB_LOST_CAP = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:4] This register contains information about the bit position of losing arbitration.
                    ARBITRATION_LOST_CAPTURE:  u5, 
                    
                    /// [5:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000b02c));
                
                /// TWAI error info capture register.
                pub const ERR_CODE_CAP = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:4] This register contains information about the location of errors on the bus.
                    ERR_CAPTURE_CODE_SEGMENT:  u5, 
                    
                    /// [5:5] 1: RX, error occurred during reception. 0: TX, error occurred during transmission.
                    ERR_CAPTURE_CODE_DIRECTION:  u1, 
                    
                    /// [6:7] 00: bit error. 01: form error. 10:stuff error. 11:other type of error.
                    ERR_CAPTURE_CODE_TYPE:  u2, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000b030));
                
                /// TWAI error threshold configuration register.
                pub const ERR_WARNING_LIMIT = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] The threshold that trigger error warning interrupt when this interrupt is enabled. Software has R/W permission in reset mode and RO in operation mode.
                    ERR_WARNING_LIMIT:  u8, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000b034));
                
                /// Rx error counter register.
                pub const RX_ERR_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] The RX error counter register reflects the current value of the transmit error counter. Software has R/W permission in reset mode and RO in operation mode.
                    RX_ERR_CNT:  u8, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000b038));
                
                /// Tx error counter register.
                pub const TX_ERR_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] The TX error counter register reflects the current value of the transmit error counter. Software has R/W permission in reset mode and RO in operation mode.
                    TX_ERR_CNT:  u8, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000b03c));
                
                /// Data register 0.
                pub const DATA_0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] In reset mode, it is acceptance code register 0 with R/W Permission. In operation mode, when software initiate write operation, it is tx data register 0 and when software initiate read operation, it is rx data register 0.
                    TX_BYTE_0:  u8, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000b040));
                
                /// Data register 1.
                pub const DATA_1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] In reset mode, it is acceptance code register 1 with R/W Permission. In operation mode, when software initiate write operation, it is tx data register 1 and when software initiate read operation, it is rx data register 1.
                    TX_BYTE_1:  u8, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000b044));
                
                /// Data register 2.
                pub const DATA_2 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] In reset mode, it is acceptance code register 2 with R/W Permission. In operation mode, when software initiate write operation, it is tx data register 2 and when software initiate read operation, it is rx data register 2.
                    TX_BYTE_2:  u8, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000b048));
                
                /// Data register 3.
                pub const DATA_3 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] In reset mode, it is acceptance code register 3 with R/W Permission. In operation mode, when software initiate write operation, it is tx data register 3 and when software initiate read operation, it is rx data register 3.
                    TX_BYTE_3:  u8, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000b04c));
                
                /// Data register 4.
                pub const DATA_4 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] In reset mode, it is acceptance mask register 0 with R/W Permission. In operation mode, when software initiate write operation, it is tx data register 4 and when software initiate read operation, it is rx data register 4.
                    TX_BYTE_4:  u8, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000b050));
                
                /// Data register 5.
                pub const DATA_5 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] In reset mode, it is acceptance mask register 1 with R/W Permission. In operation mode, when software initiate write operation, it is tx data register 5 and when software initiate read operation, it is rx data register 5.
                    TX_BYTE_5:  u8, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000b054));
                
                /// Data register 6.
                pub const DATA_6 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] In reset mode, it is acceptance mask register 2 with R/W Permission. In operation mode, when software initiate write operation, it is tx data register 6 and when software initiate read operation, it is rx data register 6.
                    TX_BYTE_6:  u8, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000b058));
                
                /// Data register 7.
                pub const DATA_7 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] In reset mode, it is acceptance mask register 3 with R/W Permission. In operation mode, when software initiate write operation, it is tx data register 7 and when software initiate read operation, it is rx data register 7.
                    TX_BYTE_7:  u8, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000b05c));
                
                /// Data register 8.
                pub const DATA_8 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] In reset mode, reserved with RO. In operation mode, when software initiate write operation, it is tx data register 8 and when software initiate read operation, it is rx data register 8.
                    TX_BYTE_8:  u8, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000b060));
                
                /// Data register 9.
                pub const DATA_9 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] In reset mode, reserved with RO. In operation mode, when software initiate write operation, it is tx data register 9 and when software initiate read operation, it is rx data register 9.
                    DATA_9:  u8, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000b064));
                
                /// Data register 10.
                pub const DATA_10 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] In reset mode, reserved with RO. In operation mode, when software initiate write operation, it is tx data register 10 and when software initiate read operation, it is rx data register 10.
                    TX_BYTE_10:  u8, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000b068));
                
                /// Data register 11.
                pub const DATA_11 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] In reset mode, reserved with RO. In operation mode, when software initiate write operation, it is tx data register 11 and when software initiate read operation, it is rx data register 11.
                    TX_BYTE_11:  u8, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000b06c));
                
                /// Data register 12.
                pub const DATA_12 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] In reset mode, reserved with RO. In operation mode, when software initiate write operation, it is tx data register 12 and when software initiate read operation, it is rx data register 12.
                    TX_BYTE_12:  u8, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000b070));
                
                /// Received message counter register.
                pub const RX_MESSAGE_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:6] Reflects the number of messages available within the RXFIFO. The value is incremented with each receive event and decremented by the release receive buffer command.
                    RX_MESSAGE_COUNTER:  u7, 
                    
                    /// [7:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000b074));
                
                /// Clock divider register.
                pub const CLOCK_DIVIDER = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] These bits are used to define the frequency at the external CLKOUT pin.
                    CD:  u8, 
                    
                    /// [8:8] 1: Disable the external CLKOUT pin. 0: Enable the external CLKOUT pin. Software has R/W permission in reset mode and RO in operation mode.
                    CLOCK_OFF:  u1, 
                    
                    /// [9:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000b07c));
                
                /// Software configure standby pin directly.
                pub const SW_STANDBY_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Enable standby pin.
                    SW_STANDBY_EN:  u1, 
                    
                    /// [1:1] Clear standby pin.
                    SW_STANDBY_CLR:  u1, 
                    
                    /// [2:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000b080));
                
                /// Hardware configure standby pin.
                pub const HW_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Enable function that hardware control standby pin.
                    HW_STANDBY_EN:  u1, 
                    
                    /// [1:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000b084));
                
                /// Configure standby counter.
                pub const HW_STANDBY_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Configure the number of cycles before standby becomes high when TWAI_HW_STANDBY_EN is enabled.
                    STANDBY_WAIT_CNT:  u32, 
                    
                }), @ptrFromInt(0x6000b088));
                
                /// Configure idle interrupt counter.
                pub const IDLE_INTR_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Configure the number of cycles before triggering idle interrupt.
                    IDLE_INTR_CNT:  u32, 
                    
                }), @ptrFromInt(0x6000b08c));
                
                /// ECO configuration register.
                pub const ECO_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Enable eco module.
                    RDN_ENA:  u1, 
                    
                    /// [1:1] Output of eco module.
                    RDN_RESULT:  u1, 
                    
                    /// [2:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000b090));
                
            };
            
            /// Two-Wire Automotive Interface
            pub const TWAI1 = struct {
                
            };
            
            /// UART (Universal Asynchronous Receiver-Transmitter) Controller 0
            pub const UART0 = struct {
                
                /// FIFO data register
                pub const FIFO = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] UART 0 accesses FIFO via this register.
                    RXFIFO_RD_BYTE:  u8, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60000000));
                
                /// Raw interrupt status
                pub const INT_RAW = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] This interrupt raw bit turns to high level when receiver receives more data than what rxfifo_full_thrhd specifies.
                    RXFIFO_FULL_INT_RAW:  u1, 
                    
                    /// [1:1] This interrupt raw bit turns to high level when the amount of data in Tx-FIFO is less than what txfifo_empty_thrhd specifies .
                    TXFIFO_EMPTY_INT_RAW:  u1, 
                    
                    /// [2:2] This interrupt raw bit turns to high level when receiver detects a parity error in the data.
                    PARITY_ERR_INT_RAW:  u1, 
                    
                    /// [3:3] This interrupt raw bit turns to high level when receiver detects a data frame error .
                    FRM_ERR_INT_RAW:  u1, 
                    
                    /// [4:4] This interrupt raw bit turns to high level when receiver receives more data than the FIFO can store.
                    RXFIFO_OVF_INT_RAW:  u1, 
                    
                    /// [5:5] This interrupt raw bit turns to high level when receiver detects the edge change of DSRn signal.
                    DSR_CHG_INT_RAW:  u1, 
                    
                    /// [6:6] This interrupt raw bit turns to high level when receiver detects the edge change of CTSn signal.
                    CTS_CHG_INT_RAW:  u1, 
                    
                    /// [7:7] This interrupt raw bit turns to high level when receiver detects a 0 after the stop bit.
                    BRK_DET_INT_RAW:  u1, 
                    
                    /// [8:8] This interrupt raw bit turns to high level when receiver takes more time than rx_tout_thrhd to receive a byte.
                    RXFIFO_TOUT_INT_RAW:  u1, 
                    
                    /// [9:9] This interrupt raw bit turns to high level when receiver recevies Xon char when uart_sw_flow_con_en is set to 1.
                    SW_XON_INT_RAW:  u1, 
                    
                    /// [10:10] This interrupt raw bit turns to high level when receiver receives Xoff char when uart_sw_flow_con_en is set to 1.
                    SW_XOFF_INT_RAW:  u1, 
                    
                    /// [11:11] This interrupt raw bit turns to high level when receiver detects a glitch in the middle of a start bit.
                    GLITCH_DET_INT_RAW:  u1, 
                    
                    /// [12:12] This interrupt raw bit turns to high level when transmitter completessendingNULL characters after all data in Tx-FIFO are sent.
                    TX_BRK_DONE_INT_RAW:  u1, 
                    
                    /// [13:13] This interrupt raw bit turns to high level when transmitter has kept the shortest duration after sending thelast data.
                    TX_BRK_IDLE_DONE_INT_RAW:  u1, 
                    
                    /// [14:14] This interrupt raw bit turns to high level when transmitter has send out all data in FIFO.
                    TX_DONE_INT_RAW:  u1, 
                    
                    /// [15:15] This interrupt raw bit turns to high level when receiver detects a parity error from the echo of transmitter in rs485 mode.
                    RS485_PARITY_ERR_INT_RAW:  u1, 
                    
                    /// [16:16] This interrupt raw bit turns to high level when receiver detects a data frame error from the echo of transmitter in rs485 mode.
                    RS485_FRM_ERR_INT_RAW:  u1, 
                    
                    /// [17:17] This interrupt raw bit turns to high level when detects a clash between transmitter and receiver in rs485 mode.
                    RS485_CLASH_INT_RAW:  u1, 
                    
                    /// [18:18] This interrupt raw bit turns to high level when receiver detects the configured at_cmd char.
                    AT_CMD_CHAR_DET_INT_RAW:  u1, 
                    
                    /// [19:19] This interrupt raw bit turns to high level when input rxd edge changes more times than what reg_active_threshold specifies in light sleeping mode.
                    WAKEUP_INT_RAW:  u1, 
                    
                    /// [20:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60000004));
                
                /// Masked interrupt status
                pub const INT_ST = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] This is the status bit for rxfifo_full_int_raw when rxfifo_full_int_ena is set to 1.
                    RXFIFO_FULL_INT_ST:  u1, 
                    
                    /// [1:1] This is the status bit fortxfifo_empty_int_rawwhen txfifo_empty_int_ena is set to 1.
                    TXFIFO_EMPTY_INT_ST:  u1, 
                    
                    /// [2:2] This is the status bit for parity_err_int_raw when parity_err_int_ena is set to 1.
                    PARITY_ERR_INT_ST:  u1, 
                    
                    /// [3:3] This is the status bit for frm_err_int_raw when frm_err_int_ena is set to 1.
                    FRM_ERR_INT_ST:  u1, 
                    
                    /// [4:4] This is the status bit for rxfifo_ovf_int_raw when rxfifo_ovf_int_ena is set to 1.
                    RXFIFO_OVF_INT_ST:  u1, 
                    
                    /// [5:5] This is the status bit for dsr_chg_int_raw when dsr_chg_int_ena is set to 1.
                    DSR_CHG_INT_ST:  u1, 
                    
                    /// [6:6] This is the status bit for cts_chg_int_raw when cts_chg_int_ena is set to 1.
                    CTS_CHG_INT_ST:  u1, 
                    
                    /// [7:7] This is the status bit for brk_det_int_raw when brk_det_int_ena is set to 1.
                    BRK_DET_INT_ST:  u1, 
                    
                    /// [8:8] This is the status bit for rxfifo_tout_int_raw when rxfifo_tout_int_ena is set to 1.
                    RXFIFO_TOUT_INT_ST:  u1, 
                    
                    /// [9:9] This is the status bit for sw_xon_int_raw when sw_xon_int_ena is set to 1.
                    SW_XON_INT_ST:  u1, 
                    
                    /// [10:10] This is the status bit for sw_xoff_int_raw when sw_xoff_int_ena is set to 1.
                    SW_XOFF_INT_ST:  u1, 
                    
                    /// [11:11] This is the status bit for glitch_det_int_raw when glitch_det_int_ena is set to 1.
                    GLITCH_DET_INT_ST:  u1, 
                    
                    /// [12:12] This is the status bit for tx_brk_done_int_raw when tx_brk_done_int_ena is set to 1.
                    TX_BRK_DONE_INT_ST:  u1, 
                    
                    /// [13:13] This is the stauts bit for tx_brk_idle_done_int_raw when tx_brk_idle_done_int_ena is set to 1.
                    TX_BRK_IDLE_DONE_INT_ST:  u1, 
                    
                    /// [14:14] This is the status bit for tx_done_int_raw when tx_done_int_ena is set to 1.
                    TX_DONE_INT_ST:  u1, 
                    
                    /// [15:15] This is the status bit for rs485_parity_err_int_raw when rs485_parity_int_ena is set to 1.
                    RS485_PARITY_ERR_INT_ST:  u1, 
                    
                    /// [16:16] This is the status bit for rs485_frm_err_int_raw when rs485_fm_err_int_ena is set to 1.
                    RS485_FRM_ERR_INT_ST:  u1, 
                    
                    /// [17:17] This is the status bit for rs485_clash_int_raw when rs485_clash_int_ena is set to 1.
                    RS485_CLASH_INT_ST:  u1, 
                    
                    /// [18:18] This is the status bit for at_cmd_det_int_raw when at_cmd_char_det_int_ena is set to 1.
                    AT_CMD_CHAR_DET_INT_ST:  u1, 
                    
                    /// [19:19] This is the status bit for uart_wakeup_int_raw when uart_wakeup_int_ena is set to 1.
                    WAKEUP_INT_ST:  u1, 
                    
                    /// [20:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60000008));
                
                /// Interrupt enable bits
                pub const INT_ENA = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] This is the enable bit for rxfifo_full_int_st register.
                    RXFIFO_FULL_INT_ENA:  u1, 
                    
                    /// [1:1] This is the enable bit for txfifo_empty_int_st register.
                    TXFIFO_EMPTY_INT_ENA:  u1, 
                    
                    /// [2:2] This is the enable bit for parity_err_int_st register.
                    PARITY_ERR_INT_ENA:  u1, 
                    
                    /// [3:3] This is the enable bit for frm_err_int_st register.
                    FRM_ERR_INT_ENA:  u1, 
                    
                    /// [4:4] This is the enable bit for rxfifo_ovf_int_st register.
                    RXFIFO_OVF_INT_ENA:  u1, 
                    
                    /// [5:5] This is the enable bit for dsr_chg_int_st register.
                    DSR_CHG_INT_ENA:  u1, 
                    
                    /// [6:6] This is the enable bit for cts_chg_int_st register.
                    CTS_CHG_INT_ENA:  u1, 
                    
                    /// [7:7] This is the enable bit for brk_det_int_st register.
                    BRK_DET_INT_ENA:  u1, 
                    
                    /// [8:8] This is the enable bit for rxfifo_tout_int_st register.
                    RXFIFO_TOUT_INT_ENA:  u1, 
                    
                    /// [9:9] This is the enable bit for sw_xon_int_st register.
                    SW_XON_INT_ENA:  u1, 
                    
                    /// [10:10] This is the enable bit for sw_xoff_int_st register.
                    SW_XOFF_INT_ENA:  u1, 
                    
                    /// [11:11] This is the enable bit for glitch_det_int_st register.
                    GLITCH_DET_INT_ENA:  u1, 
                    
                    /// [12:12] This is the enable bit for tx_brk_done_int_st register.
                    TX_BRK_DONE_INT_ENA:  u1, 
                    
                    /// [13:13] This is the enable bit for tx_brk_idle_done_int_st register.
                    TX_BRK_IDLE_DONE_INT_ENA:  u1, 
                    
                    /// [14:14] This is the enable bit for tx_done_int_st register.
                    TX_DONE_INT_ENA:  u1, 
                    
                    /// [15:15] This is the enable bit for rs485_parity_err_int_st register.
                    RS485_PARITY_ERR_INT_ENA:  u1, 
                    
                    /// [16:16] This is the enable bit for rs485_parity_err_int_st register.
                    RS485_FRM_ERR_INT_ENA:  u1, 
                    
                    /// [17:17] This is the enable bit for rs485_clash_int_st register.
                    RS485_CLASH_INT_ENA:  u1, 
                    
                    /// [18:18] This is the enable bit for at_cmd_char_det_int_st register.
                    AT_CMD_CHAR_DET_INT_ENA:  u1, 
                    
                    /// [19:19] This is the enable bit for uart_wakeup_int_st register.
                    WAKEUP_INT_ENA:  u1, 
                    
                    /// [20:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000000c));
                
                /// Interrupt clear bits
                pub const INT_CLR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Set this bit to clear the rxfifo_full_int_raw interrupt.
                    RXFIFO_FULL_INT_CLR:  u1, 
                    
                    /// [1:1] Set this bit to clear txfifo_empty_int_raw interrupt.
                    TXFIFO_EMPTY_INT_CLR:  u1, 
                    
                    /// [2:2] Set this bit to clear parity_err_int_raw interrupt.
                    PARITY_ERR_INT_CLR:  u1, 
                    
                    /// [3:3] Set this bit to clear frm_err_int_raw interrupt.
                    FRM_ERR_INT_CLR:  u1, 
                    
                    /// [4:4] Set this bit to clear rxfifo_ovf_int_raw interrupt.
                    RXFIFO_OVF_INT_CLR:  u1, 
                    
                    /// [5:5] Set this bit to clear the dsr_chg_int_raw interrupt.
                    DSR_CHG_INT_CLR:  u1, 
                    
                    /// [6:6] Set this bit to clear the cts_chg_int_raw interrupt.
                    CTS_CHG_INT_CLR:  u1, 
                    
                    /// [7:7] Set this bit to clear the brk_det_int_raw interrupt.
                    BRK_DET_INT_CLR:  u1, 
                    
                    /// [8:8] Set this bit to clear the rxfifo_tout_int_raw interrupt.
                    RXFIFO_TOUT_INT_CLR:  u1, 
                    
                    /// [9:9] Set this bit to clear the sw_xon_int_raw interrupt.
                    SW_XON_INT_CLR:  u1, 
                    
                    /// [10:10] Set this bit to clear the sw_xoff_int_raw interrupt.
                    SW_XOFF_INT_CLR:  u1, 
                    
                    /// [11:11] Set this bit to clear the glitch_det_int_raw interrupt.
                    GLITCH_DET_INT_CLR:  u1, 
                    
                    /// [12:12] Set this bit to clear the tx_brk_done_int_raw interrupt..
                    TX_BRK_DONE_INT_CLR:  u1, 
                    
                    /// [13:13] Set this bit to clear the tx_brk_idle_done_int_raw interrupt.
                    TX_BRK_IDLE_DONE_INT_CLR:  u1, 
                    
                    /// [14:14] Set this bit to clear the tx_done_int_raw interrupt.
                    TX_DONE_INT_CLR:  u1, 
                    
                    /// [15:15] Set this bit to clear the rs485_parity_err_int_raw interrupt.
                    RS485_PARITY_ERR_INT_CLR:  u1, 
                    
                    /// [16:16] Set this bit to clear the rs485_frm_err_int_raw interrupt.
                    RS485_FRM_ERR_INT_CLR:  u1, 
                    
                    /// [17:17] Set this bit to clear the rs485_clash_int_raw interrupt.
                    RS485_CLASH_INT_CLR:  u1, 
                    
                    /// [18:18] Set this bit to clear the at_cmd_char_det_int_raw interrupt.
                    AT_CMD_CHAR_DET_INT_CLR:  u1, 
                    
                    /// [19:19] Set this bit to clear the uart_wakeup_int_raw interrupt.
                    WAKEUP_INT_CLR:  u1, 
                    
                    /// [20:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60000010));
                
                /// Clock divider configuration
                pub const CLKDIV = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:11] The integral part of the frequency divider factor.
                    CLKDIV:  u12, 
                    
                    /// [12:19] 
                    res0:  u0, 
                    
                    /// [20:23] The decimal part of the frequency divider factor.
                    FRAG:  u4, 
                    
                    /// [24:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x60000014));
                
                /// Rx Filter configuration
                pub const RX_FILT = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] when input pulse width is lower than this value the pulse is ignored.
                    GLITCH_FILT:  u8, 
                    
                    /// [8:8] Set this bit to enable Rx signal filter.
                    GLITCH_FILT_EN:  u1, 
                    
                    /// [9:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60000018));
                
                /// UART status register
                pub const STATUS = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] Stores the byte number of valid data in Rx-FIFO.
                    RXFIFO_CNT:  u8, 
                    
                    /// [8:12] 
                    res0:  u0, 
                    
                    /// [13:13] The register represent the level value of the internal uart dsr signal.
                    DSRN:  u1, 
                    
                    /// [14:14] This register represent the level value of the internal uart cts signal.
                    CTSN:  u1, 
                    
                    /// [15:15] This register represent thelevel value of the internal uart rxd signal.
                    RXD:  u1, 
                    
                    /// [16:23] Stores the byte number of data in Tx-FIFO.
                    TXFIFO_CNT:  u8, 
                    
                    /// [24:28] 
                    res1:  u0, 
                    
                    /// [29:29] This bit represents the level of the internal uart dtr signal.
                    DTRN:  u1, 
                    
                    /// [30:30] This bit represents the level of the internal uart rts signal.
                    RTSN:  u1, 
                    
                    /// [31:31] This bit represents thelevel of the internal uart txd signal.
                    TXD:  u1, 
                    
                }), @ptrFromInt(0x6000001c));
                
                /// a
                pub const CONF0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] This register is used to configure the parity check mode.
                    PARITY:  u1, 
                    
                    /// [1:1] Set this bit to enable uart parity check.
                    PARITY_EN:  u1, 
                    
                    /// [2:3] This register is used to set the length of data.
                    BIT_NUM:  u2, 
                    
                    /// [4:5] This register is used to set the length ofstop bit.
                    STOP_BIT_NUM:  u2, 
                    
                    /// [6:6] Set this bit to enbale transmitter tosend NULL when the process of sending data is done.
                    TXD_BRK:  u1, 
                    
                    /// [7:7] Set this bit to enable IrDA loopback mode.
                    IRDA_DPLX:  u1, 
                    
                    /// [8:8] This is the start enable bit for IrDA transmitter.
                    IRDA_TX_EN:  u1, 
                    
                    /// [9:9] 1'h1: The IrDA transmitter's 11th bit is the same as 10th bit. 1'h0: Set IrDA transmitter's 11th bit to 0.
                    IRDA_WCTL:  u1, 
                    
                    /// [10:10] Set this bit to invert the level ofIrDA transmitter.
                    IRDA_TX_INV:  u1, 
                    
                    /// [11:11] Set this bit to invert the level of IrDA receiver.
                    IRDA_RX_INV:  u1, 
                    
                    /// [12:12] Set this bit to enable uart loopback test mode.
                    LOOPBACK:  u1, 
                    
                    /// [13:13] Set this bit to enable flow control function for transmitter.
                    TX_FLOW_EN:  u1, 
                    
                    /// [14:14] Set this bit to enable IrDA protocol.
                    IRDA_EN:  u1, 
                    
                    /// [15:15] Set this bit to inverse the level value of uart rxd signal.
                    RXD_INV:  u1, 
                    
                    /// [16:16] Set this bit to inverse the level value of uart txd signal.
                    TXD_INV:  u1, 
                    
                    /// [17:17] Disable UART Rx data overflow detect.
                    DIS_RX_DAT_OVF:  u1, 
                    
                    /// [18:18] 1'h1: Receiver stops storing data into FIFO when data is wrong. 1'h0: Receiver stores the data even if thereceived data is wrong.
                    ERR_WR_MASK:  u1, 
                    
                    /// [19:19] This is the enable bit for detecting baudrate.
                    AUTOBAUD_EN:  u1, 
                    
                    /// [20:20] UART memory clock gate enable signal.
                    MEM_CLK_EN:  u1, 
                    
                    /// [21:21] This register is used to configure the software rts signal which is used in software flow control.
                    SW_RTS:  u1, 
                    
                    /// [22:22] Set this bit to reset the uart receive-FIFO.
                    RXFIFO_RST:  u1, 
                    
                    /// [23:23] Set this bit to reset the uart transmit-FIFO.
                    TXFIFO_RST:  u1, 
                    
                    /// [24:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60000020));
                
                /// Configuration register 1
                pub const CONF1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] It will produce rxfifo_full_int interrupt when receiver receives more data than this register value.
                    RXFIFO_FULL_THRHD:  u8, 
                    
                    /// [8:15] It will produce txfifo_empty_int interrupt when the data amount in Tx-FIFO is less than this register value.
                    TXFIFO_EMPTY_THRHD:  u8, 
                    
                    /// [16:16] Set this bit to inverse the level value of uart cts signal.
                    CTS_INV:  u1, 
                    
                    /// [17:17] Set this bit to inverse the level value of uart dsr signal.
                    DSR_INV:  u1, 
                    
                    /// [18:18] Set this bit to inverse the level value of uart rts signal.
                    RTS_INV:  u1, 
                    
                    /// [19:19] Set this bit to inverse the level value of uart dtr signal.
                    DTR_INV:  u1, 
                    
                    /// [20:20] This register is used to configure the software dtr signal which is used in software flow control.
                    SW_DTR:  u1, 
                    
                    /// [21:21] 1'h1: Force clock on for register. 1'h0: Support clock only when application writes registers.
                    CLK_EN:  u1, 
                    
                    /// [22:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60000024));
                
                /// Hardware flow-control configuration
                pub const HWFC_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] This register is used to configure the maximum amount of data that can be receivedwhen hardware flow control works.
                    RX_FLOW_THRHD:  u8, 
                    
                    /// [8:8] This is the flow enable bit for UART receiver.
                    RX_FLOW_EN:  u1, 
                    
                    /// [9:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000002c));
                
                /// UART sleep configure register 0
                pub const SLEEP_CONF0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] This register restores the specified wake up char1 to wake up
                    WK_CHAR1:  u8, 
                    
                    /// [8:15] This register restores the specified wake up char2 to wake up
                    WK_CHAR2:  u8, 
                    
                    /// [16:23] This register restores the specified wake up char3 to wake up
                    WK_CHAR3:  u8, 
                    
                    /// [24:31] This register restores the specified wake up char4 to wake up
                    WK_CHAR4:  u8, 
                    
                }), @ptrFromInt(0x60000030));
                
                /// UART sleep configure register 1
                pub const SLEEP_CONF1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] This register restores the specified char0 to wake up
                    WK_CHAR0:  u8, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60000034));
                
                /// UART sleep configure register 2
                pub const SLEEP_CONF2 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:9] The uart is activated from light sleeping mode when the input rxd edge changes more times than this register value.
                    ACTIVE_THRESHOLD:  u10, 
                    
                    /// [10:17] In wake up mode 1 this field is used to set the received data number threshold to wake up chip.
                    RX_WAKE_UP_THRHD:  u8, 
                    
                    /// [18:20] This register is used to select number of wake up char.
                    WK_CHAR_NUM:  u3, 
                    
                    /// [21:25] This register is used to maskwake up char.
                    WK_CHAR_MASK:  u5, 
                    
                    /// [26:27] This register is used to select wake up mode. 0: RXD toggling to wake up. 1: received data number larger than
                    WK_MODE_SEL:  u2, 
                    
                    /// [28:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60000038));
                
                /// Software flow-control character configuration
                pub const SWFC_CONF0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] This register stores the Xon flow control char.
                    XON_CHAR:  u8, 
                    
                    /// [8:15] This register stores the Xoff flow control char.
                    XOFF_CHAR:  u8, 
                    
                    /// [16:16] In software flow control mode, UART Tx is disabled once UART Rx receives XOFF. In this status, UART Tx can not transmit XOFF even the received data number is larger than UART_XOFF_THRESHOLD. Set this bit to enable UART Tx can transmit XON/XOFF when UART Tx is disabled.
                    XON_XOFF_STILL_SEND:  u1, 
                    
                    /// [17:17] Set this bit to enable software flow control. It is used with register sw_xon or sw_xoff.
                    SW_FLOW_CON_EN:  u1, 
                    
                    /// [18:18] Set this bit to remove flow control char from the received data.
                    XONOFF_DEL:  u1, 
                    
                    /// [19:19] Set this bit to enable the transmitter to go on sending data.
                    FORCE_XON:  u1, 
                    
                    /// [20:20] Set this bit to stop thetransmitter from sending data.
                    FORCE_XOFF:  u1, 
                    
                    /// [21:21] Set this bit to send Xon char. It is cleared by hardware automatically.
                    SEND_XON:  u1, 
                    
                    /// [22:22] Set this bit to send Xoff char. It is cleared by hardware automatically.
                    SEND_XOFF:  u1, 
                    
                    /// [23:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000003c));
                
                /// Software flow-control character configuration
                pub const SWFC_CONF1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] When the data amount in Rx-FIFO is less than this register value with uart_sw_flow_con_en set to 1it will send a Xon char.
                    XON_THRESHOLD:  u8, 
                    
                    /// [8:15] When the data amount in Rx-FIFO is more than this register value with uart_sw_flow_con_en set to 1it will send a Xoff char.
                    XOFF_THRESHOLD:  u8, 
                    
                    /// [16:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60000040));
                
                /// Tx Break character configuration
                pub const TXBRK_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] This register is used to configure the number of 0 to be sent after the process of sending data is done. It is active when txd_brk is set to 1.
                    TX_BRK_NUM:  u8, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60000044));
                
                /// Frame-end idle configuration
                pub const IDLE_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:9] It will produce frame end signal when receiver takes more time to receive one byte data than this register value.
                    RX_IDLE_THRHD:  u10, 
                    
                    /// [10:19] This register is used to configure the duration time between transfers.
                    TX_IDLE_NUM:  u10, 
                    
                    /// [20:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60000048));
                
                /// RS485 mode configuration
                pub const RS485_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Set this bit to choose the rs485 mode.
                    RS485_EN:  u1, 
                    
                    /// [1:1] Set this bit to delay the stop bit by 1 bit.
                    DL0_EN:  u1, 
                    
                    /// [2:2] Set this bit to delay the stop bit by 1 bit.
                    DL1_EN:  u1, 
                    
                    /// [3:3] Set this bit to enable receiver could receive data when the transmitter is transmitting data in rs485 mode.
                    RS485TX_RX_EN:  u1, 
                    
                    /// [4:4] 1'h1: enable rs485 transmitter to send data when rs485 receiver line is busy.
                    RS485RXBY_TX_EN:  u1, 
                    
                    /// [5:5] This register is used to delay the receiver's internal data signal.
                    RS485_RX_DLY_NUM:  u1, 
                    
                    /// [6:9] This register is used to delay the transmitter's internal data signal.
                    RS485_TX_DLY_NUM:  u4, 
                    
                    /// [10:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000004c));
                
                /// Pre-sequence timing configuration
                pub const AT_CMD_PRECNT = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:15] This register is used to configure the idle duration time before the first at_cmd is received by receiver.
                    PRE_IDLE_NUM:  u16, 
                    
                    /// [16:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60000050));
                
                /// Post-sequence timing configuration
                pub const AT_CMD_POSTCNT = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:15] This register is used to configure the duration time between the last at_cmd and the next data.
                    POST_IDLE_NUM:  u16, 
                    
                    /// [16:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60000054));
                
                /// Timeout configuration
                pub const AT_CMD_GAPTOUT = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:15] This register is used to configure the duration time between the at_cmd chars.
                    RX_GAP_TOUT:  u16, 
                    
                    /// [16:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60000058));
                
                /// AT escape sequence detection configuration
                pub const AT_CMD_CHAR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] This register is used to configure the content of at_cmd char.
                    AT_CMD_CHAR:  u8, 
                    
                    /// [8:15] This register is used to configure the num of continuous at_cmd chars received by receiver.
                    CHAR_NUM:  u8, 
                    
                    /// [16:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000005c));
                
                /// UART memory power configuration
                pub const MEM_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:24] 
                    res0:  u0, 
                    
                    /// [25:25] Set this bit to force power down UART memory.
                    MEM_FORCE_PD:  u1, 
                    
                    /// [26:26] Set this bit to force power up UART memory.
                    MEM_FORCE_PU:  u1, 
                    
                    /// [27:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x60000060));
                
                /// UART threshold and allocation configuration
                pub const TOUT_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] This is the enble bit for uart receiver's timeout function.
                    RX_TOUT_EN:  u1, 
                    
                    /// [1:1] Set this bit to stop accumulating idle_cnt when hardware flow control works.
                    RX_TOUT_FLOW_DIS:  u1, 
                    
                    /// [2:11] This register is used to configure the threshold time that receiver takes to receive one byte. The rxfifo_tout_int interrupt will be trigger when the receiver takes more time to receive one byte with rx_tout_en set to 1.
                    RX_TOUT_THRHD:  u10, 
                    
                    /// [12:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60000064));
                
                /// Tx-SRAM write and read offset address.
                pub const MEM_TX_STATUS = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] This register stores the offset write address in Tx-SRAM.
                    TX_SRAM_WADDR:  u8, 
                    
                    /// [8:8] 
                    res0:  u0, 
                    
                    /// [9:16] This register stores the offset read address in Tx-SRAM.
                    TX_SRAM_RADDR:  u8, 
                    
                    /// [17:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x60000068));
                
                /// Rx-SRAM write and read offset address.
                pub const MEM_RX_STATUS = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] This register stores the offset read address in RX-SRAM.
                    RX_SRAM_RADDR:  u8, 
                    
                    /// [8:8] 
                    res0:  u0, 
                    
                    /// [9:16] This register stores the offset write address in Rx-SRAM.
                    RX_SRAM_WADDR:  u8, 
                    
                    /// [17:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x6000006c));
                
                /// UART transmit and receive status.
                pub const FSM_STATUS = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:3] This is the status register of receiver.
                    ST_URX_OUT:  u4, 
                    
                    /// [4:7] This is the status register of transmitter.
                    ST_UTX_OUT:  u4, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60000070));
                
                /// Autobaud high pulse register
                pub const POSPULSE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:11] This register stores the minimal input clock count between two positive edges. It is used in boudrate-detect process.
                    POSEDGE_MIN_CNT:  u12, 
                    
                    /// [12:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60000074));
                
                /// Autobaud low pulse register
                pub const NEGPULSE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:11] This register stores the minimal input clock count between two negative edges. It is used in boudrate-detect process.
                    NEGEDGE_MIN_CNT:  u12, 
                    
                    /// [12:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60000078));
                
                /// Autobaud minimum low pulse duration register
                pub const LOWPULSE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:11] This register stores the value of the minimum duration time of the low level pulse. It is used in baud rate-detect process.
                    MIN_CNT:  u12, 
                    
                    /// [12:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000007c));
                
                /// Autobaud minimum high pulse duration register
                pub const HIGHPULSE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:11] This register storesthe value of the maxinum duration time for the high level pulse. It is used in baud rate-detect process.
                    MIN_CNT:  u12, 
                    
                    /// [12:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60000080));
                
                /// Autobaud edge change count register
                pub const RXD_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:9] This register stores the count of rxd edge change. It is used in baud rate-detect process.
                    RXD_EDGE_CNT:  u10, 
                    
                    /// [10:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60000084));
                
                /// UART core clock configuration
                pub const CLK_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:5] Thedenominator of the frequency divider factor.
                    SCLK_DIV_B:  u6, 
                    
                    /// [6:11] The numerator of the frequency divider factor.
                    SCLK_DIV_A:  u6, 
                    
                    /// [12:19] The integral part of the frequency divider factor.
                    SCLK_DIV_NUM:  u8, 
                    
                    /// [20:21] UART clock source select. 1: 80Mhz.2: 8Mhz.3: XTAL.
                    SCLK_SEL:  u2, 
                    
                    /// [22:22] Set this bit to enable UART Tx/Rx clock.
                    SCLK_EN:  u1, 
                    
                    /// [23:23] Write 1 then write 0 to this bit to reset UART Tx/Rx.
                    RST_CORE:  u1, 
                    
                    /// [24:24] Set this bit to enable UART Tx clock.
                    TX_SCLK_EN:  u1, 
                    
                    /// [25:25] Set this bit to enable UART Rx clock.
                    RX_SCLK_EN:  u1, 
                    
                    /// [26:26] Write 1 then write 0 to this bit to reset UART Tx.
                    TX_RST_CORE:  u1, 
                    
                    /// [27:27] Write 1 then write 0 to this bit to reset UART Rx.
                    RX_RST_CORE:  u1, 
                    
                    /// [28:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60000088));
                
                /// UART Version register
                pub const DATE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] This is the version register.
                    DATE:  u32, 
                    
                }), @ptrFromInt(0x6000008c));
                
                /// UART AFIFO Status
                pub const AFIFO_STATUS = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Full signal of APB TX AFIFO.
                    TX_AFIFO_FULL:  u1, 
                    
                    /// [1:1] Empty signal of APB TX AFIFO.
                    TX_AFIFO_EMPTY:  u1, 
                    
                    /// [2:2] Full signal of APB RX AFIFO.
                    RX_AFIFO_FULL:  u1, 
                    
                    /// [3:3] Empty signal of APB RX AFIFO.
                    RX_AFIFO_EMPTY:  u1, 
                    
                    /// [4:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60000090));
                
                /// UART Registers Configuration Update register
                pub const REG_UPDATE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Software write 1 would synchronize registers into UART Core clock domain and would be cleared by hardware after synchronization is done.
                    REG_UPDATE:  u1, 
                    
                    /// [1:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60000098));
                
                /// UART ID register
                pub const ID = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] This register is used to configure the uart_id.
                    ID:  u32, 
                    
                }), @ptrFromInt(0x6000009c));
                
            };
            
            /// UART (Universal Asynchronous Receiver-Transmitter) Controller 1
            pub const UART1 = struct {
                
            };
            
            /// Universal Host Controller Interface 0
            pub const UHCI0 = struct {
                
                /// UHCI Configuration Register0
                pub const CONF0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Write 1 then write 0 to this bit to reset decode state machine.
                    TX_RST:  u1, 
                    
                    /// [1:1] Write 1 then write 0 to this bit to reset encode state machine.
                    RX_RST:  u1, 
                    
                    /// [2:2] Set this bit to link up HCI and UART0.
                    UART0_CE:  u1, 
                    
                    /// [3:3] Set this bit to link up HCI and UART1.
                    UART1_CE:  u1, 
                    
                    /// [4:4] 
                    res0:  u0, 
                    
                    /// [5:5] Set this bit to separate the data frame using a special char.
                    SEPER_EN:  u1, 
                    
                    /// [6:6] Set this bit to encode the data packet with a formatting header.
                    HEAD_EN:  u1, 
                    
                    /// [7:7] Set this bit to enable UHCI to receive the 16 bit CRC.
                    CRC_REC_EN:  u1, 
                    
                    /// [8:8] If this bit is set to 1 UHCI will end the payload receiving process when UART has been in idle state.
                    UART_IDLE_EOF_EN:  u1, 
                    
                    /// [9:9] If this bit is set to 1 UHCI decoder receiving payload data is end when the receiving byte count has reached the specified value. The value is payload length indicated by UHCI packet header when UHCI_HEAD_EN is 1 or the value is configuration value when UHCI_HEAD_EN is 0. If this bit is set to 0 UHCI decoder receiving payload data is end when 0xc0 is received.
                    LEN_EOF_EN:  u1, 
                    
                    /// [10:10] Set this bit to enable data integrity checking by appending a 16 bit CCITT-CRC to end of the payload.
                    ENCODE_CRC_EN:  u1, 
                    
                    /// [11:11] 1'b1: Force clock on for register. 1'b0: Support clock only when application writes registers.
                    CLK_EN:  u1, 
                    
                    /// [12:12] If this bit is set to 1 UHCI will end payload receive process when NULL frame is received by UART.
                    UART_RX_BRK_EOF_EN:  u1, 
                    
                    /// [13:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x60005000));
                
                /// UHCI Interrupt Raw Register
                pub const INT_RAW = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Indicates the raw interrupt of UHCI_RX_START_INT. Interrupt will be triggered when delimiter is sent successfully.
                    RX_START_INT_RAW:  u1, 
                    
                    /// [1:1] Indicates the raw interrupt of UHCI_TX_START_INT. Interrupt will be triggered when DMA detects delimiter.
                    TX_START_INT_RAW:  u1, 
                    
                    /// [2:2] Indicates the raw interrupt of UHCI_RX_HUNG_INT. Interrupt will be triggered when the required time of DMA receiving dataexceeds the configuration value.
                    RX_HUNG_INT_RAW:  u1, 
                    
                    /// [3:3] Indicates the raw interrupt of UHCI_TX_HUNG_INT. Interrupt will be triggered when the required time of DMA reading RAM dataexceeds the configuration value.
                    TX_HUNG_INT_RAW:  u1, 
                    
                    /// [4:4] Indicates the raw interrupt of UHCI_SEND_S_REG_Q_INT. Interrupt will be triggered when UHCI sends short packet successfully with single_send mode.
                    SEND_S_REG_Q_INT_RAW:  u1, 
                    
                    /// [5:5] Indicates the raw interrupt of UHCI_SEND_A_REG_Q_INT. Interrupt will be triggered when UHCI sends short packet successfully with always_send mode.
                    SEND_A_REG_Q_INT_RAW:  u1, 
                    
                    /// [6:6] Indicates the raw interrupt of UHCI_OUT_EOF_INT. Interrupt will be triggered when there are errors in EOF.
                    OUT_EOF_INT_RAW:  u1, 
                    
                    /// [7:7] Indicates the raw interrupt of UHCI_APP_CTRL0_INT. Interrupt will be triggered when UHCI_APP_CTRL0_IN_SET is set to 1.
                    APP_CTRL0_INT_RAW:  u1, 
                    
                    /// [8:8] Indicates the raw interrupt of UHCI_APP_CTRL1_INT. Interrupt will be triggered when UHCI_APP_CTRL1_IN_SET is set to 1.
                    APP_CTRL1_INT_RAW:  u1, 
                    
                    /// [9:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60005004));
                
                /// UHCI Interrupt Status Register
                pub const INT_ST = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Indicates the interrupt status of UHCI_RX_START_INT.
                    RX_START_INT_ST:  u1, 
                    
                    /// [1:1] Indicates the interrupt status of UHCI_TX_START_INT.
                    TX_START_INT_ST:  u1, 
                    
                    /// [2:2] Indicates the interrupt status of UHCI_RX_HUNG_INT.
                    RX_HUNG_INT_ST:  u1, 
                    
                    /// [3:3] Indicates the interrupt status of UHCI_TX_HUNG_INT.
                    TX_HUNG_INT_ST:  u1, 
                    
                    /// [4:4] Indicates the interrupt status of UHCI_SEND_S_REG_Q_INT.
                    SEND_S_REG_Q_INT_ST:  u1, 
                    
                    /// [5:5] Indicates the interrupt status of UHCI_SEND_A_REG_Q_INT.
                    SEND_A_REG_Q_INT_ST:  u1, 
                    
                    /// [6:6] Indicates the interrupt status of UHCI_OUT_EOF_INT.
                    OUTLINK_EOF_ERR_INT_ST:  u1, 
                    
                    /// [7:7] Indicates the interrupt status of UHCI_APP_CTRL0_INT.
                    APP_CTRL0_INT_ST:  u1, 
                    
                    /// [8:8] Indicates the interrupt status of UHCI_APP_CTRL1_INT.
                    APP_CTRL1_INT_ST:  u1, 
                    
                    /// [9:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60005008));
                
                /// UHCI Interrupt Enable Register
                pub const INT_ENA = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Set this bit to enable the interrupt of UHCI_RX_START_INT.
                    RX_START_INT_ENA:  u1, 
                    
                    /// [1:1] Set this bit to enable the interrupt of UHCI_TX_START_INT.
                    TX_START_INT_ENA:  u1, 
                    
                    /// [2:2] Set this bit to enable the interrupt of UHCI_RX_HUNG_INT.
                    RX_HUNG_INT_ENA:  u1, 
                    
                    /// [3:3] Set this bit to enable the interrupt of UHCI_TX_HUNG_INT.
                    TX_HUNG_INT_ENA:  u1, 
                    
                    /// [4:4] Set this bit to enable the interrupt of UHCI_SEND_S_REG_Q_INT.
                    SEND_S_REG_Q_INT_ENA:  u1, 
                    
                    /// [5:5] Set this bit to enable the interrupt of UHCI_SEND_A_REG_Q_INT.
                    SEND_A_REG_Q_INT_ENA:  u1, 
                    
                    /// [6:6] Set this bit to enable the interrupt of UHCI_OUT_EOF_INT.
                    OUTLINK_EOF_ERR_INT_ENA:  u1, 
                    
                    /// [7:7] Set this bit to enable the interrupt of UHCI_APP_CTRL0_INT.
                    APP_CTRL0_INT_ENA:  u1, 
                    
                    /// [8:8] Set this bit to enable the interrupt of UHCI_APP_CTRL1_INT.
                    APP_CTRL1_INT_ENA:  u1, 
                    
                    /// [9:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000500c));
                
                /// UHCI Interrupt Clear Register
                pub const INT_CLR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Set this bit to clear the raw interrupt of UHCI_RX_START_INT.
                    RX_START_INT_CLR:  u1, 
                    
                    /// [1:1] Set this bit to clear the raw interrupt of UHCI_TX_START_INT.
                    TX_START_INT_CLR:  u1, 
                    
                    /// [2:2] Set this bit to clear the raw interrupt of UHCI_RX_HUNG_INT.
                    RX_HUNG_INT_CLR:  u1, 
                    
                    /// [3:3] Set this bit to clear the raw interrupt of UHCI_TX_HUNG_INT.
                    TX_HUNG_INT_CLR:  u1, 
                    
                    /// [4:4] Set this bit to clear the raw interrupt of UHCI_SEND_S_REG_Q_INT.
                    SEND_S_REG_Q_INT_CLR:  u1, 
                    
                    /// [5:5] Set this bit to clear the raw interrupt of UHCI_SEND_A_REG_Q_INT.
                    SEND_A_REG_Q_INT_CLR:  u1, 
                    
                    /// [6:6] Set this bit to clear the raw interrupt of UHCI_OUT_EOF_INT.
                    OUTLINK_EOF_ERR_INT_CLR:  u1, 
                    
                    /// [7:7] Set this bit to clear the raw interrupt of UHCI_APP_CTRL0_INT.
                    APP_CTRL0_INT_CLR:  u1, 
                    
                    /// [8:8] Set this bit to clear the raw interrupt of UHCI_APP_CTRL1_INT.
                    APP_CTRL1_INT_CLR:  u1, 
                    
                    /// [9:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60005010));
                
                /// UHCI Configuration Register1
                pub const CONF1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Set this bit to enable head checksum check when receiving.
                    CHECK_SUM_EN:  u1, 
                    
                    /// [1:1] Set this bit toenable sequence number check when receiving.
                    CHECK_SEQ_EN:  u1, 
                    
                    /// [2:2] Set this bit to support CRC calculation, and data integrity check bit should 1.
                    CRC_DISABLE:  u1, 
                    
                    /// [3:3] Set this bit to save data packet head when UHCI receive data.
                    SAVE_HEAD:  u1, 
                    
                    /// [4:4] Set this bit to encode data packet with checksum.
                    TX_CHECK_SUM_RE:  u1, 
                    
                    /// [5:5] Set this bit to encode data packet with ACK when reliable data packet is ready.
                    TX_ACK_NUM_RE:  u1, 
                    
                    /// [6:6] 
                    res0:  u0, 
                    
                    /// [7:7] Set this bit to enable UHCI encoder transfer to ST_SW_WAIT status.
                    WAIT_SW_START:  u1, 
                    
                    /// [8:8] Set this bit to transmit data packet if UCHI_ENCODE_STATE is ST_SW_WAIT.
                    SW_START:  u1, 
                    
                    /// [9:31] 
                    res1:  u0, 
                    
                }), @ptrFromInt(0x60005014));
                
                /// UHCI Receive Status Register
                pub const STATE0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:2] Indicates the error types when DMA receives the error frame. 3'b001: UHCI packet checksum error. 3'b010: UHCI packet sequence number error. 3'b011: UHCI packet CRC bit error. 3'b100: find 0xC0, but received packet is uncompleted. 3'b101: 0xC0 is not found, but received packet is completed. 3'b110: CRC check error.
                    RX_ERR_CAUSE:  u3, 
                    
                    /// [3:5] Indicates UHCI decoder status.
                    DECODE_STATE:  u3, 
                    
                    /// [6:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60005018));
                
                /// UHCI Transmit Status Register
                pub const STATE1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:2] Indicates UHCI encoder status.
                    ENCODE_STATE:  u3, 
                    
                    /// [3:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000501c));
                
                /// UHCI Escapes Configuration Register0
                pub const ESCAPE_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Set this bit to enable resolve char 0xC0 when DMA receiving data.
                    TX_C0_ESC_EN:  u1, 
                    
                    /// [1:1] Set this bit to enable resolve char 0xDB when DMA receiving data.
                    TX_DB_ESC_EN:  u1, 
                    
                    /// [2:2] Set this bit to enable resolve flow control char 0x11 when DMA receiving data.
                    TX_11_ESC_EN:  u1, 
                    
                    /// [3:3] Set this bit to enable resolve flow control char 0x13 when DMA receiving data.
                    TX_13_ESC_EN:  u1, 
                    
                    /// [4:4] Set this bit to enable replacing 0xC0 with special char when DMA receiving data.
                    RX_C0_ESC_EN:  u1, 
                    
                    /// [5:5] Set this bit to enable replacing 0xDB with special char when DMA receiving data.
                    RX_DB_ESC_EN:  u1, 
                    
                    /// [6:6] Set this bit to enable replacing 0x11 with special char when DMA receiving data.
                    RX_11_ESC_EN:  u1, 
                    
                    /// [7:7] Set this bit to enable replacing 0x13 with special char when DMA receiving data.
                    RX_13_ESC_EN:  u1, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60005020));
                
                /// UHCI Hung Configuration Register0
                pub const HUNG_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] Stores the timeout value. DMA generates UHCI_TX_HUNG_INT for timeout when receiving data.
                    TXFIFO_TIMEOUT:  u8, 
                    
                    /// [8:10] Configures the maximum counter value.
                    TXFIFO_TIMEOUT_SHIFT:  u3, 
                    
                    /// [11:11] Set this bit to enable TX FIFO timeout when receiving.
                    TXFIFO_TIMEOUT_ENA:  u1, 
                    
                    /// [12:19] Stores the timeout value. DMA generates UHCI_TX_HUNG_INT for timeout when reading RAM data.
                    RXFIFO_TIMEOUT:  u8, 
                    
                    /// [20:22] Configures the maximum counter value.
                    RXFIFO_TIMEOUT_SHIFT:  u3, 
                    
                    /// [23:23] Set this bit to enable TX FIFO timeout when DMA sending data.
                    RXFIFO_TIMEOUT_ENA:  u1, 
                    
                    /// [24:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60005024));
                
                /// UHCI Ack Value Configuration Register0
                pub const ACK_NUM = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:2] Indicates the ACK number during software flow control.
                    ACK_NUM:  u3, 
                    
                    /// [3:3] Set this bit to load the ACK value of UHCI_ACK_NUM.
                    LOAD:  u1, 
                    
                    /// [4:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60005028));
                
                /// UHCI Head Register
                pub const RX_HEAD = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Stores the head of received packet.
                    RX_HEAD:  u32, 
                    
                }), @ptrFromInt(0x6000502c));
                
                /// UCHI Quick send Register
                pub const QUICK_SENT = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:2] Configures single_send mode.
                    SINGLE_SEND_NUM:  u3, 
                    
                    /// [3:3] Set this bit to enable sending short packet with single_send mode.
                    SINGLE_SEND_EN:  u1, 
                    
                    /// [4:6] Configures always_send mode.
                    ALWAYS_SEND_NUM:  u3, 
                    
                    /// [7:7] Set this bit to enable sending short packet with always_send mode.
                    ALWAYS_SEND_EN:  u1, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60005030));
                
                /// UHCI Q0_WORD0 Quick Send Register
                pub const REG_Q0_WORD0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Serves as quick sending register in specified mode in UHCI_ALWAYS_SEND_NUM or UHCI_SINGLE_SEND_NUM.
                    SEND_Q0_WORD0:  u32, 
                    
                }), @ptrFromInt(0x60005034));
                
                /// UHCI Q0_WORD1 Quick Send Register
                pub const REG_Q0_WORD1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Serves as quick sending register in specified mode in UHCI_ALWAYS_SEND_NUM or UHCI_SINGLE_SEND_NUM.
                    SEND_Q0_WORD1:  u32, 
                    
                }), @ptrFromInt(0x60005038));
                
                /// UHCI Q1_WORD0 Quick Send Register
                pub const REG_Q1_WORD0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Serves as quick sending register in specified mode in UHCI_ALWAYS_SEND_NUM or UHCI_SINGLE_SEND_NUM.
                    SEND_Q1_WORD0:  u32, 
                    
                }), @ptrFromInt(0x6000503c));
                
                /// UHCI Q1_WORD1 Quick Send Register
                pub const REG_Q1_WORD1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Serves as quick sending register in specified mode in UHCI_ALWAYS_SEND_NUM or UHCI_SINGLE_SEND_NUM.
                    SEND_Q1_WORD1:  u32, 
                    
                }), @ptrFromInt(0x60005040));
                
                /// UHCI Q2_WORD0 Quick Send Register
                pub const REG_Q2_WORD0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Serves as quick sending register in specified mode in UHCI_ALWAYS_SEND_NUM or UHCI_SINGLE_SEND_NUM.
                    SEND_Q2_WORD0:  u32, 
                    
                }), @ptrFromInt(0x60005044));
                
                /// UHCI Q2_WORD1 Quick Send Register
                pub const REG_Q2_WORD1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Serves as quick sending register in specified mode in UHCI_ALWAYS_SEND_NUM or UHCI_SINGLE_SEND_NUM.
                    SEND_Q2_WORD1:  u32, 
                    
                }), @ptrFromInt(0x60005048));
                
                /// UHCI Q3_WORD0 Quick Send Register
                pub const REG_Q3_WORD0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Serves as quick sending register in specified mode in UHCI_ALWAYS_SEND_NUM or UHCI_SINGLE_SEND_NUM.
                    SEND_Q3_WORD0:  u32, 
                    
                }), @ptrFromInt(0x6000504c));
                
                /// UHCI Q3_WORD1 Quick Send Register
                pub const REG_Q3_WORD1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Serves as quick sending register in specified mode in UHCI_ALWAYS_SEND_NUM or UHCI_SINGLE_SEND_NUM.
                    SEND_Q3_WORD1:  u32, 
                    
                }), @ptrFromInt(0x60005050));
                
                /// UHCI Q4_WORD0 Quick Send Register
                pub const REG_Q4_WORD0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Serves as quick sending register in specified mode in UHCI_ALWAYS_SEND_NUM or UHCI_SINGLE_SEND_NUM.
                    SEND_Q4_WORD0:  u32, 
                    
                }), @ptrFromInt(0x60005054));
                
                /// UHCI Q4_WORD1 Quick Send Register
                pub const REG_Q4_WORD1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Serves as quick sending register in specified mode in UHCI_ALWAYS_SEND_NUM or UHCI_SINGLE_SEND_NUM.
                    SEND_Q4_WORD1:  u32, 
                    
                }), @ptrFromInt(0x60005058));
                
                /// UHCI Q5_WORD0 Quick Send Register
                pub const REG_Q5_WORD0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Serves as quick sending register in specified mode in UHCI_ALWAYS_SEND_NUM or UHCI_SINGLE_SEND_NUM.
                    SEND_Q5_WORD0:  u32, 
                    
                }), @ptrFromInt(0x6000505c));
                
                /// UHCI Q5_WORD1 Quick Send Register
                pub const REG_Q5_WORD1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Serves as quick sending register in specified mode in UHCI_ALWAYS_SEND_NUM or UHCI_SINGLE_SEND_NUM.
                    SEND_Q5_WORD1:  u32, 
                    
                }), @ptrFromInt(0x60005060));
                
                /// UHCI Q6_WORD0 Quick Send Register
                pub const REG_Q6_WORD0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Serves as quick sending register in specified mode in UHCI_ALWAYS_SEND_NUM or UHCI_SINGLE_SEND_NUM.
                    SEND_Q6_WORD0:  u32, 
                    
                }), @ptrFromInt(0x60005064));
                
                /// UHCI Q6_WORD1 Quick Send Register
                pub const REG_Q6_WORD1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Serves as quick sending register in specified mode in UHCI_ALWAYS_SEND_NUM or UHCI_SINGLE_SEND_NUM.
                    SEND_Q6_WORD1:  u32, 
                    
                }), @ptrFromInt(0x60005068));
                
                /// UHCI Escapes Sequence Configuration Register0
                pub const ESC_CONF0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] Configures the delimiter for encoding, default value is 0xC0.
                    SEPER_CHAR:  u8, 
                    
                    /// [8:15] Configures the first char of SLIP escape character, default value is 0xDB.
                    SEPER_ESC_CHAR0:  u8, 
                    
                    /// [16:23] Configures the second char of SLIP escape character, default value is 0xDC.
                    SEPER_ESC_CHAR1:  u8, 
                    
                    /// [24:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000506c));
                
                /// UHCI Escapes Sequence Configuration Register1
                pub const ESC_CONF1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] Configures the char needing encoding, which is 0xDB as flow control char by default.
                    ESC_SEQ0:  u8, 
                    
                    /// [8:15] Configures the first char of SLIP escape character, default value is 0xDB.
                    ESC_SEQ0_CHAR0:  u8, 
                    
                    /// [16:23] Configures the second char of SLIP escape character, default value is 0xDD.
                    ESC_SEQ0_CHAR1:  u8, 
                    
                    /// [24:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60005070));
                
                /// UHCI Escapes Sequence Configuration Register2
                pub const ESC_CONF2 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] Configures the char needing encoding, which is 0x11 as flow control char by default.
                    ESC_SEQ1:  u8, 
                    
                    /// [8:15] Configures the first char of SLIP escape character, default value is 0xDB.
                    ESC_SEQ1_CHAR0:  u8, 
                    
                    /// [16:23] Configures the second char of SLIP escape character, default value is 0xDE.
                    ESC_SEQ1_CHAR1:  u8, 
                    
                    /// [24:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60005074));
                
                /// UHCI Escapes Sequence Configuration Register3
                pub const ESC_CONF3 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] Configures the char needing encoding, which is 0x13 as flow control char by default.
                    ESC_SEQ2:  u8, 
                    
                    /// [8:15] Configures the first char of SLIP escape character, default value is 0xDB.
                    ESC_SEQ2_CHAR0:  u8, 
                    
                    /// [16:23] Configures the second char of SLIP escape character, default value is 0xDF.
                    ESC_SEQ2_CHAR1:  u8, 
                    
                    /// [24:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x60005078));
                
                /// UCHI Packet Length Configuration Register
                pub const PKT_THRES = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:12] Configures the data packet's maximum length when UHCI_HEAD_EN is 0.
                    PKT_THRS:  u13, 
                    
                    /// [13:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000507c));
                
                /// UHCI Version Register
                pub const DATE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] Configures version.
                    DATE:  u32, 
                    
                }), @ptrFromInt(0x60005080));
                
            };
            
            /// Full-speed USB Serial/JTAG Controller
            pub const USB_DEVICE = struct {
                
                /// FIFO access for the CDC-ACM data IN and OUT endpoints.
                pub const EP1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] Write and read byte data to/from UART Tx/Rx FIFO through this field. When USB_DEVICE_SERIAL_IN_EMPTY_INT is set, then user can write data (up to 64 bytes) into UART Tx FIFO. When USB_DEVICE_SERIAL_OUT_RECV_PKT_INT is set, user can check USB_DEVICE_OUT_EP1_WR_ADDR USB_DEVICE_OUT_EP0_RD_ADDR to know how many data is received, then read data from UART Rx FIFO.
                    RDWR_BYTE:  u8, 
                    
                    /// [8:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000f000));
                
                /// Configuration and control registers for the CDC-ACM FIFOs.
                pub const EP1_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Set this bit to indicate writing byte data to UART Tx FIFO is done.
                    WR_DONE:  u1, 
                    
                    /// [1:1] 1'b1: Indicate UART Tx FIFO is not full and can write data into in. After writing USB_DEVICE_WR_DONE, this bit would be 0 until data in UART Tx FIFO is read by USB Host.
                    SERIAL_IN_EP_DATA_FREE:  u1, 
                    
                    /// [2:2] 1'b1: Indicate there is data in UART Rx FIFO.
                    SERIAL_OUT_EP_DATA_AVAIL:  u1, 
                    
                    /// [3:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000f004));
                
                /// Interrupt raw status register.
                pub const INT_RAW = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] The raw interrupt bit turns to high level when flush cmd is received for IN endpoint 2 of JTAG.
                    JTAG_IN_FLUSH_INT_RAW:  u1, 
                    
                    /// [1:1] The raw interrupt bit turns to high level when SOF frame is received.
                    SOF_INT_RAW:  u1, 
                    
                    /// [2:2] The raw interrupt bit turns to high level when Serial Port OUT Endpoint received one packet.
                    SERIAL_OUT_RECV_PKT_INT_RAW:  u1, 
                    
                    /// [3:3] The raw interrupt bit turns to high level when Serial Port IN Endpoint is empty.
                    SERIAL_IN_EMPTY_INT_RAW:  u1, 
                    
                    /// [4:4] The raw interrupt bit turns to high level when pid error is detected.
                    PID_ERR_INT_RAW:  u1, 
                    
                    /// [5:5] The raw interrupt bit turns to high level when CRC5 error is detected.
                    CRC5_ERR_INT_RAW:  u1, 
                    
                    /// [6:6] The raw interrupt bit turns to high level when CRC16 error is detected.
                    CRC16_ERR_INT_RAW:  u1, 
                    
                    /// [7:7] The raw interrupt bit turns to high level when stuff error is detected.
                    STUFF_ERR_INT_RAW:  u1, 
                    
                    /// [8:8] The raw interrupt bit turns to high level when IN token for IN endpoint 1 is received.
                    IN_TOKEN_REC_IN_EP1_INT_RAW:  u1, 
                    
                    /// [9:9] The raw interrupt bit turns to high level when usb bus reset is detected.
                    USB_BUS_RESET_INT_RAW:  u1, 
                    
                    /// [10:10] The raw interrupt bit turns to high level when OUT endpoint 1 received packet with zero palyload.
                    OUT_EP1_ZERO_PAYLOAD_INT_RAW:  u1, 
                    
                    /// [11:11] The raw interrupt bit turns to high level when OUT endpoint 2 received packet with zero palyload.
                    OUT_EP2_ZERO_PAYLOAD_INT_RAW:  u1, 
                    
                    /// [12:12] The raw interrupt bit turns to high level when level of RTS from usb serial channel is changed.
                    RTS_CHG_INT_RAW:  u1, 
                    
                    /// [13:13] The raw interrupt bit turns to high level when level of DTR from usb serial channel is changed.
                    DTR_CHG_INT_RAW:  u1, 
                    
                    /// [14:14] The raw interrupt bit turns to high level when level of GET LINE CODING request is received.
                    GET_LINE_CODE_INT_RAW:  u1, 
                    
                    /// [15:15] The raw interrupt bit turns to high level when level of SET LINE CODING request is received.
                    SET_LINE_CODE_INT_RAW:  u1, 
                    
                    /// [16:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000f008));
                
                /// Interrupt status register.
                pub const INT_ST = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] The raw interrupt status bit for the USB_DEVICE_JTAG_IN_FLUSH_INT interrupt.
                    JTAG_IN_FLUSH_INT_ST:  u1, 
                    
                    /// [1:1] The raw interrupt status bit for the USB_DEVICE_SOF_INT interrupt.
                    SOF_INT_ST:  u1, 
                    
                    /// [2:2] The raw interrupt status bit for the USB_DEVICE_SERIAL_OUT_RECV_PKT_INT interrupt.
                    SERIAL_OUT_RECV_PKT_INT_ST:  u1, 
                    
                    /// [3:3] The raw interrupt status bit for the USB_DEVICE_SERIAL_IN_EMPTY_INT interrupt.
                    SERIAL_IN_EMPTY_INT_ST:  u1, 
                    
                    /// [4:4] The raw interrupt status bit for the USB_DEVICE_PID_ERR_INT interrupt.
                    PID_ERR_INT_ST:  u1, 
                    
                    /// [5:5] The raw interrupt status bit for the USB_DEVICE_CRC5_ERR_INT interrupt.
                    CRC5_ERR_INT_ST:  u1, 
                    
                    /// [6:6] The raw interrupt status bit for the USB_DEVICE_CRC16_ERR_INT interrupt.
                    CRC16_ERR_INT_ST:  u1, 
                    
                    /// [7:7] The raw interrupt status bit for the USB_DEVICE_STUFF_ERR_INT interrupt.
                    STUFF_ERR_INT_ST:  u1, 
                    
                    /// [8:8] The raw interrupt status bit for the USB_DEVICE_IN_TOKEN_REC_IN_EP1_INT interrupt.
                    IN_TOKEN_REC_IN_EP1_INT_ST:  u1, 
                    
                    /// [9:9] The raw interrupt status bit for the USB_DEVICE_USB_BUS_RESET_INT interrupt.
                    USB_BUS_RESET_INT_ST:  u1, 
                    
                    /// [10:10] The raw interrupt status bit for the USB_DEVICE_OUT_EP1_ZERO_PAYLOAD_INT interrupt.
                    OUT_EP1_ZERO_PAYLOAD_INT_ST:  u1, 
                    
                    /// [11:11] The raw interrupt status bit for the USB_DEVICE_OUT_EP2_ZERO_PAYLOAD_INT interrupt.
                    OUT_EP2_ZERO_PAYLOAD_INT_ST:  u1, 
                    
                    /// [12:12] The raw interrupt status bit for the USB_DEVICE_RTS_CHG_INT interrupt.
                    RTS_CHG_INT_ST:  u1, 
                    
                    /// [13:13] The raw interrupt status bit for the USB_DEVICE_DTR_CHG_INT interrupt.
                    DTR_CHG_INT_ST:  u1, 
                    
                    /// [14:14] The raw interrupt status bit for the USB_DEVICE_GET_LINE_CODE_INT interrupt.
                    GET_LINE_CODE_INT_ST:  u1, 
                    
                    /// [15:15] The raw interrupt status bit for the USB_DEVICE_SET_LINE_CODE_INT interrupt.
                    SET_LINE_CODE_INT_ST:  u1, 
                    
                    /// [16:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000f00c));
                
                /// Interrupt enable status register.
                pub const INT_ENA = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] The interrupt enable bit for the USB_DEVICE_JTAG_IN_FLUSH_INT interrupt.
                    JTAG_IN_FLUSH_INT_ENA:  u1, 
                    
                    /// [1:1] The interrupt enable bit for the USB_DEVICE_SOF_INT interrupt.
                    SOF_INT_ENA:  u1, 
                    
                    /// [2:2] The interrupt enable bit for the USB_DEVICE_SERIAL_OUT_RECV_PKT_INT interrupt.
                    SERIAL_OUT_RECV_PKT_INT_ENA:  u1, 
                    
                    /// [3:3] The interrupt enable bit for the USB_DEVICE_SERIAL_IN_EMPTY_INT interrupt.
                    SERIAL_IN_EMPTY_INT_ENA:  u1, 
                    
                    /// [4:4] The interrupt enable bit for the USB_DEVICE_PID_ERR_INT interrupt.
                    PID_ERR_INT_ENA:  u1, 
                    
                    /// [5:5] The interrupt enable bit for the USB_DEVICE_CRC5_ERR_INT interrupt.
                    CRC5_ERR_INT_ENA:  u1, 
                    
                    /// [6:6] The interrupt enable bit for the USB_DEVICE_CRC16_ERR_INT interrupt.
                    CRC16_ERR_INT_ENA:  u1, 
                    
                    /// [7:7] The interrupt enable bit for the USB_DEVICE_STUFF_ERR_INT interrupt.
                    STUFF_ERR_INT_ENA:  u1, 
                    
                    /// [8:8] The interrupt enable bit for the USB_DEVICE_IN_TOKEN_REC_IN_EP1_INT interrupt.
                    IN_TOKEN_REC_IN_EP1_INT_ENA:  u1, 
                    
                    /// [9:9] The interrupt enable bit for the USB_DEVICE_USB_BUS_RESET_INT interrupt.
                    USB_BUS_RESET_INT_ENA:  u1, 
                    
                    /// [10:10] The interrupt enable bit for the USB_DEVICE_OUT_EP1_ZERO_PAYLOAD_INT interrupt.
                    OUT_EP1_ZERO_PAYLOAD_INT_ENA:  u1, 
                    
                    /// [11:11] The interrupt enable bit for the USB_DEVICE_OUT_EP2_ZERO_PAYLOAD_INT interrupt.
                    OUT_EP2_ZERO_PAYLOAD_INT_ENA:  u1, 
                    
                    /// [12:12] The interrupt enable bit for the USB_DEVICE_RTS_CHG_INT interrupt.
                    RTS_CHG_INT_ENA:  u1, 
                    
                    /// [13:13] The interrupt enable bit for the USB_DEVICE_DTR_CHG_INT interrupt.
                    DTR_CHG_INT_ENA:  u1, 
                    
                    /// [14:14] The interrupt enable bit for the USB_DEVICE_GET_LINE_CODE_INT interrupt.
                    GET_LINE_CODE_INT_ENA:  u1, 
                    
                    /// [15:15] The interrupt enable bit for the USB_DEVICE_SET_LINE_CODE_INT interrupt.
                    SET_LINE_CODE_INT_ENA:  u1, 
                    
                    /// [16:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000f010));
                
                /// Interrupt clear status register.
                pub const INT_CLR = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Set this bit to clear the USB_DEVICE_JTAG_IN_FLUSH_INT interrupt.
                    JTAG_IN_FLUSH_INT_CLR:  u1, 
                    
                    /// [1:1] Set this bit to clear the USB_DEVICE_JTAG_SOF_INT interrupt.
                    SOF_INT_CLR:  u1, 
                    
                    /// [2:2] Set this bit to clear the USB_DEVICE_SERIAL_OUT_RECV_PKT_INT interrupt.
                    SERIAL_OUT_RECV_PKT_INT_CLR:  u1, 
                    
                    /// [3:3] Set this bit to clear the USB_DEVICE_SERIAL_IN_EMPTY_INT interrupt.
                    SERIAL_IN_EMPTY_INT_CLR:  u1, 
                    
                    /// [4:4] Set this bit to clear the USB_DEVICE_PID_ERR_INT interrupt.
                    PID_ERR_INT_CLR:  u1, 
                    
                    /// [5:5] Set this bit to clear the USB_DEVICE_CRC5_ERR_INT interrupt.
                    CRC5_ERR_INT_CLR:  u1, 
                    
                    /// [6:6] Set this bit to clear the USB_DEVICE_CRC16_ERR_INT interrupt.
                    CRC16_ERR_INT_CLR:  u1, 
                    
                    /// [7:7] Set this bit to clear the USB_DEVICE_STUFF_ERR_INT interrupt.
                    STUFF_ERR_INT_CLR:  u1, 
                    
                    /// [8:8] Set this bit to clear the USB_DEVICE_IN_TOKEN_IN_EP1_INT interrupt.
                    IN_TOKEN_REC_IN_EP1_INT_CLR:  u1, 
                    
                    /// [9:9] Set this bit to clear the USB_DEVICE_USB_BUS_RESET_INT interrupt.
                    USB_BUS_RESET_INT_CLR:  u1, 
                    
                    /// [10:10] Set this bit to clear the USB_DEVICE_OUT_EP1_ZERO_PAYLOAD_INT interrupt.
                    OUT_EP1_ZERO_PAYLOAD_INT_CLR:  u1, 
                    
                    /// [11:11] Set this bit to clear the USB_DEVICE_OUT_EP2_ZERO_PAYLOAD_INT interrupt.
                    OUT_EP2_ZERO_PAYLOAD_INT_CLR:  u1, 
                    
                    /// [12:12] Set this bit to clear the USB_DEVICE_RTS_CHG_INT interrupt.
                    RTS_CHG_INT_CLR:  u1, 
                    
                    /// [13:13] Set this bit to clear the USB_DEVICE_DTR_CHG_INT interrupt.
                    DTR_CHG_INT_CLR:  u1, 
                    
                    /// [14:14] Set this bit to clear the USB_DEVICE_GET_LINE_CODE_INT interrupt.
                    GET_LINE_CODE_INT_CLR:  u1, 
                    
                    /// [15:15] Set this bit to clear the USB_DEVICE_SET_LINE_CODE_INT interrupt.
                    SET_LINE_CODE_INT_CLR:  u1, 
                    
                    /// [16:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000f014));
                
                /// PHY hardware configuration.
                pub const CONF0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Select internal/external PHY
                    PHY_SEL:  u1, 
                    
                    /// [1:1] Enable software control USB D+ D- exchange
                    EXCHG_PINS_OVERRIDE:  u1, 
                    
                    /// [2:2] USB D+ D- exchange
                    EXCHG_PINS:  u1, 
                    
                    /// [3:4] Control single-end input high threshold,1.76V to 2V, step 80mV
                    VREFH:  u2, 
                    
                    /// [5:6] Control single-end input low threshold,0.8V to 1.04V, step 80mV
                    VREFL:  u2, 
                    
                    /// [7:7] Enable software control inputthreshold
                    VREF_OVERRIDE:  u1, 
                    
                    /// [8:8] Enable software control USB D+ D- pullup pulldown
                    PAD_PULL_OVERRIDE:  u1, 
                    
                    /// [9:9] Control USB D+ pull up.
                    DP_PULLUP:  u1, 
                    
                    /// [10:10] Control USB D+ pull down.
                    DP_PULLDOWN:  u1, 
                    
                    /// [11:11] Control USB D- pull up.
                    DM_PULLUP:  u1, 
                    
                    /// [12:12] Control USB D- pull down.
                    DM_PULLDOWN:  u1, 
                    
                    /// [13:13] Control pull up value.
                    PULLUP_VALUE:  u1, 
                    
                    /// [14:14] Enable USB pad function.
                    USB_PAD_ENABLE:  u1, 
                    
                    /// [15:15] Set this bit usb_jtag, the connection between usb_jtag and internal JTAG is disconnected, and MTMS, MTDI, MTCK are output through GPIO Matrix, MTDO is input through GPIO Matrix.
                    USB_JTAG_BRIDGE_EN:  u1, 
                    
                    /// [16:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000f018));
                
                /// Registers used for debugging the PHY.
                pub const TEST = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Enable test of the USB pad
                    TEST_ENABLE:  u1, 
                    
                    /// [1:1] USB pad oen in test
                    TEST_USB_OE:  u1, 
                    
                    /// [2:2] USB D+ tx value in test
                    TEST_TX_DP:  u1, 
                    
                    /// [3:3] USB D- tx value in test
                    TEST_TX_DM:  u1, 
                    
                    /// [4:4] USB RCV value in test
                    TEST_RX_RCV:  u1, 
                    
                    /// [5:5] USB D+ rx value in test
                    TEST_RX_DP:  u1, 
                    
                    /// [6:6] USB D- rx value in test
                    TEST_RX_DM:  u1, 
                    
                    /// [7:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000f01c));
                
                /// JTAG FIFO status and control registers.
                pub const JFIFO_ST = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:1] JTAT in fifo counter.
                    IN_FIFO_CNT:  u2, 
                    
                    /// [2:2] 1: JTAG in fifo is empty.
                    IN_FIFO_EMPTY:  u1, 
                    
                    /// [3:3] 1: JTAG in fifo is full.
                    IN_FIFO_FULL:  u1, 
                    
                    /// [4:5] JTAT out fifo counter.
                    OUT_FIFO_CNT:  u2, 
                    
                    /// [6:6] 1: JTAG out fifo is empty.
                    OUT_FIFO_EMPTY:  u1, 
                    
                    /// [7:7] 1: JTAG out fifo is full.
                    OUT_FIFO_FULL:  u1, 
                    
                    /// [8:8] Write 1 to reset JTAG in fifo.
                    IN_FIFO_RESET:  u1, 
                    
                    /// [9:9] Write 1 to reset JTAG out fifo.
                    OUT_FIFO_RESET:  u1, 
                    
                    /// [10:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000f020));
                
                /// Last received SOF frame index register.
                pub const FRAM_NUM = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:10] Frame index of received SOF frame.
                    SOF_FRAME_INDEX:  u11, 
                    
                    /// [11:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000f024));
                
                /// Control IN endpoint status information.
                pub const IN_EP0_ST = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:1] State of IN Endpoint 0.
                    IN_EP0_STATE:  u2, 
                    
                    /// [2:8] Write data address of IN endpoint 0.
                    IN_EP0_WR_ADDR:  u7, 
                    
                    /// [9:15] Read data address of IN endpoint 0.
                    IN_EP0_RD_ADDR:  u7, 
                    
                    /// [16:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000f028));
                
                /// CDC-ACM IN endpoint status information.
                pub const IN_EP1_ST = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:1] State of IN Endpoint 1.
                    IN_EP1_STATE:  u2, 
                    
                    /// [2:8] Write data address of IN endpoint 1.
                    IN_EP1_WR_ADDR:  u7, 
                    
                    /// [9:15] Read data address of IN endpoint 1.
                    IN_EP1_RD_ADDR:  u7, 
                    
                    /// [16:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000f02c));
                
                /// CDC-ACM interrupt IN endpoint status information.
                pub const IN_EP2_ST = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:1] State of IN Endpoint 2.
                    IN_EP2_STATE:  u2, 
                    
                    /// [2:8] Write data address of IN endpoint 2.
                    IN_EP2_WR_ADDR:  u7, 
                    
                    /// [9:15] Read data address of IN endpoint 2.
                    IN_EP2_RD_ADDR:  u7, 
                    
                    /// [16:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000f030));
                
                /// JTAG IN endpoint status information.
                pub const IN_EP3_ST = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:1] State of IN Endpoint 3.
                    IN_EP3_STATE:  u2, 
                    
                    /// [2:8] Write data address of IN endpoint 3.
                    IN_EP3_WR_ADDR:  u7, 
                    
                    /// [9:15] Read data address of IN endpoint 3.
                    IN_EP3_RD_ADDR:  u7, 
                    
                    /// [16:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000f034));
                
                /// Control OUT endpoint status information.
                pub const OUT_EP0_ST = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:1] State of OUT Endpoint 0.
                    OUT_EP0_STATE:  u2, 
                    
                    /// [2:8] Write data address of OUT endpoint 0. When USB_DEVICE_SERIAL_OUT_RECV_PKT_INT is detected, there are USB_DEVICE_OUT_EP0_WR_ADDR-2 bytes data in OUT EP0.
                    OUT_EP0_WR_ADDR:  u7, 
                    
                    /// [9:15] Read data address of OUT endpoint 0.
                    OUT_EP0_RD_ADDR:  u7, 
                    
                    /// [16:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000f038));
                
                /// CDC-ACM OUT endpoint status information.
                pub const OUT_EP1_ST = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:1] State of OUT Endpoint 1.
                    OUT_EP1_STATE:  u2, 
                    
                    /// [2:8] Write data address of OUT endpoint 1. When USB_DEVICE_SERIAL_OUT_RECV_PKT_INT is detected, there are USB_DEVICE_OUT_EP1_WR_ADDR-2 bytes data in OUT EP1.
                    OUT_EP1_WR_ADDR:  u7, 
                    
                    /// [9:15] Read data address of OUT endpoint 1.
                    OUT_EP1_RD_ADDR:  u7, 
                    
                    /// [16:22] Data count in OUT endpoint 1 when one packet is received.
                    OUT_EP1_REC_DATA_CNT:  u7, 
                    
                    /// [23:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000f03c));
                
                /// JTAG OUT endpoint status information.
                pub const OUT_EP2_ST = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:1] State of OUT Endpoint 2.
                    OUT_EP2_STATE:  u2, 
                    
                    /// [2:8] Write data address of OUT endpoint 2. When USB_DEVICE_SERIAL_OUT_RECV_PKT_INT is detected, there are USB_DEVICE_OUT_EP2_WR_ADDR-2 bytes data in OUT EP2.
                    OUT_EP2_WR_ADDR:  u7, 
                    
                    /// [9:15] Read data address of OUT endpoint 2.
                    OUT_EP2_RD_ADDR:  u7, 
                    
                    /// [16:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000f040));
                
                /// Clock enable control
                pub const MISC_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] 1'h1: Force clock on for register. 1'h0: Support clock only when application writes registers.
                    CLK_EN:  u1, 
                    
                    /// [1:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000f044));
                
                /// Memory power control
                pub const MEM_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] 1: power down usb memory.
                    USB_MEM_PD:  u1, 
                    
                    /// [1:1] 1: Force clock on for usb memory.
                    USB_MEM_CLK_EN:  u1, 
                    
                    /// [2:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000f048));
                
                /// CDC-ACM chip reset control.
                pub const CHIP_RST = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] 1: Chip reset is detected from usb serial channel. Software write 1 to clear it.
                    RTS:  u1, 
                    
                    /// [1:1] 1: Chip reset is detected from usb jtag channel. Software write 1 to clear it.
                    DTR:  u1, 
                    
                    /// [2:2] Set this bit to disable chip reset from usb serial channel to reset chip.
                    USB_UART_CHIP_RST_DIS:  u1, 
                    
                    /// [3:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000f04c));
                
                /// W0 of SET_LINE_CODING command.
                pub const SET_LINE_CODE_W0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] The value of dwDTERate set by host through SET_LINE_CODING command.
                    DW_DTE_RATE:  u32, 
                    
                }), @ptrFromInt(0x6000f050));
                
                /// W1 of SET_LINE_CODING command.
                pub const SET_LINE_CODE_W1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] The value of bCharFormat set by host through SET_LINE_CODING command.
                    BCHAR_FORMAT:  u8, 
                    
                    /// [8:15] The value of bParityTpye set by host through SET_LINE_CODING command.
                    BPARITY_TYPE:  u8, 
                    
                    /// [16:23] The value of bDataBits set by host through SET_LINE_CODING command.
                    BDATA_BITS:  u8, 
                    
                    /// [24:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000f054));
                
                /// W0 of GET_LINE_CODING command.
                pub const GET_LINE_CODE_W0 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] The value of dwDTERate set by software which is requested by GET_LINE_CODING command.
                    GET_DW_DTE_RATE:  u32, 
                    
                }), @ptrFromInt(0x6000f058));
                
                /// W1 of GET_LINE_CODING command.
                pub const GET_LINE_CODE_W1 = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:7] The value of bCharFormat set by software which is requested by GET_LINE_CODING command.
                    GET_BDATA_BITS:  u8, 
                    
                    /// [8:15] The value of bParityTpye set by software which is requested by GET_LINE_CODING command.
                    GET_BPARITY_TYPE:  u8, 
                    
                    /// [16:23] The value of bDataBits set by software which is requested by GET_LINE_CODING command.
                    GET_BCHAR_FORMAT:  u8, 
                    
                    /// [24:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000f05c));
                
                /// Configuration registers' value update
                pub const CONFIG_UPDATE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Write 1 to this register would update the value of configure registers from APB clock domain to 48MHz clock domain.
                    CONFIG_UPDATE:  u1, 
                    
                    /// [1:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000f060));
                
                /// Serial AFIFO configure register
                pub const SER_AFIFO_CONFIG = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] Write 1 to reset CDC_ACM IN async FIFO write clock domain.
                    SERIAL_IN_AFIFO_RESET_WR:  u1, 
                    
                    /// [1:1] Write 1 to reset CDC_ACM IN async FIFO read clock domain.
                    SERIAL_IN_AFIFO_RESET_RD:  u1, 
                    
                    /// [2:2] Write 1 to reset CDC_ACM OUT async FIFO write clock domain.
                    SERIAL_OUT_AFIFO_RESET_WR:  u1, 
                    
                    /// [3:3] Write 1 to reset CDC_ACM OUT async FIFO read clock domain.
                    SERIAL_OUT_AFIFO_RESET_RD:  u1, 
                    
                    /// [4:4] CDC_ACM OUTOUT async FIFO empty signal in read clock domain.
                    SERIAL_OUT_AFIFO_REMPTY:  u1, 
                    
                    /// [5:5] CDC_ACM OUT IN async FIFO empty signal in write clock domain.
                    SERIAL_IN_AFIFO_WFULL:  u1, 
                    
                    /// [6:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000f064));
                
                /// USB Bus reset status register
                pub const BUS_RESET_ST = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:0] USB bus reset status. 0: USB-Serial-JTAG is in usb bus reset status. 1: USB bus reset is released.
                    USB_BUS_RESET_ST:  u1, 
                    
                    /// [1:31] 
                    res0:  u0, 
                    
                }), @ptrFromInt(0x6000f068));
                
                /// Date register
                pub const DATE = @as(*volatile mmio.Mmio(packed struct(u32) {
                    
                    /// [0:31] register version.
                    DATE:  u32, 
                    
                }), @ptrFromInt(0x6000f080));
                
            };
            
        };
    };
};