
const mmio = @import("./mmio.zig");

pub const devices = struct {
  pub const @"ESP32-C6" = struct {
    pub const peripherals = struct {

      /// AES (Advanced Encryption Standard) Accelerator
      pub const AES = struct {

        /// Key material key_0 configure register
        pub const KEY_0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] This bits stores key_0 that is a part of key material.
          KEY_0: u32,

        }), @ptrFromInt(0x60088000));

        /// Key material key_1 configure register
        pub const KEY_1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] This bits stores key_1 that is a part of key material.
          KEY_1: u32,

        }), @ptrFromInt(0x60088004));

        /// Key material key_2 configure register
        pub const KEY_2 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] This bits stores key_2 that is a part of key material.
          KEY_2: u32,

        }), @ptrFromInt(0x60088008));

        /// Key material key_3 configure register
        pub const KEY_3 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] This bits stores key_3 that is a part of key material.
          KEY_3: u32,

        }), @ptrFromInt(0x6008800c));

        /// Key material key_4 configure register
        pub const KEY_4 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] This bits stores key_4 that is a part of key material.
          KEY_4: u32,

        }), @ptrFromInt(0x60088010));

        /// Key material key_5 configure register
        pub const KEY_5 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] This bits stores key_5 that is a part of key material.
          KEY_5: u32,

        }), @ptrFromInt(0x60088014));

        /// Key material key_6 configure register
        pub const KEY_6 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] This bits stores key_6 that is a part of key material.
          KEY_6: u32,

        }), @ptrFromInt(0x60088018));

        /// Key material key_7 configure register
        pub const KEY_7 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] This bits stores key_7 that is a part of key material.
          KEY_7: u32,

        }), @ptrFromInt(0x6008801c));

        /// source text material text_in_0 configure register
        pub const TEXT_IN_0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] This bits stores text_in_0 that is a part of source text material.
          TEXT_IN_0: u32,

        }), @ptrFromInt(0x60088020));

        /// source text material text_in_1 configure register
        pub const TEXT_IN_1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] This bits stores text_in_1 that is a part of source text material.
          TEXT_IN_1: u32,

        }), @ptrFromInt(0x60088024));

        /// source text material text_in_2 configure register
        pub const TEXT_IN_2 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] This bits stores text_in_2 that is a part of source text material.
          TEXT_IN_2: u32,

        }), @ptrFromInt(0x60088028));

        /// source text material text_in_3 configure register
        pub const TEXT_IN_3 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] This bits stores text_in_3 that is a part of source text material.
          TEXT_IN_3: u32,

        }), @ptrFromInt(0x6008802c));

        /// result text material text_out_0 configure register
        pub const TEXT_OUT_0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] This bits stores text_out_0 that is a part of result text material.
          TEXT_OUT_0: u32,

        }), @ptrFromInt(0x60088030));

        /// result text material text_out_1 configure register
        pub const TEXT_OUT_1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] This bits stores text_out_1 that is a part of result text material.
          TEXT_OUT_1: u32,

        }), @ptrFromInt(0x60088034));

        /// result text material text_out_2 configure register
        pub const TEXT_OUT_2 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] This bits stores text_out_2 that is a part of result text material.
          TEXT_OUT_2: u32,

        }), @ptrFromInt(0x60088038));

        /// result text material text_out_3 configure register
        pub const TEXT_OUT_3 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] This bits stores text_out_3 that is a part of result text material.
          TEXT_OUT_3: u32,

        }), @ptrFromInt(0x6008803c));

        /// AES Mode register
        pub const MODE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:2] This bits decides which one operation mode will be used. 3'd0: AES-EN-128, 3'd1: AES-EN-192, 3'd2: AES-EN-256, 3'd4: AES-DE-128, 3'd5: AES-DE-192, 3'd6: AES-DE-256.
          MODE: u3,

          /// [3:31] 
          res0: u29,

        }), @ptrFromInt(0x60088040));

        /// AES Endian configure register
        pub const ENDIAN = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] endian. [1:0] key endian, [3:2] text_in endian or in_stream endian,[5:4] text_out endian or out_stream endian
          ENDIAN: u6,

          /// [6:31] 
          res0: u26,

        }), @ptrFromInt(0x60088044));

        /// AES trigger register
        pub const TRIGGER = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Set this bit to start AES calculation.
          TRIGGER: u1,

          /// [1:31] 
          res0: u31,

        }), @ptrFromInt(0x60088048));

        /// AES state register
        pub const STATE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:1] Those bits shows AES status. For typical AES, 0: idle, 1: busy. For DMA-AES, 0: idle, 1: busy, 2: calculation_done.
          STATE: u2,

          /// [2:31] 
          res0: u30,

        }), @ptrFromInt(0x6008804c));

        /// The memory that stores initialization vector
        pub const IV_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x60088050));

        /// The memory that stores initialization vector
        pub const IV_MEM1 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x60088051));

        /// The memory that stores initialization vector
        pub const IV_MEM2 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x60088052));

        /// The memory that stores initialization vector
        pub const IV_MEM3 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x60088053));

        /// The memory that stores initialization vector
        pub const IV_MEM4 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x60088054));

        /// The memory that stores initialization vector
        pub const IV_MEM5 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x60088055));

        /// The memory that stores initialization vector
        pub const IV_MEM6 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x60088056));

        /// The memory that stores initialization vector
        pub const IV_MEM7 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x60088057));

        /// The memory that stores initialization vector
        pub const IV_MEM8 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x60088058));

        /// The memory that stores initialization vector
        pub const IV_MEM9 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x60088059));

        /// The memory that stores initialization vector
        pub const IV_MEM10 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008805a));

        /// The memory that stores initialization vector
        pub const IV_MEM11 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008805b));

        /// The memory that stores initialization vector
        pub const IV_MEM12 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008805c));

        /// The memory that stores initialization vector
        pub const IV_MEM13 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008805d));

        /// The memory that stores initialization vector
        pub const IV_MEM14 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008805e));

        /// The memory that stores initialization vector
        pub const IV_MEM15 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008805f));

        /// The memory that stores GCM hash subkey
        pub const H_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x60088060));

        /// The memory that stores GCM hash subkey
        pub const H_MEM1 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x60088061));

        /// The memory that stores GCM hash subkey
        pub const H_MEM2 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x60088062));

        /// The memory that stores GCM hash subkey
        pub const H_MEM3 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x60088063));

        /// The memory that stores GCM hash subkey
        pub const H_MEM4 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x60088064));

        /// The memory that stores GCM hash subkey
        pub const H_MEM5 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x60088065));

        /// The memory that stores GCM hash subkey
        pub const H_MEM6 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x60088066));

        /// The memory that stores GCM hash subkey
        pub const H_MEM7 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x60088067));

        /// The memory that stores GCM hash subkey
        pub const H_MEM8 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x60088068));

        /// The memory that stores GCM hash subkey
        pub const H_MEM9 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x60088069));

        /// The memory that stores GCM hash subkey
        pub const H_MEM10 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008806a));

        /// The memory that stores GCM hash subkey
        pub const H_MEM11 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008806b));

        /// The memory that stores GCM hash subkey
        pub const H_MEM12 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008806c));

        /// The memory that stores GCM hash subkey
        pub const H_MEM13 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008806d));

        /// The memory that stores GCM hash subkey
        pub const H_MEM14 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008806e));

        /// The memory that stores GCM hash subkey
        pub const H_MEM15 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008806f));

        /// The memory that stores J0
        pub const J0_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x60088070));

        /// The memory that stores J0
        pub const J0_MEM1 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x60088071));

        /// The memory that stores J0
        pub const J0_MEM2 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x60088072));

        /// The memory that stores J0
        pub const J0_MEM3 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x60088073));

        /// The memory that stores J0
        pub const J0_MEM4 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x60088074));

        /// The memory that stores J0
        pub const J0_MEM5 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x60088075));

        /// The memory that stores J0
        pub const J0_MEM6 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x60088076));

        /// The memory that stores J0
        pub const J0_MEM7 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x60088077));

        /// The memory that stores J0
        pub const J0_MEM8 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x60088078));

        /// The memory that stores J0
        pub const J0_MEM9 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x60088079));

        /// The memory that stores J0
        pub const J0_MEM10 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008807a));

        /// The memory that stores J0
        pub const J0_MEM11 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008807b));

        /// The memory that stores J0
        pub const J0_MEM12 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008807c));

        /// The memory that stores J0
        pub const J0_MEM13 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008807d));

        /// The memory that stores J0
        pub const J0_MEM14 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008807e));

        /// The memory that stores J0
        pub const J0_MEM15 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008807f));

        /// The memory that stores T0
        pub const T0_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x60088080));

        /// The memory that stores T0
        pub const T0_MEM1 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x60088081));

        /// The memory that stores T0
        pub const T0_MEM2 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x60088082));

        /// The memory that stores T0
        pub const T0_MEM3 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x60088083));

        /// The memory that stores T0
        pub const T0_MEM4 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x60088084));

        /// The memory that stores T0
        pub const T0_MEM5 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x60088085));

        /// The memory that stores T0
        pub const T0_MEM6 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x60088086));

        /// The memory that stores T0
        pub const T0_MEM7 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x60088087));

        /// The memory that stores T0
        pub const T0_MEM8 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x60088088));

        /// The memory that stores T0
        pub const T0_MEM9 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x60088089));

        /// The memory that stores T0
        pub const T0_MEM10 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008808a));

        /// The memory that stores T0
        pub const T0_MEM11 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008808b));

        /// The memory that stores T0
        pub const T0_MEM12 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008808c));

        /// The memory that stores T0
        pub const T0_MEM13 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008808d));

        /// The memory that stores T0
        pub const T0_MEM14 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008808e));

        /// The memory that stores T0
        pub const T0_MEM15 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008808f));

        /// DMA-AES working mode register
        pub const DMA_ENABLE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] 1'b0: typical AES working mode, 1'b1: DMA-AES working mode.
          DMA_ENABLE: u1,

          /// [1:31] 
          res0: u31,

        }), @ptrFromInt(0x60088090));

        /// AES cipher block mode register
        pub const BLOCK_MODE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:2] Those bits decides which block mode will be used. 0x0: ECB, 0x1: CBC, 0x2: OFB, 0x3: CTR, 0x4: CFB-8, 0x5: CFB-128, 0x6: GCM, 0x7: reserved.
          BLOCK_MODE: u3,

          /// [3:31] 
          res0: u29,

        }), @ptrFromInt(0x60088094));

        /// AES block number register
        pub const BLOCK_NUM = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Those bits stores the number of Plaintext/ciphertext block.
          BLOCK_NUM: u32,

        }), @ptrFromInt(0x60088098));

        /// Standard incrementing function configure register
        pub const INC_SEL = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] This bit decides the standard incrementing function. 0: INC32. 1: INC128.
          INC_SEL: u1,

          /// [1:31] 
          res0: u31,

        }), @ptrFromInt(0x6008809c));

        /// Additional Authential Data block number register
        pub const AAD_BLOCK_NUM = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Those bits stores the number of AAD block.
          AAD_BLOCK_NUM: u32,

        }), @ptrFromInt(0x600880a0));

        /// AES remainder bit number register
        pub const REMAINDER_BIT_NUM = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:6] Those bits stores the number of remainder bit.
          REMAINDER_BIT_NUM: u7,

          /// [7:31] 
          res0: u25,

        }), @ptrFromInt(0x600880a4));

        /// AES continue register
        pub const CONTINUE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Set this bit to continue GCM operation.
          CONTINUE: u1,

          /// [1:31] 
          res0: u31,

        }), @ptrFromInt(0x600880a8));

        /// AES Interrupt clear register
        pub const INT_CLEAR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Set this bit to clear the AES interrupt.
          INT_CLEAR: u1,

          /// [1:31] 
          res0: u31,

        }), @ptrFromInt(0x600880ac));

        /// AES Interrupt enable register
        pub const INT_ENA = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Set this bit to enable interrupt that occurs when DMA-AES calculation is done.
          INT_ENA: u1,

          /// [1:31] 
          res0: u31,

        }), @ptrFromInt(0x600880b0));

        /// AES version control register
        pub const DATE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:29] This bits stores the version information of AES.
          DATE: u30,

          /// [30:31] 
          res0: u2,

        }), @ptrFromInt(0x600880b4));

        /// AES-DMA exit config
        pub const DMA_EXIT = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Set this register to leave calculation done stage. Recommend to use it after software finishes reading DMA's output buffer.
          DMA_EXIT: u1,

          /// [1:31] 
          res0: u31,

        }), @ptrFromInt(0x600880b8));

      };

      /// SAR (Successive Approximation Register) Analog-to-Digital Converter
      pub const APB_SARADC = struct {

        /// digital saradc configure register
        pub const CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] select software enable saradc sample
          SARADC_START_FORCE: u1,

          /// [1:1] software enable saradc sample
          SARADC_START: u1,

          /// [2:5] 
          res0: u4,

          /// [6:6] SAR clock gated
          SARADC_SAR_CLK_GATED: u1,

          /// [7:14] SAR clock divider
          SARADC_SAR_CLK_DIV: u8,

          /// [15:17] 0 ~ 15 means length 1 ~ 16
          SARADC_SAR_PATT_LEN: u3,

          /// [18:22] 
          res1: u5,

          /// [23:23] clear the pointer of pattern table for DIG ADC1 CTRL
          SARADC_SAR_PATT_P_CLEAR: u1,

          /// [24:26] 
          res2: u3,

          /// [27:28] force option to xpd sar blocks
          SARADC_XPD_SAR_FORCE: u2,

          /// [29:29] enable saradc2 power detect driven func.
          SARADC2_PWDET_DRV: u1,

          /// [30:31] wait arbit signal stable after sar_done
          SARADC_WAIT_ARB_CYCLE: u2,

        }), @ptrFromInt(0x6000e000));

        /// digital saradc configure register
        pub const CTRL2 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] enable max meas num
          SARADC_MEAS_NUM_LIMIT: u1,

          /// [1:8] max conversion number
          SARADC_MAX_MEAS_NUM: u8,

          /// [9:9] 1: data to DIG ADC1 CTRL is inverted, otherwise not
          SARADC_SAR1_INV: u1,

          /// [10:10] 1: data to DIG ADC2 CTRL is inverted, otherwise not
          SARADC_SAR2_INV: u1,

          /// [11:11] 
          res0: u1,

          /// [12:23] to set saradc timer target
          SARADC_TIMER_TARGET: u12,

          /// [24:24] to enable saradc timer trigger
          SARADC_TIMER_EN: u1,

          /// [25:31] 
          res1: u7,

        }), @ptrFromInt(0x6000e004));

        /// digital saradc configure register
        pub const FILTER_CTRL1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:25] 
          res0: u26,

          /// [26:28] Factor of saradc filter1
          APB_SARADC_FILTER_FACTOR1: u3,

          /// [29:31] Factor of saradc filter0
          APB_SARADC_FILTER_FACTOR0: u3,

        }), @ptrFromInt(0x6000e008));

        /// digital saradc configure register
        pub const FSM_WAIT = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] saradc_xpd_wait
          SARADC_XPD_WAIT: u8,

          /// [8:15] saradc_rstb_wait
          SARADC_RSTB_WAIT: u8,

          /// [16:23] saradc_standby_wait
          SARADC_STANDBY_WAIT: u8,

          /// [24:31] 
          res0: u8,

        }), @ptrFromInt(0x6000e00c));

        /// digital saradc configure register
        pub const SAR1_STATUS = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] saradc1 status about data and channel
          SARADC_SAR1_STATUS: u32,

        }), @ptrFromInt(0x6000e010));

        /// digital saradc configure register
        pub const SAR2_STATUS = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] saradc2 status about data and channel
          SARADC_SAR2_STATUS: u32,

        }), @ptrFromInt(0x6000e014));

        /// digital saradc configure register
        pub const SAR_PATT_TAB1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:23] item 0 ~ 3 for pattern table 1 (each item one byte)
          SARADC_SAR_PATT_TAB1: u24,

          /// [24:31] 
          res0: u8,

        }), @ptrFromInt(0x6000e018));

        /// digital saradc configure register
        pub const SAR_PATT_TAB2 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:23] Item 4 ~ 7 for pattern table 1 (each item one byte)
          SARADC_SAR_PATT_TAB2: u24,

          /// [24:31] 
          res0: u8,

        }), @ptrFromInt(0x6000e01c));

        /// digital saradc configure register
        pub const ONETIME_SAMPLE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:22] 
          res0: u23,

          /// [23:24] configure onetime atten
          SARADC_ONETIME_ATTEN: u2,

          /// [25:28] configure onetime channel
          SARADC_ONETIME_CHANNEL: u4,

          /// [29:29] trigger adc onetime sample
          SARADC_ONETIME_START: u1,

          /// [30:30] enable adc2 onetime sample
          SARADC2_ONETIME_SAMPLE: u1,

          /// [31:31] enable adc1 onetime sample
          SARADC1_ONETIME_SAMPLE: u1,

        }), @ptrFromInt(0x6000e020));

        /// digital saradc configure register
        pub const ARB_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:1] 
          res0: u2,

          /// [2:2] adc2 arbiter force to enableapb controller
          ADC_ARB_APB_FORCE: u1,

          /// [3:3] adc2 arbiter force to enable rtc controller
          ADC_ARB_RTC_FORCE: u1,

          /// [4:4] adc2 arbiter force to enable wifi controller
          ADC_ARB_WIFI_FORCE: u1,

          /// [5:5] adc2 arbiter force grant
          ADC_ARB_GRANT_FORCE: u1,

          /// [6:7] Set adc2 arbiterapb priority
          ADC_ARB_APB_PRIORITY: u2,

          /// [8:9] Set adc2 arbiter rtc priority
          ADC_ARB_RTC_PRIORITY: u2,

          /// [10:11] Set adc2 arbiter wifi priority
          ADC_ARB_WIFI_PRIORITY: u2,

          /// [12:12] adc2 arbiter uses fixed priority
          ADC_ARB_FIX_PRIORITY: u1,

          /// [13:31] 
          res1: u19,

        }), @ptrFromInt(0x6000e024));

        /// digital saradc configure register
        pub const FILTER_CTRL0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:17] 
          res0: u18,

          /// [18:21] configure filter1 to adc channel
          APB_SARADC_FILTER_CHANNEL1: u4,

          /// [22:25] configure filter0 to adc channel
          APB_SARADC_FILTER_CHANNEL0: u4,

          /// [26:30] 
          res1: u5,

          /// [31:31] enable apb_adc1_filter
          APB_SARADC_FILTER_RESET: u1,

        }), @ptrFromInt(0x6000e028));

        /// digital saradc configure register
        pub const SAR1DATA_STATUS = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:16] saradc1 data
          APB_SARADC1_DATA: u17,

          /// [17:31] 
          res0: u15,

        }), @ptrFromInt(0x6000e02c));

        /// digital saradc configure register
        pub const SAR2DATA_STATUS = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:16] saradc2 data
          APB_SARADC2_DATA: u17,

          /// [17:31] 
          res0: u15,

        }), @ptrFromInt(0x6000e030));

        /// digital saradc configure register
        pub const THRES0_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:3] configure thres0 to adc channel
          APB_SARADC_THRES0_CHANNEL: u4,

          /// [4:4] 
          res0: u1,

          /// [5:17] saradc thres0 monitor thres
          APB_SARADC_THRES0_HIGH: u13,

          /// [18:30] saradc thres0 monitor thres
          APB_SARADC_THRES0_LOW: u13,

          /// [31:31] 
          res1: u1,

        }), @ptrFromInt(0x6000e034));

        /// digital saradc configure register
        pub const THRES1_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:3] configure thres1 to adc channel
          APB_SARADC_THRES1_CHANNEL: u4,

          /// [4:4] 
          res0: u1,

          /// [5:17] saradc thres1 monitor thres
          APB_SARADC_THRES1_HIGH: u13,

          /// [18:30] saradc thres1 monitor thres
          APB_SARADC_THRES1_LOW: u13,

          /// [31:31] 
          res1: u1,

        }), @ptrFromInt(0x6000e038));

        /// digital saradc configure register
        pub const THRES_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:26] 
          res0: u27,

          /// [27:27] enable thres to all channel
          APB_SARADC_THRES_ALL_EN: u1,

          /// [28:29] 
          res1: u2,

          /// [30:30] enable thres1
          APB_SARADC_THRES1_EN: u1,

          /// [31:31] enable thres0
          APB_SARADC_THRES0_EN: u1,

        }), @ptrFromInt(0x6000e03c));

        /// digital saradc int register
        pub const INT_ENA = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:24] 
          res0: u25,

          /// [25:25] tsens lowinterrupt enable
          APB_SARADC_TSENS_INT_ENA: u1,

          /// [26:26] saradc thres1 lowinterrupt enable
          APB_SARADC_THRES1_LOW_INT_ENA: u1,

          /// [27:27] saradc thres0 low interrupt enable
          APB_SARADC_THRES0_LOW_INT_ENA: u1,

          /// [28:28] saradc thres1 high interrupt enable
          APB_SARADC_THRES1_HIGH_INT_ENA: u1,

          /// [29:29] saradc thres0 high interrupt enable
          APB_SARADC_THRES0_HIGH_INT_ENA: u1,

          /// [30:30] saradc2 done interrupt enable
          APB_SARADC2_DONE_INT_ENA: u1,

          /// [31:31] saradc1 done interrupt enable
          APB_SARADC1_DONE_INT_ENA: u1,

        }), @ptrFromInt(0x6000e040));

        /// digital saradc int register
        pub const INT_RAW = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:24] 
          res0: u25,

          /// [25:25] saradc tsensinterrupt raw
          APB_SARADC_TSENS_INT_RAW: u1,

          /// [26:26] saradc thres1 lowinterrupt raw
          APB_SARADC_THRES1_LOW_INT_RAW: u1,

          /// [27:27] saradc thres0 low interrupt raw
          APB_SARADC_THRES0_LOW_INT_RAW: u1,

          /// [28:28] saradc thres1 high interrupt raw
          APB_SARADC_THRES1_HIGH_INT_RAW: u1,

          /// [29:29] saradc thres0 high interrupt raw
          APB_SARADC_THRES0_HIGH_INT_RAW: u1,

          /// [30:30] saradc2 done interrupt raw
          APB_SARADC2_DONE_INT_RAW: u1,

          /// [31:31] saradc1 done interrupt raw
          APB_SARADC1_DONE_INT_RAW: u1,

        }), @ptrFromInt(0x6000e044));

        /// digital saradc int register
        pub const INT_ST = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:24] 
          res0: u25,

          /// [25:25] saradc tsensinterrupt state
          APB_SARADC_TSENS_INT_ST: u1,

          /// [26:26] saradc thres1 lowinterrupt state
          APB_SARADC_THRES1_LOW_INT_ST: u1,

          /// [27:27] saradc thres0 low interrupt state
          APB_SARADC_THRES0_LOW_INT_ST: u1,

          /// [28:28] saradc thres1 high interrupt state
          APB_SARADC_THRES1_HIGH_INT_ST: u1,

          /// [29:29] saradc thres0 high interrupt state
          APB_SARADC_THRES0_HIGH_INT_ST: u1,

          /// [30:30] saradc2 done interrupt state
          APB_SARADC2_DONE_INT_ST: u1,

          /// [31:31] saradc1 done interrupt state
          APB_SARADC1_DONE_INT_ST: u1,

        }), @ptrFromInt(0x6000e048));

        /// digital saradc int register
        pub const INT_CLR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:24] 
          res0: u25,

          /// [25:25] saradc tsensinterrupt clear
          APB_SARADC_TSENS_INT_CLR: u1,

          /// [26:26] saradc thres1 lowinterrupt clear
          APB_SARADC_THRES1_LOW_INT_CLR: u1,

          /// [27:27] saradc thres0 low interrupt clear
          APB_SARADC_THRES0_LOW_INT_CLR: u1,

          /// [28:28] saradc thres1 high interrupt clear
          APB_SARADC_THRES1_HIGH_INT_CLR: u1,

          /// [29:29] saradc thres0 high interrupt clear
          APB_SARADC_THRES0_HIGH_INT_CLR: u1,

          /// [30:30] saradc2 done interrupt clear
          APB_SARADC2_DONE_INT_CLR: u1,

          /// [31:31] saradc1 done interrupt clear
          APB_SARADC1_DONE_INT_CLR: u1,

        }), @ptrFromInt(0x6000e04c));

        /// digital saradc configure register
        pub const DMA_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:15] the dma_in_suc_eof gen when sample cnt = spi_eof_num
          APB_ADC_EOF_NUM: u16,

          /// [16:29] 
          res0: u14,

          /// [30:30] reset_apb_adc_state
          APB_ADC_RESET_FSM: u1,

          /// [31:31] enable apb_adc use spi_dma
          APB_ADC_TRANS: u1,

        }), @ptrFromInt(0x6000e050));

        /// digital saradc configure register
        pub const CLKM_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] Integral I2S clock divider value
          CLKM_DIV_NUM: u8,

          /// [8:13] Fractional clock divider numerator value
          CLKM_DIV_B: u6,

          /// [14:19] Fractional clock divider denominator value
          CLKM_DIV_A: u6,

          /// [20:20] reg clk en
          CLK_EN: u1,

          /// [21:22] Set this bit to enable clk_apll
          CLK_SEL: u2,

          /// [23:31] 
          res0: u9,

        }), @ptrFromInt(0x6000e054));

        /// digital tsens configure register
        pub const APB_TSENS_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] temperature sensor data out
          TSENS_OUT: u8,

          /// [8:12] 
          res0: u5,

          /// [13:13] invert temperature sensor data
          TSENS_IN_INV: u1,

          /// [14:21] temperature sensor clock divider
          TSENS_CLK_DIV: u8,

          /// [22:22] temperature sensor power up
          TSENS_PU: u1,

          /// [23:31] 
          res1: u9,

        }), @ptrFromInt(0x6000e058));

        /// digital tsens configure register
        pub const TSENS_CTRL2 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:11] the time that power up tsens need wait
          TSENS_XPD_WAIT: u12,

          /// [12:13] force power up tsens
          TSENS_XPD_FORCE: u2,

          /// [14:14] inv tsens clk
          TSENS_CLK_INV: u1,

          /// [15:15] tsens clk select
          TSENS_CLK_SEL: u1,

          /// [16:31] 
          res0: u16,

        }), @ptrFromInt(0x6000e05c));

        /// digital saradc configure register
        pub const CALI = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:16] saradc cali factor
          APB_SARADC_CALI_CFG: u17,

          /// [17:31] 
          res0: u15,

        }), @ptrFromInt(0x6000e060));

        /// digital tsens configure register
        pub const APB_TSENS_WAKE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] reg_wakeup_th_low
          WAKEUP_TH_LOW: u8,

          /// [8:15] reg_wakeup_th_high
          WAKEUP_TH_HIGH: u8,

          /// [16:16] reg_wakeup_over_upper_th
          WAKEUP_OVER_UPPER_TH: u1,

          /// [17:17] reg_wakeup_mode
          WAKEUP_MODE: u1,

          /// [18:18] reg_wakeup_en
          WAKEUP_EN: u1,

          /// [19:31] 
          res0: u13,

        }), @ptrFromInt(0x6000e064));

        /// digital tsens configure register
        pub const APB_TSENS_SAMPLE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:15] HW sample rate
          TSENS_SAMPLE_RATE: u16,

          /// [16:16] HW sample en
          TSENS_SAMPLE_EN: u1,

          /// [17:31] 
          res0: u15,

        }), @ptrFromInt(0x6000e068));

        /// version
        pub const CTRL_DATE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] version
          DATE: u32,

        }), @ptrFromInt(0x6000e3fc));

      };

      /// Debug Assist
      pub const ASSIST_DEBUG = struct {

        /// core0 monitor enable configuration register
        pub const CORE_0_MONTR_ENA = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Core0 dram0 area0 read monitor enable
          CORE_0_AREA_DRAM0_0_RD_ENA: u1,

          /// [1:1] Core0 dram0 area0 write monitor enable
          CORE_0_AREA_DRAM0_0_WR_ENA: u1,

          /// [2:2] Core0 dram0 area1 read monitor enable
          CORE_0_AREA_DRAM0_1_RD_ENA: u1,

          /// [3:3] Core0 dram0 area1 write monitor enable
          CORE_0_AREA_DRAM0_1_WR_ENA: u1,

          /// [4:4] Core0 PIF area0 read monitor enable
          CORE_0_AREA_PIF_0_RD_ENA: u1,

          /// [5:5] Core0 PIF area0 write monitor enable
          CORE_0_AREA_PIF_0_WR_ENA: u1,

          /// [6:6] Core0 PIF area1 read monitor enable
          CORE_0_AREA_PIF_1_RD_ENA: u1,

          /// [7:7] Core0 PIF area1 write monitor enable
          CORE_0_AREA_PIF_1_WR_ENA: u1,

          /// [8:8] Core0 stackpoint underflow monitor enable
          CORE_0_SP_SPILL_MIN_ENA: u1,

          /// [9:9] Core0 stackpoint overflow monitor enable
          CORE_0_SP_SPILL_MAX_ENA: u1,

          /// [10:10] IBUS busy monitor enable
          CORE_0_IRAM0_EXCEPTION_MONITOR_ENA: u1,

          /// [11:11] DBUS busy monitor enbale
          CORE_0_DRAM0_EXCEPTION_MONITOR_ENA: u1,

          /// [12:31] 
          res0: u20,

        }), @ptrFromInt(0x600c2000));

        /// core0 monitor interrupt status register
        pub const CORE_0_INTR_RAW = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Core0 dram0 area0 read monitor interrupt status
          CORE_0_AREA_DRAM0_0_RD_RAW: u1,

          /// [1:1] Core0 dram0 area0 write monitor interrupt status
          CORE_0_AREA_DRAM0_0_WR_RAW: u1,

          /// [2:2] Core0 dram0 area1 read monitor interrupt status
          CORE_0_AREA_DRAM0_1_RD_RAW: u1,

          /// [3:3] Core0 dram0 area1 write monitor interrupt status
          CORE_0_AREA_DRAM0_1_WR_RAW: u1,

          /// [4:4] Core0 PIF area0 read monitor interrupt status
          CORE_0_AREA_PIF_0_RD_RAW: u1,

          /// [5:5] Core0 PIF area0 write monitor interrupt status
          CORE_0_AREA_PIF_0_WR_RAW: u1,

          /// [6:6] Core0 PIF area1 read monitor interrupt status
          CORE_0_AREA_PIF_1_RD_RAW: u1,

          /// [7:7] Core0 PIF area1 write monitor interrupt status
          CORE_0_AREA_PIF_1_WR_RAW: u1,

          /// [8:8] Core0 stackpoint underflow monitor interrupt status
          CORE_0_SP_SPILL_MIN_RAW: u1,

          /// [9:9] Core0 stackpoint overflow monitor interrupt status
          CORE_0_SP_SPILL_MAX_RAW: u1,

          /// [10:10] IBUS busy monitor interrupt status
          CORE_0_IRAM0_EXCEPTION_MONITOR_RAW: u1,

          /// [11:11] DBUS busy monitor initerrupt status
          CORE_0_DRAM0_EXCEPTION_MONITOR_RAW: u1,

          /// [12:31] 
          res0: u20,

        }), @ptrFromInt(0x600c2004));

        /// core0 monitor interrupt enable register
        pub const CORE_0_INTR_ENA = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Core0 dram0 area0 read monitor interrupt enable
          CORE_0_AREA_DRAM0_0_RD_INTR_ENA: u1,

          /// [1:1] Core0 dram0 area0 write monitor interrupt enable
          CORE_0_AREA_DRAM0_0_WR_INTR_ENA: u1,

          /// [2:2] Core0 dram0 area1 read monitor interrupt enable
          CORE_0_AREA_DRAM0_1_RD_INTR_ENA: u1,

          /// [3:3] Core0 dram0 area1 write monitor interrupt enable
          CORE_0_AREA_DRAM0_1_WR_INTR_ENA: u1,

          /// [4:4] Core0 PIF area0 read monitor interrupt enable
          CORE_0_AREA_PIF_0_RD_INTR_ENA: u1,

          /// [5:5] Core0 PIF area0 write monitor interrupt enable
          CORE_0_AREA_PIF_0_WR_INTR_ENA: u1,

          /// [6:6] Core0 PIF area1 read monitor interrupt enable
          CORE_0_AREA_PIF_1_RD_INTR_ENA: u1,

          /// [7:7] Core0 PIF area1 write monitor interrupt enable
          CORE_0_AREA_PIF_1_WR_INTR_ENA: u1,

          /// [8:8] Core0 stackpoint underflow monitor interrupt enable
          CORE_0_SP_SPILL_MIN_INTR_ENA: u1,

          /// [9:9] Core0 stackpoint overflow monitor interrupt enable
          CORE_0_SP_SPILL_MAX_INTR_ENA: u1,

          /// [10:10] IBUS busy monitor interrupt enable
          CORE_0_IRAM0_EXCEPTION_MONITOR_INTR_ENA: u1,

          /// [11:11] DBUS busy monitor interrupt enbale
          CORE_0_DRAM0_EXCEPTION_MONITOR_INTR_ENA: u1,

          /// [12:31] 
          res0: u20,

        }), @ptrFromInt(0x600c2008));

        /// core0 monitor interrupt clr register
        pub const CORE_0_INTR_CLR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Core0 dram0 area0 read monitor interrupt clr
          CORE_0_AREA_DRAM0_0_RD_CLR: u1,

          /// [1:1] Core0 dram0 area0 write monitor interrupt clr
          CORE_0_AREA_DRAM0_0_WR_CLR: u1,

          /// [2:2] Core0 dram0 area1 read monitor interrupt clr
          CORE_0_AREA_DRAM0_1_RD_CLR: u1,

          /// [3:3] Core0 dram0 area1 write monitor interrupt clr
          CORE_0_AREA_DRAM0_1_WR_CLR: u1,

          /// [4:4] Core0 PIF area0 read monitor interrupt clr
          CORE_0_AREA_PIF_0_RD_CLR: u1,

          /// [5:5] Core0 PIF area0 write monitor interrupt clr
          CORE_0_AREA_PIF_0_WR_CLR: u1,

          /// [6:6] Core0 PIF area1 read monitor interrupt clr
          CORE_0_AREA_PIF_1_RD_CLR: u1,

          /// [7:7] Core0 PIF area1 write monitor interrupt clr
          CORE_0_AREA_PIF_1_WR_CLR: u1,

          /// [8:8] Core0 stackpoint underflow monitor interrupt clr
          CORE_0_SP_SPILL_MIN_CLR: u1,

          /// [9:9] Core0 stackpoint overflow monitor interrupt clr
          CORE_0_SP_SPILL_MAX_CLR: u1,

          /// [10:10] IBUS busy monitor interrupt clr
          CORE_0_IRAM0_EXCEPTION_MONITOR_CLR: u1,

          /// [11:11] DBUS busy monitor interrupt clr
          CORE_0_DRAM0_EXCEPTION_MONITOR_CLR: u1,

          /// [12:31] 
          res0: u20,

        }), @ptrFromInt(0x600c200c));

        /// core0 dram0 region0 addr configuration register
        pub const CORE_0_AREA_DRAM0_0_MIN = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Core0 dram0 region0 start addr
          CORE_0_AREA_DRAM0_0_MIN: u32,

        }), @ptrFromInt(0x600c2010));

        /// core0 dram0 region0 addr configuration register
        pub const CORE_0_AREA_DRAM0_0_MAX = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Core0 dram0 region0 end addr
          CORE_0_AREA_DRAM0_0_MAX: u32,

        }), @ptrFromInt(0x600c2014));

        /// core0 dram0 region1 addr configuration register
        pub const CORE_0_AREA_DRAM0_1_MIN = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Core0 dram0 region1 start addr
          CORE_0_AREA_DRAM0_1_MIN: u32,

        }), @ptrFromInt(0x600c2018));

        /// core0 dram0 region1 addr configuration register
        pub const CORE_0_AREA_DRAM0_1_MAX = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Core0 dram0 region1 end addr
          CORE_0_AREA_DRAM0_1_MAX: u32,

        }), @ptrFromInt(0x600c201c));

        /// core0 PIF region0 addr configuration register
        pub const CORE_0_AREA_PIF_0_MIN = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Core0 PIF region0 start addr
          CORE_0_AREA_PIF_0_MIN: u32,

        }), @ptrFromInt(0x600c2020));

        /// core0 PIF region0 addr configuration register
        pub const CORE_0_AREA_PIF_0_MAX = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Core0 PIF region0 end addr
          CORE_0_AREA_PIF_0_MAX: u32,

        }), @ptrFromInt(0x600c2024));

        /// core0 PIF region1 addr configuration register
        pub const CORE_0_AREA_PIF_1_MIN = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Core0 PIF region1 start addr
          CORE_0_AREA_PIF_1_MIN: u32,

        }), @ptrFromInt(0x600c2028));

        /// core0 PIF region1 addr configuration register
        pub const CORE_0_AREA_PIF_1_MAX = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Core0 PIF region1 end addr
          CORE_0_AREA_PIF_1_MAX: u32,

        }), @ptrFromInt(0x600c202c));

        /// core0 area pc status register
        pub const CORE_0_AREA_PC = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] the stackpointer when first touch region monitor interrupt
          CORE_0_AREA_PC: u32,

        }), @ptrFromInt(0x600c2030));

        /// core0 area sp status register
        pub const CORE_0_AREA_SP = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] the PC when first touch region monitor interrupt
          CORE_0_AREA_SP: u32,

        }), @ptrFromInt(0x600c2034));

        /// stack min value
        pub const CORE_0_SP_MIN = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] core0 sp region configuration regsiter
          CORE_0_SP_MIN: u32,

        }), @ptrFromInt(0x600c2038));

        /// stack max value
        pub const CORE_0_SP_MAX = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] core0 sp pc status register
          CORE_0_SP_MAX: u32,

        }), @ptrFromInt(0x600c203c));

        /// stack monitor pc status register
        pub const CORE_0_SP_PC = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] This regsiter stores the PC when trigger stack monitor.
          CORE_0_SP_PC: u32,

        }), @ptrFromInt(0x600c2040));

        /// record enable configuration register
        pub const CORE_0_RCD_EN = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Set 1 to enable record PC
          CORE_0_RCD_RECORDEN: u1,

          /// [1:1] Set 1 to enable cpu pdebug function, must set this bit can get cpu PC
          CORE_0_RCD_PDEBUGEN: u1,

          /// [2:31] 
          res0: u30,

        }), @ptrFromInt(0x600c2044));

        /// record status regsiter
        pub const CORE_0_RCD_PDEBUGPC = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] recorded PC
          CORE_0_RCD_PDEBUGPC: u32,

        }), @ptrFromInt(0x600c2048));

        /// record status regsiter
        pub const CORE_0_RCD_PDEBUGSP = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] recorded sp
          CORE_0_RCD_PDEBUGSP: u32,

        }), @ptrFromInt(0x600c204c));

        /// exception monitor status register0
        pub const CORE_0_IRAM0_EXCEPTION_MONITOR_0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:23] reg_core_0_iram0_recording_addr_0
          CORE_0_IRAM0_RECORDING_ADDR_0: u24,

          /// [24:24] reg_core_0_iram0_recording_wr_0
          CORE_0_IRAM0_RECORDING_WR_0: u1,

          /// [25:25] reg_core_0_iram0_recording_loadstore_0
          CORE_0_IRAM0_RECORDING_LOADSTORE_0: u1,

          /// [26:31] 
          res0: u6,

        }), @ptrFromInt(0x600c2050));

        /// exception monitor status register1
        pub const CORE_0_IRAM0_EXCEPTION_MONITOR_1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:23] reg_core_0_iram0_recording_addr_1
          CORE_0_IRAM0_RECORDING_ADDR_1: u24,

          /// [24:24] reg_core_0_iram0_recording_wr_1
          CORE_0_IRAM0_RECORDING_WR_1: u1,

          /// [25:25] reg_core_0_iram0_recording_loadstore_1
          CORE_0_IRAM0_RECORDING_LOADSTORE_1: u1,

          /// [26:31] 
          res0: u6,

        }), @ptrFromInt(0x600c2054));

        /// exception monitor status register2
        pub const CORE_0_DRAM0_EXCEPTION_MONITOR_0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:23] reg_core_0_dram0_recording_addr_0
          CORE_0_DRAM0_RECORDING_ADDR_0: u24,

          /// [24:24] reg_core_0_dram0_recording_wr_0
          CORE_0_DRAM0_RECORDING_WR_0: u1,

          /// [25:28] reg_core_0_dram0_recording_byteen_0
          CORE_0_DRAM0_RECORDING_BYTEEN_0: u4,

          /// [29:31] 
          res0: u3,

        }), @ptrFromInt(0x600c2058));

        /// exception monitor status register3
        pub const CORE_0_DRAM0_EXCEPTION_MONITOR_1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] reg_core_0_dram0_recording_pc_0
          CORE_0_DRAM0_RECORDING_PC_0: u32,

        }), @ptrFromInt(0x600c205c));

        /// exception monitor status register4
        pub const CORE_0_DRAM0_EXCEPTION_MONITOR_2 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:23] reg_core_0_dram0_recording_addr_1
          CORE_0_DRAM0_RECORDING_ADDR_1: u24,

          /// [24:24] reg_core_0_dram0_recording_wr_1
          CORE_0_DRAM0_RECORDING_WR_1: u1,

          /// [25:28] reg_core_0_dram0_recording_byteen_1
          CORE_0_DRAM0_RECORDING_BYTEEN_1: u4,

          /// [29:31] 
          res0: u3,

        }), @ptrFromInt(0x600c2060));

        /// exception monitor status register5
        pub const CORE_0_DRAM0_EXCEPTION_MONITOR_3 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] reg_core_0_dram0_recording_pc_1
          CORE_0_DRAM0_RECORDING_PC_1: u32,

        }), @ptrFromInt(0x600c2064));

        /// exception monitor status register6
        pub const CORE_X_IRAM0_DRAM0_EXCEPTION_MONITOR_0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:19] reg_core_x_iram0_dram0_limit_cycle_0
          CORE_X_IRAM0_DRAM0_LIMIT_CYCLE_0: u20,

          /// [20:31] 
          res0: u12,

        }), @ptrFromInt(0x600c2068));

        /// exception monitor status register7
        pub const CORE_X_IRAM0_DRAM0_EXCEPTION_MONITOR_1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:19] reg_core_x_iram0_dram0_limit_cycle_1
          CORE_X_IRAM0_DRAM0_LIMIT_CYCLE_1: u20,

          /// [20:31] 
          res0: u12,

        }), @ptrFromInt(0x600c206c));

        /// cpu status register
        pub const C0RE_0_LASTPC_BEFORE_EXCEPTION = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] cpu's lastpc before exception
          CORE_0_LASTPC_BEFORE_EXC: u32,

        }), @ptrFromInt(0x600c2070));

        /// cpu status register
        pub const C0RE_0_DEBUG_MODE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] cpu debug mode status, 1 means cpu enter debug mode.
          CORE_0_DEBUG_MODE: u1,

          /// [1:1] cpu debug_module active status
          CORE_0_DEBUG_MODULE_ACTIVE: u1,

          /// [2:31] 
          res0: u30,

        }), @ptrFromInt(0x600c2074));

        /// clock register
        pub const CLOCK_GATE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Set 1 force on the clock gate
          CLK_EN: u1,

          /// [1:31] 
          res0: u31,

        }), @ptrFromInt(0x600c2078));

        /// version register
        pub const DATE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:27] version register
          ASSIST_DEBUG_DATE: u28,

          /// [28:31] 
          res0: u4,

        }), @ptrFromInt(0x600c23fc));

      };

      /// Atomic Locker
      pub const ATOMIC = struct {

        /// hardware lock regsiter
        pub const ADDR_LOCK = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:1] read to acquire hardware lock, write to release hardware lock
          LOCK: u2,

          /// [2:31] 
          res0: u30,

        }), @ptrFromInt(0x60011000));

        /// gloable lr address regsiter
        pub const LR_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] backup gloable address
          GLOABLE_LR_ADDR: u32,

        }), @ptrFromInt(0x60011004));

        /// gloable lr value regsiter
        pub const LR_VALUE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] backup gloable value
          GLOABLE_LR_VALUE: u32,

        }), @ptrFromInt(0x60011008));

        /// lock status regsiter
        pub const LOCK_STATUS = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:1] read hareware lock status for debug
          LOCK_STATUS: u2,

          /// [2:31] 
          res0: u30,

        }), @ptrFromInt(0x6001100c));

        /// wait counter register
        pub const COUNTER = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:15] delay counter
          WAIT_COUNTER: u16,

          /// [16:31] 
          res0: u16,

        }), @ptrFromInt(0x60011010));

      };

      /// DMA (Direct Memory Access) Controller
      pub const DMA = struct {

        /// Raw status interrupt of channel 0
        pub const IN_INT_RAW_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] The raw interrupt bit turns to high level when the last data pointed by one inlink descriptor has been received for Rx channel 0.
          IN_DONE: u1,

          /// [1:1] The raw interrupt bit turns to high level when the last data pointed by one inlink descriptor has been received for Rx channel 0. For UHCI0 the raw interrupt bit turns to high level when the last data pointed by one inlink descriptor has been received and no data error is detected for Rx channel 0.
          IN_SUC_EOF: u1,

          /// [2:2] The raw interrupt bit turns to high level when data error is detected only in the case that the peripheral is UHCI0 for Rx channel 0. For other peripherals this raw interrupt is reserved.
          IN_ERR_EOF: u1,

          /// [3:3] The raw interrupt bit turns to high level when detecting inlink descriptor error including owner error and the second and third word error of inlink descriptor for Rx channel 0.
          IN_DSCR_ERR: u1,

          /// [4:4] The raw interrupt bit turns to high level when Rx buffer pointed by inlink is full and receiving data is not completed but there is no more inlink for Rx channel 0.
          IN_DSCR_EMPTY: u1,

          /// [5:5] This raw interrupt bit turns to high level when level 1 fifo of Rx channel 0 is overflow.
          INFIFO_OVF: u1,

          /// [6:6] This raw interrupt bit turns to high level when level 1 fifo of Rx channel 0 is underflow.
          INFIFO_UDF: u1,

          /// [7:31] 
          res0: u25,

        }), @ptrFromInt(0x60080000));

        /// Raw status interrupt of channel 0
        pub const IN_INT_RAW_CH1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] The raw interrupt bit turns to high level when the last data pointed by one inlink descriptor has been received for Rx channel 0.
          IN_DONE: u1,

          /// [1:1] The raw interrupt bit turns to high level when the last data pointed by one inlink descriptor has been received for Rx channel 0. For UHCI0 the raw interrupt bit turns to high level when the last data pointed by one inlink descriptor has been received and no data error is detected for Rx channel 0.
          IN_SUC_EOF: u1,

          /// [2:2] The raw interrupt bit turns to high level when data error is detected only in the case that the peripheral is UHCI0 for Rx channel 0. For other peripherals this raw interrupt is reserved.
          IN_ERR_EOF: u1,

          /// [3:3] The raw interrupt bit turns to high level when detecting inlink descriptor error including owner error and the second and third word error of inlink descriptor for Rx channel 0.
          IN_DSCR_ERR: u1,

          /// [4:4] The raw interrupt bit turns to high level when Rx buffer pointed by inlink is full and receiving data is not completed but there is no more inlink for Rx channel 0.
          IN_DSCR_EMPTY: u1,

          /// [5:5] This raw interrupt bit turns to high level when level 1 fifo of Rx channel 0 is overflow.
          INFIFO_OVF: u1,

          /// [6:6] This raw interrupt bit turns to high level when level 1 fifo of Rx channel 0 is underflow.
          INFIFO_UDF: u1,

          /// [7:31] 
          res0: u25,

        }), @ptrFromInt(0x60080004));

        /// Raw status interrupt of channel 0
        pub const IN_INT_RAW_CH2 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] The raw interrupt bit turns to high level when the last data pointed by one inlink descriptor has been received for Rx channel 0.
          IN_DONE: u1,

          /// [1:1] The raw interrupt bit turns to high level when the last data pointed by one inlink descriptor has been received for Rx channel 0. For UHCI0 the raw interrupt bit turns to high level when the last data pointed by one inlink descriptor has been received and no data error is detected for Rx channel 0.
          IN_SUC_EOF: u1,

          /// [2:2] The raw interrupt bit turns to high level when data error is detected only in the case that the peripheral is UHCI0 for Rx channel 0. For other peripherals this raw interrupt is reserved.
          IN_ERR_EOF: u1,

          /// [3:3] The raw interrupt bit turns to high level when detecting inlink descriptor error including owner error and the second and third word error of inlink descriptor for Rx channel 0.
          IN_DSCR_ERR: u1,

          /// [4:4] The raw interrupt bit turns to high level when Rx buffer pointed by inlink is full and receiving data is not completed but there is no more inlink for Rx channel 0.
          IN_DSCR_EMPTY: u1,

          /// [5:5] This raw interrupt bit turns to high level when level 1 fifo of Rx channel 0 is overflow.
          INFIFO_OVF: u1,

          /// [6:6] This raw interrupt bit turns to high level when level 1 fifo of Rx channel 0 is underflow.
          INFIFO_UDF: u1,

          /// [7:31] 
          res0: u25,

        }), @ptrFromInt(0x60080008));

        /// Masked interrupt of channel 0
        pub const IN_INT_ST_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] The raw interrupt status bit for the IN_DONE_CH_INT interrupt.
          IN_DONE: u1,

          /// [1:1] The raw interrupt status bit for the IN_SUC_EOF_CH_INT interrupt.
          IN_SUC_EOF: u1,

          /// [2:2] The raw interrupt status bit for the IN_ERR_EOF_CH_INT interrupt.
          IN_ERR_EOF: u1,

          /// [3:3] The raw interrupt status bit for the IN_DSCR_ERR_CH_INT interrupt.
          IN_DSCR_ERR: u1,

          /// [4:4] The raw interrupt status bit for the IN_DSCR_EMPTY_CH_INT interrupt.
          IN_DSCR_EMPTY: u1,

          /// [5:5] The raw interrupt status bit for the INFIFO_OVF_L1_CH_INT interrupt.
          INFIFO_OVF: u1,

          /// [6:6] The raw interrupt status bit for the INFIFO_UDF_L1_CH_INT interrupt.
          INFIFO_UDF: u1,

          /// [7:31] 
          res0: u25,

        }), @ptrFromInt(0x60080004));

        /// Masked interrupt of channel 0
        pub const IN_INT_ST_CH1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] The raw interrupt status bit for the IN_DONE_CH_INT interrupt.
          IN_DONE: u1,

          /// [1:1] The raw interrupt status bit for the IN_SUC_EOF_CH_INT interrupt.
          IN_SUC_EOF: u1,

          /// [2:2] The raw interrupt status bit for the IN_ERR_EOF_CH_INT interrupt.
          IN_ERR_EOF: u1,

          /// [3:3] The raw interrupt status bit for the IN_DSCR_ERR_CH_INT interrupt.
          IN_DSCR_ERR: u1,

          /// [4:4] The raw interrupt status bit for the IN_DSCR_EMPTY_CH_INT interrupt.
          IN_DSCR_EMPTY: u1,

          /// [5:5] The raw interrupt status bit for the INFIFO_OVF_L1_CH_INT interrupt.
          INFIFO_OVF: u1,

          /// [6:6] The raw interrupt status bit for the INFIFO_UDF_L1_CH_INT interrupt.
          INFIFO_UDF: u1,

          /// [7:31] 
          res0: u25,

        }), @ptrFromInt(0x60080008));

        /// Masked interrupt of channel 0
        pub const IN_INT_ST_CH2 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] The raw interrupt status bit for the IN_DONE_CH_INT interrupt.
          IN_DONE: u1,

          /// [1:1] The raw interrupt status bit for the IN_SUC_EOF_CH_INT interrupt.
          IN_SUC_EOF: u1,

          /// [2:2] The raw interrupt status bit for the IN_ERR_EOF_CH_INT interrupt.
          IN_ERR_EOF: u1,

          /// [3:3] The raw interrupt status bit for the IN_DSCR_ERR_CH_INT interrupt.
          IN_DSCR_ERR: u1,

          /// [4:4] The raw interrupt status bit for the IN_DSCR_EMPTY_CH_INT interrupt.
          IN_DSCR_EMPTY: u1,

          /// [5:5] The raw interrupt status bit for the INFIFO_OVF_L1_CH_INT interrupt.
          INFIFO_OVF: u1,

          /// [6:6] The raw interrupt status bit for the INFIFO_UDF_L1_CH_INT interrupt.
          INFIFO_UDF: u1,

          /// [7:31] 
          res0: u25,

        }), @ptrFromInt(0x6008000c));

        /// Interrupt enable bits of channel 0
        pub const IN_INT_ENA_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] The interrupt enable bit for the IN_DONE_CH_INT interrupt.
          IN_DONE: u1,

          /// [1:1] The interrupt enable bit for the IN_SUC_EOF_CH_INT interrupt.
          IN_SUC_EOF: u1,

          /// [2:2] The interrupt enable bit for the IN_ERR_EOF_CH_INT interrupt.
          IN_ERR_EOF: u1,

          /// [3:3] The interrupt enable bit for the IN_DSCR_ERR_CH_INT interrupt.
          IN_DSCR_ERR: u1,

          /// [4:4] The interrupt enable bit for the IN_DSCR_EMPTY_CH_INT interrupt.
          IN_DSCR_EMPTY: u1,

          /// [5:5] The interrupt enable bit for the INFIFO_OVF_L1_CH_INT interrupt.
          INFIFO_OVF: u1,

          /// [6:6] The interrupt enable bit for the INFIFO_UDF_L1_CH_INT interrupt.
          INFIFO_UDF: u1,

          /// [7:31] 
          res0: u25,

        }), @ptrFromInt(0x60080008));

        /// Interrupt enable bits of channel 0
        pub const IN_INT_ENA_CH1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] The interrupt enable bit for the IN_DONE_CH_INT interrupt.
          IN_DONE: u1,

          /// [1:1] The interrupt enable bit for the IN_SUC_EOF_CH_INT interrupt.
          IN_SUC_EOF: u1,

          /// [2:2] The interrupt enable bit for the IN_ERR_EOF_CH_INT interrupt.
          IN_ERR_EOF: u1,

          /// [3:3] The interrupt enable bit for the IN_DSCR_ERR_CH_INT interrupt.
          IN_DSCR_ERR: u1,

          /// [4:4] The interrupt enable bit for the IN_DSCR_EMPTY_CH_INT interrupt.
          IN_DSCR_EMPTY: u1,

          /// [5:5] The interrupt enable bit for the INFIFO_OVF_L1_CH_INT interrupt.
          INFIFO_OVF: u1,

          /// [6:6] The interrupt enable bit for the INFIFO_UDF_L1_CH_INT interrupt.
          INFIFO_UDF: u1,

          /// [7:31] 
          res0: u25,

        }), @ptrFromInt(0x6008000c));

        /// Interrupt enable bits of channel 0
        pub const IN_INT_ENA_CH2 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] The interrupt enable bit for the IN_DONE_CH_INT interrupt.
          IN_DONE: u1,

          /// [1:1] The interrupt enable bit for the IN_SUC_EOF_CH_INT interrupt.
          IN_SUC_EOF: u1,

          /// [2:2] The interrupt enable bit for the IN_ERR_EOF_CH_INT interrupt.
          IN_ERR_EOF: u1,

          /// [3:3] The interrupt enable bit for the IN_DSCR_ERR_CH_INT interrupt.
          IN_DSCR_ERR: u1,

          /// [4:4] The interrupt enable bit for the IN_DSCR_EMPTY_CH_INT interrupt.
          IN_DSCR_EMPTY: u1,

          /// [5:5] The interrupt enable bit for the INFIFO_OVF_L1_CH_INT interrupt.
          INFIFO_OVF: u1,

          /// [6:6] The interrupt enable bit for the INFIFO_UDF_L1_CH_INT interrupt.
          INFIFO_UDF: u1,

          /// [7:31] 
          res0: u25,

        }), @ptrFromInt(0x60080010));

        /// Interrupt clear bits of channel 0
        pub const IN_INT_CLR_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Set this bit to clear the IN_DONE_CH_INT interrupt.
          IN_DONE: u1,

          /// [1:1] Set this bit to clear the IN_SUC_EOF_CH_INT interrupt.
          IN_SUC_EOF: u1,

          /// [2:2] Set this bit to clear the IN_ERR_EOF_CH_INT interrupt.
          IN_ERR_EOF: u1,

          /// [3:3] Set this bit to clear the IN_DSCR_ERR_CH_INT interrupt.
          IN_DSCR_ERR: u1,

          /// [4:4] Set this bit to clear the IN_DSCR_EMPTY_CH_INT interrupt.
          IN_DSCR_EMPTY: u1,

          /// [5:5] Set this bit to clear the INFIFO_OVF_L1_CH_INT interrupt.
          INFIFO_OVF: u1,

          /// [6:6] Set this bit to clear the INFIFO_UDF_L1_CH_INT interrupt.
          INFIFO_UDF: u1,

          /// [7:31] 
          res0: u25,

        }), @ptrFromInt(0x6008000c));

        /// Interrupt clear bits of channel 0
        pub const IN_INT_CLR_CH1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Set this bit to clear the IN_DONE_CH_INT interrupt.
          IN_DONE: u1,

          /// [1:1] Set this bit to clear the IN_SUC_EOF_CH_INT interrupt.
          IN_SUC_EOF: u1,

          /// [2:2] Set this bit to clear the IN_ERR_EOF_CH_INT interrupt.
          IN_ERR_EOF: u1,

          /// [3:3] Set this bit to clear the IN_DSCR_ERR_CH_INT interrupt.
          IN_DSCR_ERR: u1,

          /// [4:4] Set this bit to clear the IN_DSCR_EMPTY_CH_INT interrupt.
          IN_DSCR_EMPTY: u1,

          /// [5:5] Set this bit to clear the INFIFO_OVF_L1_CH_INT interrupt.
          INFIFO_OVF: u1,

          /// [6:6] Set this bit to clear the INFIFO_UDF_L1_CH_INT interrupt.
          INFIFO_UDF: u1,

          /// [7:31] 
          res0: u25,

        }), @ptrFromInt(0x60080010));

        /// Interrupt clear bits of channel 0
        pub const IN_INT_CLR_CH2 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Set this bit to clear the IN_DONE_CH_INT interrupt.
          IN_DONE: u1,

          /// [1:1] Set this bit to clear the IN_SUC_EOF_CH_INT interrupt.
          IN_SUC_EOF: u1,

          /// [2:2] Set this bit to clear the IN_ERR_EOF_CH_INT interrupt.
          IN_ERR_EOF: u1,

          /// [3:3] Set this bit to clear the IN_DSCR_ERR_CH_INT interrupt.
          IN_DSCR_ERR: u1,

          /// [4:4] Set this bit to clear the IN_DSCR_EMPTY_CH_INT interrupt.
          IN_DSCR_EMPTY: u1,

          /// [5:5] Set this bit to clear the INFIFO_OVF_L1_CH_INT interrupt.
          INFIFO_OVF: u1,

          /// [6:6] Set this bit to clear the INFIFO_UDF_L1_CH_INT interrupt.
          INFIFO_UDF: u1,

          /// [7:31] 
          res0: u25,

        }), @ptrFromInt(0x60080014));

        /// Raw status interrupt of channel 0
        pub const OUT_INT_RAW_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] The raw interrupt bit turns to high level when the last data pointed by one outlink descriptor has been transmitted to peripherals for Tx channel 0.
          OUT_DONE: u1,

          /// [1:1] The raw interrupt bit turns to high level when the last data pointed by one outlink descriptor has been read from memory for Tx channel 0.
          OUT_EOF: u1,

          /// [2:2] The raw interrupt bit turns to high level when detecting outlink descriptor error including owner error and the second and third word error of outlink descriptor for Tx channel 0.
          OUT_DSCR_ERR: u1,

          /// [3:3] The raw interrupt bit turns to high level when data corresponding a outlink (includes one link descriptor or few link descriptors) is transmitted out for Tx channel 0.
          OUT_TOTAL_EOF: u1,

          /// [4:4] This raw interrupt bit turns to high level when level 1 fifo of Tx channel 0 is overflow.
          OUTFIFO_OVF: u1,

          /// [5:5] This raw interrupt bit turns to high level when level 1 fifo of Tx channel 0 is underflow.
          OUTFIFO_UDF: u1,

          /// [6:31] 
          res0: u26,

        }), @ptrFromInt(0x60080030));

        /// Raw status interrupt of channel 0
        pub const OUT_INT_RAW_CH1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] The raw interrupt bit turns to high level when the last data pointed by one outlink descriptor has been transmitted to peripherals for Tx channel 0.
          OUT_DONE: u1,

          /// [1:1] The raw interrupt bit turns to high level when the last data pointed by one outlink descriptor has been read from memory for Tx channel 0.
          OUT_EOF: u1,

          /// [2:2] The raw interrupt bit turns to high level when detecting outlink descriptor error including owner error and the second and third word error of outlink descriptor for Tx channel 0.
          OUT_DSCR_ERR: u1,

          /// [3:3] The raw interrupt bit turns to high level when data corresponding a outlink (includes one link descriptor or few link descriptors) is transmitted out for Tx channel 0.
          OUT_TOTAL_EOF: u1,

          /// [4:4] This raw interrupt bit turns to high level when level 1 fifo of Tx channel 0 is overflow.
          OUTFIFO_OVF: u1,

          /// [5:5] This raw interrupt bit turns to high level when level 1 fifo of Tx channel 0 is underflow.
          OUTFIFO_UDF: u1,

          /// [6:31] 
          res0: u26,

        }), @ptrFromInt(0x60080034));

        /// Raw status interrupt of channel 0
        pub const OUT_INT_RAW_CH2 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] The raw interrupt bit turns to high level when the last data pointed by one outlink descriptor has been transmitted to peripherals for Tx channel 0.
          OUT_DONE: u1,

          /// [1:1] The raw interrupt bit turns to high level when the last data pointed by one outlink descriptor has been read from memory for Tx channel 0.
          OUT_EOF: u1,

          /// [2:2] The raw interrupt bit turns to high level when detecting outlink descriptor error including owner error and the second and third word error of outlink descriptor for Tx channel 0.
          OUT_DSCR_ERR: u1,

          /// [3:3] The raw interrupt bit turns to high level when data corresponding a outlink (includes one link descriptor or few link descriptors) is transmitted out for Tx channel 0.
          OUT_TOTAL_EOF: u1,

          /// [4:4] This raw interrupt bit turns to high level when level 1 fifo of Tx channel 0 is overflow.
          OUTFIFO_OVF: u1,

          /// [5:5] This raw interrupt bit turns to high level when level 1 fifo of Tx channel 0 is underflow.
          OUTFIFO_UDF: u1,

          /// [6:31] 
          res0: u26,

        }), @ptrFromInt(0x60080038));

        /// Masked interrupt of channel 0
        pub const OUT_INT_ST_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] The raw interrupt status bit for the OUT_DONE_CH_INT interrupt.
          OUT_DONE: u1,

          /// [1:1] The raw interrupt status bit for the OUT_EOF_CH_INT interrupt.
          OUT_EOF: u1,

          /// [2:2] The raw interrupt status bit for the OUT_DSCR_ERR_CH_INT interrupt.
          OUT_DSCR_ERR: u1,

          /// [3:3] The raw interrupt status bit for the OUT_TOTAL_EOF_CH_INT interrupt.
          OUT_TOTAL_EOF: u1,

          /// [4:4] The raw interrupt status bit for the OUTFIFO_OVF_L1_CH_INT interrupt.
          OUTFIFO_OVF: u1,

          /// [5:5] The raw interrupt status bit for the OUTFIFO_UDF_L1_CH_INT interrupt.
          OUTFIFO_UDF: u1,

          /// [6:31] 
          res0: u26,

        }), @ptrFromInt(0x60080034));

        /// Masked interrupt of channel 0
        pub const OUT_INT_ST_CH1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] The raw interrupt status bit for the OUT_DONE_CH_INT interrupt.
          OUT_DONE: u1,

          /// [1:1] The raw interrupt status bit for the OUT_EOF_CH_INT interrupt.
          OUT_EOF: u1,

          /// [2:2] The raw interrupt status bit for the OUT_DSCR_ERR_CH_INT interrupt.
          OUT_DSCR_ERR: u1,

          /// [3:3] The raw interrupt status bit for the OUT_TOTAL_EOF_CH_INT interrupt.
          OUT_TOTAL_EOF: u1,

          /// [4:4] The raw interrupt status bit for the OUTFIFO_OVF_L1_CH_INT interrupt.
          OUTFIFO_OVF: u1,

          /// [5:5] The raw interrupt status bit for the OUTFIFO_UDF_L1_CH_INT interrupt.
          OUTFIFO_UDF: u1,

          /// [6:31] 
          res0: u26,

        }), @ptrFromInt(0x60080038));

        /// Masked interrupt of channel 0
        pub const OUT_INT_ST_CH2 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] The raw interrupt status bit for the OUT_DONE_CH_INT interrupt.
          OUT_DONE: u1,

          /// [1:1] The raw interrupt status bit for the OUT_EOF_CH_INT interrupt.
          OUT_EOF: u1,

          /// [2:2] The raw interrupt status bit for the OUT_DSCR_ERR_CH_INT interrupt.
          OUT_DSCR_ERR: u1,

          /// [3:3] The raw interrupt status bit for the OUT_TOTAL_EOF_CH_INT interrupt.
          OUT_TOTAL_EOF: u1,

          /// [4:4] The raw interrupt status bit for the OUTFIFO_OVF_L1_CH_INT interrupt.
          OUTFIFO_OVF: u1,

          /// [5:5] The raw interrupt status bit for the OUTFIFO_UDF_L1_CH_INT interrupt.
          OUTFIFO_UDF: u1,

          /// [6:31] 
          res0: u26,

        }), @ptrFromInt(0x6008003c));

        /// Interrupt enable bits of channel 0
        pub const OUT_INT_ENA_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] The interrupt enable bit for the OUT_DONE_CH_INT interrupt.
          OUT_DONE: u1,

          /// [1:1] The interrupt enable bit for the OUT_EOF_CH_INT interrupt.
          OUT_EOF: u1,

          /// [2:2] The interrupt enable bit for the OUT_DSCR_ERR_CH_INT interrupt.
          OUT_DSCR_ERR: u1,

          /// [3:3] The interrupt enable bit for the OUT_TOTAL_EOF_CH_INT interrupt.
          OUT_TOTAL_EOF: u1,

          /// [4:4] The interrupt enable bit for the OUTFIFO_OVF_L1_CH_INT interrupt.
          OUTFIFO_OVF: u1,

          /// [5:5] The interrupt enable bit for the OUTFIFO_UDF_L1_CH_INT interrupt.
          OUTFIFO_UDF: u1,

          /// [6:31] 
          res0: u26,

        }), @ptrFromInt(0x60080038));

        /// Interrupt enable bits of channel 0
        pub const OUT_INT_ENA_CH1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] The interrupt enable bit for the OUT_DONE_CH_INT interrupt.
          OUT_DONE: u1,

          /// [1:1] The interrupt enable bit for the OUT_EOF_CH_INT interrupt.
          OUT_EOF: u1,

          /// [2:2] The interrupt enable bit for the OUT_DSCR_ERR_CH_INT interrupt.
          OUT_DSCR_ERR: u1,

          /// [3:3] The interrupt enable bit for the OUT_TOTAL_EOF_CH_INT interrupt.
          OUT_TOTAL_EOF: u1,

          /// [4:4] The interrupt enable bit for the OUTFIFO_OVF_L1_CH_INT interrupt.
          OUTFIFO_OVF: u1,

          /// [5:5] The interrupt enable bit for the OUTFIFO_UDF_L1_CH_INT interrupt.
          OUTFIFO_UDF: u1,

          /// [6:31] 
          res0: u26,

        }), @ptrFromInt(0x6008003c));

        /// Interrupt enable bits of channel 0
        pub const OUT_INT_ENA_CH2 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] The interrupt enable bit for the OUT_DONE_CH_INT interrupt.
          OUT_DONE: u1,

          /// [1:1] The interrupt enable bit for the OUT_EOF_CH_INT interrupt.
          OUT_EOF: u1,

          /// [2:2] The interrupt enable bit for the OUT_DSCR_ERR_CH_INT interrupt.
          OUT_DSCR_ERR: u1,

          /// [3:3] The interrupt enable bit for the OUT_TOTAL_EOF_CH_INT interrupt.
          OUT_TOTAL_EOF: u1,

          /// [4:4] The interrupt enable bit for the OUTFIFO_OVF_L1_CH_INT interrupt.
          OUTFIFO_OVF: u1,

          /// [5:5] The interrupt enable bit for the OUTFIFO_UDF_L1_CH_INT interrupt.
          OUTFIFO_UDF: u1,

          /// [6:31] 
          res0: u26,

        }), @ptrFromInt(0x60080040));

        /// Interrupt clear bits of channel 0
        pub const OUT_INT_CLR_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Set this bit to clear the OUT_DONE_CH_INT interrupt.
          OUT_DONE: u1,

          /// [1:1] Set this bit to clear the OUT_EOF_CH_INT interrupt.
          OUT_EOF: u1,

          /// [2:2] Set this bit to clear the OUT_DSCR_ERR_CH_INT interrupt.
          OUT_DSCR_ERR: u1,

          /// [3:3] Set this bit to clear the OUT_TOTAL_EOF_CH_INT interrupt.
          OUT_TOTAL_EOF: u1,

          /// [4:4] Set this bit to clear the OUTFIFO_OVF_L1_CH_INT interrupt.
          OUTFIFO_OVF: u1,

          /// [5:5] Set this bit to clear the OUTFIFO_UDF_L1_CH_INT interrupt.
          OUTFIFO_UDF: u1,

          /// [6:31] 
          res0: u26,

        }), @ptrFromInt(0x6008003c));

        /// Interrupt clear bits of channel 0
        pub const OUT_INT_CLR_CH1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Set this bit to clear the OUT_DONE_CH_INT interrupt.
          OUT_DONE: u1,

          /// [1:1] Set this bit to clear the OUT_EOF_CH_INT interrupt.
          OUT_EOF: u1,

          /// [2:2] Set this bit to clear the OUT_DSCR_ERR_CH_INT interrupt.
          OUT_DSCR_ERR: u1,

          /// [3:3] Set this bit to clear the OUT_TOTAL_EOF_CH_INT interrupt.
          OUT_TOTAL_EOF: u1,

          /// [4:4] Set this bit to clear the OUTFIFO_OVF_L1_CH_INT interrupt.
          OUTFIFO_OVF: u1,

          /// [5:5] Set this bit to clear the OUTFIFO_UDF_L1_CH_INT interrupt.
          OUTFIFO_UDF: u1,

          /// [6:31] 
          res0: u26,

        }), @ptrFromInt(0x60080040));

        /// Interrupt clear bits of channel 0
        pub const OUT_INT_CLR_CH2 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Set this bit to clear the OUT_DONE_CH_INT interrupt.
          OUT_DONE: u1,

          /// [1:1] Set this bit to clear the OUT_EOF_CH_INT interrupt.
          OUT_EOF: u1,

          /// [2:2] Set this bit to clear the OUT_DSCR_ERR_CH_INT interrupt.
          OUT_DSCR_ERR: u1,

          /// [3:3] Set this bit to clear the OUT_TOTAL_EOF_CH_INT interrupt.
          OUT_TOTAL_EOF: u1,

          /// [4:4] Set this bit to clear the OUTFIFO_OVF_L1_CH_INT interrupt.
          OUTFIFO_OVF: u1,

          /// [5:5] Set this bit to clear the OUTFIFO_UDF_L1_CH_INT interrupt.
          OUTFIFO_UDF: u1,

          /// [6:31] 
          res0: u26,

        }), @ptrFromInt(0x60080044));

        /// reserved
        pub const AHB_TEST = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:2] reserved
          AHB_TESTMODE: u3,

          /// [3:3] 
          res0: u1,

          /// [4:5] reserved
          AHB_TESTADDR: u2,

          /// [6:31] 
          res1: u26,

        }), @ptrFromInt(0x60080060));

        /// MISC register
        pub const MISC_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Set this bit then clear this bit to reset the internal ahb FSM.
          AHBM_RST_INTER: u1,

          /// [1:1] 
          res0: u1,

          /// [2:2] Set this bit to disable priority arbitration function.
          ARB_PRI_DIS: u1,

          /// [3:3] 1'h1: Force clock on for register. 1'h0: Support clock only when application writes registers.
          CLK_EN: u1,

          /// [4:31] 
          res1: u28,

        }), @ptrFromInt(0x60080064));

        /// Version control register
        pub const DATE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] register version.
          DATE: u32,

        }), @ptrFromInt(0x60080068));

        /// Configure 0 register of Rx channel 0
        pub const IN_CONF0_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] This bit is used to reset DMA channel 0 Rx FSM and Rx FIFO pointer.
          IN_RST: u1,

          /// [1:1] reserved
          IN_LOOP_TEST: u1,

          /// [2:2] Set this bit to 1 to enable INCR burst transfer for Rx channel 0 reading link descriptor when accessing internal SRAM.
          INDSCR_BURST_EN: u1,

          /// [3:3] Set this bit to 1 to enable INCR burst transfer for Rx channel 0 receiving data when accessing internal SRAM.
          IN_DATA_BURST_EN: u1,

          /// [4:4] Set this bit 1 to enable automatic transmitting data from memory to memory via DMA.
          MEM_TRANS_EN: u1,

          /// [5:5] Set this bit to 1 to enable etm control mode, dma Rx channel 0 is triggered by etm task.
          IN_ETM_EN: u1,

          /// [6:31] 
          res0: u26,

        }), @ptrFromInt(0x60080070));

        /// Configure 0 register of Rx channel 0
        pub const IN_CONF0_CH1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] This bit is used to reset DMA channel 0 Rx FSM and Rx FIFO pointer.
          IN_RST: u1,

          /// [1:1] reserved
          IN_LOOP_TEST: u1,

          /// [2:2] Set this bit to 1 to enable INCR burst transfer for Rx channel 0 reading link descriptor when accessing internal SRAM.
          INDSCR_BURST_EN: u1,

          /// [3:3] Set this bit to 1 to enable INCR burst transfer for Rx channel 0 receiving data when accessing internal SRAM.
          IN_DATA_BURST_EN: u1,

          /// [4:4] Set this bit 1 to enable automatic transmitting data from memory to memory via DMA.
          MEM_TRANS_EN: u1,

          /// [5:5] Set this bit to 1 to enable etm control mode, dma Rx channel 0 is triggered by etm task.
          IN_ETM_EN: u1,

          /// [6:31] 
          res0: u26,

        }), @ptrFromInt(0x60080074));

        /// Configure 0 register of Rx channel 0
        pub const IN_CONF0_CH2 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] This bit is used to reset DMA channel 0 Rx FSM and Rx FIFO pointer.
          IN_RST: u1,

          /// [1:1] reserved
          IN_LOOP_TEST: u1,

          /// [2:2] Set this bit to 1 to enable INCR burst transfer for Rx channel 0 reading link descriptor when accessing internal SRAM.
          INDSCR_BURST_EN: u1,

          /// [3:3] Set this bit to 1 to enable INCR burst transfer for Rx channel 0 receiving data when accessing internal SRAM.
          IN_DATA_BURST_EN: u1,

          /// [4:4] Set this bit 1 to enable automatic transmitting data from memory to memory via DMA.
          MEM_TRANS_EN: u1,

          /// [5:5] Set this bit to 1 to enable etm control mode, dma Rx channel 0 is triggered by etm task.
          IN_ETM_EN: u1,

          /// [6:31] 
          res0: u26,

        }), @ptrFromInt(0x60080078));

        /// Configure 1 register of Rx channel 0
        pub const IN_CONF1_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:11] 
          res0: u12,

          /// [12:12] Set this bit to enable checking the owner attribute of the link descriptor.
          IN_CHECK_OWNER: u1,

          /// [13:31] 
          res1: u19,

        }), @ptrFromInt(0x60080074));

        /// Configure 1 register of Rx channel 0
        pub const IN_CONF1_CH1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:11] 
          res0: u12,

          /// [12:12] Set this bit to enable checking the owner attribute of the link descriptor.
          IN_CHECK_OWNER: u1,

          /// [13:31] 
          res1: u19,

        }), @ptrFromInt(0x60080078));

        /// Configure 1 register of Rx channel 0
        pub const IN_CONF1_CH2 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:11] 
          res0: u12,

          /// [12:12] Set this bit to enable checking the owner attribute of the link descriptor.
          IN_CHECK_OWNER: u1,

          /// [13:31] 
          res1: u19,

        }), @ptrFromInt(0x6008007c));

        /// Receive FIFO status of Rx channel 0
        pub const INFIFO_STATUS_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] L1 Rx FIFO full signal for Rx channel 0.
          INFIFO_FULL: u1,

          /// [1:1] L1 Rx FIFO empty signal for Rx channel 0.
          INFIFO_EMPTY: u1,

          /// [2:7] The register stores the byte number of the data in L1 Rx FIFO for Rx channel 0.
          INFIFO_CNT: u6,

          /// [8:22] 
          res0: u15,

          /// [23:23] reserved
          IN_REMAIN_UNDER_1B: u1,

          /// [24:24] reserved
          IN_REMAIN_UNDER_2B: u1,

          /// [25:25] reserved
          IN_REMAIN_UNDER_3B: u1,

          /// [26:26] reserved
          IN_REMAIN_UNDER_4B: u1,

          /// [27:27] reserved
          IN_BUF_HUNGRY: u1,

          /// [28:31] 
          res1: u4,

        }), @ptrFromInt(0x60080078));

        /// Receive FIFO status of Rx channel 0
        pub const INFIFO_STATUS_CH1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] L1 Rx FIFO full signal for Rx channel 0.
          INFIFO_FULL: u1,

          /// [1:1] L1 Rx FIFO empty signal for Rx channel 0.
          INFIFO_EMPTY: u1,

          /// [2:7] The register stores the byte number of the data in L1 Rx FIFO for Rx channel 0.
          INFIFO_CNT: u6,

          /// [8:22] 
          res0: u15,

          /// [23:23] reserved
          IN_REMAIN_UNDER_1B: u1,

          /// [24:24] reserved
          IN_REMAIN_UNDER_2B: u1,

          /// [25:25] reserved
          IN_REMAIN_UNDER_3B: u1,

          /// [26:26] reserved
          IN_REMAIN_UNDER_4B: u1,

          /// [27:27] reserved
          IN_BUF_HUNGRY: u1,

          /// [28:31] 
          res1: u4,

        }), @ptrFromInt(0x6008007c));

        /// Receive FIFO status of Rx channel 0
        pub const INFIFO_STATUS_CH2 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] L1 Rx FIFO full signal for Rx channel 0.
          INFIFO_FULL: u1,

          /// [1:1] L1 Rx FIFO empty signal for Rx channel 0.
          INFIFO_EMPTY: u1,

          /// [2:7] The register stores the byte number of the data in L1 Rx FIFO for Rx channel 0.
          INFIFO_CNT: u6,

          /// [8:22] 
          res0: u15,

          /// [23:23] reserved
          IN_REMAIN_UNDER_1B: u1,

          /// [24:24] reserved
          IN_REMAIN_UNDER_2B: u1,

          /// [25:25] reserved
          IN_REMAIN_UNDER_3B: u1,

          /// [26:26] reserved
          IN_REMAIN_UNDER_4B: u1,

          /// [27:27] reserved
          IN_BUF_HUNGRY: u1,

          /// [28:31] 
          res1: u4,

        }), @ptrFromInt(0x60080080));

        /// Pop control register of Rx channel 0
        pub const IN_POP_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:11] This register stores the data popping from DMA FIFO.
          INFIFO_RDATA: u12,

          /// [12:12] Set this bit to pop data from DMA FIFO.
          INFIFO_POP: u1,

          /// [13:31] 
          res0: u19,

        }), @ptrFromInt(0x6008007c));

        /// Pop control register of Rx channel 0
        pub const IN_POP_CH1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:11] This register stores the data popping from DMA FIFO.
          INFIFO_RDATA: u12,

          /// [12:12] Set this bit to pop data from DMA FIFO.
          INFIFO_POP: u1,

          /// [13:31] 
          res0: u19,

        }), @ptrFromInt(0x60080080));

        /// Pop control register of Rx channel 0
        pub const IN_POP_CH2 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:11] This register stores the data popping from DMA FIFO.
          INFIFO_RDATA: u12,

          /// [12:12] Set this bit to pop data from DMA FIFO.
          INFIFO_POP: u1,

          /// [13:31] 
          res0: u19,

        }), @ptrFromInt(0x60080084));

        /// Link descriptor configure and control register of Rx channel 0
        pub const IN_LINK_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:19] This register stores the 20 least significant bits of the first inlink descriptor's address.
          INLINK_ADDR: u20,

          /// [20:20] Set this bit to return to current inlink descriptor's address when there are some errors in current receiving data.
          INLINK_AUTO_RET: u1,

          /// [21:21] Set this bit to stop dealing with the inlink descriptors.
          INLINK_STOP: u1,

          /// [22:22] Set this bit to start dealing with the inlink descriptors.
          INLINK_START: u1,

          /// [23:23] Set this bit to mount a new inlink descriptor.
          INLINK_RESTART: u1,

          /// [24:24] 1: the inlink descriptor's FSM is in idle state.0: the inlink descriptor's FSM is working.
          INLINK_PARK: u1,

          /// [25:31] 
          res0: u7,

        }), @ptrFromInt(0x60080080));

        /// Link descriptor configure and control register of Rx channel 0
        pub const IN_LINK_CH1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:19] This register stores the 20 least significant bits of the first inlink descriptor's address.
          INLINK_ADDR: u20,

          /// [20:20] Set this bit to return to current inlink descriptor's address when there are some errors in current receiving data.
          INLINK_AUTO_RET: u1,

          /// [21:21] Set this bit to stop dealing with the inlink descriptors.
          INLINK_STOP: u1,

          /// [22:22] Set this bit to start dealing with the inlink descriptors.
          INLINK_START: u1,

          /// [23:23] Set this bit to mount a new inlink descriptor.
          INLINK_RESTART: u1,

          /// [24:24] 1: the inlink descriptor's FSM is in idle state.0: the inlink descriptor's FSM is working.
          INLINK_PARK: u1,

          /// [25:31] 
          res0: u7,

        }), @ptrFromInt(0x60080084));

        /// Link descriptor configure and control register of Rx channel 0
        pub const IN_LINK_CH2 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:19] This register stores the 20 least significant bits of the first inlink descriptor's address.
          INLINK_ADDR: u20,

          /// [20:20] Set this bit to return to current inlink descriptor's address when there are some errors in current receiving data.
          INLINK_AUTO_RET: u1,

          /// [21:21] Set this bit to stop dealing with the inlink descriptors.
          INLINK_STOP: u1,

          /// [22:22] Set this bit to start dealing with the inlink descriptors.
          INLINK_START: u1,

          /// [23:23] Set this bit to mount a new inlink descriptor.
          INLINK_RESTART: u1,

          /// [24:24] 1: the inlink descriptor's FSM is in idle state.0: the inlink descriptor's FSM is working.
          INLINK_PARK: u1,

          /// [25:31] 
          res0: u7,

        }), @ptrFromInt(0x60080088));

        /// Receive status of Rx channel 0
        pub const IN_STATE_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:17] This register stores the current inlink descriptor's address.
          INLINK_DSCR_ADDR: u18,

          /// [18:19] reserved
          IN_DSCR_STATE: u2,

          /// [20:22] reserved
          IN_STATE: u3,

          /// [23:31] 
          res0: u9,

        }), @ptrFromInt(0x60080084));

        /// Receive status of Rx channel 0
        pub const IN_STATE_CH1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:17] This register stores the current inlink descriptor's address.
          INLINK_DSCR_ADDR: u18,

          /// [18:19] reserved
          IN_DSCR_STATE: u2,

          /// [20:22] reserved
          IN_STATE: u3,

          /// [23:31] 
          res0: u9,

        }), @ptrFromInt(0x60080088));

        /// Receive status of Rx channel 0
        pub const IN_STATE_CH2 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:17] This register stores the current inlink descriptor's address.
          INLINK_DSCR_ADDR: u18,

          /// [18:19] reserved
          IN_DSCR_STATE: u2,

          /// [20:22] reserved
          IN_STATE: u3,

          /// [23:31] 
          res0: u9,

        }), @ptrFromInt(0x6008008c));

        /// Inlink descriptor address when EOF occurs of Rx channel 0
        pub const IN_SUC_EOF_DES_ADDR_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] This register stores the address of the inlink descriptor when the EOF bit in this descriptor is 1.
          IN_SUC_EOF_DES_ADDR: u32,

        }), @ptrFromInt(0x60080088));

        /// Inlink descriptor address when EOF occurs of Rx channel 0
        pub const IN_SUC_EOF_DES_ADDR_CH1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] This register stores the address of the inlink descriptor when the EOF bit in this descriptor is 1.
          IN_SUC_EOF_DES_ADDR: u32,

        }), @ptrFromInt(0x6008008c));

        /// Inlink descriptor address when EOF occurs of Rx channel 0
        pub const IN_SUC_EOF_DES_ADDR_CH2 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] This register stores the address of the inlink descriptor when the EOF bit in this descriptor is 1.
          IN_SUC_EOF_DES_ADDR: u32,

        }), @ptrFromInt(0x60080090));

        /// Inlink descriptor address when errors occur of Rx channel 0
        pub const IN_ERR_EOF_DES_ADDR_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] This register stores the address of the inlink descriptor when there are some errors in current receiving data. Only used when peripheral is UHCI0.
          IN_ERR_EOF_DES_ADDR: u32,

        }), @ptrFromInt(0x6008008c));

        /// Inlink descriptor address when errors occur of Rx channel 0
        pub const IN_ERR_EOF_DES_ADDR_CH1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] This register stores the address of the inlink descriptor when there are some errors in current receiving data. Only used when peripheral is UHCI0.
          IN_ERR_EOF_DES_ADDR: u32,

        }), @ptrFromInt(0x60080090));

        /// Inlink descriptor address when errors occur of Rx channel 0
        pub const IN_ERR_EOF_DES_ADDR_CH2 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] This register stores the address of the inlink descriptor when there are some errors in current receiving data. Only used when peripheral is UHCI0.
          IN_ERR_EOF_DES_ADDR: u32,

        }), @ptrFromInt(0x60080094));

        /// Current inlink descriptor address of Rx channel 0
        pub const IN_DSCR_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] The address of the current inlink descriptor x.
          INLINK_DSCR: u32,

        }), @ptrFromInt(0x60080090));

        /// Current inlink descriptor address of Rx channel 0
        pub const IN_DSCR_CH1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] The address of the current inlink descriptor x.
          INLINK_DSCR: u32,

        }), @ptrFromInt(0x60080094));

        /// Current inlink descriptor address of Rx channel 0
        pub const IN_DSCR_CH2 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] The address of the current inlink descriptor x.
          INLINK_DSCR: u32,

        }), @ptrFromInt(0x60080098));

        /// The last inlink descriptor address of Rx channel 0
        pub const IN_DSCR_BF0_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] The address of the last inlink descriptor x-1.
          INLINK_DSCR_BF0: u32,

        }), @ptrFromInt(0x60080094));

        /// The last inlink descriptor address of Rx channel 0
        pub const IN_DSCR_BF0_CH1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] The address of the last inlink descriptor x-1.
          INLINK_DSCR_BF0: u32,

        }), @ptrFromInt(0x60080098));

        /// The last inlink descriptor address of Rx channel 0
        pub const IN_DSCR_BF0_CH2 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] The address of the last inlink descriptor x-1.
          INLINK_DSCR_BF0: u32,

        }), @ptrFromInt(0x6008009c));

        /// The second-to-last inlink descriptor address of Rx channel 0
        pub const IN_DSCR_BF1_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] The address of the second-to-last inlink descriptor x-2.
          INLINK_DSCR_BF1: u32,

        }), @ptrFromInt(0x60080098));

        /// The second-to-last inlink descriptor address of Rx channel 0
        pub const IN_DSCR_BF1_CH1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] The address of the second-to-last inlink descriptor x-2.
          INLINK_DSCR_BF1: u32,

        }), @ptrFromInt(0x6008009c));

        /// The second-to-last inlink descriptor address of Rx channel 0
        pub const IN_DSCR_BF1_CH2 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] The address of the second-to-last inlink descriptor x-2.
          INLINK_DSCR_BF1: u32,

        }), @ptrFromInt(0x600800a0));

        /// Priority register of Rx channel 0
        pub const IN_PRI_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:3] The priority of Rx channel 0. The larger of the value the higher of the priority.
          RX_PRI: u4,

          /// [4:31] 
          res0: u28,

        }), @ptrFromInt(0x6008009c));

        /// Priority register of Rx channel 0
        pub const IN_PRI_CH1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:3] The priority of Rx channel 0. The larger of the value the higher of the priority.
          RX_PRI: u4,

          /// [4:31] 
          res0: u28,

        }), @ptrFromInt(0x600800a0));

        /// Priority register of Rx channel 0
        pub const IN_PRI_CH2 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:3] The priority of Rx channel 0. The larger of the value the higher of the priority.
          RX_PRI: u4,

          /// [4:31] 
          res0: u28,

        }), @ptrFromInt(0x600800a4));

        /// Peripheral selection of Rx channel 0
        pub const IN_PERI_SEL_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] This register is used to select peripheral for Rx channel 0. 0:SPI2. 1: Dummy. 2: UHCI0. 3: I2S0. 4: Dummy. 5: Dummy. 6: AES. 7: SHA. 8: ADC_DAC. 9: Parallel_IO. 10~15: Dummy
          PERI_IN_SEL: u6,

          /// [6:31] 
          res0: u26,

        }), @ptrFromInt(0x600800a0));

        /// Peripheral selection of Rx channel 0
        pub const IN_PERI_SEL_CH1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] This register is used to select peripheral for Rx channel 0. 0:SPI2. 1: Dummy. 2: UHCI0. 3: I2S0. 4: Dummy. 5: Dummy. 6: AES. 7: SHA. 8: ADC_DAC. 9: Parallel_IO. 10~15: Dummy
          PERI_IN_SEL: u6,

          /// [6:31] 
          res0: u26,

        }), @ptrFromInt(0x600800a4));

        /// Peripheral selection of Rx channel 0
        pub const IN_PERI_SEL_CH2 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] This register is used to select peripheral for Rx channel 0. 0:SPI2. 1: Dummy. 2: UHCI0. 3: I2S0. 4: Dummy. 5: Dummy. 6: AES. 7: SHA. 8: ADC_DAC. 9: Parallel_IO. 10~15: Dummy
          PERI_IN_SEL: u6,

          /// [6:31] 
          res0: u26,

        }), @ptrFromInt(0x600800a8));

        /// Configure 1 register of Tx channel 0
        pub const OUT_CONF1_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:11] 
          res0: u12,

          /// [12:12] Set this bit to enable checking the owner attribute of the link descriptor.
          OUT_CHECK_OWNER: u1,

          /// [13:31] 
          res1: u19,

        }), @ptrFromInt(0x600800d4));

        /// Configure 1 register of Tx channel 0
        pub const OUT_CONF1_CH1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:11] 
          res0: u12,

          /// [12:12] Set this bit to enable checking the owner attribute of the link descriptor.
          OUT_CHECK_OWNER: u1,

          /// [13:31] 
          res1: u19,

        }), @ptrFromInt(0x600800d8));

        /// Configure 1 register of Tx channel 0
        pub const OUT_CONF1_CH2 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:11] 
          res0: u12,

          /// [12:12] Set this bit to enable checking the owner attribute of the link descriptor.
          OUT_CHECK_OWNER: u1,

          /// [13:31] 
          res1: u19,

        }), @ptrFromInt(0x600800dc));

        /// Transmit FIFO status of Tx channel 0
        pub const OUTFIFO_STATUS_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] L1 Tx FIFO full signal for Tx channel 0.
          OUTFIFO_FULL: u1,

          /// [1:1] L1 Tx FIFO empty signal for Tx channel 0.
          OUTFIFO_EMPTY: u1,

          /// [2:7] The register stores the byte number of the data in L1 Tx FIFO for Tx channel 0.
          OUTFIFO_CNT: u6,

          /// [8:22] 
          res0: u15,

          /// [23:23] reserved
          OUT_REMAIN_UNDER_1B: u1,

          /// [24:24] reserved
          OUT_REMAIN_UNDER_2B: u1,

          /// [25:25] reserved
          OUT_REMAIN_UNDER_3B: u1,

          /// [26:26] reserved
          OUT_REMAIN_UNDER_4B: u1,

          /// [27:31] 
          res1: u5,

        }), @ptrFromInt(0x600800d8));

        /// Transmit FIFO status of Tx channel 0
        pub const OUTFIFO_STATUS_CH1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] L1 Tx FIFO full signal for Tx channel 0.
          OUTFIFO_FULL: u1,

          /// [1:1] L1 Tx FIFO empty signal for Tx channel 0.
          OUTFIFO_EMPTY: u1,

          /// [2:7] The register stores the byte number of the data in L1 Tx FIFO for Tx channel 0.
          OUTFIFO_CNT: u6,

          /// [8:22] 
          res0: u15,

          /// [23:23] reserved
          OUT_REMAIN_UNDER_1B: u1,

          /// [24:24] reserved
          OUT_REMAIN_UNDER_2B: u1,

          /// [25:25] reserved
          OUT_REMAIN_UNDER_3B: u1,

          /// [26:26] reserved
          OUT_REMAIN_UNDER_4B: u1,

          /// [27:31] 
          res1: u5,

        }), @ptrFromInt(0x600800dc));

        /// Transmit FIFO status of Tx channel 0
        pub const OUTFIFO_STATUS_CH2 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] L1 Tx FIFO full signal for Tx channel 0.
          OUTFIFO_FULL: u1,

          /// [1:1] L1 Tx FIFO empty signal for Tx channel 0.
          OUTFIFO_EMPTY: u1,

          /// [2:7] The register stores the byte number of the data in L1 Tx FIFO for Tx channel 0.
          OUTFIFO_CNT: u6,

          /// [8:22] 
          res0: u15,

          /// [23:23] reserved
          OUT_REMAIN_UNDER_1B: u1,

          /// [24:24] reserved
          OUT_REMAIN_UNDER_2B: u1,

          /// [25:25] reserved
          OUT_REMAIN_UNDER_3B: u1,

          /// [26:26] reserved
          OUT_REMAIN_UNDER_4B: u1,

          /// [27:31] 
          res1: u5,

        }), @ptrFromInt(0x600800e0));

        /// Push control register of Rx channel 0
        pub const OUT_PUSH_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:8] This register stores the data that need to be pushed into DMA FIFO.
          OUTFIFO_WDATA: u9,

          /// [9:9] Set this bit to push data into DMA FIFO.
          OUTFIFO_PUSH: u1,

          /// [10:31] 
          res0: u22,

        }), @ptrFromInt(0x600800dc));

        /// Push control register of Rx channel 0
        pub const OUT_PUSH_CH1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:8] This register stores the data that need to be pushed into DMA FIFO.
          OUTFIFO_WDATA: u9,

          /// [9:9] Set this bit to push data into DMA FIFO.
          OUTFIFO_PUSH: u1,

          /// [10:31] 
          res0: u22,

        }), @ptrFromInt(0x600800e0));

        /// Push control register of Rx channel 0
        pub const OUT_PUSH_CH2 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:8] This register stores the data that need to be pushed into DMA FIFO.
          OUTFIFO_WDATA: u9,

          /// [9:9] Set this bit to push data into DMA FIFO.
          OUTFIFO_PUSH: u1,

          /// [10:31] 
          res0: u22,

        }), @ptrFromInt(0x600800e4));

        /// Link descriptor configure and control register of Tx channel 0
        pub const OUT_LINK_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:19] This register stores the 20 least significant bits of the first outlink descriptor's address.
          OUTLINK_ADDR: u20,

          /// [20:20] Set this bit to stop dealing with the outlink descriptors.
          OUTLINK_STOP: u1,

          /// [21:21] Set this bit to start dealing with the outlink descriptors.
          OUTLINK_START: u1,

          /// [22:22] Set this bit to restart a new outlink from the last address.
          OUTLINK_RESTART: u1,

          /// [23:23] 1: the outlink descriptor's FSM is in idle state.0: the outlink descriptor's FSM is working.
          OUTLINK_PARK: u1,

          /// [24:31] 
          res0: u8,

        }), @ptrFromInt(0x600800e0));

        /// Link descriptor configure and control register of Tx channel 0
        pub const OUT_LINK_CH1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:19] This register stores the 20 least significant bits of the first outlink descriptor's address.
          OUTLINK_ADDR: u20,

          /// [20:20] Set this bit to stop dealing with the outlink descriptors.
          OUTLINK_STOP: u1,

          /// [21:21] Set this bit to start dealing with the outlink descriptors.
          OUTLINK_START: u1,

          /// [22:22] Set this bit to restart a new outlink from the last address.
          OUTLINK_RESTART: u1,

          /// [23:23] 1: the outlink descriptor's FSM is in idle state.0: the outlink descriptor's FSM is working.
          OUTLINK_PARK: u1,

          /// [24:31] 
          res0: u8,

        }), @ptrFromInt(0x600800e4));

        /// Link descriptor configure and control register of Tx channel 0
        pub const OUT_LINK_CH2 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:19] This register stores the 20 least significant bits of the first outlink descriptor's address.
          OUTLINK_ADDR: u20,

          /// [20:20] Set this bit to stop dealing with the outlink descriptors.
          OUTLINK_STOP: u1,

          /// [21:21] Set this bit to start dealing with the outlink descriptors.
          OUTLINK_START: u1,

          /// [22:22] Set this bit to restart a new outlink from the last address.
          OUTLINK_RESTART: u1,

          /// [23:23] 1: the outlink descriptor's FSM is in idle state.0: the outlink descriptor's FSM is working.
          OUTLINK_PARK: u1,

          /// [24:31] 
          res0: u8,

        }), @ptrFromInt(0x600800e8));

        /// Transmit status of Tx channel 0
        pub const OUT_STATE_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:17] This register stores the current outlink descriptor's address.
          OUTLINK_DSCR_ADDR: u18,

          /// [18:19] reserved
          OUT_DSCR_STATE: u2,

          /// [20:22] reserved
          OUT_STATE: u3,

          /// [23:31] 
          res0: u9,

        }), @ptrFromInt(0x600800e4));

        /// Transmit status of Tx channel 0
        pub const OUT_STATE_CH1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:17] This register stores the current outlink descriptor's address.
          OUTLINK_DSCR_ADDR: u18,

          /// [18:19] reserved
          OUT_DSCR_STATE: u2,

          /// [20:22] reserved
          OUT_STATE: u3,

          /// [23:31] 
          res0: u9,

        }), @ptrFromInt(0x600800e8));

        /// Transmit status of Tx channel 0
        pub const OUT_STATE_CH2 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:17] This register stores the current outlink descriptor's address.
          OUTLINK_DSCR_ADDR: u18,

          /// [18:19] reserved
          OUT_DSCR_STATE: u2,

          /// [20:22] reserved
          OUT_STATE: u3,

          /// [23:31] 
          res0: u9,

        }), @ptrFromInt(0x600800ec));

        /// Outlink descriptor address when EOF occurs of Tx channel 0
        pub const OUT_EOF_DES_ADDR_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] This register stores the address of the outlink descriptor when the EOF bit in this descriptor is 1.
          OUT_EOF_DES_ADDR: u32,

        }), @ptrFromInt(0x600800e8));

        /// Outlink descriptor address when EOF occurs of Tx channel 0
        pub const OUT_EOF_DES_ADDR_CH1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] This register stores the address of the outlink descriptor when the EOF bit in this descriptor is 1.
          OUT_EOF_DES_ADDR: u32,

        }), @ptrFromInt(0x600800ec));

        /// Outlink descriptor address when EOF occurs of Tx channel 0
        pub const OUT_EOF_DES_ADDR_CH2 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] This register stores the address of the outlink descriptor when the EOF bit in this descriptor is 1.
          OUT_EOF_DES_ADDR: u32,

        }), @ptrFromInt(0x600800f0));

        /// The last outlink descriptor address when EOF occurs of Tx channel 0
        pub const OUT_EOF_BFR_DES_ADDR_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] This register stores the address of the outlink descriptor before the last outlink descriptor.
          OUT_EOF_BFR_DES_ADDR: u32,

        }), @ptrFromInt(0x600800ec));

        /// The last outlink descriptor address when EOF occurs of Tx channel 0
        pub const OUT_EOF_BFR_DES_ADDR_CH1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] This register stores the address of the outlink descriptor before the last outlink descriptor.
          OUT_EOF_BFR_DES_ADDR: u32,

        }), @ptrFromInt(0x600800f0));

        /// The last outlink descriptor address when EOF occurs of Tx channel 0
        pub const OUT_EOF_BFR_DES_ADDR_CH2 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] This register stores the address of the outlink descriptor before the last outlink descriptor.
          OUT_EOF_BFR_DES_ADDR: u32,

        }), @ptrFromInt(0x600800f4));

        /// Current inlink descriptor address of Tx channel 0
        pub const OUT_DSCR_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] The address of the current outlink descriptor y.
          OUTLINK_DSCR: u32,

        }), @ptrFromInt(0x600800f0));

        /// Current inlink descriptor address of Tx channel 0
        pub const OUT_DSCR_CH1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] The address of the current outlink descriptor y.
          OUTLINK_DSCR: u32,

        }), @ptrFromInt(0x600800f4));

        /// Current inlink descriptor address of Tx channel 0
        pub const OUT_DSCR_CH2 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] The address of the current outlink descriptor y.
          OUTLINK_DSCR: u32,

        }), @ptrFromInt(0x600800f8));

        /// The last inlink descriptor address of Tx channel 0
        pub const OUT_DSCR_BF0_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] The address of the last outlink descriptor y-1.
          OUTLINK_DSCR_BF0: u32,

        }), @ptrFromInt(0x600800f4));

        /// The last inlink descriptor address of Tx channel 0
        pub const OUT_DSCR_BF0_CH1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] The address of the last outlink descriptor y-1.
          OUTLINK_DSCR_BF0: u32,

        }), @ptrFromInt(0x600800f8));

        /// The last inlink descriptor address of Tx channel 0
        pub const OUT_DSCR_BF0_CH2 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] The address of the last outlink descriptor y-1.
          OUTLINK_DSCR_BF0: u32,

        }), @ptrFromInt(0x600800fc));

        /// The second-to-last inlink descriptor address of Tx channel 0
        pub const OUT_DSCR_BF1_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] The address of the second-to-last inlink descriptor x-2.
          OUTLINK_DSCR_BF1: u32,

        }), @ptrFromInt(0x600800f8));

        /// The second-to-last inlink descriptor address of Tx channel 0
        pub const OUT_DSCR_BF1_CH1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] The address of the second-to-last inlink descriptor x-2.
          OUTLINK_DSCR_BF1: u32,

        }), @ptrFromInt(0x600800fc));

        /// The second-to-last inlink descriptor address of Tx channel 0
        pub const OUT_DSCR_BF1_CH2 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] The address of the second-to-last inlink descriptor x-2.
          OUTLINK_DSCR_BF1: u32,

        }), @ptrFromInt(0x60080100));

        /// Priority register of Tx channel 0.
        pub const OUT_PRI_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:3] The priority of Tx channel 0. The larger of the value the higher of the priority.
          TX_PRI: u4,

          /// [4:31] 
          res0: u28,

        }), @ptrFromInt(0x600800fc));

        /// Priority register of Tx channel 0.
        pub const OUT_PRI_CH1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:3] The priority of Tx channel 0. The larger of the value the higher of the priority.
          TX_PRI: u4,

          /// [4:31] 
          res0: u28,

        }), @ptrFromInt(0x60080100));

        /// Priority register of Tx channel 0.
        pub const OUT_PRI_CH2 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:3] The priority of Tx channel 0. The larger of the value the higher of the priority.
          TX_PRI: u4,

          /// [4:31] 
          res0: u28,

        }), @ptrFromInt(0x60080104));

        /// Peripheral selection of Tx channel 0
        pub const OUT_PERI_SEL_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] This register is used to select peripheral for Tx channel 0. 0:SPI2. 1: Dummy. 2: UHCI0. 3: I2S0. 4: Dummy. 5: Dummy. 6: AES. 7: SHA. 8: ADC_DAC. 9: Parallel_IO. 10~15: Dummy
          PERI_OUT_SEL: u6,

          /// [6:31] 
          res0: u26,

        }), @ptrFromInt(0x60080100));

        /// Peripheral selection of Tx channel 0
        pub const OUT_PERI_SEL_CH1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] This register is used to select peripheral for Tx channel 0. 0:SPI2. 1: Dummy. 2: UHCI0. 3: I2S0. 4: Dummy. 5: Dummy. 6: AES. 7: SHA. 8: ADC_DAC. 9: Parallel_IO. 10~15: Dummy
          PERI_OUT_SEL: u6,

          /// [6:31] 
          res0: u26,

        }), @ptrFromInt(0x60080104));

        /// Peripheral selection of Tx channel 0
        pub const OUT_PERI_SEL_CH2 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] This register is used to select peripheral for Tx channel 0. 0:SPI2. 1: Dummy. 2: UHCI0. 3: I2S0. 4: Dummy. 5: Dummy. 6: AES. 7: SHA. 8: ADC_DAC. 9: Parallel_IO. 10~15: Dummy
          PERI_OUT_SEL: u6,

          /// [6:31] 
          res0: u26,

        }), @ptrFromInt(0x60080108));

        /// Configure 0 register of Tx channel 1
        pub const OUT_CONF0_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] This bit is used to reset DMA channel 1 Tx FSM and Tx FIFO pointer.
          OUT_RST: u1,

          /// [1:1] reserved
          OUT_LOOP_TEST: u1,

          /// [2:2] Set this bit to enable automatic outlink-writeback when all the data in tx buffer has been transmitted.
          OUT_AUTO_WRBACK: u1,

          /// [3:3] EOF flag generation mode when transmitting data. 1: EOF flag for Tx channel 1 is generated when data need to transmit has been popped from FIFO in DMA
          OUT_EOF_MODE: u1,

          /// [4:4] Set this bit to 1 to enable INCR burst transfer for Tx channel 1 reading link descriptor when accessing internal SRAM.
          OUTDSCR_BURST_EN: u1,

          /// [5:5] Set this bit to 1 to enable INCR burst transfer for Tx channel 1 transmitting data when accessing internal SRAM.
          OUT_DATA_BURST_EN: u1,

          /// [6:6] Set this bit to 1 to enable etm control mode, dma Tx channel 1 is triggered by etm task.
          OUT_ETM_EN: u1,

          /// [7:31] 
          res0: u25,

        }), @ptrFromInt(0x60080190));

        /// Configure 0 register of Tx channel 1
        pub const OUT_CONF0_CH1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] This bit is used to reset DMA channel 1 Tx FSM and Tx FIFO pointer.
          OUT_RST: u1,

          /// [1:1] reserved
          OUT_LOOP_TEST: u1,

          /// [2:2] Set this bit to enable automatic outlink-writeback when all the data in tx buffer has been transmitted.
          OUT_AUTO_WRBACK: u1,

          /// [3:3] EOF flag generation mode when transmitting data. 1: EOF flag for Tx channel 1 is generated when data need to transmit has been popped from FIFO in DMA
          OUT_EOF_MODE: u1,

          /// [4:4] Set this bit to 1 to enable INCR burst transfer for Tx channel 1 reading link descriptor when accessing internal SRAM.
          OUTDSCR_BURST_EN: u1,

          /// [5:5] Set this bit to 1 to enable INCR burst transfer for Tx channel 1 transmitting data when accessing internal SRAM.
          OUT_DATA_BURST_EN: u1,

          /// [6:6] Set this bit to 1 to enable etm control mode, dma Tx channel 1 is triggered by etm task.
          OUT_ETM_EN: u1,

          /// [7:31] 
          res0: u25,

        }), @ptrFromInt(0x60080194));

        /// Configure 0 register of Tx channel 1
        pub const OUT_CONF0_CH2 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] This bit is used to reset DMA channel 1 Tx FSM and Tx FIFO pointer.
          OUT_RST: u1,

          /// [1:1] reserved
          OUT_LOOP_TEST: u1,

          /// [2:2] Set this bit to enable automatic outlink-writeback when all the data in tx buffer has been transmitted.
          OUT_AUTO_WRBACK: u1,

          /// [3:3] EOF flag generation mode when transmitting data. 1: EOF flag for Tx channel 1 is generated when data need to transmit has been popped from FIFO in DMA
          OUT_EOF_MODE: u1,

          /// [4:4] Set this bit to 1 to enable INCR burst transfer for Tx channel 1 reading link descriptor when accessing internal SRAM.
          OUTDSCR_BURST_EN: u1,

          /// [5:5] Set this bit to 1 to enable INCR burst transfer for Tx channel 1 transmitting data when accessing internal SRAM.
          OUT_DATA_BURST_EN: u1,

          /// [6:6] Set this bit to 1 to enable etm control mode, dma Tx channel 1 is triggered by etm task.
          OUT_ETM_EN: u1,

          /// [7:31] 
          res0: u25,

        }), @ptrFromInt(0x60080198));

      };

      /// Digital Signature
      pub const DS = struct {

        /// memory that stores Y
        pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c000));

        /// memory that stores Y
        pub const Y_MEM1 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c001));

        /// memory that stores Y
        pub const Y_MEM2 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c002));

        /// memory that stores Y
        pub const Y_MEM3 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c003));

        /// memory that stores Y
        pub const Y_MEM4 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c004));

        /// memory that stores Y
        pub const Y_MEM5 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c005));

        /// memory that stores Y
        pub const Y_MEM6 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c006));

        /// memory that stores Y
        pub const Y_MEM7 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c007));

        /// memory that stores Y
        pub const Y_MEM8 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c008));

        /// memory that stores Y
        pub const Y_MEM9 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c009));

        /// memory that stores Y
        pub const Y_MEM10 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c00a));

        /// memory that stores Y
        pub const Y_MEM11 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c00b));

        /// memory that stores Y
        pub const Y_MEM12 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c00c));

        /// memory that stores Y
        pub const Y_MEM13 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c00d));

        /// memory that stores Y
        pub const Y_MEM14 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c00e));

        /// memory that stores Y
        pub const Y_MEM15 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c00f));

        /// memory that stores Y
        pub const Y_MEM16 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c010));

        /// memory that stores Y
        pub const Y_MEM17 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c011));

        /// memory that stores Y
        pub const Y_MEM18 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c012));

        /// memory that stores Y
        pub const Y_MEM19 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c013));

        /// memory that stores Y
        pub const Y_MEM20 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c014));

        /// memory that stores Y
        pub const Y_MEM21 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c015));

        /// memory that stores Y
        pub const Y_MEM22 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c016));

        /// memory that stores Y
        pub const Y_MEM23 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c017));

        /// memory that stores Y
        pub const Y_MEM24 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c018));

        /// memory that stores Y
        pub const Y_MEM25 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c019));

        /// memory that stores Y
        pub const Y_MEM26 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c01a));

        /// memory that stores Y
        pub const Y_MEM27 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c01b));

        /// memory that stores Y
        pub const Y_MEM28 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c01c));

        /// memory that stores Y
        pub const Y_MEM29 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c01d));

        /// memory that stores Y
        pub const Y_MEM30 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c01e));

        /// memory that stores Y
        pub const Y_MEM31 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c01f));

        /// memory that stores Y
        pub const Y_MEM32 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c020));

        /// memory that stores Y
        pub const Y_MEM33 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c021));

        /// memory that stores Y
        pub const Y_MEM34 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c022));

        /// memory that stores Y
        pub const Y_MEM35 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c023));

        /// memory that stores Y
        pub const Y_MEM36 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c024));

        /// memory that stores Y
        pub const Y_MEM37 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c025));

        /// memory that stores Y
        pub const Y_MEM38 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c026));

        /// memory that stores Y
        pub const Y_MEM39 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c027));

        /// memory that stores Y
        pub const Y_MEM40 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c028));

        /// memory that stores Y
        pub const Y_MEM41 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c029));

        /// memory that stores Y
        pub const Y_MEM42 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c02a));

        /// memory that stores Y
        pub const Y_MEM43 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c02b));

        /// memory that stores Y
        pub const Y_MEM44 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c02c));

        /// memory that stores Y
        pub const Y_MEM45 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c02d));

        /// memory that stores Y
        pub const Y_MEM46 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c02e));

        /// memory that stores Y
        pub const Y_MEM47 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c02f));

        /// memory that stores Y
        pub const Y_MEM48 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c030));

        /// memory that stores Y
        pub const Y_MEM49 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c031));

        /// memory that stores Y
        pub const Y_MEM50 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c032));

        /// memory that stores Y
        pub const Y_MEM51 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c033));

        /// memory that stores Y
        pub const Y_MEM52 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c034));

        /// memory that stores Y
        pub const Y_MEM53 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c035));

        /// memory that stores Y
        pub const Y_MEM54 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c036));

        /// memory that stores Y
        pub const Y_MEM55 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c037));

        /// memory that stores Y
        pub const Y_MEM56 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c038));

        /// memory that stores Y
        pub const Y_MEM57 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c039));

        /// memory that stores Y
        pub const Y_MEM58 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c03a));

        /// memory that stores Y
        pub const Y_MEM59 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c03b));

        /// memory that stores Y
        pub const Y_MEM60 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c03c));

        /// memory that stores Y
        pub const Y_MEM61 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c03d));

        /// memory that stores Y
        pub const Y_MEM62 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c03e));

        /// memory that stores Y
        pub const Y_MEM63 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c03f));

        /// memory that stores Y
        pub const Y_MEM64 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c040));

        /// memory that stores Y
        pub const Y_MEM65 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c041));

        /// memory that stores Y
        pub const Y_MEM66 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c042));

        /// memory that stores Y
        pub const Y_MEM67 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c043));

        /// memory that stores Y
        pub const Y_MEM68 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c044));

        /// memory that stores Y
        pub const Y_MEM69 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c045));

        /// memory that stores Y
        pub const Y_MEM70 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c046));

        /// memory that stores Y
        pub const Y_MEM71 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c047));

        /// memory that stores Y
        pub const Y_MEM72 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c048));

        /// memory that stores Y
        pub const Y_MEM73 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c049));

        /// memory that stores Y
        pub const Y_MEM74 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c04a));

        /// memory that stores Y
        pub const Y_MEM75 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c04b));

        /// memory that stores Y
        pub const Y_MEM76 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c04c));

        /// memory that stores Y
        pub const Y_MEM77 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c04d));

        /// memory that stores Y
        pub const Y_MEM78 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c04e));

        /// memory that stores Y
        pub const Y_MEM79 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c04f));

        /// memory that stores Y
        pub const Y_MEM80 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c050));

        /// memory that stores Y
        pub const Y_MEM81 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c051));

        /// memory that stores Y
        pub const Y_MEM82 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c052));

        /// memory that stores Y
        pub const Y_MEM83 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c053));

        /// memory that stores Y
        pub const Y_MEM84 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c054));

        /// memory that stores Y
        pub const Y_MEM85 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c055));

        /// memory that stores Y
        pub const Y_MEM86 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c056));

        /// memory that stores Y
        pub const Y_MEM87 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c057));

        /// memory that stores Y
        pub const Y_MEM88 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c058));

        /// memory that stores Y
        pub const Y_MEM89 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c059));

        /// memory that stores Y
        pub const Y_MEM90 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c05a));

        /// memory that stores Y
        pub const Y_MEM91 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c05b));

        /// memory that stores Y
        pub const Y_MEM92 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c05c));

        /// memory that stores Y
        pub const Y_MEM93 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c05d));

        /// memory that stores Y
        pub const Y_MEM94 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c05e));

        /// memory that stores Y
        pub const Y_MEM95 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c05f));

        /// memory that stores Y
        pub const Y_MEM96 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c060));

        /// memory that stores Y
        pub const Y_MEM97 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c061));

        /// memory that stores Y
        pub const Y_MEM98 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c062));

        /// memory that stores Y
        pub const Y_MEM99 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c063));

        /// memory that stores Y
        pub const Y_MEM100 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c064));

        /// memory that stores Y
        pub const Y_MEM101 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c065));

        /// memory that stores Y
        pub const Y_MEM102 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c066));

        /// memory that stores Y
        pub const Y_MEM103 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c067));

        /// memory that stores Y
        pub const Y_MEM104 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c068));

        /// memory that stores Y
        pub const Y_MEM105 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c069));

        /// memory that stores Y
        pub const Y_MEM106 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c06a));

        /// memory that stores Y
        pub const Y_MEM107 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c06b));

        /// memory that stores Y
        pub const Y_MEM108 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c06c));

        /// memory that stores Y
        pub const Y_MEM109 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c06d));

        /// memory that stores Y
        pub const Y_MEM110 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c06e));

        /// memory that stores Y
        pub const Y_MEM111 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c06f));

        /// memory that stores Y
        pub const Y_MEM112 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c070));

        /// memory that stores Y
        pub const Y_MEM113 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c071));

        /// memory that stores Y
        pub const Y_MEM114 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c072));

        /// memory that stores Y
        pub const Y_MEM115 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c073));

        /// memory that stores Y
        pub const Y_MEM116 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c074));

        /// memory that stores Y
        pub const Y_MEM117 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c075));

        /// memory that stores Y
        pub const Y_MEM118 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c076));

        /// memory that stores Y
        pub const Y_MEM119 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c077));

        /// memory that stores Y
        pub const Y_MEM120 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c078));

        /// memory that stores Y
        pub const Y_MEM121 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c079));

        /// memory that stores Y
        pub const Y_MEM122 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c07a));

        /// memory that stores Y
        pub const Y_MEM123 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c07b));

        /// memory that stores Y
        pub const Y_MEM124 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c07c));

        /// memory that stores Y
        pub const Y_MEM125 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c07d));

        /// memory that stores Y
        pub const Y_MEM126 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c07e));

        /// memory that stores Y
        pub const Y_MEM127 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c07f));

        /// memory that stores Y
        pub const Y_MEM128 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c080));

        /// memory that stores Y
        pub const Y_MEM129 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c081));

        /// memory that stores Y
        pub const Y_MEM130 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c082));

        /// memory that stores Y
        pub const Y_MEM131 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c083));

        /// memory that stores Y
        pub const Y_MEM132 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c084));

        /// memory that stores Y
        pub const Y_MEM133 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c085));

        /// memory that stores Y
        pub const Y_MEM134 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c086));

        /// memory that stores Y
        pub const Y_MEM135 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c087));

        /// memory that stores Y
        pub const Y_MEM136 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c088));

        /// memory that stores Y
        pub const Y_MEM137 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c089));

        /// memory that stores Y
        pub const Y_MEM138 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c08a));

        /// memory that stores Y
        pub const Y_MEM139 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c08b));

        /// memory that stores Y
        pub const Y_MEM140 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c08c));

        /// memory that stores Y
        pub const Y_MEM141 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c08d));

        /// memory that stores Y
        pub const Y_MEM142 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c08e));

        /// memory that stores Y
        pub const Y_MEM143 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c08f));

        /// memory that stores Y
        pub const Y_MEM144 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c090));

        /// memory that stores Y
        pub const Y_MEM145 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c091));

        /// memory that stores Y
        pub const Y_MEM146 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c092));

        /// memory that stores Y
        pub const Y_MEM147 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c093));

        /// memory that stores Y
        pub const Y_MEM148 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c094));

        /// memory that stores Y
        pub const Y_MEM149 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c095));

        /// memory that stores Y
        pub const Y_MEM150 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c096));

        /// memory that stores Y
        pub const Y_MEM151 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c097));

        /// memory that stores Y
        pub const Y_MEM152 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c098));

        /// memory that stores Y
        pub const Y_MEM153 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c099));

        /// memory that stores Y
        pub const Y_MEM154 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c09a));

        /// memory that stores Y
        pub const Y_MEM155 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c09b));

        /// memory that stores Y
        pub const Y_MEM156 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c09c));

        /// memory that stores Y
        pub const Y_MEM157 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c09d));

        /// memory that stores Y
        pub const Y_MEM158 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c09e));

        /// memory that stores Y
        pub const Y_MEM159 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c09f));

        /// memory that stores Y
        pub const Y_MEM160 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c0a0));

        /// memory that stores Y
        pub const Y_MEM161 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c0a1));

        /// memory that stores Y
        pub const Y_MEM162 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c0a2));

        /// memory that stores Y
        pub const Y_MEM163 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c0a3));

        /// memory that stores Y
        pub const Y_MEM164 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c0a4));

        /// memory that stores Y
        pub const Y_MEM165 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c0a5));

        /// memory that stores Y
        pub const Y_MEM166 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c0a6));

        /// memory that stores Y
        pub const Y_MEM167 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c0a7));

        /// memory that stores Y
        pub const Y_MEM168 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c0a8));

        /// memory that stores Y
        pub const Y_MEM169 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c0a9));

        /// memory that stores Y
        pub const Y_MEM170 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c0aa));

        /// memory that stores Y
        pub const Y_MEM171 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c0ab));

        /// memory that stores Y
        pub const Y_MEM172 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c0ac));

        /// memory that stores Y
        pub const Y_MEM173 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c0ad));

        /// memory that stores Y
        pub const Y_MEM174 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c0ae));

        /// memory that stores Y
        pub const Y_MEM175 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c0af));

        /// memory that stores Y
        pub const Y_MEM176 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c0b0));

        /// memory that stores Y
        pub const Y_MEM177 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c0b1));

        /// memory that stores Y
        pub const Y_MEM178 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c0b2));

        /// memory that stores Y
        pub const Y_MEM179 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c0b3));

        /// memory that stores Y
        pub const Y_MEM180 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c0b4));

        /// memory that stores Y
        pub const Y_MEM181 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c0b5));

        /// memory that stores Y
        pub const Y_MEM182 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c0b6));

        /// memory that stores Y
        pub const Y_MEM183 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c0b7));

        /// memory that stores Y
        pub const Y_MEM184 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c0b8));

        /// memory that stores Y
        pub const Y_MEM185 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c0b9));

        /// memory that stores Y
        pub const Y_MEM186 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c0ba));

        /// memory that stores Y
        pub const Y_MEM187 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c0bb));

        /// memory that stores Y
        pub const Y_MEM188 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c0bc));

        /// memory that stores Y
        pub const Y_MEM189 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c0bd));

        /// memory that stores Y
        pub const Y_MEM190 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c0be));

        /// memory that stores Y
        pub const Y_MEM191 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c0bf));

        /// memory that stores Y
        pub const Y_MEM192 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c0c0));

        /// memory that stores Y
        pub const Y_MEM193 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c0c1));

        /// memory that stores Y
        pub const Y_MEM194 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c0c2));

        /// memory that stores Y
        pub const Y_MEM195 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c0c3));

        /// memory that stores Y
        pub const Y_MEM196 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c0c4));

        /// memory that stores Y
        pub const Y_MEM197 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c0c5));

        /// memory that stores Y
        pub const Y_MEM198 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c0c6));

        /// memory that stores Y
        pub const Y_MEM199 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c0c7));

        /// memory that stores Y
        pub const Y_MEM200 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c0c8));

        /// memory that stores Y
        pub const Y_MEM201 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c0c9));

        /// memory that stores Y
        pub const Y_MEM202 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c0ca));

        /// memory that stores Y
        pub const Y_MEM203 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c0cb));

        /// memory that stores Y
        pub const Y_MEM204 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c0cc));

        /// memory that stores Y
        pub const Y_MEM205 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c0cd));

        /// memory that stores Y
        pub const Y_MEM206 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c0ce));

        /// memory that stores Y
        pub const Y_MEM207 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c0cf));

        /// memory that stores Y
        pub const Y_MEM208 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c0d0));

        /// memory that stores Y
        pub const Y_MEM209 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c0d1));

        /// memory that stores Y
        pub const Y_MEM210 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c0d2));

        /// memory that stores Y
        pub const Y_MEM211 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c0d3));

        /// memory that stores Y
        pub const Y_MEM212 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c0d4));

        /// memory that stores Y
        pub const Y_MEM213 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c0d5));

        /// memory that stores Y
        pub const Y_MEM214 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c0d6));

        /// memory that stores Y
        pub const Y_MEM215 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c0d7));

        /// memory that stores Y
        pub const Y_MEM216 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c0d8));

        /// memory that stores Y
        pub const Y_MEM217 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c0d9));

        /// memory that stores Y
        pub const Y_MEM218 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c0da));

        /// memory that stores Y
        pub const Y_MEM219 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c0db));

        /// memory that stores Y
        pub const Y_MEM220 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c0dc));

        /// memory that stores Y
        pub const Y_MEM221 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c0dd));

        /// memory that stores Y
        pub const Y_MEM222 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c0de));

        /// memory that stores Y
        pub const Y_MEM223 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c0df));

        /// memory that stores Y
        pub const Y_MEM224 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c0e0));

        /// memory that stores Y
        pub const Y_MEM225 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c0e1));

        /// memory that stores Y
        pub const Y_MEM226 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c0e2));

        /// memory that stores Y
        pub const Y_MEM227 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c0e3));

        /// memory that stores Y
        pub const Y_MEM228 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c0e4));

        /// memory that stores Y
        pub const Y_MEM229 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c0e5));

        /// memory that stores Y
        pub const Y_MEM230 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c0e6));

        /// memory that stores Y
        pub const Y_MEM231 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c0e7));

        /// memory that stores Y
        pub const Y_MEM232 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c0e8));

        /// memory that stores Y
        pub const Y_MEM233 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c0e9));

        /// memory that stores Y
        pub const Y_MEM234 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c0ea));

        /// memory that stores Y
        pub const Y_MEM235 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c0eb));

        /// memory that stores Y
        pub const Y_MEM236 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c0ec));

        /// memory that stores Y
        pub const Y_MEM237 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c0ed));

        /// memory that stores Y
        pub const Y_MEM238 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c0ee));

        /// memory that stores Y
        pub const Y_MEM239 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c0ef));

        /// memory that stores Y
        pub const Y_MEM240 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c0f0));

        /// memory that stores Y
        pub const Y_MEM241 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c0f1));

        /// memory that stores Y
        pub const Y_MEM242 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c0f2));

        /// memory that stores Y
        pub const Y_MEM243 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c0f3));

        /// memory that stores Y
        pub const Y_MEM244 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c0f4));

        /// memory that stores Y
        pub const Y_MEM245 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c0f5));

        /// memory that stores Y
        pub const Y_MEM246 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c0f6));

        /// memory that stores Y
        pub const Y_MEM247 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c0f7));

        /// memory that stores Y
        pub const Y_MEM248 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c0f8));

        /// memory that stores Y
        pub const Y_MEM249 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c0f9));

        /// memory that stores Y
        pub const Y_MEM250 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c0fa));

        /// memory that stores Y
        pub const Y_MEM251 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c0fb));

        /// memory that stores Y
        pub const Y_MEM252 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c0fc));

        /// memory that stores Y
        pub const Y_MEM253 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c0fd));

        /// memory that stores Y
        pub const Y_MEM254 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c0fe));

        /// memory that stores Y
        pub const Y_MEM255 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c0ff));

        /// memory that stores Y
        pub const Y_MEM256 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c100));

        /// memory that stores Y
        pub const Y_MEM257 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c101));

        /// memory that stores Y
        pub const Y_MEM258 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c102));

        /// memory that stores Y
        pub const Y_MEM259 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c103));

        /// memory that stores Y
        pub const Y_MEM260 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c104));

        /// memory that stores Y
        pub const Y_MEM261 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c105));

        /// memory that stores Y
        pub const Y_MEM262 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c106));

        /// memory that stores Y
        pub const Y_MEM263 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c107));

        /// memory that stores Y
        pub const Y_MEM264 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c108));

        /// memory that stores Y
        pub const Y_MEM265 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c109));

        /// memory that stores Y
        pub const Y_MEM266 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c10a));

        /// memory that stores Y
        pub const Y_MEM267 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c10b));

        /// memory that stores Y
        pub const Y_MEM268 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c10c));

        /// memory that stores Y
        pub const Y_MEM269 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c10d));

        /// memory that stores Y
        pub const Y_MEM270 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c10e));

        /// memory that stores Y
        pub const Y_MEM271 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c10f));

        /// memory that stores Y
        pub const Y_MEM272 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c110));

        /// memory that stores Y
        pub const Y_MEM273 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c111));

        /// memory that stores Y
        pub const Y_MEM274 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c112));

        /// memory that stores Y
        pub const Y_MEM275 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c113));

        /// memory that stores Y
        pub const Y_MEM276 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c114));

        /// memory that stores Y
        pub const Y_MEM277 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c115));

        /// memory that stores Y
        pub const Y_MEM278 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c116));

        /// memory that stores Y
        pub const Y_MEM279 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c117));

        /// memory that stores Y
        pub const Y_MEM280 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c118));

        /// memory that stores Y
        pub const Y_MEM281 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c119));

        /// memory that stores Y
        pub const Y_MEM282 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c11a));

        /// memory that stores Y
        pub const Y_MEM283 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c11b));

        /// memory that stores Y
        pub const Y_MEM284 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c11c));

        /// memory that stores Y
        pub const Y_MEM285 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c11d));

        /// memory that stores Y
        pub const Y_MEM286 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c11e));

        /// memory that stores Y
        pub const Y_MEM287 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c11f));

        /// memory that stores Y
        pub const Y_MEM288 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c120));

        /// memory that stores Y
        pub const Y_MEM289 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c121));

        /// memory that stores Y
        pub const Y_MEM290 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c122));

        /// memory that stores Y
        pub const Y_MEM291 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c123));

        /// memory that stores Y
        pub const Y_MEM292 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c124));

        /// memory that stores Y
        pub const Y_MEM293 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c125));

        /// memory that stores Y
        pub const Y_MEM294 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c126));

        /// memory that stores Y
        pub const Y_MEM295 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c127));

        /// memory that stores Y
        pub const Y_MEM296 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c128));

        /// memory that stores Y
        pub const Y_MEM297 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c129));

        /// memory that stores Y
        pub const Y_MEM298 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c12a));

        /// memory that stores Y
        pub const Y_MEM299 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c12b));

        /// memory that stores Y
        pub const Y_MEM300 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c12c));

        /// memory that stores Y
        pub const Y_MEM301 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c12d));

        /// memory that stores Y
        pub const Y_MEM302 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c12e));

        /// memory that stores Y
        pub const Y_MEM303 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c12f));

        /// memory that stores Y
        pub const Y_MEM304 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c130));

        /// memory that stores Y
        pub const Y_MEM305 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c131));

        /// memory that stores Y
        pub const Y_MEM306 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c132));

        /// memory that stores Y
        pub const Y_MEM307 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c133));

        /// memory that stores Y
        pub const Y_MEM308 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c134));

        /// memory that stores Y
        pub const Y_MEM309 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c135));

        /// memory that stores Y
        pub const Y_MEM310 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c136));

        /// memory that stores Y
        pub const Y_MEM311 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c137));

        /// memory that stores Y
        pub const Y_MEM312 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c138));

        /// memory that stores Y
        pub const Y_MEM313 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c139));

        /// memory that stores Y
        pub const Y_MEM314 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c13a));

        /// memory that stores Y
        pub const Y_MEM315 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c13b));

        /// memory that stores Y
        pub const Y_MEM316 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c13c));

        /// memory that stores Y
        pub const Y_MEM317 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c13d));

        /// memory that stores Y
        pub const Y_MEM318 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c13e));

        /// memory that stores Y
        pub const Y_MEM319 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c13f));

        /// memory that stores Y
        pub const Y_MEM320 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c140));

        /// memory that stores Y
        pub const Y_MEM321 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c141));

        /// memory that stores Y
        pub const Y_MEM322 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c142));

        /// memory that stores Y
        pub const Y_MEM323 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c143));

        /// memory that stores Y
        pub const Y_MEM324 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c144));

        /// memory that stores Y
        pub const Y_MEM325 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c145));

        /// memory that stores Y
        pub const Y_MEM326 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c146));

        /// memory that stores Y
        pub const Y_MEM327 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c147));

        /// memory that stores Y
        pub const Y_MEM328 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c148));

        /// memory that stores Y
        pub const Y_MEM329 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c149));

        /// memory that stores Y
        pub const Y_MEM330 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c14a));

        /// memory that stores Y
        pub const Y_MEM331 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c14b));

        /// memory that stores Y
        pub const Y_MEM332 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c14c));

        /// memory that stores Y
        pub const Y_MEM333 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c14d));

        /// memory that stores Y
        pub const Y_MEM334 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c14e));

        /// memory that stores Y
        pub const Y_MEM335 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c14f));

        /// memory that stores Y
        pub const Y_MEM336 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c150));

        /// memory that stores Y
        pub const Y_MEM337 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c151));

        /// memory that stores Y
        pub const Y_MEM338 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c152));

        /// memory that stores Y
        pub const Y_MEM339 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c153));

        /// memory that stores Y
        pub const Y_MEM340 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c154));

        /// memory that stores Y
        pub const Y_MEM341 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c155));

        /// memory that stores Y
        pub const Y_MEM342 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c156));

        /// memory that stores Y
        pub const Y_MEM343 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c157));

        /// memory that stores Y
        pub const Y_MEM344 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c158));

        /// memory that stores Y
        pub const Y_MEM345 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c159));

        /// memory that stores Y
        pub const Y_MEM346 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c15a));

        /// memory that stores Y
        pub const Y_MEM347 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c15b));

        /// memory that stores Y
        pub const Y_MEM348 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c15c));

        /// memory that stores Y
        pub const Y_MEM349 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c15d));

        /// memory that stores Y
        pub const Y_MEM350 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c15e));

        /// memory that stores Y
        pub const Y_MEM351 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c15f));

        /// memory that stores Y
        pub const Y_MEM352 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c160));

        /// memory that stores Y
        pub const Y_MEM353 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c161));

        /// memory that stores Y
        pub const Y_MEM354 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c162));

        /// memory that stores Y
        pub const Y_MEM355 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c163));

        /// memory that stores Y
        pub const Y_MEM356 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c164));

        /// memory that stores Y
        pub const Y_MEM357 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c165));

        /// memory that stores Y
        pub const Y_MEM358 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c166));

        /// memory that stores Y
        pub const Y_MEM359 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c167));

        /// memory that stores Y
        pub const Y_MEM360 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c168));

        /// memory that stores Y
        pub const Y_MEM361 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c169));

        /// memory that stores Y
        pub const Y_MEM362 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c16a));

        /// memory that stores Y
        pub const Y_MEM363 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c16b));

        /// memory that stores Y
        pub const Y_MEM364 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c16c));

        /// memory that stores Y
        pub const Y_MEM365 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c16d));

        /// memory that stores Y
        pub const Y_MEM366 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c16e));

        /// memory that stores Y
        pub const Y_MEM367 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c16f));

        /// memory that stores Y
        pub const Y_MEM368 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c170));

        /// memory that stores Y
        pub const Y_MEM369 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c171));

        /// memory that stores Y
        pub const Y_MEM370 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c172));

        /// memory that stores Y
        pub const Y_MEM371 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c173));

        /// memory that stores Y
        pub const Y_MEM372 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c174));

        /// memory that stores Y
        pub const Y_MEM373 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c175));

        /// memory that stores Y
        pub const Y_MEM374 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c176));

        /// memory that stores Y
        pub const Y_MEM375 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c177));

        /// memory that stores Y
        pub const Y_MEM376 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c178));

        /// memory that stores Y
        pub const Y_MEM377 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c179));

        /// memory that stores Y
        pub const Y_MEM378 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c17a));

        /// memory that stores Y
        pub const Y_MEM379 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c17b));

        /// memory that stores Y
        pub const Y_MEM380 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c17c));

        /// memory that stores Y
        pub const Y_MEM381 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c17d));

        /// memory that stores Y
        pub const Y_MEM382 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c17e));

        /// memory that stores Y
        pub const Y_MEM383 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c17f));

        /// memory that stores Y
        pub const Y_MEM384 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c180));

        /// memory that stores Y
        pub const Y_MEM385 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c181));

        /// memory that stores Y
        pub const Y_MEM386 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c182));

        /// memory that stores Y
        pub const Y_MEM387 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c183));

        /// memory that stores Y
        pub const Y_MEM388 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c184));

        /// memory that stores Y
        pub const Y_MEM389 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c185));

        /// memory that stores Y
        pub const Y_MEM390 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c186));

        /// memory that stores Y
        pub const Y_MEM391 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c187));

        /// memory that stores Y
        pub const Y_MEM392 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c188));

        /// memory that stores Y
        pub const Y_MEM393 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c189));

        /// memory that stores Y
        pub const Y_MEM394 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c18a));

        /// memory that stores Y
        pub const Y_MEM395 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c18b));

        /// memory that stores Y
        pub const Y_MEM396 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c18c));

        /// memory that stores Y
        pub const Y_MEM397 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c18d));

        /// memory that stores Y
        pub const Y_MEM398 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c18e));

        /// memory that stores Y
        pub const Y_MEM399 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c18f));

        /// memory that stores Y
        pub const Y_MEM400 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c190));

        /// memory that stores Y
        pub const Y_MEM401 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c191));

        /// memory that stores Y
        pub const Y_MEM402 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c192));

        /// memory that stores Y
        pub const Y_MEM403 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c193));

        /// memory that stores Y
        pub const Y_MEM404 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c194));

        /// memory that stores Y
        pub const Y_MEM405 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c195));

        /// memory that stores Y
        pub const Y_MEM406 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c196));

        /// memory that stores Y
        pub const Y_MEM407 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c197));

        /// memory that stores Y
        pub const Y_MEM408 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c198));

        /// memory that stores Y
        pub const Y_MEM409 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c199));

        /// memory that stores Y
        pub const Y_MEM410 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c19a));

        /// memory that stores Y
        pub const Y_MEM411 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c19b));

        /// memory that stores Y
        pub const Y_MEM412 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c19c));

        /// memory that stores Y
        pub const Y_MEM413 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c19d));

        /// memory that stores Y
        pub const Y_MEM414 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c19e));

        /// memory that stores Y
        pub const Y_MEM415 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c19f));

        /// memory that stores Y
        pub const Y_MEM416 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c1a0));

        /// memory that stores Y
        pub const Y_MEM417 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c1a1));

        /// memory that stores Y
        pub const Y_MEM418 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c1a2));

        /// memory that stores Y
        pub const Y_MEM419 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c1a3));

        /// memory that stores Y
        pub const Y_MEM420 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c1a4));

        /// memory that stores Y
        pub const Y_MEM421 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c1a5));

        /// memory that stores Y
        pub const Y_MEM422 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c1a6));

        /// memory that stores Y
        pub const Y_MEM423 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c1a7));

        /// memory that stores Y
        pub const Y_MEM424 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c1a8));

        /// memory that stores Y
        pub const Y_MEM425 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c1a9));

        /// memory that stores Y
        pub const Y_MEM426 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c1aa));

        /// memory that stores Y
        pub const Y_MEM427 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c1ab));

        /// memory that stores Y
        pub const Y_MEM428 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c1ac));

        /// memory that stores Y
        pub const Y_MEM429 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c1ad));

        /// memory that stores Y
        pub const Y_MEM430 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c1ae));

        /// memory that stores Y
        pub const Y_MEM431 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c1af));

        /// memory that stores Y
        pub const Y_MEM432 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c1b0));

        /// memory that stores Y
        pub const Y_MEM433 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c1b1));

        /// memory that stores Y
        pub const Y_MEM434 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c1b2));

        /// memory that stores Y
        pub const Y_MEM435 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c1b3));

        /// memory that stores Y
        pub const Y_MEM436 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c1b4));

        /// memory that stores Y
        pub const Y_MEM437 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c1b5));

        /// memory that stores Y
        pub const Y_MEM438 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c1b6));

        /// memory that stores Y
        pub const Y_MEM439 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c1b7));

        /// memory that stores Y
        pub const Y_MEM440 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c1b8));

        /// memory that stores Y
        pub const Y_MEM441 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c1b9));

        /// memory that stores Y
        pub const Y_MEM442 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c1ba));

        /// memory that stores Y
        pub const Y_MEM443 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c1bb));

        /// memory that stores Y
        pub const Y_MEM444 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c1bc));

        /// memory that stores Y
        pub const Y_MEM445 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c1bd));

        /// memory that stores Y
        pub const Y_MEM446 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c1be));

        /// memory that stores Y
        pub const Y_MEM447 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c1bf));

        /// memory that stores Y
        pub const Y_MEM448 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c1c0));

        /// memory that stores Y
        pub const Y_MEM449 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c1c1));

        /// memory that stores Y
        pub const Y_MEM450 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c1c2));

        /// memory that stores Y
        pub const Y_MEM451 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c1c3));

        /// memory that stores Y
        pub const Y_MEM452 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c1c4));

        /// memory that stores Y
        pub const Y_MEM453 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c1c5));

        /// memory that stores Y
        pub const Y_MEM454 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c1c6));

        /// memory that stores Y
        pub const Y_MEM455 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c1c7));

        /// memory that stores Y
        pub const Y_MEM456 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c1c8));

        /// memory that stores Y
        pub const Y_MEM457 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c1c9));

        /// memory that stores Y
        pub const Y_MEM458 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c1ca));

        /// memory that stores Y
        pub const Y_MEM459 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c1cb));

        /// memory that stores Y
        pub const Y_MEM460 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c1cc));

        /// memory that stores Y
        pub const Y_MEM461 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c1cd));

        /// memory that stores Y
        pub const Y_MEM462 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c1ce));

        /// memory that stores Y
        pub const Y_MEM463 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c1cf));

        /// memory that stores Y
        pub const Y_MEM464 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c1d0));

        /// memory that stores Y
        pub const Y_MEM465 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c1d1));

        /// memory that stores Y
        pub const Y_MEM466 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c1d2));

        /// memory that stores Y
        pub const Y_MEM467 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c1d3));

        /// memory that stores Y
        pub const Y_MEM468 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c1d4));

        /// memory that stores Y
        pub const Y_MEM469 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c1d5));

        /// memory that stores Y
        pub const Y_MEM470 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c1d6));

        /// memory that stores Y
        pub const Y_MEM471 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c1d7));

        /// memory that stores Y
        pub const Y_MEM472 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c1d8));

        /// memory that stores Y
        pub const Y_MEM473 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c1d9));

        /// memory that stores Y
        pub const Y_MEM474 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c1da));

        /// memory that stores Y
        pub const Y_MEM475 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c1db));

        /// memory that stores Y
        pub const Y_MEM476 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c1dc));

        /// memory that stores Y
        pub const Y_MEM477 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c1dd));

        /// memory that stores Y
        pub const Y_MEM478 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c1de));

        /// memory that stores Y
        pub const Y_MEM479 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c1df));

        /// memory that stores Y
        pub const Y_MEM480 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c1e0));

        /// memory that stores Y
        pub const Y_MEM481 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c1e1));

        /// memory that stores Y
        pub const Y_MEM482 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c1e2));

        /// memory that stores Y
        pub const Y_MEM483 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c1e3));

        /// memory that stores Y
        pub const Y_MEM484 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c1e4));

        /// memory that stores Y
        pub const Y_MEM485 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c1e5));

        /// memory that stores Y
        pub const Y_MEM486 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c1e6));

        /// memory that stores Y
        pub const Y_MEM487 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c1e7));

        /// memory that stores Y
        pub const Y_MEM488 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c1e8));

        /// memory that stores Y
        pub const Y_MEM489 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c1e9));

        /// memory that stores Y
        pub const Y_MEM490 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c1ea));

        /// memory that stores Y
        pub const Y_MEM491 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c1eb));

        /// memory that stores Y
        pub const Y_MEM492 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c1ec));

        /// memory that stores Y
        pub const Y_MEM493 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c1ed));

        /// memory that stores Y
        pub const Y_MEM494 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c1ee));

        /// memory that stores Y
        pub const Y_MEM495 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c1ef));

        /// memory that stores Y
        pub const Y_MEM496 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c1f0));

        /// memory that stores Y
        pub const Y_MEM497 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c1f1));

        /// memory that stores Y
        pub const Y_MEM498 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c1f2));

        /// memory that stores Y
        pub const Y_MEM499 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c1f3));

        /// memory that stores Y
        pub const Y_MEM500 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c1f4));

        /// memory that stores Y
        pub const Y_MEM501 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c1f5));

        /// memory that stores Y
        pub const Y_MEM502 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c1f6));

        /// memory that stores Y
        pub const Y_MEM503 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c1f7));

        /// memory that stores Y
        pub const Y_MEM504 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c1f8));

        /// memory that stores Y
        pub const Y_MEM505 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c1f9));

        /// memory that stores Y
        pub const Y_MEM506 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c1fa));

        /// memory that stores Y
        pub const Y_MEM507 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c1fb));

        /// memory that stores Y
        pub const Y_MEM508 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c1fc));

        /// memory that stores Y
        pub const Y_MEM509 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c1fd));

        /// memory that stores Y
        pub const Y_MEM510 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c1fe));

        /// memory that stores Y
        pub const Y_MEM511 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c1ff));

        /// memory that stores M
        pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c200));

        /// memory that stores M
        pub const M_MEM1 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c201));

        /// memory that stores M
        pub const M_MEM2 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c202));

        /// memory that stores M
        pub const M_MEM3 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c203));

        /// memory that stores M
        pub const M_MEM4 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c204));

        /// memory that stores M
        pub const M_MEM5 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c205));

        /// memory that stores M
        pub const M_MEM6 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c206));

        /// memory that stores M
        pub const M_MEM7 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c207));

        /// memory that stores M
        pub const M_MEM8 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c208));

        /// memory that stores M
        pub const M_MEM9 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c209));

        /// memory that stores M
        pub const M_MEM10 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c20a));

        /// memory that stores M
        pub const M_MEM11 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c20b));

        /// memory that stores M
        pub const M_MEM12 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c20c));

        /// memory that stores M
        pub const M_MEM13 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c20d));

        /// memory that stores M
        pub const M_MEM14 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c20e));

        /// memory that stores M
        pub const M_MEM15 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c20f));

        /// memory that stores M
        pub const M_MEM16 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c210));

        /// memory that stores M
        pub const M_MEM17 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c211));

        /// memory that stores M
        pub const M_MEM18 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c212));

        /// memory that stores M
        pub const M_MEM19 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c213));

        /// memory that stores M
        pub const M_MEM20 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c214));

        /// memory that stores M
        pub const M_MEM21 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c215));

        /// memory that stores M
        pub const M_MEM22 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c216));

        /// memory that stores M
        pub const M_MEM23 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c217));

        /// memory that stores M
        pub const M_MEM24 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c218));

        /// memory that stores M
        pub const M_MEM25 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c219));

        /// memory that stores M
        pub const M_MEM26 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c21a));

        /// memory that stores M
        pub const M_MEM27 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c21b));

        /// memory that stores M
        pub const M_MEM28 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c21c));

        /// memory that stores M
        pub const M_MEM29 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c21d));

        /// memory that stores M
        pub const M_MEM30 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c21e));

        /// memory that stores M
        pub const M_MEM31 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c21f));

        /// memory that stores M
        pub const M_MEM32 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c220));

        /// memory that stores M
        pub const M_MEM33 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c221));

        /// memory that stores M
        pub const M_MEM34 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c222));

        /// memory that stores M
        pub const M_MEM35 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c223));

        /// memory that stores M
        pub const M_MEM36 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c224));

        /// memory that stores M
        pub const M_MEM37 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c225));

        /// memory that stores M
        pub const M_MEM38 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c226));

        /// memory that stores M
        pub const M_MEM39 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c227));

        /// memory that stores M
        pub const M_MEM40 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c228));

        /// memory that stores M
        pub const M_MEM41 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c229));

        /// memory that stores M
        pub const M_MEM42 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c22a));

        /// memory that stores M
        pub const M_MEM43 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c22b));

        /// memory that stores M
        pub const M_MEM44 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c22c));

        /// memory that stores M
        pub const M_MEM45 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c22d));

        /// memory that stores M
        pub const M_MEM46 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c22e));

        /// memory that stores M
        pub const M_MEM47 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c22f));

        /// memory that stores M
        pub const M_MEM48 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c230));

        /// memory that stores M
        pub const M_MEM49 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c231));

        /// memory that stores M
        pub const M_MEM50 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c232));

        /// memory that stores M
        pub const M_MEM51 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c233));

        /// memory that stores M
        pub const M_MEM52 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c234));

        /// memory that stores M
        pub const M_MEM53 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c235));

        /// memory that stores M
        pub const M_MEM54 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c236));

        /// memory that stores M
        pub const M_MEM55 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c237));

        /// memory that stores M
        pub const M_MEM56 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c238));

        /// memory that stores M
        pub const M_MEM57 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c239));

        /// memory that stores M
        pub const M_MEM58 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c23a));

        /// memory that stores M
        pub const M_MEM59 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c23b));

        /// memory that stores M
        pub const M_MEM60 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c23c));

        /// memory that stores M
        pub const M_MEM61 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c23d));

        /// memory that stores M
        pub const M_MEM62 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c23e));

        /// memory that stores M
        pub const M_MEM63 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c23f));

        /// memory that stores M
        pub const M_MEM64 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c240));

        /// memory that stores M
        pub const M_MEM65 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c241));

        /// memory that stores M
        pub const M_MEM66 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c242));

        /// memory that stores M
        pub const M_MEM67 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c243));

        /// memory that stores M
        pub const M_MEM68 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c244));

        /// memory that stores M
        pub const M_MEM69 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c245));

        /// memory that stores M
        pub const M_MEM70 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c246));

        /// memory that stores M
        pub const M_MEM71 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c247));

        /// memory that stores M
        pub const M_MEM72 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c248));

        /// memory that stores M
        pub const M_MEM73 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c249));

        /// memory that stores M
        pub const M_MEM74 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c24a));

        /// memory that stores M
        pub const M_MEM75 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c24b));

        /// memory that stores M
        pub const M_MEM76 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c24c));

        /// memory that stores M
        pub const M_MEM77 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c24d));

        /// memory that stores M
        pub const M_MEM78 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c24e));

        /// memory that stores M
        pub const M_MEM79 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c24f));

        /// memory that stores M
        pub const M_MEM80 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c250));

        /// memory that stores M
        pub const M_MEM81 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c251));

        /// memory that stores M
        pub const M_MEM82 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c252));

        /// memory that stores M
        pub const M_MEM83 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c253));

        /// memory that stores M
        pub const M_MEM84 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c254));

        /// memory that stores M
        pub const M_MEM85 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c255));

        /// memory that stores M
        pub const M_MEM86 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c256));

        /// memory that stores M
        pub const M_MEM87 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c257));

        /// memory that stores M
        pub const M_MEM88 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c258));

        /// memory that stores M
        pub const M_MEM89 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c259));

        /// memory that stores M
        pub const M_MEM90 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c25a));

        /// memory that stores M
        pub const M_MEM91 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c25b));

        /// memory that stores M
        pub const M_MEM92 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c25c));

        /// memory that stores M
        pub const M_MEM93 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c25d));

        /// memory that stores M
        pub const M_MEM94 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c25e));

        /// memory that stores M
        pub const M_MEM95 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c25f));

        /// memory that stores M
        pub const M_MEM96 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c260));

        /// memory that stores M
        pub const M_MEM97 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c261));

        /// memory that stores M
        pub const M_MEM98 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c262));

        /// memory that stores M
        pub const M_MEM99 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c263));

        /// memory that stores M
        pub const M_MEM100 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c264));

        /// memory that stores M
        pub const M_MEM101 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c265));

        /// memory that stores M
        pub const M_MEM102 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c266));

        /// memory that stores M
        pub const M_MEM103 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c267));

        /// memory that stores M
        pub const M_MEM104 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c268));

        /// memory that stores M
        pub const M_MEM105 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c269));

        /// memory that stores M
        pub const M_MEM106 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c26a));

        /// memory that stores M
        pub const M_MEM107 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c26b));

        /// memory that stores M
        pub const M_MEM108 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c26c));

        /// memory that stores M
        pub const M_MEM109 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c26d));

        /// memory that stores M
        pub const M_MEM110 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c26e));

        /// memory that stores M
        pub const M_MEM111 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c26f));

        /// memory that stores M
        pub const M_MEM112 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c270));

        /// memory that stores M
        pub const M_MEM113 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c271));

        /// memory that stores M
        pub const M_MEM114 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c272));

        /// memory that stores M
        pub const M_MEM115 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c273));

        /// memory that stores M
        pub const M_MEM116 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c274));

        /// memory that stores M
        pub const M_MEM117 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c275));

        /// memory that stores M
        pub const M_MEM118 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c276));

        /// memory that stores M
        pub const M_MEM119 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c277));

        /// memory that stores M
        pub const M_MEM120 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c278));

        /// memory that stores M
        pub const M_MEM121 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c279));

        /// memory that stores M
        pub const M_MEM122 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c27a));

        /// memory that stores M
        pub const M_MEM123 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c27b));

        /// memory that stores M
        pub const M_MEM124 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c27c));

        /// memory that stores M
        pub const M_MEM125 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c27d));

        /// memory that stores M
        pub const M_MEM126 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c27e));

        /// memory that stores M
        pub const M_MEM127 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c27f));

        /// memory that stores M
        pub const M_MEM128 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c280));

        /// memory that stores M
        pub const M_MEM129 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c281));

        /// memory that stores M
        pub const M_MEM130 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c282));

        /// memory that stores M
        pub const M_MEM131 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c283));

        /// memory that stores M
        pub const M_MEM132 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c284));

        /// memory that stores M
        pub const M_MEM133 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c285));

        /// memory that stores M
        pub const M_MEM134 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c286));

        /// memory that stores M
        pub const M_MEM135 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c287));

        /// memory that stores M
        pub const M_MEM136 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c288));

        /// memory that stores M
        pub const M_MEM137 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c289));

        /// memory that stores M
        pub const M_MEM138 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c28a));

        /// memory that stores M
        pub const M_MEM139 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c28b));

        /// memory that stores M
        pub const M_MEM140 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c28c));

        /// memory that stores M
        pub const M_MEM141 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c28d));

        /// memory that stores M
        pub const M_MEM142 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c28e));

        /// memory that stores M
        pub const M_MEM143 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c28f));

        /// memory that stores M
        pub const M_MEM144 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c290));

        /// memory that stores M
        pub const M_MEM145 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c291));

        /// memory that stores M
        pub const M_MEM146 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c292));

        /// memory that stores M
        pub const M_MEM147 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c293));

        /// memory that stores M
        pub const M_MEM148 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c294));

        /// memory that stores M
        pub const M_MEM149 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c295));

        /// memory that stores M
        pub const M_MEM150 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c296));

        /// memory that stores M
        pub const M_MEM151 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c297));

        /// memory that stores M
        pub const M_MEM152 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c298));

        /// memory that stores M
        pub const M_MEM153 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c299));

        /// memory that stores M
        pub const M_MEM154 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c29a));

        /// memory that stores M
        pub const M_MEM155 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c29b));

        /// memory that stores M
        pub const M_MEM156 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c29c));

        /// memory that stores M
        pub const M_MEM157 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c29d));

        /// memory that stores M
        pub const M_MEM158 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c29e));

        /// memory that stores M
        pub const M_MEM159 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c29f));

        /// memory that stores M
        pub const M_MEM160 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c2a0));

        /// memory that stores M
        pub const M_MEM161 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c2a1));

        /// memory that stores M
        pub const M_MEM162 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c2a2));

        /// memory that stores M
        pub const M_MEM163 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c2a3));

        /// memory that stores M
        pub const M_MEM164 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c2a4));

        /// memory that stores M
        pub const M_MEM165 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c2a5));

        /// memory that stores M
        pub const M_MEM166 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c2a6));

        /// memory that stores M
        pub const M_MEM167 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c2a7));

        /// memory that stores M
        pub const M_MEM168 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c2a8));

        /// memory that stores M
        pub const M_MEM169 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c2a9));

        /// memory that stores M
        pub const M_MEM170 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c2aa));

        /// memory that stores M
        pub const M_MEM171 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c2ab));

        /// memory that stores M
        pub const M_MEM172 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c2ac));

        /// memory that stores M
        pub const M_MEM173 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c2ad));

        /// memory that stores M
        pub const M_MEM174 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c2ae));

        /// memory that stores M
        pub const M_MEM175 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c2af));

        /// memory that stores M
        pub const M_MEM176 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c2b0));

        /// memory that stores M
        pub const M_MEM177 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c2b1));

        /// memory that stores M
        pub const M_MEM178 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c2b2));

        /// memory that stores M
        pub const M_MEM179 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c2b3));

        /// memory that stores M
        pub const M_MEM180 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c2b4));

        /// memory that stores M
        pub const M_MEM181 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c2b5));

        /// memory that stores M
        pub const M_MEM182 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c2b6));

        /// memory that stores M
        pub const M_MEM183 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c2b7));

        /// memory that stores M
        pub const M_MEM184 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c2b8));

        /// memory that stores M
        pub const M_MEM185 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c2b9));

        /// memory that stores M
        pub const M_MEM186 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c2ba));

        /// memory that stores M
        pub const M_MEM187 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c2bb));

        /// memory that stores M
        pub const M_MEM188 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c2bc));

        /// memory that stores M
        pub const M_MEM189 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c2bd));

        /// memory that stores M
        pub const M_MEM190 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c2be));

        /// memory that stores M
        pub const M_MEM191 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c2bf));

        /// memory that stores M
        pub const M_MEM192 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c2c0));

        /// memory that stores M
        pub const M_MEM193 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c2c1));

        /// memory that stores M
        pub const M_MEM194 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c2c2));

        /// memory that stores M
        pub const M_MEM195 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c2c3));

        /// memory that stores M
        pub const M_MEM196 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c2c4));

        /// memory that stores M
        pub const M_MEM197 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c2c5));

        /// memory that stores M
        pub const M_MEM198 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c2c6));

        /// memory that stores M
        pub const M_MEM199 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c2c7));

        /// memory that stores M
        pub const M_MEM200 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c2c8));

        /// memory that stores M
        pub const M_MEM201 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c2c9));

        /// memory that stores M
        pub const M_MEM202 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c2ca));

        /// memory that stores M
        pub const M_MEM203 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c2cb));

        /// memory that stores M
        pub const M_MEM204 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c2cc));

        /// memory that stores M
        pub const M_MEM205 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c2cd));

        /// memory that stores M
        pub const M_MEM206 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c2ce));

        /// memory that stores M
        pub const M_MEM207 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c2cf));

        /// memory that stores M
        pub const M_MEM208 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c2d0));

        /// memory that stores M
        pub const M_MEM209 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c2d1));

        /// memory that stores M
        pub const M_MEM210 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c2d2));

        /// memory that stores M
        pub const M_MEM211 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c2d3));

        /// memory that stores M
        pub const M_MEM212 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c2d4));

        /// memory that stores M
        pub const M_MEM213 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c2d5));

        /// memory that stores M
        pub const M_MEM214 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c2d6));

        /// memory that stores M
        pub const M_MEM215 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c2d7));

        /// memory that stores M
        pub const M_MEM216 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c2d8));

        /// memory that stores M
        pub const M_MEM217 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c2d9));

        /// memory that stores M
        pub const M_MEM218 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c2da));

        /// memory that stores M
        pub const M_MEM219 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c2db));

        /// memory that stores M
        pub const M_MEM220 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c2dc));

        /// memory that stores M
        pub const M_MEM221 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c2dd));

        /// memory that stores M
        pub const M_MEM222 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c2de));

        /// memory that stores M
        pub const M_MEM223 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c2df));

        /// memory that stores M
        pub const M_MEM224 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c2e0));

        /// memory that stores M
        pub const M_MEM225 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c2e1));

        /// memory that stores M
        pub const M_MEM226 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c2e2));

        /// memory that stores M
        pub const M_MEM227 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c2e3));

        /// memory that stores M
        pub const M_MEM228 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c2e4));

        /// memory that stores M
        pub const M_MEM229 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c2e5));

        /// memory that stores M
        pub const M_MEM230 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c2e6));

        /// memory that stores M
        pub const M_MEM231 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c2e7));

        /// memory that stores M
        pub const M_MEM232 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c2e8));

        /// memory that stores M
        pub const M_MEM233 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c2e9));

        /// memory that stores M
        pub const M_MEM234 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c2ea));

        /// memory that stores M
        pub const M_MEM235 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c2eb));

        /// memory that stores M
        pub const M_MEM236 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c2ec));

        /// memory that stores M
        pub const M_MEM237 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c2ed));

        /// memory that stores M
        pub const M_MEM238 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c2ee));

        /// memory that stores M
        pub const M_MEM239 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c2ef));

        /// memory that stores M
        pub const M_MEM240 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c2f0));

        /// memory that stores M
        pub const M_MEM241 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c2f1));

        /// memory that stores M
        pub const M_MEM242 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c2f2));

        /// memory that stores M
        pub const M_MEM243 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c2f3));

        /// memory that stores M
        pub const M_MEM244 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c2f4));

        /// memory that stores M
        pub const M_MEM245 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c2f5));

        /// memory that stores M
        pub const M_MEM246 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c2f6));

        /// memory that stores M
        pub const M_MEM247 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c2f7));

        /// memory that stores M
        pub const M_MEM248 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c2f8));

        /// memory that stores M
        pub const M_MEM249 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c2f9));

        /// memory that stores M
        pub const M_MEM250 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c2fa));

        /// memory that stores M
        pub const M_MEM251 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c2fb));

        /// memory that stores M
        pub const M_MEM252 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c2fc));

        /// memory that stores M
        pub const M_MEM253 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c2fd));

        /// memory that stores M
        pub const M_MEM254 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c2fe));

        /// memory that stores M
        pub const M_MEM255 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c2ff));

        /// memory that stores M
        pub const M_MEM256 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c300));

        /// memory that stores M
        pub const M_MEM257 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c301));

        /// memory that stores M
        pub const M_MEM258 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c302));

        /// memory that stores M
        pub const M_MEM259 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c303));

        /// memory that stores M
        pub const M_MEM260 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c304));

        /// memory that stores M
        pub const M_MEM261 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c305));

        /// memory that stores M
        pub const M_MEM262 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c306));

        /// memory that stores M
        pub const M_MEM263 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c307));

        /// memory that stores M
        pub const M_MEM264 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c308));

        /// memory that stores M
        pub const M_MEM265 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c309));

        /// memory that stores M
        pub const M_MEM266 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c30a));

        /// memory that stores M
        pub const M_MEM267 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c30b));

        /// memory that stores M
        pub const M_MEM268 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c30c));

        /// memory that stores M
        pub const M_MEM269 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c30d));

        /// memory that stores M
        pub const M_MEM270 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c30e));

        /// memory that stores M
        pub const M_MEM271 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c30f));

        /// memory that stores M
        pub const M_MEM272 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c310));

        /// memory that stores M
        pub const M_MEM273 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c311));

        /// memory that stores M
        pub const M_MEM274 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c312));

        /// memory that stores M
        pub const M_MEM275 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c313));

        /// memory that stores M
        pub const M_MEM276 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c314));

        /// memory that stores M
        pub const M_MEM277 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c315));

        /// memory that stores M
        pub const M_MEM278 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c316));

        /// memory that stores M
        pub const M_MEM279 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c317));

        /// memory that stores M
        pub const M_MEM280 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c318));

        /// memory that stores M
        pub const M_MEM281 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c319));

        /// memory that stores M
        pub const M_MEM282 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c31a));

        /// memory that stores M
        pub const M_MEM283 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c31b));

        /// memory that stores M
        pub const M_MEM284 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c31c));

        /// memory that stores M
        pub const M_MEM285 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c31d));

        /// memory that stores M
        pub const M_MEM286 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c31e));

        /// memory that stores M
        pub const M_MEM287 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c31f));

        /// memory that stores M
        pub const M_MEM288 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c320));

        /// memory that stores M
        pub const M_MEM289 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c321));

        /// memory that stores M
        pub const M_MEM290 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c322));

        /// memory that stores M
        pub const M_MEM291 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c323));

        /// memory that stores M
        pub const M_MEM292 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c324));

        /// memory that stores M
        pub const M_MEM293 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c325));

        /// memory that stores M
        pub const M_MEM294 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c326));

        /// memory that stores M
        pub const M_MEM295 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c327));

        /// memory that stores M
        pub const M_MEM296 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c328));

        /// memory that stores M
        pub const M_MEM297 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c329));

        /// memory that stores M
        pub const M_MEM298 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c32a));

        /// memory that stores M
        pub const M_MEM299 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c32b));

        /// memory that stores M
        pub const M_MEM300 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c32c));

        /// memory that stores M
        pub const M_MEM301 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c32d));

        /// memory that stores M
        pub const M_MEM302 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c32e));

        /// memory that stores M
        pub const M_MEM303 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c32f));

        /// memory that stores M
        pub const M_MEM304 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c330));

        /// memory that stores M
        pub const M_MEM305 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c331));

        /// memory that stores M
        pub const M_MEM306 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c332));

        /// memory that stores M
        pub const M_MEM307 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c333));

        /// memory that stores M
        pub const M_MEM308 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c334));

        /// memory that stores M
        pub const M_MEM309 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c335));

        /// memory that stores M
        pub const M_MEM310 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c336));

        /// memory that stores M
        pub const M_MEM311 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c337));

        /// memory that stores M
        pub const M_MEM312 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c338));

        /// memory that stores M
        pub const M_MEM313 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c339));

        /// memory that stores M
        pub const M_MEM314 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c33a));

        /// memory that stores M
        pub const M_MEM315 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c33b));

        /// memory that stores M
        pub const M_MEM316 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c33c));

        /// memory that stores M
        pub const M_MEM317 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c33d));

        /// memory that stores M
        pub const M_MEM318 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c33e));

        /// memory that stores M
        pub const M_MEM319 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c33f));

        /// memory that stores M
        pub const M_MEM320 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c340));

        /// memory that stores M
        pub const M_MEM321 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c341));

        /// memory that stores M
        pub const M_MEM322 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c342));

        /// memory that stores M
        pub const M_MEM323 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c343));

        /// memory that stores M
        pub const M_MEM324 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c344));

        /// memory that stores M
        pub const M_MEM325 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c345));

        /// memory that stores M
        pub const M_MEM326 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c346));

        /// memory that stores M
        pub const M_MEM327 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c347));

        /// memory that stores M
        pub const M_MEM328 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c348));

        /// memory that stores M
        pub const M_MEM329 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c349));

        /// memory that stores M
        pub const M_MEM330 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c34a));

        /// memory that stores M
        pub const M_MEM331 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c34b));

        /// memory that stores M
        pub const M_MEM332 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c34c));

        /// memory that stores M
        pub const M_MEM333 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c34d));

        /// memory that stores M
        pub const M_MEM334 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c34e));

        /// memory that stores M
        pub const M_MEM335 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c34f));

        /// memory that stores M
        pub const M_MEM336 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c350));

        /// memory that stores M
        pub const M_MEM337 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c351));

        /// memory that stores M
        pub const M_MEM338 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c352));

        /// memory that stores M
        pub const M_MEM339 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c353));

        /// memory that stores M
        pub const M_MEM340 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c354));

        /// memory that stores M
        pub const M_MEM341 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c355));

        /// memory that stores M
        pub const M_MEM342 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c356));

        /// memory that stores M
        pub const M_MEM343 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c357));

        /// memory that stores M
        pub const M_MEM344 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c358));

        /// memory that stores M
        pub const M_MEM345 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c359));

        /// memory that stores M
        pub const M_MEM346 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c35a));

        /// memory that stores M
        pub const M_MEM347 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c35b));

        /// memory that stores M
        pub const M_MEM348 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c35c));

        /// memory that stores M
        pub const M_MEM349 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c35d));

        /// memory that stores M
        pub const M_MEM350 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c35e));

        /// memory that stores M
        pub const M_MEM351 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c35f));

        /// memory that stores M
        pub const M_MEM352 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c360));

        /// memory that stores M
        pub const M_MEM353 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c361));

        /// memory that stores M
        pub const M_MEM354 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c362));

        /// memory that stores M
        pub const M_MEM355 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c363));

        /// memory that stores M
        pub const M_MEM356 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c364));

        /// memory that stores M
        pub const M_MEM357 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c365));

        /// memory that stores M
        pub const M_MEM358 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c366));

        /// memory that stores M
        pub const M_MEM359 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c367));

        /// memory that stores M
        pub const M_MEM360 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c368));

        /// memory that stores M
        pub const M_MEM361 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c369));

        /// memory that stores M
        pub const M_MEM362 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c36a));

        /// memory that stores M
        pub const M_MEM363 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c36b));

        /// memory that stores M
        pub const M_MEM364 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c36c));

        /// memory that stores M
        pub const M_MEM365 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c36d));

        /// memory that stores M
        pub const M_MEM366 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c36e));

        /// memory that stores M
        pub const M_MEM367 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c36f));

        /// memory that stores M
        pub const M_MEM368 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c370));

        /// memory that stores M
        pub const M_MEM369 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c371));

        /// memory that stores M
        pub const M_MEM370 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c372));

        /// memory that stores M
        pub const M_MEM371 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c373));

        /// memory that stores M
        pub const M_MEM372 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c374));

        /// memory that stores M
        pub const M_MEM373 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c375));

        /// memory that stores M
        pub const M_MEM374 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c376));

        /// memory that stores M
        pub const M_MEM375 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c377));

        /// memory that stores M
        pub const M_MEM376 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c378));

        /// memory that stores M
        pub const M_MEM377 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c379));

        /// memory that stores M
        pub const M_MEM378 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c37a));

        /// memory that stores M
        pub const M_MEM379 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c37b));

        /// memory that stores M
        pub const M_MEM380 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c37c));

        /// memory that stores M
        pub const M_MEM381 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c37d));

        /// memory that stores M
        pub const M_MEM382 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c37e));

        /// memory that stores M
        pub const M_MEM383 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c37f));

        /// memory that stores M
        pub const M_MEM384 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c380));

        /// memory that stores M
        pub const M_MEM385 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c381));

        /// memory that stores M
        pub const M_MEM386 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c382));

        /// memory that stores M
        pub const M_MEM387 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c383));

        /// memory that stores M
        pub const M_MEM388 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c384));

        /// memory that stores M
        pub const M_MEM389 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c385));

        /// memory that stores M
        pub const M_MEM390 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c386));

        /// memory that stores M
        pub const M_MEM391 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c387));

        /// memory that stores M
        pub const M_MEM392 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c388));

        /// memory that stores M
        pub const M_MEM393 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c389));

        /// memory that stores M
        pub const M_MEM394 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c38a));

        /// memory that stores M
        pub const M_MEM395 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c38b));

        /// memory that stores M
        pub const M_MEM396 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c38c));

        /// memory that stores M
        pub const M_MEM397 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c38d));

        /// memory that stores M
        pub const M_MEM398 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c38e));

        /// memory that stores M
        pub const M_MEM399 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c38f));

        /// memory that stores M
        pub const M_MEM400 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c390));

        /// memory that stores M
        pub const M_MEM401 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c391));

        /// memory that stores M
        pub const M_MEM402 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c392));

        /// memory that stores M
        pub const M_MEM403 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c393));

        /// memory that stores M
        pub const M_MEM404 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c394));

        /// memory that stores M
        pub const M_MEM405 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c395));

        /// memory that stores M
        pub const M_MEM406 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c396));

        /// memory that stores M
        pub const M_MEM407 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c397));

        /// memory that stores M
        pub const M_MEM408 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c398));

        /// memory that stores M
        pub const M_MEM409 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c399));

        /// memory that stores M
        pub const M_MEM410 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c39a));

        /// memory that stores M
        pub const M_MEM411 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c39b));

        /// memory that stores M
        pub const M_MEM412 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c39c));

        /// memory that stores M
        pub const M_MEM413 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c39d));

        /// memory that stores M
        pub const M_MEM414 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c39e));

        /// memory that stores M
        pub const M_MEM415 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c39f));

        /// memory that stores M
        pub const M_MEM416 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c3a0));

        /// memory that stores M
        pub const M_MEM417 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c3a1));

        /// memory that stores M
        pub const M_MEM418 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c3a2));

        /// memory that stores M
        pub const M_MEM419 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c3a3));

        /// memory that stores M
        pub const M_MEM420 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c3a4));

        /// memory that stores M
        pub const M_MEM421 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c3a5));

        /// memory that stores M
        pub const M_MEM422 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c3a6));

        /// memory that stores M
        pub const M_MEM423 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c3a7));

        /// memory that stores M
        pub const M_MEM424 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c3a8));

        /// memory that stores M
        pub const M_MEM425 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c3a9));

        /// memory that stores M
        pub const M_MEM426 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c3aa));

        /// memory that stores M
        pub const M_MEM427 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c3ab));

        /// memory that stores M
        pub const M_MEM428 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c3ac));

        /// memory that stores M
        pub const M_MEM429 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c3ad));

        /// memory that stores M
        pub const M_MEM430 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c3ae));

        /// memory that stores M
        pub const M_MEM431 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c3af));

        /// memory that stores M
        pub const M_MEM432 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c3b0));

        /// memory that stores M
        pub const M_MEM433 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c3b1));

        /// memory that stores M
        pub const M_MEM434 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c3b2));

        /// memory that stores M
        pub const M_MEM435 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c3b3));

        /// memory that stores M
        pub const M_MEM436 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c3b4));

        /// memory that stores M
        pub const M_MEM437 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c3b5));

        /// memory that stores M
        pub const M_MEM438 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c3b6));

        /// memory that stores M
        pub const M_MEM439 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c3b7));

        /// memory that stores M
        pub const M_MEM440 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c3b8));

        /// memory that stores M
        pub const M_MEM441 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c3b9));

        /// memory that stores M
        pub const M_MEM442 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c3ba));

        /// memory that stores M
        pub const M_MEM443 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c3bb));

        /// memory that stores M
        pub const M_MEM444 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c3bc));

        /// memory that stores M
        pub const M_MEM445 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c3bd));

        /// memory that stores M
        pub const M_MEM446 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c3be));

        /// memory that stores M
        pub const M_MEM447 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c3bf));

        /// memory that stores M
        pub const M_MEM448 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c3c0));

        /// memory that stores M
        pub const M_MEM449 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c3c1));

        /// memory that stores M
        pub const M_MEM450 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c3c2));

        /// memory that stores M
        pub const M_MEM451 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c3c3));

        /// memory that stores M
        pub const M_MEM452 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c3c4));

        /// memory that stores M
        pub const M_MEM453 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c3c5));

        /// memory that stores M
        pub const M_MEM454 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c3c6));

        /// memory that stores M
        pub const M_MEM455 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c3c7));

        /// memory that stores M
        pub const M_MEM456 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c3c8));

        /// memory that stores M
        pub const M_MEM457 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c3c9));

        /// memory that stores M
        pub const M_MEM458 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c3ca));

        /// memory that stores M
        pub const M_MEM459 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c3cb));

        /// memory that stores M
        pub const M_MEM460 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c3cc));

        /// memory that stores M
        pub const M_MEM461 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c3cd));

        /// memory that stores M
        pub const M_MEM462 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c3ce));

        /// memory that stores M
        pub const M_MEM463 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c3cf));

        /// memory that stores M
        pub const M_MEM464 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c3d0));

        /// memory that stores M
        pub const M_MEM465 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c3d1));

        /// memory that stores M
        pub const M_MEM466 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c3d2));

        /// memory that stores M
        pub const M_MEM467 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c3d3));

        /// memory that stores M
        pub const M_MEM468 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c3d4));

        /// memory that stores M
        pub const M_MEM469 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c3d5));

        /// memory that stores M
        pub const M_MEM470 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c3d6));

        /// memory that stores M
        pub const M_MEM471 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c3d7));

        /// memory that stores M
        pub const M_MEM472 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c3d8));

        /// memory that stores M
        pub const M_MEM473 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c3d9));

        /// memory that stores M
        pub const M_MEM474 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c3da));

        /// memory that stores M
        pub const M_MEM475 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c3db));

        /// memory that stores M
        pub const M_MEM476 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c3dc));

        /// memory that stores M
        pub const M_MEM477 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c3dd));

        /// memory that stores M
        pub const M_MEM478 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c3de));

        /// memory that stores M
        pub const M_MEM479 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c3df));

        /// memory that stores M
        pub const M_MEM480 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c3e0));

        /// memory that stores M
        pub const M_MEM481 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c3e1));

        /// memory that stores M
        pub const M_MEM482 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c3e2));

        /// memory that stores M
        pub const M_MEM483 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c3e3));

        /// memory that stores M
        pub const M_MEM484 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c3e4));

        /// memory that stores M
        pub const M_MEM485 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c3e5));

        /// memory that stores M
        pub const M_MEM486 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c3e6));

        /// memory that stores M
        pub const M_MEM487 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c3e7));

        /// memory that stores M
        pub const M_MEM488 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c3e8));

        /// memory that stores M
        pub const M_MEM489 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c3e9));

        /// memory that stores M
        pub const M_MEM490 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c3ea));

        /// memory that stores M
        pub const M_MEM491 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c3eb));

        /// memory that stores M
        pub const M_MEM492 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c3ec));

        /// memory that stores M
        pub const M_MEM493 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c3ed));

        /// memory that stores M
        pub const M_MEM494 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c3ee));

        /// memory that stores M
        pub const M_MEM495 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c3ef));

        /// memory that stores M
        pub const M_MEM496 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c3f0));

        /// memory that stores M
        pub const M_MEM497 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c3f1));

        /// memory that stores M
        pub const M_MEM498 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c3f2));

        /// memory that stores M
        pub const M_MEM499 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c3f3));

        /// memory that stores M
        pub const M_MEM500 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c3f4));

        /// memory that stores M
        pub const M_MEM501 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c3f5));

        /// memory that stores M
        pub const M_MEM502 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c3f6));

        /// memory that stores M
        pub const M_MEM503 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c3f7));

        /// memory that stores M
        pub const M_MEM504 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c3f8));

        /// memory that stores M
        pub const M_MEM505 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c3f9));

        /// memory that stores M
        pub const M_MEM506 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c3fa));

        /// memory that stores M
        pub const M_MEM507 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c3fb));

        /// memory that stores M
        pub const M_MEM508 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c3fc));

        /// memory that stores M
        pub const M_MEM509 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c3fd));

        /// memory that stores M
        pub const M_MEM510 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c3fe));

        /// memory that stores M
        pub const M_MEM511 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c3ff));

        /// memory that stores Rb
        pub const RB_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c400));

        /// memory that stores Rb
        pub const RB_MEM1 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c401));

        /// memory that stores Rb
        pub const RB_MEM2 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c402));

        /// memory that stores Rb
        pub const RB_MEM3 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c403));

        /// memory that stores Rb
        pub const RB_MEM4 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c404));

        /// memory that stores Rb
        pub const RB_MEM5 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c405));

        /// memory that stores Rb
        pub const RB_MEM6 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c406));

        /// memory that stores Rb
        pub const RB_MEM7 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c407));

        /// memory that stores Rb
        pub const RB_MEM8 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c408));

        /// memory that stores Rb
        pub const RB_MEM9 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c409));

        /// memory that stores Rb
        pub const RB_MEM10 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c40a));

        /// memory that stores Rb
        pub const RB_MEM11 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c40b));

        /// memory that stores Rb
        pub const RB_MEM12 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c40c));

        /// memory that stores Rb
        pub const RB_MEM13 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c40d));

        /// memory that stores Rb
        pub const RB_MEM14 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c40e));

        /// memory that stores Rb
        pub const RB_MEM15 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c40f));

        /// memory that stores Rb
        pub const RB_MEM16 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c410));

        /// memory that stores Rb
        pub const RB_MEM17 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c411));

        /// memory that stores Rb
        pub const RB_MEM18 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c412));

        /// memory that stores Rb
        pub const RB_MEM19 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c413));

        /// memory that stores Rb
        pub const RB_MEM20 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c414));

        /// memory that stores Rb
        pub const RB_MEM21 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c415));

        /// memory that stores Rb
        pub const RB_MEM22 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c416));

        /// memory that stores Rb
        pub const RB_MEM23 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c417));

        /// memory that stores Rb
        pub const RB_MEM24 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c418));

        /// memory that stores Rb
        pub const RB_MEM25 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c419));

        /// memory that stores Rb
        pub const RB_MEM26 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c41a));

        /// memory that stores Rb
        pub const RB_MEM27 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c41b));

        /// memory that stores Rb
        pub const RB_MEM28 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c41c));

        /// memory that stores Rb
        pub const RB_MEM29 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c41d));

        /// memory that stores Rb
        pub const RB_MEM30 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c41e));

        /// memory that stores Rb
        pub const RB_MEM31 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c41f));

        /// memory that stores Rb
        pub const RB_MEM32 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c420));

        /// memory that stores Rb
        pub const RB_MEM33 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c421));

        /// memory that stores Rb
        pub const RB_MEM34 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c422));

        /// memory that stores Rb
        pub const RB_MEM35 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c423));

        /// memory that stores Rb
        pub const RB_MEM36 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c424));

        /// memory that stores Rb
        pub const RB_MEM37 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c425));

        /// memory that stores Rb
        pub const RB_MEM38 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c426));

        /// memory that stores Rb
        pub const RB_MEM39 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c427));

        /// memory that stores Rb
        pub const RB_MEM40 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c428));

        /// memory that stores Rb
        pub const RB_MEM41 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c429));

        /// memory that stores Rb
        pub const RB_MEM42 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c42a));

        /// memory that stores Rb
        pub const RB_MEM43 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c42b));

        /// memory that stores Rb
        pub const RB_MEM44 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c42c));

        /// memory that stores Rb
        pub const RB_MEM45 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c42d));

        /// memory that stores Rb
        pub const RB_MEM46 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c42e));

        /// memory that stores Rb
        pub const RB_MEM47 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c42f));

        /// memory that stores Rb
        pub const RB_MEM48 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c430));

        /// memory that stores Rb
        pub const RB_MEM49 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c431));

        /// memory that stores Rb
        pub const RB_MEM50 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c432));

        /// memory that stores Rb
        pub const RB_MEM51 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c433));

        /// memory that stores Rb
        pub const RB_MEM52 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c434));

        /// memory that stores Rb
        pub const RB_MEM53 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c435));

        /// memory that stores Rb
        pub const RB_MEM54 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c436));

        /// memory that stores Rb
        pub const RB_MEM55 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c437));

        /// memory that stores Rb
        pub const RB_MEM56 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c438));

        /// memory that stores Rb
        pub const RB_MEM57 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c439));

        /// memory that stores Rb
        pub const RB_MEM58 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c43a));

        /// memory that stores Rb
        pub const RB_MEM59 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c43b));

        /// memory that stores Rb
        pub const RB_MEM60 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c43c));

        /// memory that stores Rb
        pub const RB_MEM61 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c43d));

        /// memory that stores Rb
        pub const RB_MEM62 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c43e));

        /// memory that stores Rb
        pub const RB_MEM63 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c43f));

        /// memory that stores Rb
        pub const RB_MEM64 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c440));

        /// memory that stores Rb
        pub const RB_MEM65 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c441));

        /// memory that stores Rb
        pub const RB_MEM66 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c442));

        /// memory that stores Rb
        pub const RB_MEM67 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c443));

        /// memory that stores Rb
        pub const RB_MEM68 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c444));

        /// memory that stores Rb
        pub const RB_MEM69 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c445));

        /// memory that stores Rb
        pub const RB_MEM70 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c446));

        /// memory that stores Rb
        pub const RB_MEM71 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c447));

        /// memory that stores Rb
        pub const RB_MEM72 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c448));

        /// memory that stores Rb
        pub const RB_MEM73 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c449));

        /// memory that stores Rb
        pub const RB_MEM74 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c44a));

        /// memory that stores Rb
        pub const RB_MEM75 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c44b));

        /// memory that stores Rb
        pub const RB_MEM76 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c44c));

        /// memory that stores Rb
        pub const RB_MEM77 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c44d));

        /// memory that stores Rb
        pub const RB_MEM78 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c44e));

        /// memory that stores Rb
        pub const RB_MEM79 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c44f));

        /// memory that stores Rb
        pub const RB_MEM80 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c450));

        /// memory that stores Rb
        pub const RB_MEM81 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c451));

        /// memory that stores Rb
        pub const RB_MEM82 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c452));

        /// memory that stores Rb
        pub const RB_MEM83 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c453));

        /// memory that stores Rb
        pub const RB_MEM84 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c454));

        /// memory that stores Rb
        pub const RB_MEM85 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c455));

        /// memory that stores Rb
        pub const RB_MEM86 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c456));

        /// memory that stores Rb
        pub const RB_MEM87 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c457));

        /// memory that stores Rb
        pub const RB_MEM88 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c458));

        /// memory that stores Rb
        pub const RB_MEM89 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c459));

        /// memory that stores Rb
        pub const RB_MEM90 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c45a));

        /// memory that stores Rb
        pub const RB_MEM91 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c45b));

        /// memory that stores Rb
        pub const RB_MEM92 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c45c));

        /// memory that stores Rb
        pub const RB_MEM93 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c45d));

        /// memory that stores Rb
        pub const RB_MEM94 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c45e));

        /// memory that stores Rb
        pub const RB_MEM95 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c45f));

        /// memory that stores Rb
        pub const RB_MEM96 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c460));

        /// memory that stores Rb
        pub const RB_MEM97 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c461));

        /// memory that stores Rb
        pub const RB_MEM98 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c462));

        /// memory that stores Rb
        pub const RB_MEM99 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c463));

        /// memory that stores Rb
        pub const RB_MEM100 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c464));

        /// memory that stores Rb
        pub const RB_MEM101 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c465));

        /// memory that stores Rb
        pub const RB_MEM102 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c466));

        /// memory that stores Rb
        pub const RB_MEM103 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c467));

        /// memory that stores Rb
        pub const RB_MEM104 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c468));

        /// memory that stores Rb
        pub const RB_MEM105 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c469));

        /// memory that stores Rb
        pub const RB_MEM106 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c46a));

        /// memory that stores Rb
        pub const RB_MEM107 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c46b));

        /// memory that stores Rb
        pub const RB_MEM108 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c46c));

        /// memory that stores Rb
        pub const RB_MEM109 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c46d));

        /// memory that stores Rb
        pub const RB_MEM110 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c46e));

        /// memory that stores Rb
        pub const RB_MEM111 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c46f));

        /// memory that stores Rb
        pub const RB_MEM112 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c470));

        /// memory that stores Rb
        pub const RB_MEM113 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c471));

        /// memory that stores Rb
        pub const RB_MEM114 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c472));

        /// memory that stores Rb
        pub const RB_MEM115 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c473));

        /// memory that stores Rb
        pub const RB_MEM116 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c474));

        /// memory that stores Rb
        pub const RB_MEM117 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c475));

        /// memory that stores Rb
        pub const RB_MEM118 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c476));

        /// memory that stores Rb
        pub const RB_MEM119 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c477));

        /// memory that stores Rb
        pub const RB_MEM120 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c478));

        /// memory that stores Rb
        pub const RB_MEM121 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c479));

        /// memory that stores Rb
        pub const RB_MEM122 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c47a));

        /// memory that stores Rb
        pub const RB_MEM123 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c47b));

        /// memory that stores Rb
        pub const RB_MEM124 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c47c));

        /// memory that stores Rb
        pub const RB_MEM125 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c47d));

        /// memory that stores Rb
        pub const RB_MEM126 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c47e));

        /// memory that stores Rb
        pub const RB_MEM127 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c47f));

        /// memory that stores Rb
        pub const RB_MEM128 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c480));

        /// memory that stores Rb
        pub const RB_MEM129 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c481));

        /// memory that stores Rb
        pub const RB_MEM130 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c482));

        /// memory that stores Rb
        pub const RB_MEM131 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c483));

        /// memory that stores Rb
        pub const RB_MEM132 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c484));

        /// memory that stores Rb
        pub const RB_MEM133 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c485));

        /// memory that stores Rb
        pub const RB_MEM134 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c486));

        /// memory that stores Rb
        pub const RB_MEM135 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c487));

        /// memory that stores Rb
        pub const RB_MEM136 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c488));

        /// memory that stores Rb
        pub const RB_MEM137 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c489));

        /// memory that stores Rb
        pub const RB_MEM138 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c48a));

        /// memory that stores Rb
        pub const RB_MEM139 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c48b));

        /// memory that stores Rb
        pub const RB_MEM140 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c48c));

        /// memory that stores Rb
        pub const RB_MEM141 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c48d));

        /// memory that stores Rb
        pub const RB_MEM142 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c48e));

        /// memory that stores Rb
        pub const RB_MEM143 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c48f));

        /// memory that stores Rb
        pub const RB_MEM144 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c490));

        /// memory that stores Rb
        pub const RB_MEM145 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c491));

        /// memory that stores Rb
        pub const RB_MEM146 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c492));

        /// memory that stores Rb
        pub const RB_MEM147 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c493));

        /// memory that stores Rb
        pub const RB_MEM148 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c494));

        /// memory that stores Rb
        pub const RB_MEM149 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c495));

        /// memory that stores Rb
        pub const RB_MEM150 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c496));

        /// memory that stores Rb
        pub const RB_MEM151 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c497));

        /// memory that stores Rb
        pub const RB_MEM152 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c498));

        /// memory that stores Rb
        pub const RB_MEM153 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c499));

        /// memory that stores Rb
        pub const RB_MEM154 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c49a));

        /// memory that stores Rb
        pub const RB_MEM155 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c49b));

        /// memory that stores Rb
        pub const RB_MEM156 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c49c));

        /// memory that stores Rb
        pub const RB_MEM157 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c49d));

        /// memory that stores Rb
        pub const RB_MEM158 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c49e));

        /// memory that stores Rb
        pub const RB_MEM159 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c49f));

        /// memory that stores Rb
        pub const RB_MEM160 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c4a0));

        /// memory that stores Rb
        pub const RB_MEM161 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c4a1));

        /// memory that stores Rb
        pub const RB_MEM162 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c4a2));

        /// memory that stores Rb
        pub const RB_MEM163 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c4a3));

        /// memory that stores Rb
        pub const RB_MEM164 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c4a4));

        /// memory that stores Rb
        pub const RB_MEM165 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c4a5));

        /// memory that stores Rb
        pub const RB_MEM166 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c4a6));

        /// memory that stores Rb
        pub const RB_MEM167 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c4a7));

        /// memory that stores Rb
        pub const RB_MEM168 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c4a8));

        /// memory that stores Rb
        pub const RB_MEM169 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c4a9));

        /// memory that stores Rb
        pub const RB_MEM170 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c4aa));

        /// memory that stores Rb
        pub const RB_MEM171 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c4ab));

        /// memory that stores Rb
        pub const RB_MEM172 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c4ac));

        /// memory that stores Rb
        pub const RB_MEM173 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c4ad));

        /// memory that stores Rb
        pub const RB_MEM174 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c4ae));

        /// memory that stores Rb
        pub const RB_MEM175 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c4af));

        /// memory that stores Rb
        pub const RB_MEM176 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c4b0));

        /// memory that stores Rb
        pub const RB_MEM177 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c4b1));

        /// memory that stores Rb
        pub const RB_MEM178 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c4b2));

        /// memory that stores Rb
        pub const RB_MEM179 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c4b3));

        /// memory that stores Rb
        pub const RB_MEM180 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c4b4));

        /// memory that stores Rb
        pub const RB_MEM181 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c4b5));

        /// memory that stores Rb
        pub const RB_MEM182 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c4b6));

        /// memory that stores Rb
        pub const RB_MEM183 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c4b7));

        /// memory that stores Rb
        pub const RB_MEM184 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c4b8));

        /// memory that stores Rb
        pub const RB_MEM185 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c4b9));

        /// memory that stores Rb
        pub const RB_MEM186 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c4ba));

        /// memory that stores Rb
        pub const RB_MEM187 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c4bb));

        /// memory that stores Rb
        pub const RB_MEM188 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c4bc));

        /// memory that stores Rb
        pub const RB_MEM189 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c4bd));

        /// memory that stores Rb
        pub const RB_MEM190 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c4be));

        /// memory that stores Rb
        pub const RB_MEM191 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c4bf));

        /// memory that stores Rb
        pub const RB_MEM192 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c4c0));

        /// memory that stores Rb
        pub const RB_MEM193 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c4c1));

        /// memory that stores Rb
        pub const RB_MEM194 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c4c2));

        /// memory that stores Rb
        pub const RB_MEM195 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c4c3));

        /// memory that stores Rb
        pub const RB_MEM196 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c4c4));

        /// memory that stores Rb
        pub const RB_MEM197 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c4c5));

        /// memory that stores Rb
        pub const RB_MEM198 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c4c6));

        /// memory that stores Rb
        pub const RB_MEM199 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c4c7));

        /// memory that stores Rb
        pub const RB_MEM200 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c4c8));

        /// memory that stores Rb
        pub const RB_MEM201 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c4c9));

        /// memory that stores Rb
        pub const RB_MEM202 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c4ca));

        /// memory that stores Rb
        pub const RB_MEM203 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c4cb));

        /// memory that stores Rb
        pub const RB_MEM204 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c4cc));

        /// memory that stores Rb
        pub const RB_MEM205 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c4cd));

        /// memory that stores Rb
        pub const RB_MEM206 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c4ce));

        /// memory that stores Rb
        pub const RB_MEM207 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c4cf));

        /// memory that stores Rb
        pub const RB_MEM208 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c4d0));

        /// memory that stores Rb
        pub const RB_MEM209 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c4d1));

        /// memory that stores Rb
        pub const RB_MEM210 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c4d2));

        /// memory that stores Rb
        pub const RB_MEM211 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c4d3));

        /// memory that stores Rb
        pub const RB_MEM212 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c4d4));

        /// memory that stores Rb
        pub const RB_MEM213 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c4d5));

        /// memory that stores Rb
        pub const RB_MEM214 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c4d6));

        /// memory that stores Rb
        pub const RB_MEM215 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c4d7));

        /// memory that stores Rb
        pub const RB_MEM216 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c4d8));

        /// memory that stores Rb
        pub const RB_MEM217 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c4d9));

        /// memory that stores Rb
        pub const RB_MEM218 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c4da));

        /// memory that stores Rb
        pub const RB_MEM219 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c4db));

        /// memory that stores Rb
        pub const RB_MEM220 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c4dc));

        /// memory that stores Rb
        pub const RB_MEM221 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c4dd));

        /// memory that stores Rb
        pub const RB_MEM222 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c4de));

        /// memory that stores Rb
        pub const RB_MEM223 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c4df));

        /// memory that stores Rb
        pub const RB_MEM224 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c4e0));

        /// memory that stores Rb
        pub const RB_MEM225 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c4e1));

        /// memory that stores Rb
        pub const RB_MEM226 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c4e2));

        /// memory that stores Rb
        pub const RB_MEM227 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c4e3));

        /// memory that stores Rb
        pub const RB_MEM228 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c4e4));

        /// memory that stores Rb
        pub const RB_MEM229 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c4e5));

        /// memory that stores Rb
        pub const RB_MEM230 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c4e6));

        /// memory that stores Rb
        pub const RB_MEM231 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c4e7));

        /// memory that stores Rb
        pub const RB_MEM232 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c4e8));

        /// memory that stores Rb
        pub const RB_MEM233 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c4e9));

        /// memory that stores Rb
        pub const RB_MEM234 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c4ea));

        /// memory that stores Rb
        pub const RB_MEM235 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c4eb));

        /// memory that stores Rb
        pub const RB_MEM236 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c4ec));

        /// memory that stores Rb
        pub const RB_MEM237 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c4ed));

        /// memory that stores Rb
        pub const RB_MEM238 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c4ee));

        /// memory that stores Rb
        pub const RB_MEM239 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c4ef));

        /// memory that stores Rb
        pub const RB_MEM240 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c4f0));

        /// memory that stores Rb
        pub const RB_MEM241 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c4f1));

        /// memory that stores Rb
        pub const RB_MEM242 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c4f2));

        /// memory that stores Rb
        pub const RB_MEM243 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c4f3));

        /// memory that stores Rb
        pub const RB_MEM244 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c4f4));

        /// memory that stores Rb
        pub const RB_MEM245 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c4f5));

        /// memory that stores Rb
        pub const RB_MEM246 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c4f6));

        /// memory that stores Rb
        pub const RB_MEM247 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c4f7));

        /// memory that stores Rb
        pub const RB_MEM248 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c4f8));

        /// memory that stores Rb
        pub const RB_MEM249 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c4f9));

        /// memory that stores Rb
        pub const RB_MEM250 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c4fa));

        /// memory that stores Rb
        pub const RB_MEM251 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c4fb));

        /// memory that stores Rb
        pub const RB_MEM252 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c4fc));

        /// memory that stores Rb
        pub const RB_MEM253 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c4fd));

        /// memory that stores Rb
        pub const RB_MEM254 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c4fe));

        /// memory that stores Rb
        pub const RB_MEM255 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c4ff));

        /// memory that stores Rb
        pub const RB_MEM256 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c500));

        /// memory that stores Rb
        pub const RB_MEM257 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c501));

        /// memory that stores Rb
        pub const RB_MEM258 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c502));

        /// memory that stores Rb
        pub const RB_MEM259 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c503));

        /// memory that stores Rb
        pub const RB_MEM260 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c504));

        /// memory that stores Rb
        pub const RB_MEM261 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c505));

        /// memory that stores Rb
        pub const RB_MEM262 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c506));

        /// memory that stores Rb
        pub const RB_MEM263 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c507));

        /// memory that stores Rb
        pub const RB_MEM264 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c508));

        /// memory that stores Rb
        pub const RB_MEM265 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c509));

        /// memory that stores Rb
        pub const RB_MEM266 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c50a));

        /// memory that stores Rb
        pub const RB_MEM267 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c50b));

        /// memory that stores Rb
        pub const RB_MEM268 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c50c));

        /// memory that stores Rb
        pub const RB_MEM269 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c50d));

        /// memory that stores Rb
        pub const RB_MEM270 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c50e));

        /// memory that stores Rb
        pub const RB_MEM271 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c50f));

        /// memory that stores Rb
        pub const RB_MEM272 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c510));

        /// memory that stores Rb
        pub const RB_MEM273 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c511));

        /// memory that stores Rb
        pub const RB_MEM274 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c512));

        /// memory that stores Rb
        pub const RB_MEM275 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c513));

        /// memory that stores Rb
        pub const RB_MEM276 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c514));

        /// memory that stores Rb
        pub const RB_MEM277 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c515));

        /// memory that stores Rb
        pub const RB_MEM278 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c516));

        /// memory that stores Rb
        pub const RB_MEM279 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c517));

        /// memory that stores Rb
        pub const RB_MEM280 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c518));

        /// memory that stores Rb
        pub const RB_MEM281 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c519));

        /// memory that stores Rb
        pub const RB_MEM282 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c51a));

        /// memory that stores Rb
        pub const RB_MEM283 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c51b));

        /// memory that stores Rb
        pub const RB_MEM284 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c51c));

        /// memory that stores Rb
        pub const RB_MEM285 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c51d));

        /// memory that stores Rb
        pub const RB_MEM286 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c51e));

        /// memory that stores Rb
        pub const RB_MEM287 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c51f));

        /// memory that stores Rb
        pub const RB_MEM288 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c520));

        /// memory that stores Rb
        pub const RB_MEM289 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c521));

        /// memory that stores Rb
        pub const RB_MEM290 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c522));

        /// memory that stores Rb
        pub const RB_MEM291 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c523));

        /// memory that stores Rb
        pub const RB_MEM292 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c524));

        /// memory that stores Rb
        pub const RB_MEM293 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c525));

        /// memory that stores Rb
        pub const RB_MEM294 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c526));

        /// memory that stores Rb
        pub const RB_MEM295 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c527));

        /// memory that stores Rb
        pub const RB_MEM296 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c528));

        /// memory that stores Rb
        pub const RB_MEM297 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c529));

        /// memory that stores Rb
        pub const RB_MEM298 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c52a));

        /// memory that stores Rb
        pub const RB_MEM299 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c52b));

        /// memory that stores Rb
        pub const RB_MEM300 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c52c));

        /// memory that stores Rb
        pub const RB_MEM301 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c52d));

        /// memory that stores Rb
        pub const RB_MEM302 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c52e));

        /// memory that stores Rb
        pub const RB_MEM303 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c52f));

        /// memory that stores Rb
        pub const RB_MEM304 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c530));

        /// memory that stores Rb
        pub const RB_MEM305 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c531));

        /// memory that stores Rb
        pub const RB_MEM306 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c532));

        /// memory that stores Rb
        pub const RB_MEM307 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c533));

        /// memory that stores Rb
        pub const RB_MEM308 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c534));

        /// memory that stores Rb
        pub const RB_MEM309 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c535));

        /// memory that stores Rb
        pub const RB_MEM310 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c536));

        /// memory that stores Rb
        pub const RB_MEM311 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c537));

        /// memory that stores Rb
        pub const RB_MEM312 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c538));

        /// memory that stores Rb
        pub const RB_MEM313 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c539));

        /// memory that stores Rb
        pub const RB_MEM314 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c53a));

        /// memory that stores Rb
        pub const RB_MEM315 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c53b));

        /// memory that stores Rb
        pub const RB_MEM316 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c53c));

        /// memory that stores Rb
        pub const RB_MEM317 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c53d));

        /// memory that stores Rb
        pub const RB_MEM318 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c53e));

        /// memory that stores Rb
        pub const RB_MEM319 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c53f));

        /// memory that stores Rb
        pub const RB_MEM320 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c540));

        /// memory that stores Rb
        pub const RB_MEM321 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c541));

        /// memory that stores Rb
        pub const RB_MEM322 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c542));

        /// memory that stores Rb
        pub const RB_MEM323 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c543));

        /// memory that stores Rb
        pub const RB_MEM324 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c544));

        /// memory that stores Rb
        pub const RB_MEM325 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c545));

        /// memory that stores Rb
        pub const RB_MEM326 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c546));

        /// memory that stores Rb
        pub const RB_MEM327 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c547));

        /// memory that stores Rb
        pub const RB_MEM328 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c548));

        /// memory that stores Rb
        pub const RB_MEM329 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c549));

        /// memory that stores Rb
        pub const RB_MEM330 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c54a));

        /// memory that stores Rb
        pub const RB_MEM331 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c54b));

        /// memory that stores Rb
        pub const RB_MEM332 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c54c));

        /// memory that stores Rb
        pub const RB_MEM333 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c54d));

        /// memory that stores Rb
        pub const RB_MEM334 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c54e));

        /// memory that stores Rb
        pub const RB_MEM335 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c54f));

        /// memory that stores Rb
        pub const RB_MEM336 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c550));

        /// memory that stores Rb
        pub const RB_MEM337 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c551));

        /// memory that stores Rb
        pub const RB_MEM338 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c552));

        /// memory that stores Rb
        pub const RB_MEM339 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c553));

        /// memory that stores Rb
        pub const RB_MEM340 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c554));

        /// memory that stores Rb
        pub const RB_MEM341 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c555));

        /// memory that stores Rb
        pub const RB_MEM342 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c556));

        /// memory that stores Rb
        pub const RB_MEM343 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c557));

        /// memory that stores Rb
        pub const RB_MEM344 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c558));

        /// memory that stores Rb
        pub const RB_MEM345 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c559));

        /// memory that stores Rb
        pub const RB_MEM346 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c55a));

        /// memory that stores Rb
        pub const RB_MEM347 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c55b));

        /// memory that stores Rb
        pub const RB_MEM348 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c55c));

        /// memory that stores Rb
        pub const RB_MEM349 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c55d));

        /// memory that stores Rb
        pub const RB_MEM350 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c55e));

        /// memory that stores Rb
        pub const RB_MEM351 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c55f));

        /// memory that stores Rb
        pub const RB_MEM352 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c560));

        /// memory that stores Rb
        pub const RB_MEM353 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c561));

        /// memory that stores Rb
        pub const RB_MEM354 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c562));

        /// memory that stores Rb
        pub const RB_MEM355 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c563));

        /// memory that stores Rb
        pub const RB_MEM356 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c564));

        /// memory that stores Rb
        pub const RB_MEM357 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c565));

        /// memory that stores Rb
        pub const RB_MEM358 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c566));

        /// memory that stores Rb
        pub const RB_MEM359 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c567));

        /// memory that stores Rb
        pub const RB_MEM360 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c568));

        /// memory that stores Rb
        pub const RB_MEM361 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c569));

        /// memory that stores Rb
        pub const RB_MEM362 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c56a));

        /// memory that stores Rb
        pub const RB_MEM363 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c56b));

        /// memory that stores Rb
        pub const RB_MEM364 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c56c));

        /// memory that stores Rb
        pub const RB_MEM365 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c56d));

        /// memory that stores Rb
        pub const RB_MEM366 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c56e));

        /// memory that stores Rb
        pub const RB_MEM367 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c56f));

        /// memory that stores Rb
        pub const RB_MEM368 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c570));

        /// memory that stores Rb
        pub const RB_MEM369 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c571));

        /// memory that stores Rb
        pub const RB_MEM370 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c572));

        /// memory that stores Rb
        pub const RB_MEM371 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c573));

        /// memory that stores Rb
        pub const RB_MEM372 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c574));

        /// memory that stores Rb
        pub const RB_MEM373 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c575));

        /// memory that stores Rb
        pub const RB_MEM374 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c576));

        /// memory that stores Rb
        pub const RB_MEM375 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c577));

        /// memory that stores Rb
        pub const RB_MEM376 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c578));

        /// memory that stores Rb
        pub const RB_MEM377 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c579));

        /// memory that stores Rb
        pub const RB_MEM378 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c57a));

        /// memory that stores Rb
        pub const RB_MEM379 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c57b));

        /// memory that stores Rb
        pub const RB_MEM380 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c57c));

        /// memory that stores Rb
        pub const RB_MEM381 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c57d));

        /// memory that stores Rb
        pub const RB_MEM382 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c57e));

        /// memory that stores Rb
        pub const RB_MEM383 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c57f));

        /// memory that stores Rb
        pub const RB_MEM384 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c580));

        /// memory that stores Rb
        pub const RB_MEM385 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c581));

        /// memory that stores Rb
        pub const RB_MEM386 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c582));

        /// memory that stores Rb
        pub const RB_MEM387 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c583));

        /// memory that stores Rb
        pub const RB_MEM388 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c584));

        /// memory that stores Rb
        pub const RB_MEM389 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c585));

        /// memory that stores Rb
        pub const RB_MEM390 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c586));

        /// memory that stores Rb
        pub const RB_MEM391 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c587));

        /// memory that stores Rb
        pub const RB_MEM392 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c588));

        /// memory that stores Rb
        pub const RB_MEM393 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c589));

        /// memory that stores Rb
        pub const RB_MEM394 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c58a));

        /// memory that stores Rb
        pub const RB_MEM395 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c58b));

        /// memory that stores Rb
        pub const RB_MEM396 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c58c));

        /// memory that stores Rb
        pub const RB_MEM397 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c58d));

        /// memory that stores Rb
        pub const RB_MEM398 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c58e));

        /// memory that stores Rb
        pub const RB_MEM399 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c58f));

        /// memory that stores Rb
        pub const RB_MEM400 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c590));

        /// memory that stores Rb
        pub const RB_MEM401 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c591));

        /// memory that stores Rb
        pub const RB_MEM402 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c592));

        /// memory that stores Rb
        pub const RB_MEM403 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c593));

        /// memory that stores Rb
        pub const RB_MEM404 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c594));

        /// memory that stores Rb
        pub const RB_MEM405 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c595));

        /// memory that stores Rb
        pub const RB_MEM406 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c596));

        /// memory that stores Rb
        pub const RB_MEM407 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c597));

        /// memory that stores Rb
        pub const RB_MEM408 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c598));

        /// memory that stores Rb
        pub const RB_MEM409 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c599));

        /// memory that stores Rb
        pub const RB_MEM410 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c59a));

        /// memory that stores Rb
        pub const RB_MEM411 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c59b));

        /// memory that stores Rb
        pub const RB_MEM412 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c59c));

        /// memory that stores Rb
        pub const RB_MEM413 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c59d));

        /// memory that stores Rb
        pub const RB_MEM414 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c59e));

        /// memory that stores Rb
        pub const RB_MEM415 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c59f));

        /// memory that stores Rb
        pub const RB_MEM416 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c5a0));

        /// memory that stores Rb
        pub const RB_MEM417 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c5a1));

        /// memory that stores Rb
        pub const RB_MEM418 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c5a2));

        /// memory that stores Rb
        pub const RB_MEM419 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c5a3));

        /// memory that stores Rb
        pub const RB_MEM420 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c5a4));

        /// memory that stores Rb
        pub const RB_MEM421 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c5a5));

        /// memory that stores Rb
        pub const RB_MEM422 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c5a6));

        /// memory that stores Rb
        pub const RB_MEM423 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c5a7));

        /// memory that stores Rb
        pub const RB_MEM424 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c5a8));

        /// memory that stores Rb
        pub const RB_MEM425 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c5a9));

        /// memory that stores Rb
        pub const RB_MEM426 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c5aa));

        /// memory that stores Rb
        pub const RB_MEM427 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c5ab));

        /// memory that stores Rb
        pub const RB_MEM428 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c5ac));

        /// memory that stores Rb
        pub const RB_MEM429 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c5ad));

        /// memory that stores Rb
        pub const RB_MEM430 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c5ae));

        /// memory that stores Rb
        pub const RB_MEM431 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c5af));

        /// memory that stores Rb
        pub const RB_MEM432 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c5b0));

        /// memory that stores Rb
        pub const RB_MEM433 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c5b1));

        /// memory that stores Rb
        pub const RB_MEM434 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c5b2));

        /// memory that stores Rb
        pub const RB_MEM435 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c5b3));

        /// memory that stores Rb
        pub const RB_MEM436 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c5b4));

        /// memory that stores Rb
        pub const RB_MEM437 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c5b5));

        /// memory that stores Rb
        pub const RB_MEM438 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c5b6));

        /// memory that stores Rb
        pub const RB_MEM439 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c5b7));

        /// memory that stores Rb
        pub const RB_MEM440 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c5b8));

        /// memory that stores Rb
        pub const RB_MEM441 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c5b9));

        /// memory that stores Rb
        pub const RB_MEM442 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c5ba));

        /// memory that stores Rb
        pub const RB_MEM443 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c5bb));

        /// memory that stores Rb
        pub const RB_MEM444 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c5bc));

        /// memory that stores Rb
        pub const RB_MEM445 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c5bd));

        /// memory that stores Rb
        pub const RB_MEM446 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c5be));

        /// memory that stores Rb
        pub const RB_MEM447 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c5bf));

        /// memory that stores Rb
        pub const RB_MEM448 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c5c0));

        /// memory that stores Rb
        pub const RB_MEM449 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c5c1));

        /// memory that stores Rb
        pub const RB_MEM450 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c5c2));

        /// memory that stores Rb
        pub const RB_MEM451 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c5c3));

        /// memory that stores Rb
        pub const RB_MEM452 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c5c4));

        /// memory that stores Rb
        pub const RB_MEM453 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c5c5));

        /// memory that stores Rb
        pub const RB_MEM454 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c5c6));

        /// memory that stores Rb
        pub const RB_MEM455 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c5c7));

        /// memory that stores Rb
        pub const RB_MEM456 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c5c8));

        /// memory that stores Rb
        pub const RB_MEM457 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c5c9));

        /// memory that stores Rb
        pub const RB_MEM458 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c5ca));

        /// memory that stores Rb
        pub const RB_MEM459 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c5cb));

        /// memory that stores Rb
        pub const RB_MEM460 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c5cc));

        /// memory that stores Rb
        pub const RB_MEM461 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c5cd));

        /// memory that stores Rb
        pub const RB_MEM462 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c5ce));

        /// memory that stores Rb
        pub const RB_MEM463 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c5cf));

        /// memory that stores Rb
        pub const RB_MEM464 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c5d0));

        /// memory that stores Rb
        pub const RB_MEM465 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c5d1));

        /// memory that stores Rb
        pub const RB_MEM466 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c5d2));

        /// memory that stores Rb
        pub const RB_MEM467 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c5d3));

        /// memory that stores Rb
        pub const RB_MEM468 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c5d4));

        /// memory that stores Rb
        pub const RB_MEM469 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c5d5));

        /// memory that stores Rb
        pub const RB_MEM470 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c5d6));

        /// memory that stores Rb
        pub const RB_MEM471 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c5d7));

        /// memory that stores Rb
        pub const RB_MEM472 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c5d8));

        /// memory that stores Rb
        pub const RB_MEM473 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c5d9));

        /// memory that stores Rb
        pub const RB_MEM474 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c5da));

        /// memory that stores Rb
        pub const RB_MEM475 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c5db));

        /// memory that stores Rb
        pub const RB_MEM476 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c5dc));

        /// memory that stores Rb
        pub const RB_MEM477 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c5dd));

        /// memory that stores Rb
        pub const RB_MEM478 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c5de));

        /// memory that stores Rb
        pub const RB_MEM479 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c5df));

        /// memory that stores Rb
        pub const RB_MEM480 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c5e0));

        /// memory that stores Rb
        pub const RB_MEM481 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c5e1));

        /// memory that stores Rb
        pub const RB_MEM482 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c5e2));

        /// memory that stores Rb
        pub const RB_MEM483 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c5e3));

        /// memory that stores Rb
        pub const RB_MEM484 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c5e4));

        /// memory that stores Rb
        pub const RB_MEM485 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c5e5));

        /// memory that stores Rb
        pub const RB_MEM486 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c5e6));

        /// memory that stores Rb
        pub const RB_MEM487 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c5e7));

        /// memory that stores Rb
        pub const RB_MEM488 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c5e8));

        /// memory that stores Rb
        pub const RB_MEM489 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c5e9));

        /// memory that stores Rb
        pub const RB_MEM490 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c5ea));

        /// memory that stores Rb
        pub const RB_MEM491 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c5eb));

        /// memory that stores Rb
        pub const RB_MEM492 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c5ec));

        /// memory that stores Rb
        pub const RB_MEM493 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c5ed));

        /// memory that stores Rb
        pub const RB_MEM494 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c5ee));

        /// memory that stores Rb
        pub const RB_MEM495 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c5ef));

        /// memory that stores Rb
        pub const RB_MEM496 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c5f0));

        /// memory that stores Rb
        pub const RB_MEM497 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c5f1));

        /// memory that stores Rb
        pub const RB_MEM498 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c5f2));

        /// memory that stores Rb
        pub const RB_MEM499 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c5f3));

        /// memory that stores Rb
        pub const RB_MEM500 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c5f4));

        /// memory that stores Rb
        pub const RB_MEM501 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c5f5));

        /// memory that stores Rb
        pub const RB_MEM502 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c5f6));

        /// memory that stores Rb
        pub const RB_MEM503 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c5f7));

        /// memory that stores Rb
        pub const RB_MEM504 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c5f8));

        /// memory that stores Rb
        pub const RB_MEM505 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c5f9));

        /// memory that stores Rb
        pub const RB_MEM506 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c5fa));

        /// memory that stores Rb
        pub const RB_MEM507 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c5fb));

        /// memory that stores Rb
        pub const RB_MEM508 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c5fc));

        /// memory that stores Rb
        pub const RB_MEM509 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c5fd));

        /// memory that stores Rb
        pub const RB_MEM510 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c5fe));

        /// memory that stores Rb
        pub const RB_MEM511 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c5ff));

        /// memory that stores BOX
        pub const BOX_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c600));

        /// memory that stores BOX
        pub const BOX_MEM1 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c601));

        /// memory that stores BOX
        pub const BOX_MEM2 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c602));

        /// memory that stores BOX
        pub const BOX_MEM3 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c603));

        /// memory that stores BOX
        pub const BOX_MEM4 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c604));

        /// memory that stores BOX
        pub const BOX_MEM5 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c605));

        /// memory that stores BOX
        pub const BOX_MEM6 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c606));

        /// memory that stores BOX
        pub const BOX_MEM7 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c607));

        /// memory that stores BOX
        pub const BOX_MEM8 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c608));

        /// memory that stores BOX
        pub const BOX_MEM9 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c609));

        /// memory that stores BOX
        pub const BOX_MEM10 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c60a));

        /// memory that stores BOX
        pub const BOX_MEM11 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c60b));

        /// memory that stores BOX
        pub const BOX_MEM12 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c60c));

        /// memory that stores BOX
        pub const BOX_MEM13 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c60d));

        /// memory that stores BOX
        pub const BOX_MEM14 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c60e));

        /// memory that stores BOX
        pub const BOX_MEM15 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c60f));

        /// memory that stores BOX
        pub const BOX_MEM16 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c610));

        /// memory that stores BOX
        pub const BOX_MEM17 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c611));

        /// memory that stores BOX
        pub const BOX_MEM18 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c612));

        /// memory that stores BOX
        pub const BOX_MEM19 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c613));

        /// memory that stores BOX
        pub const BOX_MEM20 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c614));

        /// memory that stores BOX
        pub const BOX_MEM21 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c615));

        /// memory that stores BOX
        pub const BOX_MEM22 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c616));

        /// memory that stores BOX
        pub const BOX_MEM23 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c617));

        /// memory that stores BOX
        pub const BOX_MEM24 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c618));

        /// memory that stores BOX
        pub const BOX_MEM25 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c619));

        /// memory that stores BOX
        pub const BOX_MEM26 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c61a));

        /// memory that stores BOX
        pub const BOX_MEM27 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c61b));

        /// memory that stores BOX
        pub const BOX_MEM28 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c61c));

        /// memory that stores BOX
        pub const BOX_MEM29 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c61d));

        /// memory that stores BOX
        pub const BOX_MEM30 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c61e));

        /// memory that stores BOX
        pub const BOX_MEM31 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c61f));

        /// memory that stores BOX
        pub const BOX_MEM32 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c620));

        /// memory that stores BOX
        pub const BOX_MEM33 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c621));

        /// memory that stores BOX
        pub const BOX_MEM34 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c622));

        /// memory that stores BOX
        pub const BOX_MEM35 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c623));

        /// memory that stores BOX
        pub const BOX_MEM36 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c624));

        /// memory that stores BOX
        pub const BOX_MEM37 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c625));

        /// memory that stores BOX
        pub const BOX_MEM38 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c626));

        /// memory that stores BOX
        pub const BOX_MEM39 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c627));

        /// memory that stores BOX
        pub const BOX_MEM40 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c628));

        /// memory that stores BOX
        pub const BOX_MEM41 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c629));

        /// memory that stores BOX
        pub const BOX_MEM42 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c62a));

        /// memory that stores BOX
        pub const BOX_MEM43 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c62b));

        /// memory that stores BOX
        pub const BOX_MEM44 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c62c));

        /// memory that stores BOX
        pub const BOX_MEM45 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c62d));

        /// memory that stores BOX
        pub const BOX_MEM46 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c62e));

        /// memory that stores BOX
        pub const BOX_MEM47 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c62f));

        /// memory that stores IV
        pub const IV_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c630));

        /// memory that stores IV
        pub const IV_MEM1 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c631));

        /// memory that stores IV
        pub const IV_MEM2 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c632));

        /// memory that stores IV
        pub const IV_MEM3 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c633));

        /// memory that stores IV
        pub const IV_MEM4 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c634));

        /// memory that stores IV
        pub const IV_MEM5 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c635));

        /// memory that stores IV
        pub const IV_MEM6 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c636));

        /// memory that stores IV
        pub const IV_MEM7 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c637));

        /// memory that stores IV
        pub const IV_MEM8 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c638));

        /// memory that stores IV
        pub const IV_MEM9 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c639));

        /// memory that stores IV
        pub const IV_MEM10 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c63a));

        /// memory that stores IV
        pub const IV_MEM11 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c63b));

        /// memory that stores IV
        pub const IV_MEM12 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c63c));

        /// memory that stores IV
        pub const IV_MEM13 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c63d));

        /// memory that stores IV
        pub const IV_MEM14 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c63e));

        /// memory that stores IV
        pub const IV_MEM15 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c63f));

        /// memory that stores X
        pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c800));

        /// memory that stores X
        pub const X_MEM1 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c801));

        /// memory that stores X
        pub const X_MEM2 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c802));

        /// memory that stores X
        pub const X_MEM3 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c803));

        /// memory that stores X
        pub const X_MEM4 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c804));

        /// memory that stores X
        pub const X_MEM5 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c805));

        /// memory that stores X
        pub const X_MEM6 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c806));

        /// memory that stores X
        pub const X_MEM7 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c807));

        /// memory that stores X
        pub const X_MEM8 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c808));

        /// memory that stores X
        pub const X_MEM9 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c809));

        /// memory that stores X
        pub const X_MEM10 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c80a));

        /// memory that stores X
        pub const X_MEM11 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c80b));

        /// memory that stores X
        pub const X_MEM12 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c80c));

        /// memory that stores X
        pub const X_MEM13 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c80d));

        /// memory that stores X
        pub const X_MEM14 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c80e));

        /// memory that stores X
        pub const X_MEM15 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c80f));

        /// memory that stores X
        pub const X_MEM16 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c810));

        /// memory that stores X
        pub const X_MEM17 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c811));

        /// memory that stores X
        pub const X_MEM18 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c812));

        /// memory that stores X
        pub const X_MEM19 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c813));

        /// memory that stores X
        pub const X_MEM20 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c814));

        /// memory that stores X
        pub const X_MEM21 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c815));

        /// memory that stores X
        pub const X_MEM22 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c816));

        /// memory that stores X
        pub const X_MEM23 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c817));

        /// memory that stores X
        pub const X_MEM24 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c818));

        /// memory that stores X
        pub const X_MEM25 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c819));

        /// memory that stores X
        pub const X_MEM26 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c81a));

        /// memory that stores X
        pub const X_MEM27 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c81b));

        /// memory that stores X
        pub const X_MEM28 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c81c));

        /// memory that stores X
        pub const X_MEM29 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c81d));

        /// memory that stores X
        pub const X_MEM30 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c81e));

        /// memory that stores X
        pub const X_MEM31 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c81f));

        /// memory that stores X
        pub const X_MEM32 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c820));

        /// memory that stores X
        pub const X_MEM33 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c821));

        /// memory that stores X
        pub const X_MEM34 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c822));

        /// memory that stores X
        pub const X_MEM35 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c823));

        /// memory that stores X
        pub const X_MEM36 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c824));

        /// memory that stores X
        pub const X_MEM37 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c825));

        /// memory that stores X
        pub const X_MEM38 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c826));

        /// memory that stores X
        pub const X_MEM39 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c827));

        /// memory that stores X
        pub const X_MEM40 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c828));

        /// memory that stores X
        pub const X_MEM41 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c829));

        /// memory that stores X
        pub const X_MEM42 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c82a));

        /// memory that stores X
        pub const X_MEM43 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c82b));

        /// memory that stores X
        pub const X_MEM44 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c82c));

        /// memory that stores X
        pub const X_MEM45 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c82d));

        /// memory that stores X
        pub const X_MEM46 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c82e));

        /// memory that stores X
        pub const X_MEM47 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c82f));

        /// memory that stores X
        pub const X_MEM48 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c830));

        /// memory that stores X
        pub const X_MEM49 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c831));

        /// memory that stores X
        pub const X_MEM50 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c832));

        /// memory that stores X
        pub const X_MEM51 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c833));

        /// memory that stores X
        pub const X_MEM52 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c834));

        /// memory that stores X
        pub const X_MEM53 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c835));

        /// memory that stores X
        pub const X_MEM54 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c836));

        /// memory that stores X
        pub const X_MEM55 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c837));

        /// memory that stores X
        pub const X_MEM56 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c838));

        /// memory that stores X
        pub const X_MEM57 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c839));

        /// memory that stores X
        pub const X_MEM58 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c83a));

        /// memory that stores X
        pub const X_MEM59 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c83b));

        /// memory that stores X
        pub const X_MEM60 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c83c));

        /// memory that stores X
        pub const X_MEM61 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c83d));

        /// memory that stores X
        pub const X_MEM62 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c83e));

        /// memory that stores X
        pub const X_MEM63 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c83f));

        /// memory that stores X
        pub const X_MEM64 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c840));

        /// memory that stores X
        pub const X_MEM65 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c841));

        /// memory that stores X
        pub const X_MEM66 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c842));

        /// memory that stores X
        pub const X_MEM67 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c843));

        /// memory that stores X
        pub const X_MEM68 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c844));

        /// memory that stores X
        pub const X_MEM69 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c845));

        /// memory that stores X
        pub const X_MEM70 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c846));

        /// memory that stores X
        pub const X_MEM71 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c847));

        /// memory that stores X
        pub const X_MEM72 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c848));

        /// memory that stores X
        pub const X_MEM73 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c849));

        /// memory that stores X
        pub const X_MEM74 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c84a));

        /// memory that stores X
        pub const X_MEM75 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c84b));

        /// memory that stores X
        pub const X_MEM76 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c84c));

        /// memory that stores X
        pub const X_MEM77 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c84d));

        /// memory that stores X
        pub const X_MEM78 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c84e));

        /// memory that stores X
        pub const X_MEM79 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c84f));

        /// memory that stores X
        pub const X_MEM80 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c850));

        /// memory that stores X
        pub const X_MEM81 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c851));

        /// memory that stores X
        pub const X_MEM82 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c852));

        /// memory that stores X
        pub const X_MEM83 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c853));

        /// memory that stores X
        pub const X_MEM84 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c854));

        /// memory that stores X
        pub const X_MEM85 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c855));

        /// memory that stores X
        pub const X_MEM86 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c856));

        /// memory that stores X
        pub const X_MEM87 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c857));

        /// memory that stores X
        pub const X_MEM88 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c858));

        /// memory that stores X
        pub const X_MEM89 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c859));

        /// memory that stores X
        pub const X_MEM90 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c85a));

        /// memory that stores X
        pub const X_MEM91 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c85b));

        /// memory that stores X
        pub const X_MEM92 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c85c));

        /// memory that stores X
        pub const X_MEM93 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c85d));

        /// memory that stores X
        pub const X_MEM94 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c85e));

        /// memory that stores X
        pub const X_MEM95 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c85f));

        /// memory that stores X
        pub const X_MEM96 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c860));

        /// memory that stores X
        pub const X_MEM97 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c861));

        /// memory that stores X
        pub const X_MEM98 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c862));

        /// memory that stores X
        pub const X_MEM99 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c863));

        /// memory that stores X
        pub const X_MEM100 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c864));

        /// memory that stores X
        pub const X_MEM101 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c865));

        /// memory that stores X
        pub const X_MEM102 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c866));

        /// memory that stores X
        pub const X_MEM103 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c867));

        /// memory that stores X
        pub const X_MEM104 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c868));

        /// memory that stores X
        pub const X_MEM105 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c869));

        /// memory that stores X
        pub const X_MEM106 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c86a));

        /// memory that stores X
        pub const X_MEM107 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c86b));

        /// memory that stores X
        pub const X_MEM108 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c86c));

        /// memory that stores X
        pub const X_MEM109 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c86d));

        /// memory that stores X
        pub const X_MEM110 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c86e));

        /// memory that stores X
        pub const X_MEM111 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c86f));

        /// memory that stores X
        pub const X_MEM112 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c870));

        /// memory that stores X
        pub const X_MEM113 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c871));

        /// memory that stores X
        pub const X_MEM114 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c872));

        /// memory that stores X
        pub const X_MEM115 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c873));

        /// memory that stores X
        pub const X_MEM116 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c874));

        /// memory that stores X
        pub const X_MEM117 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c875));

        /// memory that stores X
        pub const X_MEM118 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c876));

        /// memory that stores X
        pub const X_MEM119 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c877));

        /// memory that stores X
        pub const X_MEM120 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c878));

        /// memory that stores X
        pub const X_MEM121 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c879));

        /// memory that stores X
        pub const X_MEM122 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c87a));

        /// memory that stores X
        pub const X_MEM123 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c87b));

        /// memory that stores X
        pub const X_MEM124 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c87c));

        /// memory that stores X
        pub const X_MEM125 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c87d));

        /// memory that stores X
        pub const X_MEM126 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c87e));

        /// memory that stores X
        pub const X_MEM127 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c87f));

        /// memory that stores X
        pub const X_MEM128 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c880));

        /// memory that stores X
        pub const X_MEM129 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c881));

        /// memory that stores X
        pub const X_MEM130 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c882));

        /// memory that stores X
        pub const X_MEM131 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c883));

        /// memory that stores X
        pub const X_MEM132 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c884));

        /// memory that stores X
        pub const X_MEM133 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c885));

        /// memory that stores X
        pub const X_MEM134 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c886));

        /// memory that stores X
        pub const X_MEM135 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c887));

        /// memory that stores X
        pub const X_MEM136 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c888));

        /// memory that stores X
        pub const X_MEM137 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c889));

        /// memory that stores X
        pub const X_MEM138 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c88a));

        /// memory that stores X
        pub const X_MEM139 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c88b));

        /// memory that stores X
        pub const X_MEM140 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c88c));

        /// memory that stores X
        pub const X_MEM141 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c88d));

        /// memory that stores X
        pub const X_MEM142 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c88e));

        /// memory that stores X
        pub const X_MEM143 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c88f));

        /// memory that stores X
        pub const X_MEM144 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c890));

        /// memory that stores X
        pub const X_MEM145 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c891));

        /// memory that stores X
        pub const X_MEM146 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c892));

        /// memory that stores X
        pub const X_MEM147 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c893));

        /// memory that stores X
        pub const X_MEM148 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c894));

        /// memory that stores X
        pub const X_MEM149 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c895));

        /// memory that stores X
        pub const X_MEM150 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c896));

        /// memory that stores X
        pub const X_MEM151 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c897));

        /// memory that stores X
        pub const X_MEM152 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c898));

        /// memory that stores X
        pub const X_MEM153 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c899));

        /// memory that stores X
        pub const X_MEM154 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c89a));

        /// memory that stores X
        pub const X_MEM155 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c89b));

        /// memory that stores X
        pub const X_MEM156 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c89c));

        /// memory that stores X
        pub const X_MEM157 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c89d));

        /// memory that stores X
        pub const X_MEM158 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c89e));

        /// memory that stores X
        pub const X_MEM159 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c89f));

        /// memory that stores X
        pub const X_MEM160 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c8a0));

        /// memory that stores X
        pub const X_MEM161 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c8a1));

        /// memory that stores X
        pub const X_MEM162 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c8a2));

        /// memory that stores X
        pub const X_MEM163 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c8a3));

        /// memory that stores X
        pub const X_MEM164 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c8a4));

        /// memory that stores X
        pub const X_MEM165 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c8a5));

        /// memory that stores X
        pub const X_MEM166 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c8a6));

        /// memory that stores X
        pub const X_MEM167 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c8a7));

        /// memory that stores X
        pub const X_MEM168 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c8a8));

        /// memory that stores X
        pub const X_MEM169 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c8a9));

        /// memory that stores X
        pub const X_MEM170 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c8aa));

        /// memory that stores X
        pub const X_MEM171 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c8ab));

        /// memory that stores X
        pub const X_MEM172 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c8ac));

        /// memory that stores X
        pub const X_MEM173 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c8ad));

        /// memory that stores X
        pub const X_MEM174 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c8ae));

        /// memory that stores X
        pub const X_MEM175 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c8af));

        /// memory that stores X
        pub const X_MEM176 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c8b0));

        /// memory that stores X
        pub const X_MEM177 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c8b1));

        /// memory that stores X
        pub const X_MEM178 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c8b2));

        /// memory that stores X
        pub const X_MEM179 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c8b3));

        /// memory that stores X
        pub const X_MEM180 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c8b4));

        /// memory that stores X
        pub const X_MEM181 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c8b5));

        /// memory that stores X
        pub const X_MEM182 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c8b6));

        /// memory that stores X
        pub const X_MEM183 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c8b7));

        /// memory that stores X
        pub const X_MEM184 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c8b8));

        /// memory that stores X
        pub const X_MEM185 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c8b9));

        /// memory that stores X
        pub const X_MEM186 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c8ba));

        /// memory that stores X
        pub const X_MEM187 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c8bb));

        /// memory that stores X
        pub const X_MEM188 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c8bc));

        /// memory that stores X
        pub const X_MEM189 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c8bd));

        /// memory that stores X
        pub const X_MEM190 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c8be));

        /// memory that stores X
        pub const X_MEM191 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c8bf));

        /// memory that stores X
        pub const X_MEM192 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c8c0));

        /// memory that stores X
        pub const X_MEM193 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c8c1));

        /// memory that stores X
        pub const X_MEM194 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c8c2));

        /// memory that stores X
        pub const X_MEM195 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c8c3));

        /// memory that stores X
        pub const X_MEM196 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c8c4));

        /// memory that stores X
        pub const X_MEM197 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c8c5));

        /// memory that stores X
        pub const X_MEM198 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c8c6));

        /// memory that stores X
        pub const X_MEM199 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c8c7));

        /// memory that stores X
        pub const X_MEM200 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c8c8));

        /// memory that stores X
        pub const X_MEM201 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c8c9));

        /// memory that stores X
        pub const X_MEM202 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c8ca));

        /// memory that stores X
        pub const X_MEM203 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c8cb));

        /// memory that stores X
        pub const X_MEM204 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c8cc));

        /// memory that stores X
        pub const X_MEM205 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c8cd));

        /// memory that stores X
        pub const X_MEM206 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c8ce));

        /// memory that stores X
        pub const X_MEM207 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c8cf));

        /// memory that stores X
        pub const X_MEM208 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c8d0));

        /// memory that stores X
        pub const X_MEM209 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c8d1));

        /// memory that stores X
        pub const X_MEM210 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c8d2));

        /// memory that stores X
        pub const X_MEM211 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c8d3));

        /// memory that stores X
        pub const X_MEM212 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c8d4));

        /// memory that stores X
        pub const X_MEM213 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c8d5));

        /// memory that stores X
        pub const X_MEM214 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c8d6));

        /// memory that stores X
        pub const X_MEM215 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c8d7));

        /// memory that stores X
        pub const X_MEM216 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c8d8));

        /// memory that stores X
        pub const X_MEM217 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c8d9));

        /// memory that stores X
        pub const X_MEM218 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c8da));

        /// memory that stores X
        pub const X_MEM219 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c8db));

        /// memory that stores X
        pub const X_MEM220 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c8dc));

        /// memory that stores X
        pub const X_MEM221 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c8dd));

        /// memory that stores X
        pub const X_MEM222 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c8de));

        /// memory that stores X
        pub const X_MEM223 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c8df));

        /// memory that stores X
        pub const X_MEM224 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c8e0));

        /// memory that stores X
        pub const X_MEM225 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c8e1));

        /// memory that stores X
        pub const X_MEM226 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c8e2));

        /// memory that stores X
        pub const X_MEM227 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c8e3));

        /// memory that stores X
        pub const X_MEM228 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c8e4));

        /// memory that stores X
        pub const X_MEM229 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c8e5));

        /// memory that stores X
        pub const X_MEM230 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c8e6));

        /// memory that stores X
        pub const X_MEM231 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c8e7));

        /// memory that stores X
        pub const X_MEM232 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c8e8));

        /// memory that stores X
        pub const X_MEM233 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c8e9));

        /// memory that stores X
        pub const X_MEM234 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c8ea));

        /// memory that stores X
        pub const X_MEM235 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c8eb));

        /// memory that stores X
        pub const X_MEM236 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c8ec));

        /// memory that stores X
        pub const X_MEM237 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c8ed));

        /// memory that stores X
        pub const X_MEM238 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c8ee));

        /// memory that stores X
        pub const X_MEM239 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c8ef));

        /// memory that stores X
        pub const X_MEM240 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c8f0));

        /// memory that stores X
        pub const X_MEM241 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c8f1));

        /// memory that stores X
        pub const X_MEM242 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c8f2));

        /// memory that stores X
        pub const X_MEM243 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c8f3));

        /// memory that stores X
        pub const X_MEM244 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c8f4));

        /// memory that stores X
        pub const X_MEM245 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c8f5));

        /// memory that stores X
        pub const X_MEM246 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c8f6));

        /// memory that stores X
        pub const X_MEM247 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c8f7));

        /// memory that stores X
        pub const X_MEM248 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c8f8));

        /// memory that stores X
        pub const X_MEM249 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c8f9));

        /// memory that stores X
        pub const X_MEM250 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c8fa));

        /// memory that stores X
        pub const X_MEM251 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c8fb));

        /// memory that stores X
        pub const X_MEM252 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c8fc));

        /// memory that stores X
        pub const X_MEM253 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c8fd));

        /// memory that stores X
        pub const X_MEM254 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c8fe));

        /// memory that stores X
        pub const X_MEM255 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c8ff));

        /// memory that stores X
        pub const X_MEM256 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c900));

        /// memory that stores X
        pub const X_MEM257 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c901));

        /// memory that stores X
        pub const X_MEM258 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c902));

        /// memory that stores X
        pub const X_MEM259 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c903));

        /// memory that stores X
        pub const X_MEM260 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c904));

        /// memory that stores X
        pub const X_MEM261 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c905));

        /// memory that stores X
        pub const X_MEM262 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c906));

        /// memory that stores X
        pub const X_MEM263 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c907));

        /// memory that stores X
        pub const X_MEM264 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c908));

        /// memory that stores X
        pub const X_MEM265 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c909));

        /// memory that stores X
        pub const X_MEM266 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c90a));

        /// memory that stores X
        pub const X_MEM267 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c90b));

        /// memory that stores X
        pub const X_MEM268 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c90c));

        /// memory that stores X
        pub const X_MEM269 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c90d));

        /// memory that stores X
        pub const X_MEM270 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c90e));

        /// memory that stores X
        pub const X_MEM271 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c90f));

        /// memory that stores X
        pub const X_MEM272 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c910));

        /// memory that stores X
        pub const X_MEM273 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c911));

        /// memory that stores X
        pub const X_MEM274 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c912));

        /// memory that stores X
        pub const X_MEM275 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c913));

        /// memory that stores X
        pub const X_MEM276 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c914));

        /// memory that stores X
        pub const X_MEM277 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c915));

        /// memory that stores X
        pub const X_MEM278 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c916));

        /// memory that stores X
        pub const X_MEM279 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c917));

        /// memory that stores X
        pub const X_MEM280 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c918));

        /// memory that stores X
        pub const X_MEM281 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c919));

        /// memory that stores X
        pub const X_MEM282 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c91a));

        /// memory that stores X
        pub const X_MEM283 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c91b));

        /// memory that stores X
        pub const X_MEM284 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c91c));

        /// memory that stores X
        pub const X_MEM285 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c91d));

        /// memory that stores X
        pub const X_MEM286 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c91e));

        /// memory that stores X
        pub const X_MEM287 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c91f));

        /// memory that stores X
        pub const X_MEM288 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c920));

        /// memory that stores X
        pub const X_MEM289 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c921));

        /// memory that stores X
        pub const X_MEM290 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c922));

        /// memory that stores X
        pub const X_MEM291 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c923));

        /// memory that stores X
        pub const X_MEM292 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c924));

        /// memory that stores X
        pub const X_MEM293 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c925));

        /// memory that stores X
        pub const X_MEM294 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c926));

        /// memory that stores X
        pub const X_MEM295 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c927));

        /// memory that stores X
        pub const X_MEM296 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c928));

        /// memory that stores X
        pub const X_MEM297 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c929));

        /// memory that stores X
        pub const X_MEM298 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c92a));

        /// memory that stores X
        pub const X_MEM299 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c92b));

        /// memory that stores X
        pub const X_MEM300 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c92c));

        /// memory that stores X
        pub const X_MEM301 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c92d));

        /// memory that stores X
        pub const X_MEM302 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c92e));

        /// memory that stores X
        pub const X_MEM303 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c92f));

        /// memory that stores X
        pub const X_MEM304 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c930));

        /// memory that stores X
        pub const X_MEM305 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c931));

        /// memory that stores X
        pub const X_MEM306 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c932));

        /// memory that stores X
        pub const X_MEM307 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c933));

        /// memory that stores X
        pub const X_MEM308 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c934));

        /// memory that stores X
        pub const X_MEM309 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c935));

        /// memory that stores X
        pub const X_MEM310 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c936));

        /// memory that stores X
        pub const X_MEM311 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c937));

        /// memory that stores X
        pub const X_MEM312 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c938));

        /// memory that stores X
        pub const X_MEM313 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c939));

        /// memory that stores X
        pub const X_MEM314 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c93a));

        /// memory that stores X
        pub const X_MEM315 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c93b));

        /// memory that stores X
        pub const X_MEM316 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c93c));

        /// memory that stores X
        pub const X_MEM317 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c93d));

        /// memory that stores X
        pub const X_MEM318 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c93e));

        /// memory that stores X
        pub const X_MEM319 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c93f));

        /// memory that stores X
        pub const X_MEM320 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c940));

        /// memory that stores X
        pub const X_MEM321 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c941));

        /// memory that stores X
        pub const X_MEM322 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c942));

        /// memory that stores X
        pub const X_MEM323 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c943));

        /// memory that stores X
        pub const X_MEM324 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c944));

        /// memory that stores X
        pub const X_MEM325 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c945));

        /// memory that stores X
        pub const X_MEM326 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c946));

        /// memory that stores X
        pub const X_MEM327 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c947));

        /// memory that stores X
        pub const X_MEM328 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c948));

        /// memory that stores X
        pub const X_MEM329 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c949));

        /// memory that stores X
        pub const X_MEM330 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c94a));

        /// memory that stores X
        pub const X_MEM331 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c94b));

        /// memory that stores X
        pub const X_MEM332 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c94c));

        /// memory that stores X
        pub const X_MEM333 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c94d));

        /// memory that stores X
        pub const X_MEM334 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c94e));

        /// memory that stores X
        pub const X_MEM335 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c94f));

        /// memory that stores X
        pub const X_MEM336 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c950));

        /// memory that stores X
        pub const X_MEM337 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c951));

        /// memory that stores X
        pub const X_MEM338 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c952));

        /// memory that stores X
        pub const X_MEM339 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c953));

        /// memory that stores X
        pub const X_MEM340 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c954));

        /// memory that stores X
        pub const X_MEM341 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c955));

        /// memory that stores X
        pub const X_MEM342 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c956));

        /// memory that stores X
        pub const X_MEM343 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c957));

        /// memory that stores X
        pub const X_MEM344 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c958));

        /// memory that stores X
        pub const X_MEM345 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c959));

        /// memory that stores X
        pub const X_MEM346 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c95a));

        /// memory that stores X
        pub const X_MEM347 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c95b));

        /// memory that stores X
        pub const X_MEM348 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c95c));

        /// memory that stores X
        pub const X_MEM349 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c95d));

        /// memory that stores X
        pub const X_MEM350 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c95e));

        /// memory that stores X
        pub const X_MEM351 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c95f));

        /// memory that stores X
        pub const X_MEM352 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c960));

        /// memory that stores X
        pub const X_MEM353 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c961));

        /// memory that stores X
        pub const X_MEM354 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c962));

        /// memory that stores X
        pub const X_MEM355 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c963));

        /// memory that stores X
        pub const X_MEM356 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c964));

        /// memory that stores X
        pub const X_MEM357 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c965));

        /// memory that stores X
        pub const X_MEM358 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c966));

        /// memory that stores X
        pub const X_MEM359 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c967));

        /// memory that stores X
        pub const X_MEM360 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c968));

        /// memory that stores X
        pub const X_MEM361 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c969));

        /// memory that stores X
        pub const X_MEM362 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c96a));

        /// memory that stores X
        pub const X_MEM363 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c96b));

        /// memory that stores X
        pub const X_MEM364 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c96c));

        /// memory that stores X
        pub const X_MEM365 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c96d));

        /// memory that stores X
        pub const X_MEM366 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c96e));

        /// memory that stores X
        pub const X_MEM367 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c96f));

        /// memory that stores X
        pub const X_MEM368 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c970));

        /// memory that stores X
        pub const X_MEM369 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c971));

        /// memory that stores X
        pub const X_MEM370 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c972));

        /// memory that stores X
        pub const X_MEM371 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c973));

        /// memory that stores X
        pub const X_MEM372 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c974));

        /// memory that stores X
        pub const X_MEM373 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c975));

        /// memory that stores X
        pub const X_MEM374 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c976));

        /// memory that stores X
        pub const X_MEM375 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c977));

        /// memory that stores X
        pub const X_MEM376 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c978));

        /// memory that stores X
        pub const X_MEM377 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c979));

        /// memory that stores X
        pub const X_MEM378 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c97a));

        /// memory that stores X
        pub const X_MEM379 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c97b));

        /// memory that stores X
        pub const X_MEM380 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c97c));

        /// memory that stores X
        pub const X_MEM381 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c97d));

        /// memory that stores X
        pub const X_MEM382 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c97e));

        /// memory that stores X
        pub const X_MEM383 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c97f));

        /// memory that stores X
        pub const X_MEM384 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c980));

        /// memory that stores X
        pub const X_MEM385 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c981));

        /// memory that stores X
        pub const X_MEM386 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c982));

        /// memory that stores X
        pub const X_MEM387 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c983));

        /// memory that stores X
        pub const X_MEM388 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c984));

        /// memory that stores X
        pub const X_MEM389 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c985));

        /// memory that stores X
        pub const X_MEM390 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c986));

        /// memory that stores X
        pub const X_MEM391 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c987));

        /// memory that stores X
        pub const X_MEM392 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c988));

        /// memory that stores X
        pub const X_MEM393 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c989));

        /// memory that stores X
        pub const X_MEM394 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c98a));

        /// memory that stores X
        pub const X_MEM395 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c98b));

        /// memory that stores X
        pub const X_MEM396 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c98c));

        /// memory that stores X
        pub const X_MEM397 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c98d));

        /// memory that stores X
        pub const X_MEM398 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c98e));

        /// memory that stores X
        pub const X_MEM399 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c98f));

        /// memory that stores X
        pub const X_MEM400 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c990));

        /// memory that stores X
        pub const X_MEM401 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c991));

        /// memory that stores X
        pub const X_MEM402 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c992));

        /// memory that stores X
        pub const X_MEM403 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c993));

        /// memory that stores X
        pub const X_MEM404 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c994));

        /// memory that stores X
        pub const X_MEM405 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c995));

        /// memory that stores X
        pub const X_MEM406 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c996));

        /// memory that stores X
        pub const X_MEM407 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c997));

        /// memory that stores X
        pub const X_MEM408 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c998));

        /// memory that stores X
        pub const X_MEM409 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c999));

        /// memory that stores X
        pub const X_MEM410 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c99a));

        /// memory that stores X
        pub const X_MEM411 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c99b));

        /// memory that stores X
        pub const X_MEM412 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c99c));

        /// memory that stores X
        pub const X_MEM413 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c99d));

        /// memory that stores X
        pub const X_MEM414 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c99e));

        /// memory that stores X
        pub const X_MEM415 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c99f));

        /// memory that stores X
        pub const X_MEM416 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c9a0));

        /// memory that stores X
        pub const X_MEM417 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c9a1));

        /// memory that stores X
        pub const X_MEM418 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c9a2));

        /// memory that stores X
        pub const X_MEM419 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c9a3));

        /// memory that stores X
        pub const X_MEM420 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c9a4));

        /// memory that stores X
        pub const X_MEM421 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c9a5));

        /// memory that stores X
        pub const X_MEM422 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c9a6));

        /// memory that stores X
        pub const X_MEM423 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c9a7));

        /// memory that stores X
        pub const X_MEM424 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c9a8));

        /// memory that stores X
        pub const X_MEM425 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c9a9));

        /// memory that stores X
        pub const X_MEM426 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c9aa));

        /// memory that stores X
        pub const X_MEM427 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c9ab));

        /// memory that stores X
        pub const X_MEM428 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c9ac));

        /// memory that stores X
        pub const X_MEM429 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c9ad));

        /// memory that stores X
        pub const X_MEM430 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c9ae));

        /// memory that stores X
        pub const X_MEM431 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c9af));

        /// memory that stores X
        pub const X_MEM432 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c9b0));

        /// memory that stores X
        pub const X_MEM433 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c9b1));

        /// memory that stores X
        pub const X_MEM434 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c9b2));

        /// memory that stores X
        pub const X_MEM435 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c9b3));

        /// memory that stores X
        pub const X_MEM436 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c9b4));

        /// memory that stores X
        pub const X_MEM437 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c9b5));

        /// memory that stores X
        pub const X_MEM438 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c9b6));

        /// memory that stores X
        pub const X_MEM439 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c9b7));

        /// memory that stores X
        pub const X_MEM440 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c9b8));

        /// memory that stores X
        pub const X_MEM441 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c9b9));

        /// memory that stores X
        pub const X_MEM442 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c9ba));

        /// memory that stores X
        pub const X_MEM443 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c9bb));

        /// memory that stores X
        pub const X_MEM444 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c9bc));

        /// memory that stores X
        pub const X_MEM445 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c9bd));

        /// memory that stores X
        pub const X_MEM446 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c9be));

        /// memory that stores X
        pub const X_MEM447 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c9bf));

        /// memory that stores X
        pub const X_MEM448 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c9c0));

        /// memory that stores X
        pub const X_MEM449 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c9c1));

        /// memory that stores X
        pub const X_MEM450 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c9c2));

        /// memory that stores X
        pub const X_MEM451 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c9c3));

        /// memory that stores X
        pub const X_MEM452 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c9c4));

        /// memory that stores X
        pub const X_MEM453 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c9c5));

        /// memory that stores X
        pub const X_MEM454 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c9c6));

        /// memory that stores X
        pub const X_MEM455 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c9c7));

        /// memory that stores X
        pub const X_MEM456 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c9c8));

        /// memory that stores X
        pub const X_MEM457 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c9c9));

        /// memory that stores X
        pub const X_MEM458 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c9ca));

        /// memory that stores X
        pub const X_MEM459 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c9cb));

        /// memory that stores X
        pub const X_MEM460 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c9cc));

        /// memory that stores X
        pub const X_MEM461 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c9cd));

        /// memory that stores X
        pub const X_MEM462 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c9ce));

        /// memory that stores X
        pub const X_MEM463 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c9cf));

        /// memory that stores X
        pub const X_MEM464 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c9d0));

        /// memory that stores X
        pub const X_MEM465 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c9d1));

        /// memory that stores X
        pub const X_MEM466 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c9d2));

        /// memory that stores X
        pub const X_MEM467 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c9d3));

        /// memory that stores X
        pub const X_MEM468 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c9d4));

        /// memory that stores X
        pub const X_MEM469 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c9d5));

        /// memory that stores X
        pub const X_MEM470 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c9d6));

        /// memory that stores X
        pub const X_MEM471 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c9d7));

        /// memory that stores X
        pub const X_MEM472 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c9d8));

        /// memory that stores X
        pub const X_MEM473 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c9d9));

        /// memory that stores X
        pub const X_MEM474 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c9da));

        /// memory that stores X
        pub const X_MEM475 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c9db));

        /// memory that stores X
        pub const X_MEM476 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c9dc));

        /// memory that stores X
        pub const X_MEM477 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c9dd));

        /// memory that stores X
        pub const X_MEM478 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c9de));

        /// memory that stores X
        pub const X_MEM479 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c9df));

        /// memory that stores X
        pub const X_MEM480 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c9e0));

        /// memory that stores X
        pub const X_MEM481 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c9e1));

        /// memory that stores X
        pub const X_MEM482 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c9e2));

        /// memory that stores X
        pub const X_MEM483 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c9e3));

        /// memory that stores X
        pub const X_MEM484 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c9e4));

        /// memory that stores X
        pub const X_MEM485 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c9e5));

        /// memory that stores X
        pub const X_MEM486 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c9e6));

        /// memory that stores X
        pub const X_MEM487 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c9e7));

        /// memory that stores X
        pub const X_MEM488 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c9e8));

        /// memory that stores X
        pub const X_MEM489 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c9e9));

        /// memory that stores X
        pub const X_MEM490 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c9ea));

        /// memory that stores X
        pub const X_MEM491 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c9eb));

        /// memory that stores X
        pub const X_MEM492 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c9ec));

        /// memory that stores X
        pub const X_MEM493 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c9ed));

        /// memory that stores X
        pub const X_MEM494 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c9ee));

        /// memory that stores X
        pub const X_MEM495 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c9ef));

        /// memory that stores X
        pub const X_MEM496 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c9f0));

        /// memory that stores X
        pub const X_MEM497 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c9f1));

        /// memory that stores X
        pub const X_MEM498 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c9f2));

        /// memory that stores X
        pub const X_MEM499 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c9f3));

        /// memory that stores X
        pub const X_MEM500 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c9f4));

        /// memory that stores X
        pub const X_MEM501 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c9f5));

        /// memory that stores X
        pub const X_MEM502 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c9f6));

        /// memory that stores X
        pub const X_MEM503 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c9f7));

        /// memory that stores X
        pub const X_MEM504 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c9f8));

        /// memory that stores X
        pub const X_MEM505 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c9f9));

        /// memory that stores X
        pub const X_MEM506 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c9fa));

        /// memory that stores X
        pub const X_MEM507 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c9fb));

        /// memory that stores X
        pub const X_MEM508 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c9fc));

        /// memory that stores X
        pub const X_MEM509 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c9fd));

        /// memory that stores X
        pub const X_MEM510 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c9fe));

        /// memory that stores X
        pub const X_MEM511 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008c9ff));

        /// memory that stores Z
        pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca00));

        /// memory that stores Z
        pub const Z_MEM1 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca01));

        /// memory that stores Z
        pub const Z_MEM2 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca02));

        /// memory that stores Z
        pub const Z_MEM3 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca03));

        /// memory that stores Z
        pub const Z_MEM4 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca04));

        /// memory that stores Z
        pub const Z_MEM5 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca05));

        /// memory that stores Z
        pub const Z_MEM6 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca06));

        /// memory that stores Z
        pub const Z_MEM7 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca07));

        /// memory that stores Z
        pub const Z_MEM8 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca08));

        /// memory that stores Z
        pub const Z_MEM9 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca09));

        /// memory that stores Z
        pub const Z_MEM10 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca0a));

        /// memory that stores Z
        pub const Z_MEM11 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca0b));

        /// memory that stores Z
        pub const Z_MEM12 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca0c));

        /// memory that stores Z
        pub const Z_MEM13 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca0d));

        /// memory that stores Z
        pub const Z_MEM14 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca0e));

        /// memory that stores Z
        pub const Z_MEM15 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca0f));

        /// memory that stores Z
        pub const Z_MEM16 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca10));

        /// memory that stores Z
        pub const Z_MEM17 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca11));

        /// memory that stores Z
        pub const Z_MEM18 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca12));

        /// memory that stores Z
        pub const Z_MEM19 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca13));

        /// memory that stores Z
        pub const Z_MEM20 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca14));

        /// memory that stores Z
        pub const Z_MEM21 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca15));

        /// memory that stores Z
        pub const Z_MEM22 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca16));

        /// memory that stores Z
        pub const Z_MEM23 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca17));

        /// memory that stores Z
        pub const Z_MEM24 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca18));

        /// memory that stores Z
        pub const Z_MEM25 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca19));

        /// memory that stores Z
        pub const Z_MEM26 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca1a));

        /// memory that stores Z
        pub const Z_MEM27 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca1b));

        /// memory that stores Z
        pub const Z_MEM28 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca1c));

        /// memory that stores Z
        pub const Z_MEM29 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca1d));

        /// memory that stores Z
        pub const Z_MEM30 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca1e));

        /// memory that stores Z
        pub const Z_MEM31 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca1f));

        /// memory that stores Z
        pub const Z_MEM32 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca20));

        /// memory that stores Z
        pub const Z_MEM33 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca21));

        /// memory that stores Z
        pub const Z_MEM34 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca22));

        /// memory that stores Z
        pub const Z_MEM35 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca23));

        /// memory that stores Z
        pub const Z_MEM36 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca24));

        /// memory that stores Z
        pub const Z_MEM37 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca25));

        /// memory that stores Z
        pub const Z_MEM38 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca26));

        /// memory that stores Z
        pub const Z_MEM39 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca27));

        /// memory that stores Z
        pub const Z_MEM40 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca28));

        /// memory that stores Z
        pub const Z_MEM41 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca29));

        /// memory that stores Z
        pub const Z_MEM42 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca2a));

        /// memory that stores Z
        pub const Z_MEM43 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca2b));

        /// memory that stores Z
        pub const Z_MEM44 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca2c));

        /// memory that stores Z
        pub const Z_MEM45 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca2d));

        /// memory that stores Z
        pub const Z_MEM46 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca2e));

        /// memory that stores Z
        pub const Z_MEM47 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca2f));

        /// memory that stores Z
        pub const Z_MEM48 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca30));

        /// memory that stores Z
        pub const Z_MEM49 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca31));

        /// memory that stores Z
        pub const Z_MEM50 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca32));

        /// memory that stores Z
        pub const Z_MEM51 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca33));

        /// memory that stores Z
        pub const Z_MEM52 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca34));

        /// memory that stores Z
        pub const Z_MEM53 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca35));

        /// memory that stores Z
        pub const Z_MEM54 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca36));

        /// memory that stores Z
        pub const Z_MEM55 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca37));

        /// memory that stores Z
        pub const Z_MEM56 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca38));

        /// memory that stores Z
        pub const Z_MEM57 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca39));

        /// memory that stores Z
        pub const Z_MEM58 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca3a));

        /// memory that stores Z
        pub const Z_MEM59 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca3b));

        /// memory that stores Z
        pub const Z_MEM60 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca3c));

        /// memory that stores Z
        pub const Z_MEM61 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca3d));

        /// memory that stores Z
        pub const Z_MEM62 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca3e));

        /// memory that stores Z
        pub const Z_MEM63 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca3f));

        /// memory that stores Z
        pub const Z_MEM64 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca40));

        /// memory that stores Z
        pub const Z_MEM65 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca41));

        /// memory that stores Z
        pub const Z_MEM66 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca42));

        /// memory that stores Z
        pub const Z_MEM67 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca43));

        /// memory that stores Z
        pub const Z_MEM68 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca44));

        /// memory that stores Z
        pub const Z_MEM69 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca45));

        /// memory that stores Z
        pub const Z_MEM70 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca46));

        /// memory that stores Z
        pub const Z_MEM71 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca47));

        /// memory that stores Z
        pub const Z_MEM72 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca48));

        /// memory that stores Z
        pub const Z_MEM73 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca49));

        /// memory that stores Z
        pub const Z_MEM74 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca4a));

        /// memory that stores Z
        pub const Z_MEM75 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca4b));

        /// memory that stores Z
        pub const Z_MEM76 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca4c));

        /// memory that stores Z
        pub const Z_MEM77 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca4d));

        /// memory that stores Z
        pub const Z_MEM78 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca4e));

        /// memory that stores Z
        pub const Z_MEM79 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca4f));

        /// memory that stores Z
        pub const Z_MEM80 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca50));

        /// memory that stores Z
        pub const Z_MEM81 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca51));

        /// memory that stores Z
        pub const Z_MEM82 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca52));

        /// memory that stores Z
        pub const Z_MEM83 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca53));

        /// memory that stores Z
        pub const Z_MEM84 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca54));

        /// memory that stores Z
        pub const Z_MEM85 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca55));

        /// memory that stores Z
        pub const Z_MEM86 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca56));

        /// memory that stores Z
        pub const Z_MEM87 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca57));

        /// memory that stores Z
        pub const Z_MEM88 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca58));

        /// memory that stores Z
        pub const Z_MEM89 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca59));

        /// memory that stores Z
        pub const Z_MEM90 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca5a));

        /// memory that stores Z
        pub const Z_MEM91 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca5b));

        /// memory that stores Z
        pub const Z_MEM92 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca5c));

        /// memory that stores Z
        pub const Z_MEM93 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca5d));

        /// memory that stores Z
        pub const Z_MEM94 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca5e));

        /// memory that stores Z
        pub const Z_MEM95 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca5f));

        /// memory that stores Z
        pub const Z_MEM96 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca60));

        /// memory that stores Z
        pub const Z_MEM97 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca61));

        /// memory that stores Z
        pub const Z_MEM98 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca62));

        /// memory that stores Z
        pub const Z_MEM99 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca63));

        /// memory that stores Z
        pub const Z_MEM100 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca64));

        /// memory that stores Z
        pub const Z_MEM101 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca65));

        /// memory that stores Z
        pub const Z_MEM102 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca66));

        /// memory that stores Z
        pub const Z_MEM103 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca67));

        /// memory that stores Z
        pub const Z_MEM104 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca68));

        /// memory that stores Z
        pub const Z_MEM105 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca69));

        /// memory that stores Z
        pub const Z_MEM106 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca6a));

        /// memory that stores Z
        pub const Z_MEM107 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca6b));

        /// memory that stores Z
        pub const Z_MEM108 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca6c));

        /// memory that stores Z
        pub const Z_MEM109 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca6d));

        /// memory that stores Z
        pub const Z_MEM110 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca6e));

        /// memory that stores Z
        pub const Z_MEM111 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca6f));

        /// memory that stores Z
        pub const Z_MEM112 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca70));

        /// memory that stores Z
        pub const Z_MEM113 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca71));

        /// memory that stores Z
        pub const Z_MEM114 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca72));

        /// memory that stores Z
        pub const Z_MEM115 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca73));

        /// memory that stores Z
        pub const Z_MEM116 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca74));

        /// memory that stores Z
        pub const Z_MEM117 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca75));

        /// memory that stores Z
        pub const Z_MEM118 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca76));

        /// memory that stores Z
        pub const Z_MEM119 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca77));

        /// memory that stores Z
        pub const Z_MEM120 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca78));

        /// memory that stores Z
        pub const Z_MEM121 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca79));

        /// memory that stores Z
        pub const Z_MEM122 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca7a));

        /// memory that stores Z
        pub const Z_MEM123 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca7b));

        /// memory that stores Z
        pub const Z_MEM124 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca7c));

        /// memory that stores Z
        pub const Z_MEM125 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca7d));

        /// memory that stores Z
        pub const Z_MEM126 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca7e));

        /// memory that stores Z
        pub const Z_MEM127 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca7f));

        /// memory that stores Z
        pub const Z_MEM128 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca80));

        /// memory that stores Z
        pub const Z_MEM129 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca81));

        /// memory that stores Z
        pub const Z_MEM130 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca82));

        /// memory that stores Z
        pub const Z_MEM131 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca83));

        /// memory that stores Z
        pub const Z_MEM132 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca84));

        /// memory that stores Z
        pub const Z_MEM133 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca85));

        /// memory that stores Z
        pub const Z_MEM134 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca86));

        /// memory that stores Z
        pub const Z_MEM135 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca87));

        /// memory that stores Z
        pub const Z_MEM136 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca88));

        /// memory that stores Z
        pub const Z_MEM137 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca89));

        /// memory that stores Z
        pub const Z_MEM138 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca8a));

        /// memory that stores Z
        pub const Z_MEM139 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca8b));

        /// memory that stores Z
        pub const Z_MEM140 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca8c));

        /// memory that stores Z
        pub const Z_MEM141 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca8d));

        /// memory that stores Z
        pub const Z_MEM142 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca8e));

        /// memory that stores Z
        pub const Z_MEM143 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca8f));

        /// memory that stores Z
        pub const Z_MEM144 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca90));

        /// memory that stores Z
        pub const Z_MEM145 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca91));

        /// memory that stores Z
        pub const Z_MEM146 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca92));

        /// memory that stores Z
        pub const Z_MEM147 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca93));

        /// memory that stores Z
        pub const Z_MEM148 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca94));

        /// memory that stores Z
        pub const Z_MEM149 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca95));

        /// memory that stores Z
        pub const Z_MEM150 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca96));

        /// memory that stores Z
        pub const Z_MEM151 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca97));

        /// memory that stores Z
        pub const Z_MEM152 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca98));

        /// memory that stores Z
        pub const Z_MEM153 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca99));

        /// memory that stores Z
        pub const Z_MEM154 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca9a));

        /// memory that stores Z
        pub const Z_MEM155 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca9b));

        /// memory that stores Z
        pub const Z_MEM156 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca9c));

        /// memory that stores Z
        pub const Z_MEM157 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca9d));

        /// memory that stores Z
        pub const Z_MEM158 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca9e));

        /// memory that stores Z
        pub const Z_MEM159 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008ca9f));

        /// memory that stores Z
        pub const Z_MEM160 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008caa0));

        /// memory that stores Z
        pub const Z_MEM161 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008caa1));

        /// memory that stores Z
        pub const Z_MEM162 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008caa2));

        /// memory that stores Z
        pub const Z_MEM163 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008caa3));

        /// memory that stores Z
        pub const Z_MEM164 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008caa4));

        /// memory that stores Z
        pub const Z_MEM165 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008caa5));

        /// memory that stores Z
        pub const Z_MEM166 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008caa6));

        /// memory that stores Z
        pub const Z_MEM167 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008caa7));

        /// memory that stores Z
        pub const Z_MEM168 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008caa8));

        /// memory that stores Z
        pub const Z_MEM169 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008caa9));

        /// memory that stores Z
        pub const Z_MEM170 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008caaa));

        /// memory that stores Z
        pub const Z_MEM171 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008caab));

        /// memory that stores Z
        pub const Z_MEM172 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008caac));

        /// memory that stores Z
        pub const Z_MEM173 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008caad));

        /// memory that stores Z
        pub const Z_MEM174 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008caae));

        /// memory that stores Z
        pub const Z_MEM175 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008caaf));

        /// memory that stores Z
        pub const Z_MEM176 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cab0));

        /// memory that stores Z
        pub const Z_MEM177 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cab1));

        /// memory that stores Z
        pub const Z_MEM178 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cab2));

        /// memory that stores Z
        pub const Z_MEM179 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cab3));

        /// memory that stores Z
        pub const Z_MEM180 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cab4));

        /// memory that stores Z
        pub const Z_MEM181 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cab5));

        /// memory that stores Z
        pub const Z_MEM182 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cab6));

        /// memory that stores Z
        pub const Z_MEM183 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cab7));

        /// memory that stores Z
        pub const Z_MEM184 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cab8));

        /// memory that stores Z
        pub const Z_MEM185 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cab9));

        /// memory that stores Z
        pub const Z_MEM186 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008caba));

        /// memory that stores Z
        pub const Z_MEM187 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cabb));

        /// memory that stores Z
        pub const Z_MEM188 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cabc));

        /// memory that stores Z
        pub const Z_MEM189 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cabd));

        /// memory that stores Z
        pub const Z_MEM190 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cabe));

        /// memory that stores Z
        pub const Z_MEM191 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cabf));

        /// memory that stores Z
        pub const Z_MEM192 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cac0));

        /// memory that stores Z
        pub const Z_MEM193 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cac1));

        /// memory that stores Z
        pub const Z_MEM194 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cac2));

        /// memory that stores Z
        pub const Z_MEM195 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cac3));

        /// memory that stores Z
        pub const Z_MEM196 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cac4));

        /// memory that stores Z
        pub const Z_MEM197 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cac5));

        /// memory that stores Z
        pub const Z_MEM198 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cac6));

        /// memory that stores Z
        pub const Z_MEM199 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cac7));

        /// memory that stores Z
        pub const Z_MEM200 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cac8));

        /// memory that stores Z
        pub const Z_MEM201 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cac9));

        /// memory that stores Z
        pub const Z_MEM202 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008caca));

        /// memory that stores Z
        pub const Z_MEM203 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cacb));

        /// memory that stores Z
        pub const Z_MEM204 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cacc));

        /// memory that stores Z
        pub const Z_MEM205 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cacd));

        /// memory that stores Z
        pub const Z_MEM206 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cace));

        /// memory that stores Z
        pub const Z_MEM207 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cacf));

        /// memory that stores Z
        pub const Z_MEM208 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cad0));

        /// memory that stores Z
        pub const Z_MEM209 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cad1));

        /// memory that stores Z
        pub const Z_MEM210 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cad2));

        /// memory that stores Z
        pub const Z_MEM211 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cad3));

        /// memory that stores Z
        pub const Z_MEM212 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cad4));

        /// memory that stores Z
        pub const Z_MEM213 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cad5));

        /// memory that stores Z
        pub const Z_MEM214 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cad6));

        /// memory that stores Z
        pub const Z_MEM215 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cad7));

        /// memory that stores Z
        pub const Z_MEM216 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cad8));

        /// memory that stores Z
        pub const Z_MEM217 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cad9));

        /// memory that stores Z
        pub const Z_MEM218 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cada));

        /// memory that stores Z
        pub const Z_MEM219 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cadb));

        /// memory that stores Z
        pub const Z_MEM220 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cadc));

        /// memory that stores Z
        pub const Z_MEM221 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cadd));

        /// memory that stores Z
        pub const Z_MEM222 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cade));

        /// memory that stores Z
        pub const Z_MEM223 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cadf));

        /// memory that stores Z
        pub const Z_MEM224 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cae0));

        /// memory that stores Z
        pub const Z_MEM225 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cae1));

        /// memory that stores Z
        pub const Z_MEM226 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cae2));

        /// memory that stores Z
        pub const Z_MEM227 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cae3));

        /// memory that stores Z
        pub const Z_MEM228 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cae4));

        /// memory that stores Z
        pub const Z_MEM229 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cae5));

        /// memory that stores Z
        pub const Z_MEM230 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cae6));

        /// memory that stores Z
        pub const Z_MEM231 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cae7));

        /// memory that stores Z
        pub const Z_MEM232 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cae8));

        /// memory that stores Z
        pub const Z_MEM233 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cae9));

        /// memory that stores Z
        pub const Z_MEM234 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008caea));

        /// memory that stores Z
        pub const Z_MEM235 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008caeb));

        /// memory that stores Z
        pub const Z_MEM236 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008caec));

        /// memory that stores Z
        pub const Z_MEM237 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008caed));

        /// memory that stores Z
        pub const Z_MEM238 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008caee));

        /// memory that stores Z
        pub const Z_MEM239 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008caef));

        /// memory that stores Z
        pub const Z_MEM240 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008caf0));

        /// memory that stores Z
        pub const Z_MEM241 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008caf1));

        /// memory that stores Z
        pub const Z_MEM242 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008caf2));

        /// memory that stores Z
        pub const Z_MEM243 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008caf3));

        /// memory that stores Z
        pub const Z_MEM244 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008caf4));

        /// memory that stores Z
        pub const Z_MEM245 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008caf5));

        /// memory that stores Z
        pub const Z_MEM246 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008caf6));

        /// memory that stores Z
        pub const Z_MEM247 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008caf7));

        /// memory that stores Z
        pub const Z_MEM248 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008caf8));

        /// memory that stores Z
        pub const Z_MEM249 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008caf9));

        /// memory that stores Z
        pub const Z_MEM250 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cafa));

        /// memory that stores Z
        pub const Z_MEM251 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cafb));

        /// memory that stores Z
        pub const Z_MEM252 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cafc));

        /// memory that stores Z
        pub const Z_MEM253 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cafd));

        /// memory that stores Z
        pub const Z_MEM254 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cafe));

        /// memory that stores Z
        pub const Z_MEM255 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008caff));

        /// memory that stores Z
        pub const Z_MEM256 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb00));

        /// memory that stores Z
        pub const Z_MEM257 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb01));

        /// memory that stores Z
        pub const Z_MEM258 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb02));

        /// memory that stores Z
        pub const Z_MEM259 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb03));

        /// memory that stores Z
        pub const Z_MEM260 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb04));

        /// memory that stores Z
        pub const Z_MEM261 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb05));

        /// memory that stores Z
        pub const Z_MEM262 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb06));

        /// memory that stores Z
        pub const Z_MEM263 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb07));

        /// memory that stores Z
        pub const Z_MEM264 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb08));

        /// memory that stores Z
        pub const Z_MEM265 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb09));

        /// memory that stores Z
        pub const Z_MEM266 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb0a));

        /// memory that stores Z
        pub const Z_MEM267 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb0b));

        /// memory that stores Z
        pub const Z_MEM268 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb0c));

        /// memory that stores Z
        pub const Z_MEM269 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb0d));

        /// memory that stores Z
        pub const Z_MEM270 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb0e));

        /// memory that stores Z
        pub const Z_MEM271 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb0f));

        /// memory that stores Z
        pub const Z_MEM272 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb10));

        /// memory that stores Z
        pub const Z_MEM273 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb11));

        /// memory that stores Z
        pub const Z_MEM274 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb12));

        /// memory that stores Z
        pub const Z_MEM275 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb13));

        /// memory that stores Z
        pub const Z_MEM276 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb14));

        /// memory that stores Z
        pub const Z_MEM277 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb15));

        /// memory that stores Z
        pub const Z_MEM278 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb16));

        /// memory that stores Z
        pub const Z_MEM279 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb17));

        /// memory that stores Z
        pub const Z_MEM280 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb18));

        /// memory that stores Z
        pub const Z_MEM281 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb19));

        /// memory that stores Z
        pub const Z_MEM282 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb1a));

        /// memory that stores Z
        pub const Z_MEM283 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb1b));

        /// memory that stores Z
        pub const Z_MEM284 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb1c));

        /// memory that stores Z
        pub const Z_MEM285 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb1d));

        /// memory that stores Z
        pub const Z_MEM286 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb1e));

        /// memory that stores Z
        pub const Z_MEM287 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb1f));

        /// memory that stores Z
        pub const Z_MEM288 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb20));

        /// memory that stores Z
        pub const Z_MEM289 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb21));

        /// memory that stores Z
        pub const Z_MEM290 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb22));

        /// memory that stores Z
        pub const Z_MEM291 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb23));

        /// memory that stores Z
        pub const Z_MEM292 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb24));

        /// memory that stores Z
        pub const Z_MEM293 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb25));

        /// memory that stores Z
        pub const Z_MEM294 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb26));

        /// memory that stores Z
        pub const Z_MEM295 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb27));

        /// memory that stores Z
        pub const Z_MEM296 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb28));

        /// memory that stores Z
        pub const Z_MEM297 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb29));

        /// memory that stores Z
        pub const Z_MEM298 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb2a));

        /// memory that stores Z
        pub const Z_MEM299 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb2b));

        /// memory that stores Z
        pub const Z_MEM300 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb2c));

        /// memory that stores Z
        pub const Z_MEM301 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb2d));

        /// memory that stores Z
        pub const Z_MEM302 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb2e));

        /// memory that stores Z
        pub const Z_MEM303 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb2f));

        /// memory that stores Z
        pub const Z_MEM304 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb30));

        /// memory that stores Z
        pub const Z_MEM305 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb31));

        /// memory that stores Z
        pub const Z_MEM306 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb32));

        /// memory that stores Z
        pub const Z_MEM307 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb33));

        /// memory that stores Z
        pub const Z_MEM308 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb34));

        /// memory that stores Z
        pub const Z_MEM309 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb35));

        /// memory that stores Z
        pub const Z_MEM310 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb36));

        /// memory that stores Z
        pub const Z_MEM311 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb37));

        /// memory that stores Z
        pub const Z_MEM312 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb38));

        /// memory that stores Z
        pub const Z_MEM313 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb39));

        /// memory that stores Z
        pub const Z_MEM314 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb3a));

        /// memory that stores Z
        pub const Z_MEM315 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb3b));

        /// memory that stores Z
        pub const Z_MEM316 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb3c));

        /// memory that stores Z
        pub const Z_MEM317 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb3d));

        /// memory that stores Z
        pub const Z_MEM318 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb3e));

        /// memory that stores Z
        pub const Z_MEM319 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb3f));

        /// memory that stores Z
        pub const Z_MEM320 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb40));

        /// memory that stores Z
        pub const Z_MEM321 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb41));

        /// memory that stores Z
        pub const Z_MEM322 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb42));

        /// memory that stores Z
        pub const Z_MEM323 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb43));

        /// memory that stores Z
        pub const Z_MEM324 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb44));

        /// memory that stores Z
        pub const Z_MEM325 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb45));

        /// memory that stores Z
        pub const Z_MEM326 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb46));

        /// memory that stores Z
        pub const Z_MEM327 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb47));

        /// memory that stores Z
        pub const Z_MEM328 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb48));

        /// memory that stores Z
        pub const Z_MEM329 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb49));

        /// memory that stores Z
        pub const Z_MEM330 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb4a));

        /// memory that stores Z
        pub const Z_MEM331 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb4b));

        /// memory that stores Z
        pub const Z_MEM332 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb4c));

        /// memory that stores Z
        pub const Z_MEM333 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb4d));

        /// memory that stores Z
        pub const Z_MEM334 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb4e));

        /// memory that stores Z
        pub const Z_MEM335 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb4f));

        /// memory that stores Z
        pub const Z_MEM336 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb50));

        /// memory that stores Z
        pub const Z_MEM337 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb51));

        /// memory that stores Z
        pub const Z_MEM338 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb52));

        /// memory that stores Z
        pub const Z_MEM339 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb53));

        /// memory that stores Z
        pub const Z_MEM340 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb54));

        /// memory that stores Z
        pub const Z_MEM341 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb55));

        /// memory that stores Z
        pub const Z_MEM342 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb56));

        /// memory that stores Z
        pub const Z_MEM343 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb57));

        /// memory that stores Z
        pub const Z_MEM344 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb58));

        /// memory that stores Z
        pub const Z_MEM345 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb59));

        /// memory that stores Z
        pub const Z_MEM346 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb5a));

        /// memory that stores Z
        pub const Z_MEM347 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb5b));

        /// memory that stores Z
        pub const Z_MEM348 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb5c));

        /// memory that stores Z
        pub const Z_MEM349 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb5d));

        /// memory that stores Z
        pub const Z_MEM350 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb5e));

        /// memory that stores Z
        pub const Z_MEM351 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb5f));

        /// memory that stores Z
        pub const Z_MEM352 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb60));

        /// memory that stores Z
        pub const Z_MEM353 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb61));

        /// memory that stores Z
        pub const Z_MEM354 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb62));

        /// memory that stores Z
        pub const Z_MEM355 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb63));

        /// memory that stores Z
        pub const Z_MEM356 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb64));

        /// memory that stores Z
        pub const Z_MEM357 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb65));

        /// memory that stores Z
        pub const Z_MEM358 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb66));

        /// memory that stores Z
        pub const Z_MEM359 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb67));

        /// memory that stores Z
        pub const Z_MEM360 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb68));

        /// memory that stores Z
        pub const Z_MEM361 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb69));

        /// memory that stores Z
        pub const Z_MEM362 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb6a));

        /// memory that stores Z
        pub const Z_MEM363 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb6b));

        /// memory that stores Z
        pub const Z_MEM364 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb6c));

        /// memory that stores Z
        pub const Z_MEM365 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb6d));

        /// memory that stores Z
        pub const Z_MEM366 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb6e));

        /// memory that stores Z
        pub const Z_MEM367 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb6f));

        /// memory that stores Z
        pub const Z_MEM368 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb70));

        /// memory that stores Z
        pub const Z_MEM369 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb71));

        /// memory that stores Z
        pub const Z_MEM370 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb72));

        /// memory that stores Z
        pub const Z_MEM371 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb73));

        /// memory that stores Z
        pub const Z_MEM372 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb74));

        /// memory that stores Z
        pub const Z_MEM373 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb75));

        /// memory that stores Z
        pub const Z_MEM374 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb76));

        /// memory that stores Z
        pub const Z_MEM375 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb77));

        /// memory that stores Z
        pub const Z_MEM376 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb78));

        /// memory that stores Z
        pub const Z_MEM377 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb79));

        /// memory that stores Z
        pub const Z_MEM378 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb7a));

        /// memory that stores Z
        pub const Z_MEM379 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb7b));

        /// memory that stores Z
        pub const Z_MEM380 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb7c));

        /// memory that stores Z
        pub const Z_MEM381 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb7d));

        /// memory that stores Z
        pub const Z_MEM382 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb7e));

        /// memory that stores Z
        pub const Z_MEM383 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb7f));

        /// memory that stores Z
        pub const Z_MEM384 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb80));

        /// memory that stores Z
        pub const Z_MEM385 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb81));

        /// memory that stores Z
        pub const Z_MEM386 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb82));

        /// memory that stores Z
        pub const Z_MEM387 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb83));

        /// memory that stores Z
        pub const Z_MEM388 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb84));

        /// memory that stores Z
        pub const Z_MEM389 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb85));

        /// memory that stores Z
        pub const Z_MEM390 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb86));

        /// memory that stores Z
        pub const Z_MEM391 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb87));

        /// memory that stores Z
        pub const Z_MEM392 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb88));

        /// memory that stores Z
        pub const Z_MEM393 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb89));

        /// memory that stores Z
        pub const Z_MEM394 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb8a));

        /// memory that stores Z
        pub const Z_MEM395 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb8b));

        /// memory that stores Z
        pub const Z_MEM396 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb8c));

        /// memory that stores Z
        pub const Z_MEM397 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb8d));

        /// memory that stores Z
        pub const Z_MEM398 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb8e));

        /// memory that stores Z
        pub const Z_MEM399 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb8f));

        /// memory that stores Z
        pub const Z_MEM400 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb90));

        /// memory that stores Z
        pub const Z_MEM401 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb91));

        /// memory that stores Z
        pub const Z_MEM402 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb92));

        /// memory that stores Z
        pub const Z_MEM403 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb93));

        /// memory that stores Z
        pub const Z_MEM404 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb94));

        /// memory that stores Z
        pub const Z_MEM405 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb95));

        /// memory that stores Z
        pub const Z_MEM406 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb96));

        /// memory that stores Z
        pub const Z_MEM407 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb97));

        /// memory that stores Z
        pub const Z_MEM408 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb98));

        /// memory that stores Z
        pub const Z_MEM409 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb99));

        /// memory that stores Z
        pub const Z_MEM410 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb9a));

        /// memory that stores Z
        pub const Z_MEM411 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb9b));

        /// memory that stores Z
        pub const Z_MEM412 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb9c));

        /// memory that stores Z
        pub const Z_MEM413 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb9d));

        /// memory that stores Z
        pub const Z_MEM414 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb9e));

        /// memory that stores Z
        pub const Z_MEM415 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cb9f));

        /// memory that stores Z
        pub const Z_MEM416 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cba0));

        /// memory that stores Z
        pub const Z_MEM417 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cba1));

        /// memory that stores Z
        pub const Z_MEM418 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cba2));

        /// memory that stores Z
        pub const Z_MEM419 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cba3));

        /// memory that stores Z
        pub const Z_MEM420 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cba4));

        /// memory that stores Z
        pub const Z_MEM421 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cba5));

        /// memory that stores Z
        pub const Z_MEM422 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cba6));

        /// memory that stores Z
        pub const Z_MEM423 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cba7));

        /// memory that stores Z
        pub const Z_MEM424 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cba8));

        /// memory that stores Z
        pub const Z_MEM425 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cba9));

        /// memory that stores Z
        pub const Z_MEM426 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cbaa));

        /// memory that stores Z
        pub const Z_MEM427 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cbab));

        /// memory that stores Z
        pub const Z_MEM428 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cbac));

        /// memory that stores Z
        pub const Z_MEM429 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cbad));

        /// memory that stores Z
        pub const Z_MEM430 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cbae));

        /// memory that stores Z
        pub const Z_MEM431 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cbaf));

        /// memory that stores Z
        pub const Z_MEM432 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cbb0));

        /// memory that stores Z
        pub const Z_MEM433 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cbb1));

        /// memory that stores Z
        pub const Z_MEM434 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cbb2));

        /// memory that stores Z
        pub const Z_MEM435 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cbb3));

        /// memory that stores Z
        pub const Z_MEM436 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cbb4));

        /// memory that stores Z
        pub const Z_MEM437 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cbb5));

        /// memory that stores Z
        pub const Z_MEM438 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cbb6));

        /// memory that stores Z
        pub const Z_MEM439 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cbb7));

        /// memory that stores Z
        pub const Z_MEM440 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cbb8));

        /// memory that stores Z
        pub const Z_MEM441 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cbb9));

        /// memory that stores Z
        pub const Z_MEM442 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cbba));

        /// memory that stores Z
        pub const Z_MEM443 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cbbb));

        /// memory that stores Z
        pub const Z_MEM444 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cbbc));

        /// memory that stores Z
        pub const Z_MEM445 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cbbd));

        /// memory that stores Z
        pub const Z_MEM446 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cbbe));

        /// memory that stores Z
        pub const Z_MEM447 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cbbf));

        /// memory that stores Z
        pub const Z_MEM448 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cbc0));

        /// memory that stores Z
        pub const Z_MEM449 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cbc1));

        /// memory that stores Z
        pub const Z_MEM450 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cbc2));

        /// memory that stores Z
        pub const Z_MEM451 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cbc3));

        /// memory that stores Z
        pub const Z_MEM452 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cbc4));

        /// memory that stores Z
        pub const Z_MEM453 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cbc5));

        /// memory that stores Z
        pub const Z_MEM454 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cbc6));

        /// memory that stores Z
        pub const Z_MEM455 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cbc7));

        /// memory that stores Z
        pub const Z_MEM456 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cbc8));

        /// memory that stores Z
        pub const Z_MEM457 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cbc9));

        /// memory that stores Z
        pub const Z_MEM458 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cbca));

        /// memory that stores Z
        pub const Z_MEM459 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cbcb));

        /// memory that stores Z
        pub const Z_MEM460 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cbcc));

        /// memory that stores Z
        pub const Z_MEM461 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cbcd));

        /// memory that stores Z
        pub const Z_MEM462 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cbce));

        /// memory that stores Z
        pub const Z_MEM463 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cbcf));

        /// memory that stores Z
        pub const Z_MEM464 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cbd0));

        /// memory that stores Z
        pub const Z_MEM465 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cbd1));

        /// memory that stores Z
        pub const Z_MEM466 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cbd2));

        /// memory that stores Z
        pub const Z_MEM467 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cbd3));

        /// memory that stores Z
        pub const Z_MEM468 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cbd4));

        /// memory that stores Z
        pub const Z_MEM469 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cbd5));

        /// memory that stores Z
        pub const Z_MEM470 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cbd6));

        /// memory that stores Z
        pub const Z_MEM471 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cbd7));

        /// memory that stores Z
        pub const Z_MEM472 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cbd8));

        /// memory that stores Z
        pub const Z_MEM473 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cbd9));

        /// memory that stores Z
        pub const Z_MEM474 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cbda));

        /// memory that stores Z
        pub const Z_MEM475 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cbdb));

        /// memory that stores Z
        pub const Z_MEM476 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cbdc));

        /// memory that stores Z
        pub const Z_MEM477 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cbdd));

        /// memory that stores Z
        pub const Z_MEM478 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cbde));

        /// memory that stores Z
        pub const Z_MEM479 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cbdf));

        /// memory that stores Z
        pub const Z_MEM480 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cbe0));

        /// memory that stores Z
        pub const Z_MEM481 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cbe1));

        /// memory that stores Z
        pub const Z_MEM482 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cbe2));

        /// memory that stores Z
        pub const Z_MEM483 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cbe3));

        /// memory that stores Z
        pub const Z_MEM484 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cbe4));

        /// memory that stores Z
        pub const Z_MEM485 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cbe5));

        /// memory that stores Z
        pub const Z_MEM486 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cbe6));

        /// memory that stores Z
        pub const Z_MEM487 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cbe7));

        /// memory that stores Z
        pub const Z_MEM488 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cbe8));

        /// memory that stores Z
        pub const Z_MEM489 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cbe9));

        /// memory that stores Z
        pub const Z_MEM490 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cbea));

        /// memory that stores Z
        pub const Z_MEM491 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cbeb));

        /// memory that stores Z
        pub const Z_MEM492 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cbec));

        /// memory that stores Z
        pub const Z_MEM493 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cbed));

        /// memory that stores Z
        pub const Z_MEM494 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cbee));

        /// memory that stores Z
        pub const Z_MEM495 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cbef));

        /// memory that stores Z
        pub const Z_MEM496 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cbf0));

        /// memory that stores Z
        pub const Z_MEM497 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cbf1));

        /// memory that stores Z
        pub const Z_MEM498 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cbf2));

        /// memory that stores Z
        pub const Z_MEM499 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cbf3));

        /// memory that stores Z
        pub const Z_MEM500 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cbf4));

        /// memory that stores Z
        pub const Z_MEM501 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cbf5));

        /// memory that stores Z
        pub const Z_MEM502 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cbf6));

        /// memory that stores Z
        pub const Z_MEM503 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cbf7));

        /// memory that stores Z
        pub const Z_MEM504 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cbf8));

        /// memory that stores Z
        pub const Z_MEM505 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cbf9));

        /// memory that stores Z
        pub const Z_MEM506 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cbfa));

        /// memory that stores Z
        pub const Z_MEM507 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cbfb));

        /// memory that stores Z
        pub const Z_MEM508 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cbfc));

        /// memory that stores Z
        pub const Z_MEM509 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cbfd));

        /// memory that stores Z
        pub const Z_MEM510 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cbfe));

        /// memory that stores Z
        pub const Z_MEM511 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008cbff));

        /// DS start control register
        pub const SET_START = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] set this bit to start DS operation.
          SET_START: u1,

          /// [1:31] 
          res0: u31,

        }), @ptrFromInt(0x6008ce00));

        /// DS continue control register
        pub const SET_CONTINUE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] set this bit to continue DS operation.
          SET_CONTINUE: u1,

          /// [1:31] 
          res0: u31,

        }), @ptrFromInt(0x6008ce04));

        /// DS finish control register
        pub const SET_FINISH = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Set this bit to finish DS process.
          SET_FINISH: u1,

          /// [1:31] 
          res0: u31,

        }), @ptrFromInt(0x6008ce08));

        /// DS query busy register
        pub const QUERY_BUSY = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] digital signature state. 1'b0: idle, 1'b1: busy
          QUERY_BUSY: u1,

          /// [1:31] 
          res0: u31,

        }), @ptrFromInt(0x6008ce0c));

        /// DS query key-wrong counter register
        pub const QUERY_KEY_WRONG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:3] digital signature key wrong counter
          QUERY_KEY_WRONG: u4,

          /// [4:31] 
          res0: u28,

        }), @ptrFromInt(0x6008ce10));

        /// DS query check result register
        pub const QUERY_CHECK = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] MD checkout result. 1'b0: MD check pass, 1'b1: MD check fail
          MD_ERROR: u1,

          /// [1:1] padding checkout result. 1'b0: a good padding, 1'b1: a bad padding
          PADDING_BAD: u1,

          /// [2:31] 
          res0: u30,

        }), @ptrFromInt(0x6008ce14));

        /// DS version control register
        pub const DATE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:29] ds version information
          DATE: u30,

          /// [30:31] 
          res0: u2,

        }), @ptrFromInt(0x6008ce20));

      };

      /// ECC (ECC Hardware Accelerator)
      pub const ECC = struct {

        /// ECC interrupt raw register, valid in level.
        pub const MULT_INT_RAW = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] The raw interrupt status bitfor the ecc_calc_done_int interrupt
          CALC_DONE_INT_RAW: u1,

          /// [1:31] 
          res0: u31,

        }), @ptrFromInt(0x6008b00c));

        /// ECC interrupt status register.
        pub const MULT_INT_ST = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] The masked interrupt status bitfor the ecc_calc_done_int interrupt
          CALC_DONE_INT_ST: u1,

          /// [1:31] 
          res0: u31,

        }), @ptrFromInt(0x6008b010));

        /// ECC interrupt enable register.
        pub const MULT_INT_ENA = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] The interrupt enable bitfor the ecc_calc_done_int interrupt
          CALC_DONE_INT_ENA: u1,

          /// [1:31] 
          res0: u31,

        }), @ptrFromInt(0x6008b014));

        /// ECC interrupt clear register.
        pub const MULT_INT_CLR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Set this bit to clear the ecc_calc_done_int interrupt
          CALC_DONE_INT_CLR: u1,

          /// [1:31] 
          res0: u31,

        }), @ptrFromInt(0x6008b018));

        /// ECC configure register
        pub const MULT_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Write 1 to start caculation of ECC Accelerator. This bit will be self-cleared after the caculatrion is done.
          START: u1,

          /// [1:1] Write 1 to reset ECC Accelerator.
          RESET: u1,

          /// [2:2] The key length mode bit of ECC Accelerator.0: P-192.1: P-256.
          KEY_LENGTH: u1,

          /// [3:3] Reserved
          SECURITY_MODE: u1,

          /// [4:4] Write 1 to force on register clock gate.
          CLK_EN: u1,

          /// [5:7] The work mode bits of ECC Accelerator. 0: Point Mult Mode. 1: Division mode. 2: Point verification mode. 3: Point Verif+mult mode. 4: Jacobian Point Mult Mode. 5: Reserved. 6: Jacobian Point Verification Mode. 7: Point Verif + Jacobian Mult Mode.
          WORK_MODE: u3,

          /// [8:8] The verification result bit of ECC Accelerator, only valid when calculation is done.
          VERIFICATION_RESULT: u1,

          /// [9:30] 
          res0: u22,

          /// [31:31] ECC memory clock gate force on register
          MEM_CLOCK_GATE_FORCE_ON: u1,

        }), @ptrFromInt(0x6008b01c));

        /// Version control register
        pub const MULT_DATE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:27] ECC mult version control register
          DATE: u28,

          /// [28:31] 
          res0: u4,

        }), @ptrFromInt(0x6008b0fc));

        /// The memory that stores k.
        pub const K_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008b100));

        /// The memory that stores k.
        pub const K_MEM1 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008b101));

        /// The memory that stores k.
        pub const K_MEM2 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008b102));

        /// The memory that stores k.
        pub const K_MEM3 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008b103));

        /// The memory that stores k.
        pub const K_MEM4 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008b104));

        /// The memory that stores k.
        pub const K_MEM5 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008b105));

        /// The memory that stores k.
        pub const K_MEM6 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008b106));

        /// The memory that stores k.
        pub const K_MEM7 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008b107));

        /// The memory that stores k.
        pub const K_MEM8 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008b108));

        /// The memory that stores k.
        pub const K_MEM9 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008b109));

        /// The memory that stores k.
        pub const K_MEM10 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008b10a));

        /// The memory that stores k.
        pub const K_MEM11 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008b10b));

        /// The memory that stores k.
        pub const K_MEM12 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008b10c));

        /// The memory that stores k.
        pub const K_MEM13 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008b10d));

        /// The memory that stores k.
        pub const K_MEM14 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008b10e));

        /// The memory that stores k.
        pub const K_MEM15 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008b10f));

        /// The memory that stores k.
        pub const K_MEM16 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008b110));

        /// The memory that stores k.
        pub const K_MEM17 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008b111));

        /// The memory that stores k.
        pub const K_MEM18 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008b112));

        /// The memory that stores k.
        pub const K_MEM19 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008b113));

        /// The memory that stores k.
        pub const K_MEM20 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008b114));

        /// The memory that stores k.
        pub const K_MEM21 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008b115));

        /// The memory that stores k.
        pub const K_MEM22 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008b116));

        /// The memory that stores k.
        pub const K_MEM23 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008b117));

        /// The memory that stores k.
        pub const K_MEM24 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008b118));

        /// The memory that stores k.
        pub const K_MEM25 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008b119));

        /// The memory that stores k.
        pub const K_MEM26 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008b11a));

        /// The memory that stores k.
        pub const K_MEM27 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008b11b));

        /// The memory that stores k.
        pub const K_MEM28 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008b11c));

        /// The memory that stores k.
        pub const K_MEM29 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008b11d));

        /// The memory that stores k.
        pub const K_MEM30 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008b11e));

        /// The memory that stores k.
        pub const K_MEM31 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008b11f));

        /// The memory that stores Px.
        pub const PX_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008b120));

        /// The memory that stores Px.
        pub const PX_MEM1 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008b121));

        /// The memory that stores Px.
        pub const PX_MEM2 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008b122));

        /// The memory that stores Px.
        pub const PX_MEM3 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008b123));

        /// The memory that stores Px.
        pub const PX_MEM4 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008b124));

        /// The memory that stores Px.
        pub const PX_MEM5 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008b125));

        /// The memory that stores Px.
        pub const PX_MEM6 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008b126));

        /// The memory that stores Px.
        pub const PX_MEM7 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008b127));

        /// The memory that stores Px.
        pub const PX_MEM8 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008b128));

        /// The memory that stores Px.
        pub const PX_MEM9 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008b129));

        /// The memory that stores Px.
        pub const PX_MEM10 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008b12a));

        /// The memory that stores Px.
        pub const PX_MEM11 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008b12b));

        /// The memory that stores Px.
        pub const PX_MEM12 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008b12c));

        /// The memory that stores Px.
        pub const PX_MEM13 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008b12d));

        /// The memory that stores Px.
        pub const PX_MEM14 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008b12e));

        /// The memory that stores Px.
        pub const PX_MEM15 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008b12f));

        /// The memory that stores Px.
        pub const PX_MEM16 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008b130));

        /// The memory that stores Px.
        pub const PX_MEM17 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008b131));

        /// The memory that stores Px.
        pub const PX_MEM18 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008b132));

        /// The memory that stores Px.
        pub const PX_MEM19 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008b133));

        /// The memory that stores Px.
        pub const PX_MEM20 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008b134));

        /// The memory that stores Px.
        pub const PX_MEM21 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008b135));

        /// The memory that stores Px.
        pub const PX_MEM22 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008b136));

        /// The memory that stores Px.
        pub const PX_MEM23 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008b137));

        /// The memory that stores Px.
        pub const PX_MEM24 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008b138));

        /// The memory that stores Px.
        pub const PX_MEM25 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008b139));

        /// The memory that stores Px.
        pub const PX_MEM26 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008b13a));

        /// The memory that stores Px.
        pub const PX_MEM27 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008b13b));

        /// The memory that stores Px.
        pub const PX_MEM28 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008b13c));

        /// The memory that stores Px.
        pub const PX_MEM29 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008b13d));

        /// The memory that stores Px.
        pub const PX_MEM30 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008b13e));

        /// The memory that stores Px.
        pub const PX_MEM31 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008b13f));

        /// The memory that stores Py.
        pub const PY_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008b140));

        /// The memory that stores Py.
        pub const PY_MEM1 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008b141));

        /// The memory that stores Py.
        pub const PY_MEM2 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008b142));

        /// The memory that stores Py.
        pub const PY_MEM3 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008b143));

        /// The memory that stores Py.
        pub const PY_MEM4 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008b144));

        /// The memory that stores Py.
        pub const PY_MEM5 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008b145));

        /// The memory that stores Py.
        pub const PY_MEM6 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008b146));

        /// The memory that stores Py.
        pub const PY_MEM7 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008b147));

        /// The memory that stores Py.
        pub const PY_MEM8 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008b148));

        /// The memory that stores Py.
        pub const PY_MEM9 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008b149));

        /// The memory that stores Py.
        pub const PY_MEM10 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008b14a));

        /// The memory that stores Py.
        pub const PY_MEM11 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008b14b));

        /// The memory that stores Py.
        pub const PY_MEM12 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008b14c));

        /// The memory that stores Py.
        pub const PY_MEM13 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008b14d));

        /// The memory that stores Py.
        pub const PY_MEM14 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008b14e));

        /// The memory that stores Py.
        pub const PY_MEM15 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008b14f));

        /// The memory that stores Py.
        pub const PY_MEM16 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008b150));

        /// The memory that stores Py.
        pub const PY_MEM17 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008b151));

        /// The memory that stores Py.
        pub const PY_MEM18 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008b152));

        /// The memory that stores Py.
        pub const PY_MEM19 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008b153));

        /// The memory that stores Py.
        pub const PY_MEM20 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008b154));

        /// The memory that stores Py.
        pub const PY_MEM21 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008b155));

        /// The memory that stores Py.
        pub const PY_MEM22 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008b156));

        /// The memory that stores Py.
        pub const PY_MEM23 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008b157));

        /// The memory that stores Py.
        pub const PY_MEM24 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008b158));

        /// The memory that stores Py.
        pub const PY_MEM25 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008b159));

        /// The memory that stores Py.
        pub const PY_MEM26 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008b15a));

        /// The memory that stores Py.
        pub const PY_MEM27 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008b15b));

        /// The memory that stores Py.
        pub const PY_MEM28 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008b15c));

        /// The memory that stores Py.
        pub const PY_MEM29 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008b15d));

        /// The memory that stores Py.
        pub const PY_MEM30 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008b15e));

        /// The memory that stores Py.
        pub const PY_MEM31 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008b15f));

      };

      /// eFuse Controller
      pub const EFUSE = struct {

        /// Register 0 that stores data to be programmed.
        pub const PGM_DATA0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Configures the 0th 32-bit data to be programmed.
          PGM_DATA_0: u32,

        }), @ptrFromInt(0x600b0800));

        /// Register 1 that stores data to be programmed.
        pub const PGM_DATA1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Configures the 1st 32-bit data to be programmed.
          PGM_DATA_1: u32,

        }), @ptrFromInt(0x600b0804));

        /// Register 2 that stores data to be programmed.
        pub const PGM_DATA2 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Configures the 2nd 32-bit data to be programmed.
          PGM_DATA_2: u32,

        }), @ptrFromInt(0x600b0808));

        /// Register 3 that stores data to be programmed.
        pub const PGM_DATA3 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Configures the 3rd 32-bit data to be programmed.
          PGM_DATA_3: u32,

        }), @ptrFromInt(0x600b080c));

        /// Register 4 that stores data to be programmed.
        pub const PGM_DATA4 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Configures the 4th 32-bit data to be programmed.
          PGM_DATA_4: u32,

        }), @ptrFromInt(0x600b0810));

        /// Register 5 that stores data to be programmed.
        pub const PGM_DATA5 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Configures the 5th 32-bit data to be programmed.
          PGM_DATA_5: u32,

        }), @ptrFromInt(0x600b0814));

        /// Register 6 that stores data to be programmed.
        pub const PGM_DATA6 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Configures the 6th 32-bit data to be programmed.
          PGM_DATA_6: u32,

        }), @ptrFromInt(0x600b0818));

        /// Register 7 that stores data to be programmed.
        pub const PGM_DATA7 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Configures the 7th 32-bit data to be programmed.
          PGM_DATA_7: u32,

        }), @ptrFromInt(0x600b081c));

        /// Register 0 that stores the RS code to be programmed.
        pub const PGM_CHECK_VALUE0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Configures the 0th 32-bit RS code to be programmed.
          PGM_RS_DATA_0: u32,

        }), @ptrFromInt(0x600b0820));

        /// Register 1 that stores the RS code to be programmed.
        pub const PGM_CHECK_VALUE1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Configures the 1st 32-bit RS code to be programmed.
          PGM_RS_DATA_1: u32,

        }), @ptrFromInt(0x600b0824));

        /// Register 2 that stores the RS code to be programmed.
        pub const PGM_CHECK_VALUE2 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Configures the 2nd 32-bit RS code to be programmed.
          PGM_RS_DATA_2: u32,

        }), @ptrFromInt(0x600b0828));

        /// BLOCK0 data register 0.
        pub const RD_WR_DIS = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Represents whether programming of individual eFuse memory bit is disabled or enabled. 1: Disabled. 0 Enabled.
          WR_DIS: u32,

        }), @ptrFromInt(0x600b082c));

        /// BLOCK0 data register 1.
        pub const RD_REPEAT_DATA0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:6] Represents whether reading of individual eFuse block(block4~block10) is disabled or enabled. 1: disabled. 0: enabled.
          RD_DIS: u7,

          /// [7:7] Represents whether pad of uart and sdio is swapped or not. 1: swapped. 0: not swapped.
          SWAP_UART_SDIO_EN: u1,

          /// [8:8] Represents whether icache is disabled or enabled. 1: disabled. 0: enabled.
          DIS_ICACHE: u1,

          /// [9:9] Represents whether the function of usb switch to jtag is disabled or enabled. 1: disabled. 0: enabled.
          DIS_USB_JTAG: u1,

          /// [10:10] Represents whether icache is disabled or enabled in Download mode. 1: disabled. 0: enabled.
          DIS_DOWNLOAD_ICACHE: u1,

          /// [11:11] Represents whether USB-Serial-JTAG is disabled or enabled. 1: disabled. 0: enabled.
          DIS_USB_SERIAL_JTAG: u1,

          /// [12:12] Represents whether the function that forces chip into download mode is disabled or enabled. 1: disabled. 0: enabled.
          DIS_FORCE_DOWNLOAD: u1,

          /// [13:13] Represents whether SPI0 controller during boot_mode_download is disabled or enabled. 1: disabled. 0: enabled.
          SPI_DOWNLOAD_MSPI_DIS: u1,

          /// [14:14] Represents whether TWAI function is disabled or enabled. 1: disabled. 0: enabled.
          DIS_CAN: u1,

          /// [15:15] Represents whether the selection between usb_to_jtag and pad_to_jtag through strapping gpio15 when both EFUSE_DIS_PAD_JTAG and EFUSE_DIS_USB_JTAG are equal to 0 is enabled or disabled. 1: enabled. 0: disabled.
          JTAG_SEL_ENABLE: u1,

          /// [16:18] Represents whether JTAG is disabled in soft way. Odd number: disabled. Even number: enabled.
          SOFT_DIS_JTAG: u3,

          /// [19:19] Represents whether JTAG is disabled in the hard way(permanently). 1: disabled. 0: enabled.
          DIS_PAD_JTAG: u1,

          /// [20:20] Represents whether flash encrypt function is disabled or enabled(except in SPI boot mode). 1: disabled. 0: enabled.
          DIS_DOWNLOAD_MANUAL_ENCRYPT: u1,

          /// [21:22] Represents the single-end input threhold vrefh, 1.76 V to 2 V with step of 80 mV.
          USB_DREFH: u2,

          /// [23:24] Represents the single-end input threhold vrefl, 1.76 V to 2 V with step of 80 mV.
          USB_DREFL: u2,

          /// [25:25] Represents whether the D+ and D- pins is exchanged. 1: exchanged. 0: not exchanged.
          USB_EXCHG_PINS: u1,

          /// [26:26] Represents whether vdd spi pin is functioned as gpio. 1: functioned. 0: not functioned.
          VDD_SPI_AS_GPIO: u1,

          /// [27:28] Reserved.
          RPT4_RESERVED0_2: u2,

          /// [29:29] Reserved.
          RPT4_RESERVED0_1: u1,

          /// [30:31] Reserved.
          RPT4_RESERVED0_0: u2,

        }), @ptrFromInt(0x600b0830));

        /// BLOCK0 data register 2.
        pub const RD_REPEAT_DATA1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:15] Reserved.
          RPT4_RESERVED1_0: u16,

          /// [16:17] Represents whether RTC watchdog timeout threshold is selected at startup. 1: selected. 0: not selected.
          WDT_DELAY_SEL: u2,

          /// [18:20] Represents whether SPI boot encrypt/decrypt is disabled or enabled. Odd number of 1: enabled. Even number of 1: disabled.
          SPI_BOOT_CRYPT_CNT: u3,

          /// [21:21] Represents whether revoking first secure boot key is enabled or disabled. 1: enabled. 0: disabled.
          SECURE_BOOT_KEY_REVOKE0: u1,

          /// [22:22] Represents whether revoking second secure boot key is enabled or disabled. 1: enabled. 0: disabled.
          SECURE_BOOT_KEY_REVOKE1: u1,

          /// [23:23] Represents whether revoking third secure boot key is enabled or disabled. 1: enabled. 0: disabled.
          SECURE_BOOT_KEY_REVOKE2: u1,

          /// [24:27] Represents the purpose of Key0.
          KEY_PURPOSE_0: u4,

          /// [28:31] Represents the purpose of Key1.
          KEY_PURPOSE_1: u4,

        }), @ptrFromInt(0x600b0834));

        /// BLOCK0 data register 3.
        pub const RD_REPEAT_DATA2 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:3] Represents the purpose of Key2.
          KEY_PURPOSE_2: u4,

          /// [4:7] Represents the purpose of Key3.
          KEY_PURPOSE_3: u4,

          /// [8:11] Represents the purpose of Key4.
          KEY_PURPOSE_4: u4,

          /// [12:15] Represents the purpose of Key5.
          KEY_PURPOSE_5: u4,

          /// [16:17] Represents the spa secure level by configuring the clock random divide mode.
          DPA_SEC_LEVEL: u2,

          /// [18:18] Reserved.
          RPT4_RESERVED2_1: u1,

          /// [19:19] Represents whether anti-dpa attack is enabled. 1:enabled. 0: disabled.
          CRYPT_DPA_ENABLE: u1,

          /// [20:20] Represents whether secure boot is enabled or disabled. 1: enabled. 0: disabled.
          SECURE_BOOT_EN: u1,

          /// [21:21] Represents whether revoking aggressive secure boot is enabled or disabled. 1: enabled. 0: disabled.
          SECURE_BOOT_AGGRESSIVE_REVOKE: u1,

          /// [22:27] Reserved.
          RPT4_RESERVED2_0: u6,

          /// [28:31] Represents the flash waiting time after power-up, in unit of ms. When the value less than 15, the waiting time is the programmed value. Otherwise, the waiting time is 2 times the programmed value.
          FLASH_TPUW: u4,

        }), @ptrFromInt(0x600b0838));

        /// BLOCK0 data register 4.
        pub const RD_REPEAT_DATA3 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Represents whether Download mode is disabled or enabled. 1: disabled. 0: enabled.
          DIS_DOWNLOAD_MODE: u1,

          /// [1:1] Represents whether direct boot mode is disabled or enabled. 1: disabled. 0: enabled.
          DIS_DIRECT_BOOT: u1,

          /// [2:2] Represents whether print from USB-Serial-JTAG is disabled or enabled. 1: disabled. 0: enabled.
          DIS_USB_PRINT: u1,

          /// [3:3] Reserved.
          RPT4_RESERVED3_5: u1,

          /// [4:4] Represents whether the USB-Serial-JTAG download function is disabled or enabled. 1: disabled. 0: enabled.
          DIS_USB_SERIAL_JTAG_DOWNLOAD_MODE: u1,

          /// [5:5] Represents whether security download is enabled or disabled. 1: enabled. 0: disabled.
          ENABLE_SECURITY_DOWNLOAD: u1,

          /// [6:7] Represents the type of UART printing. 00: force enable printing. 01: enable printing when GPIO8 is reset at low level. 10: enable printing when GPIO8 is reset at high level. 11: force disable printing.
          UART_PRINT_CONTROL: u2,

          /// [8:8] Reserved.
          RPT4_RESERVED3_4: u1,

          /// [9:9] Reserved.
          RPT4_RESERVED3_3: u1,

          /// [10:11] Reserved.
          RPT4_RESERVED3_2: u2,

          /// [12:12] Reserved.
          RPT4_RESERVED3_1: u1,

          /// [13:13] Represents whether ROM code is forced to send a resume command during SPI boot. 1: forced. 0:not forced.
          FORCE_SEND_RESUME: u1,

          /// [14:29] Represents the version used by ESP-IDF anti-rollback feature.
          SECURE_VERSION: u16,

          /// [30:30] Represents whether FAST VERIFY ON WAKE is disabled or enabled when Secure Boot is enabled. 1: disabled. 0: enabled.
          SECURE_BOOT_DISABLE_FAST_WAKE: u1,

          /// [31:31] Reserved.
          RPT4_RESERVED3_0: u1,

        }), @ptrFromInt(0x600b083c));

        /// BLOCK0 data register 5.
        pub const RD_REPEAT_DATA4 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:23] Reserved.
          RPT4_RESERVED4_1: u24,

          /// [24:31] Reserved.
          RPT4_RESERVED4_0: u8,

        }), @ptrFromInt(0x600b0840));

        /// BLOCK1 data register $n.
        pub const RD_MAC_SPI_SYS_0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Stores the low 32 bits of MAC address.
          MAC_0: u32,

        }), @ptrFromInt(0x600b0844));

        /// BLOCK1 data register $n.
        pub const RD_MAC_SPI_SYS_1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:15] Stores the high 16 bits of MAC address.
          MAC_1: u16,

          /// [16:31] Stores the extended bits of MAC address.
          MAC_EXT: u16,

        }), @ptrFromInt(0x600b0848));

        /// BLOCK1 data register $n.
        pub const RD_MAC_SPI_SYS_2 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:13] Reserved.
          MAC_SPI_RESERVED: u14,

          /// [14:31] Stores the first part of SPI_PAD_CONF.
          SPI_PAD_CONF_1: u18,

        }), @ptrFromInt(0x600b084c));

        /// BLOCK1 data register $n.
        pub const RD_MAC_SPI_SYS_3 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:17] Stores the second part of SPI_PAD_CONF.
          SPI_PAD_CONF_2: u18,

          /// [18:31] Stores the first 14 bits of the zeroth part of system data.
          SYS_DATA_PART0_0: u14,

        }), @ptrFromInt(0x600b0850));

        /// BLOCK1 data register $n.
        pub const RD_MAC_SPI_SYS_4 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Stores the first 32 bits of the zeroth part of system data.
          SYS_DATA_PART0_1: u32,

        }), @ptrFromInt(0x600b0854));

        /// BLOCK1 data register $n.
        pub const RD_MAC_SPI_SYS_5 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Stores the second 32 bits of the zeroth part of system data.
          SYS_DATA_PART0_2: u32,

        }), @ptrFromInt(0x600b0858));

        /// Register $n of BLOCK2 (system).
        pub const RD_SYS_PART1_DATA0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Stores the zeroth 32 bits of the first part of system data.
          SYS_DATA_PART1_0: u32,

        }), @ptrFromInt(0x600b085c));

        /// Register $n of BLOCK2 (system).
        pub const RD_SYS_PART1_DATA1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Stores the first 32 bits of the first part of system data.
          SYS_DATA_PART1_1: u32,

        }), @ptrFromInt(0x600b0860));

        /// Register $n of BLOCK2 (system).
        pub const RD_SYS_PART1_DATA2 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Stores the second 32 bits of the first part of system data.
          SYS_DATA_PART1_2: u32,

        }), @ptrFromInt(0x600b0864));

        /// Register $n of BLOCK2 (system).
        pub const RD_SYS_PART1_DATA3 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Stores the third 32 bits of the first part of system data.
          SYS_DATA_PART1_3: u32,

        }), @ptrFromInt(0x600b0868));

        /// Register $n of BLOCK2 (system).
        pub const RD_SYS_PART1_DATA4 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Stores the fourth 32 bits of the first part of system data.
          SYS_DATA_PART1_4: u32,

        }), @ptrFromInt(0x600b086c));

        /// Register $n of BLOCK2 (system).
        pub const RD_SYS_PART1_DATA5 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Stores the fifth 32 bits of the first part of system data.
          SYS_DATA_PART1_5: u32,

        }), @ptrFromInt(0x600b0870));

        /// Register $n of BLOCK2 (system).
        pub const RD_SYS_PART1_DATA6 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Stores the sixth 32 bits of the first part of system data.
          SYS_DATA_PART1_6: u32,

        }), @ptrFromInt(0x600b0874));

        /// Register $n of BLOCK2 (system).
        pub const RD_SYS_PART1_DATA7 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Stores the seventh 32 bits of the first part of system data.
          SYS_DATA_PART1_7: u32,

        }), @ptrFromInt(0x600b0878));

        /// Register $n of BLOCK3 (user).
        pub const RD_USR_DATA0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Stores the zeroth 32 bits of BLOCK3 (user).
          USR_DATA0: u32,

        }), @ptrFromInt(0x600b087c));

        /// Register $n of BLOCK3 (user).
        pub const RD_USR_DATA1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Stores the first 32 bits of BLOCK3 (user).
          USR_DATA1: u32,

        }), @ptrFromInt(0x600b0880));

        /// Register $n of BLOCK3 (user).
        pub const RD_USR_DATA2 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Stores the second 32 bits of BLOCK3 (user).
          USR_DATA2: u32,

        }), @ptrFromInt(0x600b0884));

        /// Register $n of BLOCK3 (user).
        pub const RD_USR_DATA3 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Stores the third 32 bits of BLOCK3 (user).
          USR_DATA3: u32,

        }), @ptrFromInt(0x600b0888));

        /// Register $n of BLOCK3 (user).
        pub const RD_USR_DATA4 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Stores the fourth 32 bits of BLOCK3 (user).
          USR_DATA4: u32,

        }), @ptrFromInt(0x600b088c));

        /// Register $n of BLOCK3 (user).
        pub const RD_USR_DATA5 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Stores the fifth 32 bits of BLOCK3 (user).
          USR_DATA5: u32,

        }), @ptrFromInt(0x600b0890));

        /// Register $n of BLOCK3 (user).
        pub const RD_USR_DATA6 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Stores the sixth 32 bits of BLOCK3 (user).
          USR_DATA6: u32,

        }), @ptrFromInt(0x600b0894));

        /// Register $n of BLOCK3 (user).
        pub const RD_USR_DATA7 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Stores the seventh 32 bits of BLOCK3 (user).
          USR_DATA7: u32,

        }), @ptrFromInt(0x600b0898));

        /// Register $n of BLOCK4 (KEY0).
        pub const RD_KEY0_DATA0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Stores the zeroth 32 bits of KEY0.
          KEY0_DATA0: u32,

        }), @ptrFromInt(0x600b089c));

        /// Register $n of BLOCK4 (KEY0).
        pub const RD_KEY0_DATA1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Stores the first 32 bits of KEY0.
          KEY0_DATA1: u32,

        }), @ptrFromInt(0x600b08a0));

        /// Register $n of BLOCK4 (KEY0).
        pub const RD_KEY0_DATA2 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Stores the second 32 bits of KEY0.
          KEY0_DATA2: u32,

        }), @ptrFromInt(0x600b08a4));

        /// Register $n of BLOCK4 (KEY0).
        pub const RD_KEY0_DATA3 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Stores the third 32 bits of KEY0.
          KEY0_DATA3: u32,

        }), @ptrFromInt(0x600b08a8));

        /// Register $n of BLOCK4 (KEY0).
        pub const RD_KEY0_DATA4 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Stores the fourth 32 bits of KEY0.
          KEY0_DATA4: u32,

        }), @ptrFromInt(0x600b08ac));

        /// Register $n of BLOCK4 (KEY0).
        pub const RD_KEY0_DATA5 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Stores the fifth 32 bits of KEY0.
          KEY0_DATA5: u32,

        }), @ptrFromInt(0x600b08b0));

        /// Register $n of BLOCK4 (KEY0).
        pub const RD_KEY0_DATA6 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Stores the sixth 32 bits of KEY0.
          KEY0_DATA6: u32,

        }), @ptrFromInt(0x600b08b4));

        /// Register $n of BLOCK4 (KEY0).
        pub const RD_KEY0_DATA7 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Stores the seventh 32 bits of KEY0.
          KEY0_DATA7: u32,

        }), @ptrFromInt(0x600b08b8));

        /// Register $n of BLOCK5 (KEY1).
        pub const RD_KEY1_DATA0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Stores the zeroth 32 bits of KEY1.
          KEY1_DATA0: u32,

        }), @ptrFromInt(0x600b08bc));

        /// Register $n of BLOCK5 (KEY1).
        pub const RD_KEY1_DATA1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Stores the first 32 bits of KEY1.
          KEY1_DATA1: u32,

        }), @ptrFromInt(0x600b08c0));

        /// Register $n of BLOCK5 (KEY1).
        pub const RD_KEY1_DATA2 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Stores the second 32 bits of KEY1.
          KEY1_DATA2: u32,

        }), @ptrFromInt(0x600b08c4));

        /// Register $n of BLOCK5 (KEY1).
        pub const RD_KEY1_DATA3 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Stores the third 32 bits of KEY1.
          KEY1_DATA3: u32,

        }), @ptrFromInt(0x600b08c8));

        /// Register $n of BLOCK5 (KEY1).
        pub const RD_KEY1_DATA4 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Stores the fourth 32 bits of KEY1.
          KEY1_DATA4: u32,

        }), @ptrFromInt(0x600b08cc));

        /// Register $n of BLOCK5 (KEY1).
        pub const RD_KEY1_DATA5 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Stores the fifth 32 bits of KEY1.
          KEY1_DATA5: u32,

        }), @ptrFromInt(0x600b08d0));

        /// Register $n of BLOCK5 (KEY1).
        pub const RD_KEY1_DATA6 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Stores the sixth 32 bits of KEY1.
          KEY1_DATA6: u32,

        }), @ptrFromInt(0x600b08d4));

        /// Register $n of BLOCK5 (KEY1).
        pub const RD_KEY1_DATA7 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Stores the seventh 32 bits of KEY1.
          KEY1_DATA7: u32,

        }), @ptrFromInt(0x600b08d8));

        /// Register $n of BLOCK6 (KEY2).
        pub const RD_KEY2_DATA0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Stores the zeroth 32 bits of KEY2.
          KEY2_DATA0: u32,

        }), @ptrFromInt(0x600b08dc));

        /// Register $n of BLOCK6 (KEY2).
        pub const RD_KEY2_DATA1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Stores the first 32 bits of KEY2.
          KEY2_DATA1: u32,

        }), @ptrFromInt(0x600b08e0));

        /// Register $n of BLOCK6 (KEY2).
        pub const RD_KEY2_DATA2 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Stores the second 32 bits of KEY2.
          KEY2_DATA2: u32,

        }), @ptrFromInt(0x600b08e4));

        /// Register $n of BLOCK6 (KEY2).
        pub const RD_KEY2_DATA3 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Stores the third 32 bits of KEY2.
          KEY2_DATA3: u32,

        }), @ptrFromInt(0x600b08e8));

        /// Register $n of BLOCK6 (KEY2).
        pub const RD_KEY2_DATA4 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Stores the fourth 32 bits of KEY2.
          KEY2_DATA4: u32,

        }), @ptrFromInt(0x600b08ec));

        /// Register $n of BLOCK6 (KEY2).
        pub const RD_KEY2_DATA5 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Stores the fifth 32 bits of KEY2.
          KEY2_DATA5: u32,

        }), @ptrFromInt(0x600b08f0));

        /// Register $n of BLOCK6 (KEY2).
        pub const RD_KEY2_DATA6 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Stores the sixth 32 bits of KEY2.
          KEY2_DATA6: u32,

        }), @ptrFromInt(0x600b08f4));

        /// Register $n of BLOCK6 (KEY2).
        pub const RD_KEY2_DATA7 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Stores the seventh 32 bits of KEY2.
          KEY2_DATA7: u32,

        }), @ptrFromInt(0x600b08f8));

        /// Register $n of BLOCK7 (KEY3).
        pub const RD_KEY3_DATA0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Stores the zeroth 32 bits of KEY3.
          KEY3_DATA0: u32,

        }), @ptrFromInt(0x600b08fc));

        /// Register $n of BLOCK7 (KEY3).
        pub const RD_KEY3_DATA1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Stores the first 32 bits of KEY3.
          KEY3_DATA1: u32,

        }), @ptrFromInt(0x600b0900));

        /// Register $n of BLOCK7 (KEY3).
        pub const RD_KEY3_DATA2 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Stores the second 32 bits of KEY3.
          KEY3_DATA2: u32,

        }), @ptrFromInt(0x600b0904));

        /// Register $n of BLOCK7 (KEY3).
        pub const RD_KEY3_DATA3 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Stores the third 32 bits of KEY3.
          KEY3_DATA3: u32,

        }), @ptrFromInt(0x600b0908));

        /// Register $n of BLOCK7 (KEY3).
        pub const RD_KEY3_DATA4 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Stores the fourth 32 bits of KEY3.
          KEY3_DATA4: u32,

        }), @ptrFromInt(0x600b090c));

        /// Register $n of BLOCK7 (KEY3).
        pub const RD_KEY3_DATA5 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Stores the fifth 32 bits of KEY3.
          KEY3_DATA5: u32,

        }), @ptrFromInt(0x600b0910));

        /// Register $n of BLOCK7 (KEY3).
        pub const RD_KEY3_DATA6 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Stores the sixth 32 bits of KEY3.
          KEY3_DATA6: u32,

        }), @ptrFromInt(0x600b0914));

        /// Register $n of BLOCK7 (KEY3).
        pub const RD_KEY3_DATA7 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Stores the seventh 32 bits of KEY3.
          KEY3_DATA7: u32,

        }), @ptrFromInt(0x600b0918));

        /// Register $n of BLOCK8 (KEY4).
        pub const RD_KEY4_DATA0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Stores the zeroth 32 bits of KEY4.
          KEY4_DATA0: u32,

        }), @ptrFromInt(0x600b091c));

        /// Register $n of BLOCK8 (KEY4).
        pub const RD_KEY4_DATA1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Stores the first 32 bits of KEY4.
          KEY4_DATA1: u32,

        }), @ptrFromInt(0x600b0920));

        /// Register $n of BLOCK8 (KEY4).
        pub const RD_KEY4_DATA2 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Stores the second 32 bits of KEY4.
          KEY4_DATA2: u32,

        }), @ptrFromInt(0x600b0924));

        /// Register $n of BLOCK8 (KEY4).
        pub const RD_KEY4_DATA3 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Stores the third 32 bits of KEY4.
          KEY4_DATA3: u32,

        }), @ptrFromInt(0x600b0928));

        /// Register $n of BLOCK8 (KEY4).
        pub const RD_KEY4_DATA4 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Stores the fourth 32 bits of KEY4.
          KEY4_DATA4: u32,

        }), @ptrFromInt(0x600b092c));

        /// Register $n of BLOCK8 (KEY4).
        pub const RD_KEY4_DATA5 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Stores the fifth 32 bits of KEY4.
          KEY4_DATA5: u32,

        }), @ptrFromInt(0x600b0930));

        /// Register $n of BLOCK8 (KEY4).
        pub const RD_KEY4_DATA6 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Stores the sixth 32 bits of KEY4.
          KEY4_DATA6: u32,

        }), @ptrFromInt(0x600b0934));

        /// Register $n of BLOCK8 (KEY4).
        pub const RD_KEY4_DATA7 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Stores the seventh 32 bits of KEY4.
          KEY4_DATA7: u32,

        }), @ptrFromInt(0x600b0938));

        /// Register $n of BLOCK9 (KEY5).
        pub const RD_KEY5_DATA0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Stores the zeroth 32 bits of KEY5.
          KEY5_DATA0: u32,

        }), @ptrFromInt(0x600b093c));

        /// Register $n of BLOCK9 (KEY5).
        pub const RD_KEY5_DATA1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Stores the first 32 bits of KEY5.
          KEY5_DATA1: u32,

        }), @ptrFromInt(0x600b0940));

        /// Register $n of BLOCK9 (KEY5).
        pub const RD_KEY5_DATA2 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Stores the second 32 bits of KEY5.
          KEY5_DATA2: u32,

        }), @ptrFromInt(0x600b0944));

        /// Register $n of BLOCK9 (KEY5).
        pub const RD_KEY5_DATA3 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Stores the third 32 bits of KEY5.
          KEY5_DATA3: u32,

        }), @ptrFromInt(0x600b0948));

        /// Register $n of BLOCK9 (KEY5).
        pub const RD_KEY5_DATA4 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Stores the fourth 32 bits of KEY5.
          KEY5_DATA4: u32,

        }), @ptrFromInt(0x600b094c));

        /// Register $n of BLOCK9 (KEY5).
        pub const RD_KEY5_DATA5 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Stores the fifth 32 bits of KEY5.
          KEY5_DATA5: u32,

        }), @ptrFromInt(0x600b0950));

        /// Register $n of BLOCK9 (KEY5).
        pub const RD_KEY5_DATA6 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Stores the sixth 32 bits of KEY5.
          KEY5_DATA6: u32,

        }), @ptrFromInt(0x600b0954));

        /// Register $n of BLOCK9 (KEY5).
        pub const RD_KEY5_DATA7 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Stores the seventh 32 bits of KEY5.
          KEY5_DATA7: u32,

        }), @ptrFromInt(0x600b0958));

        /// Register $n of BLOCK10 (system).
        pub const RD_SYS_PART2_DATA0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Stores the 0th 32 bits of the 2nd part of system data.
          SYS_DATA_PART2_0: u32,

        }), @ptrFromInt(0x600b095c));

        /// Register $n of BLOCK9 (KEY5).
        pub const RD_SYS_PART2_DATA1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Stores the 0th 32 bits of the 2nd part of system data.
          SYS_DATA_PART2_1: u32,

        }), @ptrFromInt(0x600b0960));

        /// Register $n of BLOCK10 (system).
        pub const RD_SYS_PART2_DATA2 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Stores the 0th 32 bits of the 2nd part of system data.
          SYS_DATA_PART2_2: u32,

        }), @ptrFromInt(0x600b0964));

        /// Register $n of BLOCK10 (system).
        pub const RD_SYS_PART2_DATA3 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Stores the 0th 32 bits of the 2nd part of system data.
          SYS_DATA_PART2_3: u32,

        }), @ptrFromInt(0x600b0968));

        /// Register $n of BLOCK10 (system).
        pub const RD_SYS_PART2_DATA4 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Stores the 0th 32 bits of the 2nd part of system data.
          SYS_DATA_PART2_4: u32,

        }), @ptrFromInt(0x600b096c));

        /// Register $n of BLOCK10 (system).
        pub const RD_SYS_PART2_DATA5 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Stores the 0th 32 bits of the 2nd part of system data.
          SYS_DATA_PART2_5: u32,

        }), @ptrFromInt(0x600b0970));

        /// Register $n of BLOCK10 (system).
        pub const RD_SYS_PART2_DATA6 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Stores the 0th 32 bits of the 2nd part of system data.
          SYS_DATA_PART2_6: u32,

        }), @ptrFromInt(0x600b0974));

        /// Register $n of BLOCK10 (system).
        pub const RD_SYS_PART2_DATA7 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Stores the 0th 32 bits of the 2nd part of system data.
          SYS_DATA_PART2_7: u32,

        }), @ptrFromInt(0x600b0978));

        /// Programming error record register 0 of BLOCK0.
        pub const RD_REPEAT_ERR0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:6] Indicates a programming error of RD_DIS.
          RD_DIS_ERR: u7,

          /// [7:7] Indicates a programming error of SWAP_UART_SDIO_EN.
          SWAP_UART_SDIO_EN_ERR: u1,

          /// [8:8] Indicates a programming error of DIS_ICACHE.
          DIS_ICACHE_ERR: u1,

          /// [9:9] Indicates a programming error of DIS_USB_JTAG.
          DIS_USB_JTAG_ERR: u1,

          /// [10:10] Indicates a programming error of DIS_DOWNLOAD_ICACHE.
          DIS_DOWNLOAD_ICACHE_ERR: u1,

          /// [11:11] Indicates a programming error of DIS_USB_DEVICE.
          DIS_USB_SERIAL_JTAG_ERR: u1,

          /// [12:12] Indicates a programming error of DIS_FORCE_DOWNLOAD.
          DIS_FORCE_DOWNLOAD_ERR: u1,

          /// [13:13] Indicates a programming error of SPI_DOWNLOAD_MSPI_DIS.
          SPI_DOWNLOAD_MSPI_DIS_ERR: u1,

          /// [14:14] Indicates a programming error of DIS_CAN.
          DIS_TWAI_ERR: u1,

          /// [15:15] Indicates a programming error of JTAG_SEL_ENABLE.
          JTAG_SEL_ENABLE_ERR: u1,

          /// [16:18] Indicates a programming error of SOFT_DIS_JTAG.
          SOFT_DIS_JTAG_ERR: u3,

          /// [19:19] Indicates a programming error of DIS_PAD_JTAG.
          DIS_PAD_JTAG_ERR: u1,

          /// [20:20] Indicates a programming error of DIS_DOWNLOAD_MANUAL_ENCRYPT.
          DIS_DOWNLOAD_MANUAL_ENCRYPT_ERR: u1,

          /// [21:22] Indicates a programming error of USB_DREFH.
          USB_DREFH_ERR: u2,

          /// [23:24] Indicates a programming error of USB_DREFL.
          USB_DREFL_ERR: u2,

          /// [25:25] Indicates a programming error of USB_EXCHG_PINS.
          USB_EXCHG_PINS_ERR: u1,

          /// [26:26] Indicates a programming error of VDD_SPI_AS_GPIO.
          VDD_SPI_AS_GPIO_ERR: u1,

          /// [27:28] Reserved.
          RPT4_RESERVED0_ERR_2: u2,

          /// [29:29] Reserved.
          RPT4_RESERVED0_ERR_1: u1,

          /// [30:31] Reserved.
          RPT4_RESERVED0_ERR_0: u2,

        }), @ptrFromInt(0x600b097c));

        /// Programming error record register 1 of BLOCK0.
        pub const RD_REPEAT_ERR1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:15] Reserved.
          RPT4_RESERVED1_ERR_0: u16,

          /// [16:17] Indicates a programming error of WDT_DELAY_SEL.
          WDT_DELAY_SEL_ERR: u2,

          /// [18:20] Indicates a programming error of SPI_BOOT_CRYPT_CNT.
          SPI_BOOT_CRYPT_CNT_ERR: u3,

          /// [21:21] Indicates a programming error of SECURE_BOOT_KEY_REVOKE0.
          SECURE_BOOT_KEY_REVOKE0_ERR: u1,

          /// [22:22] Indicates a programming error of SECURE_BOOT_KEY_REVOKE1.
          SECURE_BOOT_KEY_REVOKE1_ERR: u1,

          /// [23:23] Indicates a programming error of SECURE_BOOT_KEY_REVOKE2.
          SECURE_BOOT_KEY_REVOKE2_ERR: u1,

          /// [24:27] Indicates a programming error of KEY_PURPOSE_0.
          KEY_PURPOSE_0_ERR: u4,

          /// [28:31] Indicates a programming error of KEY_PURPOSE_1.
          KEY_PURPOSE_1_ERR: u4,

        }), @ptrFromInt(0x600b0980));

        /// Programming error record register 2 of BLOCK0.
        pub const RD_REPEAT_ERR2 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:3] Indicates a programming error of KEY_PURPOSE_2.
          KEY_PURPOSE_2_ERR: u4,

          /// [4:7] Indicates a programming error of KEY_PURPOSE_3.
          KEY_PURPOSE_3_ERR: u4,

          /// [8:11] Indicates a programming error of KEY_PURPOSE_4.
          KEY_PURPOSE_4_ERR: u4,

          /// [12:15] Indicates a programming error of KEY_PURPOSE_5.
          KEY_PURPOSE_5_ERR: u4,

          /// [16:17] Indicates a programming error of SEC_DPA_LEVEL.
          SEC_DPA_LEVEL_ERR: u2,

          /// [18:18] Reserved.
          RPT4_RESERVED2_ERR_1: u1,

          /// [19:19] Indicates a programming error of CRYPT_DPA_ENABLE.
          CRYPT_DPA_ENABLE_ERR: u1,

          /// [20:20] Indicates a programming error of SECURE_BOOT_EN.
          SECURE_BOOT_EN_ERR: u1,

          /// [21:21] Indicates a programming error of SECURE_BOOT_AGGRESSIVE_REVOKE.
          SECURE_BOOT_AGGRESSIVE_REVOKE_ERR: u1,

          /// [22:27] Reserved.
          RPT4_RESERVED2_ERR_0: u6,

          /// [28:31] Indicates a programming error of FLASH_TPUW.
          FLASH_TPUW_ERR: u4,

        }), @ptrFromInt(0x600b0984));

        /// Programming error record register 3 of BLOCK0.
        pub const RD_REPEAT_ERR3 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Indicates a programming error of DIS_DOWNLOAD_MODE.
          DIS_DOWNLOAD_MODE_ERR: u1,

          /// [1:1] Indicates a programming error of DIS_DIRECT_BOOT.
          DIS_DIRECT_BOOT_ERR: u1,

          /// [2:2] Indicates a programming error of UART_PRINT_CHANNEL.
          USB_PRINT_ERR: u1,

          /// [3:3] Reserved.
          RPT4_RESERVED3_ERR_5: u1,

          /// [4:4] Indicates a programming error of DIS_USB_SERIAL_JTAG_DOWNLOAD_MODE.
          DIS_USB_SERIAL_JTAG_DOWNLOAD_MODE_ERR: u1,

          /// [5:5] Indicates a programming error of ENABLE_SECURITY_DOWNLOAD.
          ENABLE_SECURITY_DOWNLOAD_ERR: u1,

          /// [6:7] Indicates a programming error of UART_PRINT_CONTROL.
          UART_PRINT_CONTROL_ERR: u2,

          /// [8:8] Reserved.
          RPT4_RESERVED3_ERR_4: u1,

          /// [9:9] Reserved.
          RPT4_RESERVED3_ERR_3: u1,

          /// [10:11] Reserved.
          RPT4_RESERVED3_ERR_2: u2,

          /// [12:12] Reserved.
          RPT4_RESERVED3_ERR_1: u1,

          /// [13:13] Indicates a programming error of FORCE_SEND_RESUME.
          FORCE_SEND_RESUME_ERR: u1,

          /// [14:29] Indicates a programming error of SECURE_VERSION.
          SECURE_VERSION_ERR: u16,

          /// [30:31] Reserved.
          RPT4_RESERVED3_ERR_0: u2,

        }), @ptrFromInt(0x600b0988));

        /// Programming error record register 4 of BLOCK0.
        pub const RD_REPEAT_ERR4 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:23] Reserved.
          RPT4_RESERVED4_ERR_1: u24,

          /// [24:31] Reserved.
          RPT4_RESERVED4_ERR_0: u8,

        }), @ptrFromInt(0x600b0990));

        /// Programming error record register 0 of BLOCK1-10.
        pub const RD_RS_ERR0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:2] The value of this signal means the number of error bytes.
          MAC_SPI_8M_ERR_NUM: u3,

          /// [3:3] 0: Means no failure and that the data of MAC_SPI_8M is reliable 1: Means that programming user data failed and the number of error bytes is over 6.
          MAC_SPI_8M_FAIL: u1,

          /// [4:6] The value of this signal means the number of error bytes.
          SYS_PART1_NUM: u3,

          /// [7:7] 0: Means no failure and that the data of system part1 is reliable 1: Means that programming user data failed and the number of error bytes is over 6.
          SYS_PART1_FAIL: u1,

          /// [8:10] The value of this signal means the number of error bytes.
          USR_DATA_ERR_NUM: u3,

          /// [11:11] 0: Means no failure and that the user data is reliable 1: Means that programming user data failed and the number of error bytes is over 6.
          USR_DATA_FAIL: u1,

          /// [12:14] The value of this signal means the number of error bytes.
          KEY0_ERR_NUM: u3,

          /// [15:15] 0: Means no failure and that the data of key0 is reliable 1: Means that programming key0 failed and the number of error bytes is over 6.
          KEY0_FAIL: u1,

          /// [16:18] The value of this signal means the number of error bytes.
          KEY1_ERR_NUM: u3,

          /// [19:19] 0: Means no failure and that the data of key1 is reliable 1: Means that programming key1 failed and the number of error bytes is over 6.
          KEY1_FAIL: u1,

          /// [20:22] The value of this signal means the number of error bytes.
          KEY2_ERR_NUM: u3,

          /// [23:23] 0: Means no failure and that the data of key2 is reliable 1: Means that programming key2 failed and the number of error bytes is over 6.
          KEY2_FAIL: u1,

          /// [24:26] The value of this signal means the number of error bytes.
          KEY3_ERR_NUM: u3,

          /// [27:27] 0: Means no failure and that the data of key3 is reliable 1: Means that programming key3 failed and the number of error bytes is over 6.
          KEY3_FAIL: u1,

          /// [28:30] The value of this signal means the number of error bytes.
          KEY4_ERR_NUM: u3,

          /// [31:31] 0: Means no failure and that the data of key4 is reliable 1: Means that programming key4 failed and the number of error bytes is over 6.
          KEY4_FAIL: u1,

        }), @ptrFromInt(0x600b09c0));

        /// Programming error record register 1 of BLOCK1-10.
        pub const RD_RS_ERR1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:2] The value of this signal means the number of error bytes.
          KEY5_ERR_NUM: u3,

          /// [3:3] 0: Means no failure and that the data of key5 is reliable 1: Means that programming key5 failed and the number of error bytes is over 6.
          KEY5_FAIL: u1,

          /// [4:6] The value of this signal means the number of error bytes.
          SYS_PART2_ERR_NUM: u3,

          /// [7:7] 0: Means no failure and that the data of system part2 is reliable 1: Means that programming user data failed and the number of error bytes is over 6.
          SYS_PART2_FAIL: u1,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x600b09c4));

        /// eFuse clcok configuration register.
        pub const CLK = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Set this bit to force eFuse SRAM into power-saving mode.
          MEM_FORCE_PD: u1,

          /// [1:1] Set this bit and force to activate clock signal of eFuse SRAM.
          MEM_CLK_FORCE_ON: u1,

          /// [2:2] Set this bit to force eFuse SRAM into working mode.
          MEM_FORCE_PU: u1,

          /// [3:15] 
          res0: u13,

          /// [16:16] Set this bit to force enable eFuse register configuration clock signal.
          EN: u1,

          /// [17:31] 
          res1: u15,

        }), @ptrFromInt(0x600b09c8));

        /// eFuse operation mode configuraiton register
        pub const CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:15] 0x5A5A:programming operation command 0x5AA5: read operation command.
          OP_CODE: u16,

          /// [16:31] 
          res0: u16,

        }), @ptrFromInt(0x600b09cc));

        /// eFuse status register.
        pub const STATUS = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:3] Indicates the state of the eFuse state machine.
          STATE: u4,

          /// [4:4] The value of OTP_LOAD_SW.
          OTP_LOAD_SW: u1,

          /// [5:5] The value of OTP_VDDQ_C_SYNC2.
          OTP_VDDQ_C_SYNC2: u1,

          /// [6:6] The value of OTP_STROBE_SW.
          OTP_STROBE_SW: u1,

          /// [7:7] The value of OTP_CSB_SW.
          OTP_CSB_SW: u1,

          /// [8:8] The value of OTP_PGENB_SW.
          OTP_PGENB_SW: u1,

          /// [9:9] The value of OTP_VDDQ_IS_SW.
          OTP_VDDQ_IS_SW: u1,

          /// [10:19] Indicates the number of block valid bit.
          BLK0_VALID_BIT_CNT: u10,

          /// [20:31] 
          res0: u12,

        }), @ptrFromInt(0x600b09d0));

        /// eFuse command register.
        pub const CMD = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Set this bit to send read command.
          READ_CMD: u1,

          /// [1:1] Set this bit to send programming command.
          PGM_CMD: u1,

          /// [2:5] The serial number of the block to be programmed. Value 0-10 corresponds to block number 0-10, respectively.
          BLK_NUM: u4,

          /// [6:31] 
          res0: u26,

        }), @ptrFromInt(0x600b09d4));

        /// eFuse raw interrupt register.
        pub const INT_RAW = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] The raw bit signal for read_done interrupt.
          READ_DONE_INT_RAW: u1,

          /// [1:1] The raw bit signal for pgm_done interrupt.
          PGM_DONE_INT_RAW: u1,

          /// [2:31] 
          res0: u30,

        }), @ptrFromInt(0x600b09d8));

        /// eFuse interrupt status register.
        pub const INT_ST = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] The status signal for read_done interrupt.
          READ_DONE_INT_ST: u1,

          /// [1:1] The status signal for pgm_done interrupt.
          PGM_DONE_INT_ST: u1,

          /// [2:31] 
          res0: u30,

        }), @ptrFromInt(0x600b09dc));

        /// eFuse interrupt enable register.
        pub const INT_ENA = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] The enable signal for read_done interrupt.
          READ_DONE_INT_ENA: u1,

          /// [1:1] The enable signal for pgm_done interrupt.
          PGM_DONE_INT_ENA: u1,

          /// [2:31] 
          res0: u30,

        }), @ptrFromInt(0x600b09e0));

        /// eFuse interrupt clear register.
        pub const INT_CLR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] The clear signal for read_done interrupt.
          READ_DONE_INT_CLR: u1,

          /// [1:1] The clear signal for pgm_done interrupt.
          PGM_DONE_INT_CLR: u1,

          /// [2:31] 
          res0: u30,

        }), @ptrFromInt(0x600b09e4));

        /// Controls the eFuse programming voltage.
        pub const DAC_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] Controls the division factor of the rising clock of the programming voltage.
          DAC_CLK_DIV: u8,

          /// [8:8] Don't care.
          DAC_CLK_PAD_SEL: u1,

          /// [9:16] Controls the rising period of the programming voltage.
          DAC_NUM: u8,

          /// [17:17] Reduces the power supply of the programming voltage.
          OE_CLR: u1,

          /// [18:31] 
          res0: u14,

        }), @ptrFromInt(0x600b09e8));

        /// Configures read timing parameters.
        pub const RD_TIM_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] Configures the read hold time.
          THR_A: u8,

          /// [8:15] Configures the read time.
          TRD: u8,

          /// [16:23] Configures the read setup time.
          TSUR_A: u8,

          /// [24:31] Configures the waiting time of reading eFuse memory.
          READ_INIT_NUM: u8,

        }), @ptrFromInt(0x600b09ec));

        /// Configurarion register 1 of eFuse programming timing parameters.
        pub const WR_TIM_CONF1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] Configures the programming setup time.
          TSUP_A: u8,

          /// [8:23] Configures the power up time for VDDQ.
          PWR_ON_NUM: u16,

          /// [24:31] Configures the programming hold time.
          THP_A: u8,

        }), @ptrFromInt(0x600b09f0));

        /// Configurarion register 2 of eFuse programming timing parameters.
        pub const WR_TIM_CONF2 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:15] Configures the power outage time for VDDQ.
          PWR_OFF_NUM: u16,

          /// [16:31] Configures the active programming time.
          TPGM: u16,

        }), @ptrFromInt(0x600b09f4));

        /// Configurarion register0 of eFuse programming time parameters and rs bypass operation.
        pub const WR_TIM_CONF0_RS_BYPASS = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Set this bit to bypass reed solomon correction step.
          BYPASS_RS_CORRECTION: u1,

          /// [1:11] Configures block number of programming twice operation.
          BYPASS_RS_BLK_NUM: u11,

          /// [12:12] Set this bit to update multi-bit register signals.
          UPDATE: u1,

          /// [13:20] Configures the inactive programming time.
          TPGM_INACTIVE: u8,

          /// [21:31] 
          res0: u11,

        }), @ptrFromInt(0x600b09f8));

        /// eFuse version register.
        pub const DATE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:27] Stores eFuse version.
          DATE: u28,

          /// [28:31] 
          res0: u4,

        }), @ptrFromInt(0x600b09fc));

      };

      /// External Memory
      pub const EXTMEM = struct {

        /// L1 instruction Cache(L1-ICache) control register
        pub const L1_ICACHE_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] The bit is used to disable core0 ibus access L1-ICache, 0: enable, 1: disable
          L1_ICACHE_SHUT_IBUS0: u1,

          /// [1:1] The bit is used to disable core1 ibus access L1-ICache, 0: enable, 1: disable
          L1_ICACHE_SHUT_IBUS1: u1,

          /// [2:2] Reserved
          L1_ICACHE_SHUT_IBUS2: u1,

          /// [3:3] Reserved
          L1_ICACHE_SHUT_IBUS3: u1,

          /// [4:7] Reserved
          L1_ICACHE_UNDEF_OP: u4,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x600c8000));

        /// L1 data Cache(L1-Cache) control register
        pub const L1_CACHE_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] The bit is used to disable core0 dbus access L1-Cache, 0: enable, 1: disable
          L1_CACHE_SHUT_BUS0: u1,

          /// [1:1] The bit is used to disable core1 dbus access L1-Cache, 0: enable, 1: disable
          L1_CACHE_SHUT_BUS1: u1,

          /// [2:2] Reserved
          L1_CACHE_SHUT_DBUS2: u1,

          /// [3:3] Reserved
          L1_CACHE_SHUT_DBUS3: u1,

          /// [4:4] The bit is used to disable DMA access L1-Cache, 0: enable, 1: disable
          L1_CACHE_SHUT_DMA: u1,

          /// [5:7] 
          res0: u3,

          /// [8:11] Reserved
          L1_CACHE_UNDEF_OP: u4,

          /// [12:31] 
          res1: u20,

        }), @ptrFromInt(0x600c8004));

        /// Bypass Cache configure register
        pub const L1_BYPASS_CACHE_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] The bit is used to enable bypass L1-ICache0. 0: disable bypass, 1: enable bypass.
          BYPASS_L1_ICACHE0_EN: u1,

          /// [1:1] The bit is used to enable bypass L1-ICache1. 0: disable bypass, 1: enable bypass.
          BYPASS_L1_ICACHE1_EN: u1,

          /// [2:2] Reserved
          BYPASS_L1_ICACHE2_EN: u1,

          /// [3:3] Reserved
          BYPASS_L1_ICACHE3_EN: u1,

          /// [4:4] The bit is used to enable bypass L1-DCache. 0: disable bypass, 1: enable bypass.
          BYPASS_L1_DCACHE_EN: u1,

          /// [5:31] 
          res0: u27,

        }), @ptrFromInt(0x600c8008));

        /// L1 Cache atomic feature configure register
        pub const L1_CACHE_ATOMIC_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] The bit is used to enable atomic feature on L1-Cache when multiple cores access L1-Cache.1: disable, 1: enable.
          L1_CACHE_ATOMIC_EN: u1,

          /// [1:31] 
          res0: u31,

        }), @ptrFromInt(0x600c800c));

        /// L1 instruction Cache CacheSize mode configure register
        pub const L1_ICACHE_CACHESIZE_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] The field is used to configure cachesize of L1-ICache as 1k bytes. This field and all other fields within this register is onehot.
          L1_ICACHE_CACHESIZE_1K: u1,

          /// [1:1] The field is used to configure cachesize of L1-ICache as 2k bytes. This field and all other fields within this register is onehot.
          L1_ICACHE_CACHESIZE_2K: u1,

          /// [2:2] The field is used to configure cachesize of L1-ICache as 4k bytes. This field and all other fields within this register is onehot.
          L1_ICACHE_CACHESIZE_4K: u1,

          /// [3:3] The field is used to configure cachesize of L1-ICache as 8k bytes. This field and all other fields within this register is onehot.
          L1_ICACHE_CACHESIZE_8K: u1,

          /// [4:4] The field is used to configure cachesize of L1-ICache as 16k bytes. This field and all other fields within this register is onehot.
          L1_ICACHE_CACHESIZE_16K: u1,

          /// [5:5] The field is used to configure cachesize of L1-ICache as 32k bytes. This field and all other fields within this register is onehot.
          L1_ICACHE_CACHESIZE_32K: u1,

          /// [6:6] The field is used to configure cachesize of L1-ICache as 64k bytes. This field and all other fields within this register is onehot.
          L1_ICACHE_CACHESIZE_64K: u1,

          /// [7:7] The field is used to configure cachesize of L1-ICache as 128k bytes. This field and all other fields within this register is onehot.
          L1_ICACHE_CACHESIZE_128K: u1,

          /// [8:8] The field is used to configure cachesize of L1-ICache as 256k bytes. This field and all other fields within this register is onehot.
          L1_ICACHE_CACHESIZE_256K: u1,

          /// [9:9] The field is used to configure cachesize of L1-ICache as 512k bytes. This field and all other fields within this register is onehot.
          L1_ICACHE_CACHESIZE_512K: u1,

          /// [10:10] The field is used to configure cachesize of L1-ICache as 1024k bytes. This field and all other fields within this register is onehot.
          L1_ICACHE_CACHESIZE_1024K: u1,

          /// [11:11] The field is used to configure cachesize of L1-ICache as 2048k bytes. This field and all other fields within this register is onehot.
          L1_ICACHE_CACHESIZE_2048K: u1,

          /// [12:12] The field is used to configure cachesize of L1-ICache as 4096k bytes. This field and all other fields within this register is onehot.
          L1_ICACHE_CACHESIZE_4096K: u1,

          /// [13:31] 
          res0: u19,

        }), @ptrFromInt(0x600c8010));

        /// L1 instruction Cache BlockSize mode configure register
        pub const L1_ICACHE_BLOCKSIZE_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] The field is used to configureblocksize of L1-ICache as 8 bytes. This field and all other fields within this register is onehot.
          L1_ICACHE_BLOCKSIZE_8: u1,

          /// [1:1] The field is used to configureblocksize of L1-ICache as 16 bytes. This field and all other fields within this register is onehot.
          L1_ICACHE_BLOCKSIZE_16: u1,

          /// [2:2] The field is used to configureblocksize of L1-ICache as 32 bytes. This field and all other fields within this register is onehot.
          L1_ICACHE_BLOCKSIZE_32: u1,

          /// [3:3] The field is used to configureblocksize of L1-ICache as 64 bytes. This field and all other fields within this register is onehot.
          L1_ICACHE_BLOCKSIZE_64: u1,

          /// [4:4] The field is used to configureblocksize of L1-ICache as 128 bytes. This field and all other fields within this register is onehot.
          L1_ICACHE_BLOCKSIZE_128: u1,

          /// [5:5] The field is used to configureblocksize of L1-ICache as 256 bytes. This field and all other fields within this register is onehot.
          L1_ICACHE_BLOCKSIZE_256: u1,

          /// [6:31] 
          res0: u26,

        }), @ptrFromInt(0x600c8014));

        /// L1 data Cache CacheSize mode configure register
        pub const L1_CACHE_CACHESIZE_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] The field is used to configure cachesize of L1-Cache as 1k bytes. This field and all other fields within this register is onehot.
          L1_CACHE_CACHESIZE_1K: u1,

          /// [1:1] The field is used to configure cachesize of L1-Cache as 2k bytes. This field and all other fields within this register is onehot.
          L1_CACHE_CACHESIZE_2K: u1,

          /// [2:2] The field is used to configure cachesize of L1-Cache as 4k bytes. This field and all other fields within this register is onehot.
          L1_CACHE_CACHESIZE_4K: u1,

          /// [3:3] The field is used to configure cachesize of L1-Cache as 8k bytes. This field and all other fields within this register is onehot.
          L1_CACHE_CACHESIZE_8K: u1,

          /// [4:4] The field is used to configure cachesize of L1-Cache as 16k bytes. This field and all other fields within this register is onehot.
          L1_CACHE_CACHESIZE_16K: u1,

          /// [5:5] The field is used to configure cachesize of L1-Cache as 32k bytes. This field and all other fields within this register is onehot.
          L1_CACHE_CACHESIZE_32K: u1,

          /// [6:6] The field is used to configure cachesize of L1-Cache as 64k bytes. This field and all other fields within this register is onehot.
          L1_CACHE_CACHESIZE_64K: u1,

          /// [7:7] The field is used to configure cachesize of L1-Cache as 128k bytes. This field and all other fields within this register is onehot.
          L1_CACHE_CACHESIZE_128K: u1,

          /// [8:8] The field is used to configure cachesize of L1-Cache as 256k bytes. This field and all other fields within this register is onehot.
          L1_CACHE_CACHESIZE_256K: u1,

          /// [9:9] The field is used to configure cachesize of L1-Cache as 512k bytes. This field and all other fields within this register is onehot.
          L1_CACHE_CACHESIZE_512K: u1,

          /// [10:10] The field is used to configure cachesize of L1-Cache as 1024k bytes. This field and all other fields within this register is onehot.
          L1_CACHE_CACHESIZE_1024K: u1,

          /// [11:11] The field is used to configure cachesize of L1-Cache as 2048k bytes. This field and all other fields within this register is onehot.
          L1_CACHE_CACHESIZE_2048K: u1,

          /// [12:12] The field is used to configure cachesize of L1-Cache as 4096k bytes. This field and all other fields within this register is onehot.
          L1_CACHE_CACHESIZE_4096K: u1,

          /// [13:31] 
          res0: u19,

        }), @ptrFromInt(0x600c8018));

        /// L1 data Cache BlockSize mode configure register
        pub const L1_CACHE_BLOCKSIZE_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] The field is used to configureblocksize of L1-DCache as 8 bytes. This field and all other fields within this register is onehot.
          L1_CACHE_BLOCKSIZE_8: u1,

          /// [1:1] The field is used to configureblocksize of L1-DCache as 16 bytes. This field and all other fields within this register is onehot.
          L1_CACHE_BLOCKSIZE_16: u1,

          /// [2:2] The field is used to configureblocksize of L1-DCache as 32 bytes. This field and all other fields within this register is onehot.
          L1_CACHE_BLOCKSIZE_32: u1,

          /// [3:3] The field is used to configureblocksize of L1-DCache as 64 bytes. This field and all other fields within this register is onehot.
          L1_CACHE_BLOCKSIZE_64: u1,

          /// [4:4] The field is used to configureblocksize of L1-DCache as 128 bytes. This field and all other fields within this register is onehot.
          L1_CACHE_BLOCKSIZE_128: u1,

          /// [5:5] The field is used to configureblocksize of L1-DCache as 256 bytes. This field and all other fields within this register is onehot.
          L1_CACHE_BLOCKSIZE_256: u1,

          /// [6:31] 
          res0: u26,

        }), @ptrFromInt(0x600c801c));

        /// Cache wrap around control register
        pub const L1_CACHE_WRAP_AROUND_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Set this bit as 1 to enable L1-ICache0 wrap around mode.
          L1_ICACHE0_WRAP: u1,

          /// [1:1] Set this bit as 1 to enable L1-ICache1 wrap around mode.
          L1_ICACHE1_WRAP: u1,

          /// [2:2] Reserved
          L1_ICACHE2_WRAP: u1,

          /// [3:3] Reserved
          L1_ICACHE3_WRAP: u1,

          /// [4:4] Set this bit as 1 to enable L1-DCache wrap around mode.
          L1_CACHE_WRAP: u1,

          /// [5:31] 
          res0: u27,

        }), @ptrFromInt(0x600c8020));

        /// Cache tag memory power control register
        pub const L1_CACHE_TAG_MEM_POWER_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] The bit is used to close clock gating ofL1-ICache0 tag memory. 1: close gating, 0: open clock gating.
          L1_ICACHE0_TAG_MEM_FORCE_ON: u1,

          /// [1:1] The bit is used to power L1-ICache0 tag memory down. 0: follow rtc_lslp, 1: power down
          L1_ICACHE0_TAG_MEM_FORCE_PD: u1,

          /// [2:2] The bit is used to power L1-ICache0 tag memory up. 0: follow rtc_lslp, 1: power up
          L1_ICACHE0_TAG_MEM_FORCE_PU: u1,

          /// [3:3] 
          res0: u1,

          /// [4:4] The bit is used to close clock gating ofL1-ICache1 tag memory. 1: close gating, 0: open clock gating.
          L1_ICACHE1_TAG_MEM_FORCE_ON: u1,

          /// [5:5] The bit is used to power L1-ICache1 tag memory down. 0: follow rtc_lslp, 1: power down
          L1_ICACHE1_TAG_MEM_FORCE_PD: u1,

          /// [6:6] The bit is used to power L1-ICache1 tag memory up. 0: follow rtc_lslp, 1: power up
          L1_ICACHE1_TAG_MEM_FORCE_PU: u1,

          /// [7:7] 
          res1: u1,

          /// [8:8] Reserved
          L1_ICACHE2_TAG_MEM_FORCE_ON: u1,

          /// [9:9] Reserved
          L1_ICACHE2_TAG_MEM_FORCE_PD: u1,

          /// [10:10] Reserved
          L1_ICACHE2_TAG_MEM_FORCE_PU: u1,

          /// [11:11] 
          res2: u1,

          /// [12:12] Reserved
          L1_ICACHE3_TAG_MEM_FORCE_ON: u1,

          /// [13:13] Reserved
          L1_ICACHE3_TAG_MEM_FORCE_PD: u1,

          /// [14:14] Reserved
          L1_ICACHE3_TAG_MEM_FORCE_PU: u1,

          /// [15:15] 
          res3: u1,

          /// [16:16] The bit is used to close clock gating ofL1-Cache tag memory. 1: close gating, 0: open clock gating.
          L1_CACHE_TAG_MEM_FORCE_ON: u1,

          /// [17:17] The bit is used to power L1-Cache tag memory down. 0: follow rtc_lslp, 1: power down
          L1_CACHE_TAG_MEM_FORCE_PD: u1,

          /// [18:18] The bit is used to power L1-Cache tag memory up. 0: follow rtc_lslp, 1: power up
          L1_CACHE_TAG_MEM_FORCE_PU: u1,

          /// [19:31] 
          res4: u13,

        }), @ptrFromInt(0x600c8024));

        /// Cache data memory power control register
        pub const L1_CACHE_DATA_MEM_POWER_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] The bit is used to close clock gating ofL1-ICache0 data memory. 1: close gating, 0: open clock gating.
          L1_ICACHE0_DATA_MEM_FORCE_ON: u1,

          /// [1:1] The bit is used to power L1-ICache0 data memory down. 0: follow rtc_lslp, 1: power down
          L1_ICACHE0_DATA_MEM_FORCE_PD: u1,

          /// [2:2] The bit is used to power L1-ICache0 data memory up. 0: follow rtc_lslp, 1: power up
          L1_ICACHE0_DATA_MEM_FORCE_PU: u1,

          /// [3:3] 
          res0: u1,

          /// [4:4] The bit is used to close clock gating ofL1-ICache1 data memory. 1: close gating, 0: open clock gating.
          L1_ICACHE1_DATA_MEM_FORCE_ON: u1,

          /// [5:5] The bit is used to power L1-ICache1 data memory down. 0: follow rtc_lslp, 1: power down
          L1_ICACHE1_DATA_MEM_FORCE_PD: u1,

          /// [6:6] The bit is used to power L1-ICache1 data memory up. 0: follow rtc_lslp, 1: power up
          L1_ICACHE1_DATA_MEM_FORCE_PU: u1,

          /// [7:7] 
          res1: u1,

          /// [8:8] Reserved
          L1_ICACHE2_DATA_MEM_FORCE_ON: u1,

          /// [9:9] Reserved
          L1_ICACHE2_DATA_MEM_FORCE_PD: u1,

          /// [10:10] Reserved
          L1_ICACHE2_DATA_MEM_FORCE_PU: u1,

          /// [11:11] 
          res2: u1,

          /// [12:12] Reserved
          L1_ICACHE3_DATA_MEM_FORCE_ON: u1,

          /// [13:13] Reserved
          L1_ICACHE3_DATA_MEM_FORCE_PD: u1,

          /// [14:14] Reserved
          L1_ICACHE3_DATA_MEM_FORCE_PU: u1,

          /// [15:15] 
          res3: u1,

          /// [16:16] The bit is used to close clock gating ofL1-Cache data memory. 1: close gating, 0: open clock gating.
          L1_CACHE_DATA_MEM_FORCE_ON: u1,

          /// [17:17] The bit is used to power L1-Cache data memory down. 0: follow rtc_lslp, 1: power down
          L1_CACHE_DATA_MEM_FORCE_PD: u1,

          /// [18:18] The bit is used to power L1-Cache data memory up. 0: follow rtc_lslp, 1: power up
          L1_CACHE_DATA_MEM_FORCE_PU: u1,

          /// [19:31] 
          res4: u13,

        }), @ptrFromInt(0x600c8028));

        /// Cache Freeze control register
        pub const L1_CACHE_FREEZE_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] The bit is used to enable freeze operation on L1-ICache0. It can be cleared by software.
          L1_ICACHE0_FREEZE_EN: u1,

          /// [1:1] The bit is used to configure mode of freeze operation L1-ICache0. 0: a miss-access will not stuck. 1: a miss-access will stuck.
          L1_ICACHE0_FREEZE_MODE: u1,

          /// [2:2] The bit is used to indicate whether freeze operation on L1-ICache0 is finished or not. 0: not finished. 1: finished.
          L1_ICACHE0_FREEZE_DONE: u1,

          /// [3:3] 
          res0: u1,

          /// [4:4] The bit is used to enable freeze operation on L1-ICache1. It can be cleared by software.
          L1_ICACHE1_FREEZE_EN: u1,

          /// [5:5] The bit is used to configure mode of freeze operation L1-ICache1. 0: a miss-access will not stuck. 1: a miss-access will stuck.
          L1_ICACHE1_FREEZE_MODE: u1,

          /// [6:6] The bit is used to indicate whether freeze operation on L1-ICache1 is finished or not. 0: not finished. 1: finished.
          L1_ICACHE1_FREEZE_DONE: u1,

          /// [7:7] 
          res1: u1,

          /// [8:8] Reserved
          L1_ICACHE2_FREEZE_EN: u1,

          /// [9:9] Reserved
          L1_ICACHE2_FREEZE_MODE: u1,

          /// [10:10] Reserved
          L1_ICACHE2_FREEZE_DONE: u1,

          /// [11:11] 
          res2: u1,

          /// [12:12] Reserved
          L1_ICACHE3_FREEZE_EN: u1,

          /// [13:13] Reserved
          L1_ICACHE3_FREEZE_MODE: u1,

          /// [14:14] Reserved
          L1_ICACHE3_FREEZE_DONE: u1,

          /// [15:15] 
          res3: u1,

          /// [16:16] The bit is used to enable freeze operation on L1-Cache. It can be cleared by software.
          L1_CACHE_FREEZE_EN: u1,

          /// [17:17] The bit is used to configure mode of freeze operation L1-Cache. 0: a miss-access will not stuck. 1: a miss-access will stuck.
          L1_CACHE_FREEZE_MODE: u1,

          /// [18:18] The bit is used to indicate whether freeze operation on L1-Cache is finished or not. 0: not finished. 1: finished.
          L1_CACHE_FREEZE_DONE: u1,

          /// [19:31] 
          res4: u13,

        }), @ptrFromInt(0x600c802c));

        /// Cache data memory access configure register
        pub const L1_CACHE_DATA_MEM_ACS_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] The bit is used to enable config-bus read L1-ICache0 data memoryory. 0: disable, 1: enable.
          L1_ICACHE0_DATA_MEM_RD_EN: u1,

          /// [1:1] The bit is used to enable config-bus write L1-ICache0 data memoryory. 0: disable, 1: enable.
          L1_ICACHE0_DATA_MEM_WR_EN: u1,

          /// [2:3] 
          res0: u2,

          /// [4:4] The bit is used to enable config-bus read L1-ICache1 data memoryory. 0: disable, 1: enable.
          L1_ICACHE1_DATA_MEM_RD_EN: u1,

          /// [5:5] The bit is used to enable config-bus write L1-ICache1 data memoryory. 0: disable, 1: enable.
          L1_ICACHE1_DATA_MEM_WR_EN: u1,

          /// [6:7] 
          res1: u2,

          /// [8:8] Reserved
          L1_ICACHE2_DATA_MEM_RD_EN: u1,

          /// [9:9] Reserved
          L1_ICACHE2_DATA_MEM_WR_EN: u1,

          /// [10:11] 
          res2: u2,

          /// [12:12] Reserved
          L1_ICACHE3_DATA_MEM_RD_EN: u1,

          /// [13:13] Reserved
          L1_ICACHE3_DATA_MEM_WR_EN: u1,

          /// [14:15] 
          res3: u2,

          /// [16:16] The bit is used to enable config-bus read L1-Cache data memoryory. 0: disable, 1: enable.
          L1_CACHE_DATA_MEM_RD_EN: u1,

          /// [17:17] The bit is used to enable config-bus write L1-Cache data memoryory. 0: disable, 1: enable.
          L1_CACHE_DATA_MEM_WR_EN: u1,

          /// [18:31] 
          res4: u14,

        }), @ptrFromInt(0x600c8030));

        /// Cache tag memory access configure register
        pub const L1_CACHE_TAG_MEM_ACS_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] The bit is used to enable config-bus read L1-ICache0 tag memoryory. 0: disable, 1: enable.
          L1_ICACHE0_TAG_MEM_RD_EN: u1,

          /// [1:1] The bit is used to enable config-bus write L1-ICache0 tag memoryory. 0: disable, 1: enable.
          L1_ICACHE0_TAG_MEM_WR_EN: u1,

          /// [2:3] 
          res0: u2,

          /// [4:4] The bit is used to enable config-bus read L1-ICache1 tag memoryory. 0: disable, 1: enable.
          L1_ICACHE1_TAG_MEM_RD_EN: u1,

          /// [5:5] The bit is used to enable config-bus write L1-ICache1 tag memoryory. 0: disable, 1: enable.
          L1_ICACHE1_TAG_MEM_WR_EN: u1,

          /// [6:7] 
          res1: u2,

          /// [8:8] Reserved
          L1_ICACHE2_TAG_MEM_RD_EN: u1,

          /// [9:9] Reserved
          L1_ICACHE2_TAG_MEM_WR_EN: u1,

          /// [10:11] 
          res2: u2,

          /// [12:12] Reserved
          L1_ICACHE3_TAG_MEM_RD_EN: u1,

          /// [13:13] Reserved
          L1_ICACHE3_TAG_MEM_WR_EN: u1,

          /// [14:15] 
          res3: u2,

          /// [16:16] The bit is used to enable config-bus read L1-Cache tag memoryory. 0: disable, 1: enable.
          L1_CACHE_TAG_MEM_RD_EN: u1,

          /// [17:17] The bit is used to enable config-bus write L1-Cache tag memoryory. 0: disable, 1: enable.
          L1_CACHE_TAG_MEM_WR_EN: u1,

          /// [18:31] 
          res4: u14,

        }), @ptrFromInt(0x600c8034));

        /// L1 instruction Cache 0 prelock configure register
        pub const L1_ICACHE0_PRELOCK_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] The bit is used to enable the first section of prelock function on L1-ICache0.
          L1_ICACHE0_PRELOCK_SCT0_EN: u1,

          /// [1:1] The bit is used to enable the second section of prelock function on L1-ICache0.
          L1_ICACHE0_PRELOCK_SCT1_EN: u1,

          /// [2:5] The bit is used to setthe gid of l1 icache0 prelock.
          L1_ICACHE0_PRELOCK_RGID: u4,

          /// [6:31] 
          res0: u26,

        }), @ptrFromInt(0x600c8038));

        /// L1 instruction Cache 0 prelock section0 address configure register
        pub const L1_ICACHE0_PRELOCK_SCT0_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Those bits are used to configure the start virtual address of the first section of prelock on L1-ICache0, which should be used together with L1_ICACHE0_PRELOCK_SCT0_SIZE_REG
          L1_ICACHE0_PRELOCK_SCT0_ADDR: u32,

        }), @ptrFromInt(0x600c803c));

        /// L1 instruction Cache 0 prelock section1 address configure register
        pub const L1_ICACHE0_PRELOCK_SCT1_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Those bits are used to configure the start virtual address of the second section of prelock on L1-ICache0, which should be used together with L1_ICACHE0_PRELOCK_SCT1_SIZE_REG
          L1_ICACHE0_PRELOCK_SCT1_ADDR: u32,

        }), @ptrFromInt(0x600c8040));

        /// L1 instruction Cache 0 prelock section size configure register
        pub const L1_ICACHE0_PRELOCK_SCT_SIZE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:13] Those bits are used to configure the size of the first section of prelock on L1-ICache0, which should be used together with L1_ICACHE0_PRELOCK_SCT0_ADDR_REG
          L1_ICACHE0_PRELOCK_SCT0_SIZE: u14,

          /// [14:15] 
          res0: u2,

          /// [16:29] Those bits are used to configure the size of the second section of prelock on L1-ICache0, which should be used together with L1_ICACHE0_PRELOCK_SCT1_ADDR_REG
          L1_ICACHE0_PRELOCK_SCT1_SIZE: u14,

          /// [30:31] 
          res1: u2,

        }), @ptrFromInt(0x600c8044));

        /// L1 instruction Cache 1 prelock configure register
        pub const L1_ICACHE1_PRELOCK_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] The bit is used to enable the first section of prelock function on L1-ICache1.
          L1_ICACHE1_PRELOCK_SCT0_EN: u1,

          /// [1:1] The bit is used to enable the second section of prelock function on L1-ICache1.
          L1_ICACHE1_PRELOCK_SCT1_EN: u1,

          /// [2:5] The bit is used to setthe gid of l1 icache1 prelock.
          L1_ICACHE1_PRELOCK_RGID: u4,

          /// [6:31] 
          res0: u26,

        }), @ptrFromInt(0x600c8048));

        /// L1 instruction Cache 1 prelock section0 address configure register
        pub const L1_ICACHE1_PRELOCK_SCT0_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Those bits are used to configure the start virtual address of the first section of prelock on L1-ICache1, which should be used together with L1_ICACHE1_PRELOCK_SCT0_SIZE_REG
          L1_ICACHE1_PRELOCK_SCT0_ADDR: u32,

        }), @ptrFromInt(0x600c804c));

        /// L1 instruction Cache 1 prelock section1 address configure register
        pub const L1_ICACHE1_PRELOCK_SCT1_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Those bits are used to configure the start virtual address of the second section of prelock on L1-ICache1, which should be used together with L1_ICACHE1_PRELOCK_SCT1_SIZE_REG
          L1_ICACHE1_PRELOCK_SCT1_ADDR: u32,

        }), @ptrFromInt(0x600c8050));

        /// L1 instruction Cache 1 prelock section size configure register
        pub const L1_ICACHE1_PRELOCK_SCT_SIZE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:13] Those bits are used to configure the size of the first section of prelock on L1-ICache1, which should be used together with L1_ICACHE1_PRELOCK_SCT0_ADDR_REG
          L1_ICACHE1_PRELOCK_SCT0_SIZE: u14,

          /// [14:15] 
          res0: u2,

          /// [16:29] Those bits are used to configure the size of the second section of prelock on L1-ICache1, which should be used together with L1_ICACHE1_PRELOCK_SCT1_ADDR_REG
          L1_ICACHE1_PRELOCK_SCT1_SIZE: u14,

          /// [30:31] 
          res1: u2,

        }), @ptrFromInt(0x600c8054));

        /// L1 instruction Cache 2 prelock configure register
        pub const L1_ICACHE2_PRELOCK_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] The bit is used to enable the first section of prelock function on L1-ICache2.
          L1_ICACHE2_PRELOCK_SCT0_EN: u1,

          /// [1:1] The bit is used to enable the second section of prelock function on L1-ICache2.
          L1_ICACHE2_PRELOCK_SCT1_EN: u1,

          /// [2:5] The bit is used to setthe gid of l1 icache2 prelock.
          L1_ICACHE2_PRELOCK_RGID: u4,

          /// [6:31] 
          res0: u26,

        }), @ptrFromInt(0x600c8058));

        /// L1 instruction Cache 2 prelock section0 address configure register
        pub const L1_ICACHE2_PRELOCK_SCT0_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Those bits are used to configure the start virtual address of the first section of prelock on L1-ICache2, which should be used together with L1_ICACHE2_PRELOCK_SCT0_SIZE_REG
          L1_ICACHE2_PRELOCK_SCT0_ADDR: u32,

        }), @ptrFromInt(0x600c805c));

        /// L1 instruction Cache 2 prelock section1 address configure register
        pub const L1_ICACHE2_PRELOCK_SCT1_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Those bits are used to configure the start virtual address of the second section of prelock on L1-ICache2, which should be used together with L1_ICACHE2_PRELOCK_SCT1_SIZE_REG
          L1_ICACHE2_PRELOCK_SCT1_ADDR: u32,

        }), @ptrFromInt(0x600c8060));

        /// L1 instruction Cache 2 prelock section size configure register
        pub const L1_ICACHE2_PRELOCK_SCT_SIZE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:13] Those bits are used to configure the size of the first section of prelock on L1-ICache2, which should be used together with L1_ICACHE2_PRELOCK_SCT0_ADDR_REG
          L1_ICACHE2_PRELOCK_SCT0_SIZE: u14,

          /// [14:15] 
          res0: u2,

          /// [16:29] Those bits are used to configure the size of the second section of prelock on L1-ICache2, which should be used together with L1_ICACHE2_PRELOCK_SCT1_ADDR_REG
          L1_ICACHE2_PRELOCK_SCT1_SIZE: u14,

          /// [30:31] 
          res1: u2,

        }), @ptrFromInt(0x600c8064));

        /// L1 instruction Cache 3 prelock configure register
        pub const L1_ICACHE3_PRELOCK_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] The bit is used to enable the first section of prelock function on L1-ICache3.
          L1_ICACHE3_PRELOCK_SCT0_EN: u1,

          /// [1:1] The bit is used to enable the second section of prelock function on L1-ICache3.
          L1_ICACHE3_PRELOCK_SCT1_EN: u1,

          /// [2:5] The bit is used to setthe gid of l1 icache3 prelock.
          L1_ICACHE3_PRELOCK_RGID: u4,

          /// [6:31] 
          res0: u26,

        }), @ptrFromInt(0x600c8068));

        /// L1 instruction Cache 3 prelock section0 address configure register
        pub const L1_ICACHE3_PRELOCK_SCT0_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Those bits are used to configure the start virtual address of the first section of prelock on L1-ICache3, which should be used together with L1_ICACHE3_PRELOCK_SCT0_SIZE_REG
          L1_ICACHE3_PRELOCK_SCT0_ADDR: u32,

        }), @ptrFromInt(0x600c806c));

        /// L1 instruction Cache 3 prelock section1 address configure register
        pub const L1_ICACHE3_PRELOCK_SCT1_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Those bits are used to configure the start virtual address of the second section of prelock on L1-ICache3, which should be used together with L1_ICACHE3_PRELOCK_SCT1_SIZE_REG
          L1_ICACHE3_PRELOCK_SCT1_ADDR: u32,

        }), @ptrFromInt(0x600c8070));

        /// L1 instruction Cache 3 prelock section size configure register
        pub const L1_ICACHE3_PRELOCK_SCT_SIZE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:13] Those bits are used to configure the size of the first section of prelock on L1-ICache3, which should be used together with L1_ICACHE3_PRELOCK_SCT0_ADDR_REG
          L1_ICACHE3_PRELOCK_SCT0_SIZE: u14,

          /// [14:15] 
          res0: u2,

          /// [16:29] Those bits are used to configure the size of the second section of prelock on L1-ICache3, which should be used together with L1_ICACHE3_PRELOCK_SCT1_ADDR_REG
          L1_ICACHE3_PRELOCK_SCT1_SIZE: u14,

          /// [30:31] 
          res1: u2,

        }), @ptrFromInt(0x600c8074));

        /// L1 Cache prelock configure register
        pub const L1_CACHE_PRELOCK_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] The bit is used to enable the first section of prelock function on L1-Cache.
          L1_CACHE_PRELOCK_SCT0_EN: u1,

          /// [1:1] The bit is used to enable the second section of prelock function on L1-Cache.
          L1_CACHE_PRELOCK_SCT1_EN: u1,

          /// [2:5] The bit is used to setthe gid of l1 cache prelock.
          L1_CACHE_PRELOCK_RGID: u4,

          /// [6:31] 
          res0: u26,

        }), @ptrFromInt(0x600c8078));

        /// L1 Cache prelock section0 address configure register
        pub const L1_CACHE_PRELOCK_SCT0_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Those bits are used to configure the start virtual address of the first section of prelock on L1-Cache, which should be used together with L1_CACHE_PRELOCK_SCT0_SIZE_REG
          L1_CACHE_PRELOCK_SCT0_ADDR: u32,

        }), @ptrFromInt(0x600c807c));

        /// L1 Cache prelock section1 address configure register
        pub const L1_DCACHE_PRELOCK_SCT1_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Those bits are used to configure the start virtual address of the second section of prelock on L1-Cache, which should be used together with L1_CACHE_PRELOCK_SCT1_SIZE_REG
          L1_CACHE_PRELOCK_SCT1_ADDR: u32,

        }), @ptrFromInt(0x600c8080));

        /// L1Cache prelock section size configure register
        pub const L1_DCACHE_PRELOCK_SCT_SIZE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:13] Those bits are used to configure the size of the first section of prelock on L1-Cache, which should be used together with L1_CACHE_PRELOCK_SCT0_ADDR_REG
          L1_CACHE_PRELOCK_SCT0_SIZE: u14,

          /// [14:15] 
          res0: u2,

          /// [16:29] Those bits are used to configure the size of the second section of prelock on L1-Cache, which should be used together with L1_CACHE_PRELOCK_SCT1_ADDR_REG
          L1_CACHE_PRELOCK_SCT1_SIZE: u14,

          /// [30:31] 
          res1: u2,

        }), @ptrFromInt(0x600c8084));

        /// Lock-class (manual lock) operation control register
        pub const CACHE_LOCK_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] The bit is used to enable lock operation. It will be cleared by hardware after lock operation done
          CACHE_LOCK_ENA: u1,

          /// [1:1] The bit is used to enable unlock operation. It will be cleared by hardware after unlock operation done
          CACHE_UNLOCK_ENA: u1,

          /// [2:2] The bit is used to indicate whether unlock/lock operation is finished or not. 0: not finished. 1: finished.
          CACHE_LOCK_DONE: u1,

          /// [3:6] The bit is used to setthe gid of cache lock/unlock.
          CACHE_LOCK_RGID: u4,

          /// [7:31] 
          res0: u25,

        }), @ptrFromInt(0x600c8088));

        /// Lock (manual lock) map configure register
        pub const CACHE_LOCK_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] Those bits are used to indicate which caches in the two-level cache structure will apply this lock/unlock operation. [4]: L1-Cache
          CACHE_LOCK_MAP: u6,

          /// [6:31] 
          res0: u26,

        }), @ptrFromInt(0x600c808c));

        /// Lock (manual lock) address configure register
        pub const CACHE_LOCK_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Those bits are used to configure the start virtual address of the lock/unlock operation, which should be used together with CACHE_LOCK_SIZE_REG
          CACHE_LOCK_ADDR: u32,

        }), @ptrFromInt(0x600c8090));

        /// Lock (manual lock) size configure register
        pub const CACHE_LOCK_SIZE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:15] Those bits are used to configure the size of the lock/unlock operation, which should be used together with CACHE_LOCK_ADDR_REG
          CACHE_LOCK_SIZE: u16,

          /// [16:31] 
          res0: u16,

        }), @ptrFromInt(0x600c8094));

        /// Sync-class operation control register
        pub const CACHE_SYNC_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] The bit is used to enable invalidate operation. It will be cleared by hardware after invalidate operation done. Note that this bit and the other sync-bits (clean_ena, writeback_ena, writeback_invalidate_ena) are mutually exclusive, that is, those bits can not be set to 1 at the same time.
          CACHE_INVALIDATE_ENA: u1,

          /// [1:1] The bit is used to enable clean operation. It will be cleared by hardware after clean operation done. Note that this bit and the other sync-bits (invalidate_ena, writeback_ena, writeback_invalidate_ena) are mutually exclusive, that is, those bits can not be set to 1 at the same time.
          CACHE_CLEAN_ENA: u1,

          /// [2:2] The bit is used to enable writeback operation. It will be cleared by hardware after writeback operation done. Note that this bit and the other sync-bits (invalidate_ena, clean_ena, writeback_invalidate_ena) are mutually exclusive, that is, those bits can not be set to 1 at the same time.
          CACHE_WRITEBACK_ENA: u1,

          /// [3:3] The bit is used to enable writeback-invalidate operation. It will be cleared by hardware after writeback-invalidate operation done. Note that this bit and the other sync-bits (invalidate_ena, clean_ena, writeback_ena) are mutually exclusive, that is, those bits can not be set to 1 at the same time.
          CACHE_WRITEBACK_INVALIDATE_ENA: u1,

          /// [4:4] The bit is used to indicate whether sync operation (invalidate, clean, writeback, writeback_invalidate) is finished or not. 0: not finished. 1: finished.
          CACHE_SYNC_DONE: u1,

          /// [5:8] The bit is used to setthe gid of cache sync operation (invalidate, clean, writeback, writeback_invalidate)
          CACHE_SYNC_RGID: u4,

          /// [9:31] 
          res0: u23,

        }), @ptrFromInt(0x600c8098));

        /// Sync map configure register
        pub const CACHE_SYNC_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] Those bits are used to indicate which caches in the two-level cache structure will apply the sync operation.[4]: L1-Cache
          CACHE_SYNC_MAP: u6,

          /// [6:31] 
          res0: u26,

        }), @ptrFromInt(0x600c809c));

        /// Sync address configure register
        pub const CACHE_SYNC_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Those bits are used to configure the start virtual address of the sync operation, which should be used together with CACHE_SYNC_SIZE_REG
          CACHE_SYNC_ADDR: u32,

        }), @ptrFromInt(0x600c80a0));

        /// Sync size configure register
        pub const CACHE_SYNC_SIZE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:23] Those bits are used to configure the size of the sync operation, which should be used together with CACHE_SYNC_ADDR_REG
          CACHE_SYNC_SIZE: u24,

          /// [24:31] 
          res0: u8,

        }), @ptrFromInt(0x600c80a4));

        /// L1 instruction Cache 0 preload-operation control register
        pub const L1_ICACHE0_PRELOAD_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] The bit is used to enable preload operation on L1-ICache0. It will be cleared by hardware automatically after preload operation is done.
          L1_ICACHE0_PRELOAD_ENA: u1,

          /// [1:1] The bit is used to indicate whether preload operation is finished or not. 0: not finished. 1: finished.
          L1_ICACHE0_PRELOAD_DONE: u1,

          /// [2:2] The bit is used to configure the direction of preload operation. 0: ascending, 1: descending.
          L1_ICACHE0_PRELOAD_ORDER: u1,

          /// [3:6] The bit is used to setthe gid of l1 icache0 preload.
          L1_ICACHE0_PRELOAD_RGID: u4,

          /// [7:31] 
          res0: u25,

        }), @ptrFromInt(0x600c80a8));

        /// L1 instruction Cache 0 preload address configure register
        pub const L1_ICACHE0_PRELOAD_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Those bits are used to configure the start virtual address of preload on L1-ICache0, which should be used together with L1_ICACHE0_PRELOAD_SIZE_REG
          L1_ICACHE0_PRELOAD_ADDR: u32,

        }), @ptrFromInt(0x600c80ac));

        /// L1 instruction Cache 0 preload size configure register
        pub const L1_ICACHE0_PRELOAD_SIZE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:13] Those bits are used to configure the size of the first section of prelock on L1-ICache0, which should be used together with L1_ICACHE0_PRELOAD_ADDR_REG
          L1_ICACHE0_PRELOAD_SIZE: u14,

          /// [14:31] 
          res0: u18,

        }), @ptrFromInt(0x600c80b0));

        /// L1 instruction Cache 1 preload-operation control register
        pub const L1_ICACHE1_PRELOAD_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] The bit is used to enable preload operation on L1-ICache1. It will be cleared by hardware automatically after preload operation is done.
          L1_ICACHE1_PRELOAD_ENA: u1,

          /// [1:1] The bit is used to indicate whether preload operation is finished or not. 0: not finished. 1: finished.
          L1_ICACHE1_PRELOAD_DONE: u1,

          /// [2:2] The bit is used to configure the direction of preload operation. 0: ascending, 1: descending.
          L1_ICACHE1_PRELOAD_ORDER: u1,

          /// [3:6] The bit is used to setthe gid of l1 icache1 preload.
          L1_ICACHE1_PRELOAD_RGID: u4,

          /// [7:31] 
          res0: u25,

        }), @ptrFromInt(0x600c80b4));

        /// L1 instruction Cache 1 preload address configure register
        pub const L1_ICACHE1_PRELOAD_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Those bits are used to configure the start virtual address of preload on L1-ICache1, which should be used together with L1_ICACHE1_PRELOAD_SIZE_REG
          L1_ICACHE1_PRELOAD_ADDR: u32,

        }), @ptrFromInt(0x600c80b8));

        /// L1 instruction Cache 1 preload size configure register
        pub const L1_ICACHE1_PRELOAD_SIZE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:13] Those bits are used to configure the size of the first section of prelock on L1-ICache1, which should be used together with L1_ICACHE1_PRELOAD_ADDR_REG
          L1_ICACHE1_PRELOAD_SIZE: u14,

          /// [14:31] 
          res0: u18,

        }), @ptrFromInt(0x600c80bc));

        /// L1 instruction Cache 2 preload-operation control register
        pub const L1_ICACHE2_PRELOAD_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] The bit is used to enable preload operation on L1-ICache2. It will be cleared by hardware automatically after preload operation is done.
          L1_ICACHE2_PRELOAD_ENA: u1,

          /// [1:1] The bit is used to indicate whether preload operation is finished or not. 0: not finished. 1: finished.
          L1_ICACHE2_PRELOAD_DONE: u1,

          /// [2:2] The bit is used to configure the direction of preload operation. 0: ascending, 1: descending.
          L1_ICACHE2_PRELOAD_ORDER: u1,

          /// [3:6] The bit is used to setthe gid of l1 icache2 preload.
          L1_ICACHE2_PRELOAD_RGID: u4,

          /// [7:31] 
          res0: u25,

        }), @ptrFromInt(0x600c80c0));

        /// L1 instruction Cache 2 preload address configure register
        pub const L1_ICACHE2_PRELOAD_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Those bits are used to configure the start virtual address of preload on L1-ICache2, which should be used together with L1_ICACHE2_PRELOAD_SIZE_REG
          L1_ICACHE2_PRELOAD_ADDR: u32,

        }), @ptrFromInt(0x600c80c4));

        /// L1 instruction Cache 2 preload size configure register
        pub const L1_ICACHE2_PRELOAD_SIZE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:13] Those bits are used to configure the size of the first section of prelock on L1-ICache2, which should be used together with L1_ICACHE2_PRELOAD_ADDR_REG
          L1_ICACHE2_PRELOAD_SIZE: u14,

          /// [14:31] 
          res0: u18,

        }), @ptrFromInt(0x600c80c8));

        /// L1 instruction Cache 3 preload-operation control register
        pub const L1_ICACHE3_PRELOAD_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] The bit is used to enable preload operation on L1-ICache3. It will be cleared by hardware automatically after preload operation is done.
          L1_ICACHE3_PRELOAD_ENA: u1,

          /// [1:1] The bit is used to indicate whether preload operation is finished or not. 0: not finished. 1: finished.
          L1_ICACHE3_PRELOAD_DONE: u1,

          /// [2:2] The bit is used to configure the direction of preload operation. 0: ascending, 1: descending.
          L1_ICACHE3_PRELOAD_ORDER: u1,

          /// [3:6] The bit is used to setthe gid of l1 icache3 preload.
          L1_ICACHE3_PRELOAD_RGID: u4,

          /// [7:31] 
          res0: u25,

        }), @ptrFromInt(0x600c80cc));

        /// L1 instruction Cache 3 preload address configure register
        pub const L1_ICACHE3_PRELOAD_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Those bits are used to configure the start virtual address of preload on L1-ICache3, which should be used together with L1_ICACHE3_PRELOAD_SIZE_REG
          L1_ICACHE3_PRELOAD_ADDR: u32,

        }), @ptrFromInt(0x600c80d0));

        /// L1 instruction Cache 3 preload size configure register
        pub const L1_ICACHE3_PRELOAD_SIZE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:13] Those bits are used to configure the size of the first section of prelock on L1-ICache3, which should be used together with L1_ICACHE3_PRELOAD_ADDR_REG
          L1_ICACHE3_PRELOAD_SIZE: u14,

          /// [14:31] 
          res0: u18,

        }), @ptrFromInt(0x600c80d4));

        /// L1 Cachepreload-operation control register
        pub const L1_CACHE_PRELOAD_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] The bit is used to enable preload operation on L1-Cache. It will be cleared by hardware automatically after preload operation is done.
          L1_CACHE_PRELOAD_ENA: u1,

          /// [1:1] The bit is used to indicate whether preload operation is finished or not. 0: not finished. 1: finished.
          L1_CACHE_PRELOAD_DONE: u1,

          /// [2:2] The bit is used to configure the direction of preload operation. 0: ascending, 1: descending.
          L1_CACHE_PRELOAD_ORDER: u1,

          /// [3:6] The bit is used to setthe gid of l1 cache preload.
          L1_CACHE_PRELOAD_RGID: u4,

          /// [7:31] 
          res0: u25,

        }), @ptrFromInt(0x600c80d8));

        /// L1 Cachepreload address configure register
        pub const L1_DCACHE_PRELOAD_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Those bits are used to configure the start virtual address of preload on L1-Cache, which should be used together with L1_CACHE_PRELOAD_SIZE_REG
          L1_CACHE_PRELOAD_ADDR: u32,

        }), @ptrFromInt(0x600c80dc));

        /// L1 Cachepreload size configure register
        pub const L1_DCACHE_PRELOAD_SIZE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:13] Those bits are used to configure the size of the first section of prelock on L1-Cache, which should be used together with L1_CACHE_PRELOAD_ADDR_REG
          L1_CACHE_PRELOAD_SIZE: u14,

          /// [14:31] 
          res0: u18,

        }), @ptrFromInt(0x600c80e0));

        /// L1 instruction Cache 0 autoload-operation control register
        pub const L1_ICACHE0_AUTOLOAD_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] The bit is used to enable and disable autoload operation on L1-ICache0.1: enable, 0: disable.
          L1_ICACHE0_AUTOLOAD_ENA: u1,

          /// [1:1] The bit is used to indicate whether autoload operation on L1-ICache0 is finished or not. 0: not finished. 1: finished.
          L1_ICACHE0_AUTOLOAD_DONE: u1,

          /// [2:2] The bit is used to configure the direction of autoload operation on L1-ICache0. 0: ascending. 1: descending.
          L1_ICACHE0_AUTOLOAD_ORDER: u1,

          /// [3:4] The field is used to configure trigger mode of autoload operation on L1-ICache0. 0/3: miss-trigger, 1: hit-trigger, 2: miss-hit-trigger.
          L1_ICACHE0_AUTOLOAD_TRIGGER_MODE: u2,

          /// [5:7] 
          res0: u3,

          /// [8:8] The bit is used to enable the first section for autoload operation on L1-ICache0.
          L1_ICACHE0_AUTOLOAD_SCT0_ENA: u1,

          /// [9:9] The bit is used to enable the second section for autoload operation on L1-ICache0.
          L1_ICACHE0_AUTOLOAD_SCT1_ENA: u1,

          /// [10:13] The bit is used to setthe gid of l1 icache0 autoload.
          L1_ICACHE0_AUTOLOAD_RGID: u4,

          /// [14:31] 
          res1: u18,

        }), @ptrFromInt(0x600c80e4));

        /// L1 instruction Cache 0 autoload section 0 address configure register
        pub const L1_ICACHE0_AUTOLOAD_SCT0_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Those bits are used to configure the start virtual address of the first section for autoload operation on L1-ICache0. Note that it should be used together with L1_ICACHE0_AUTOLOAD_SCT0_SIZE and L1_ICACHE_AUTOLOAD_SCT0_ENA.
          L1_ICACHE0_AUTOLOAD_SCT0_ADDR: u32,

        }), @ptrFromInt(0x600c80e8));

        /// L1 instruction Cache 0 autoload section 0 size configure register
        pub const L1_ICACHE0_AUTOLOAD_SCT0_SIZE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:27] Those bits are used to configure the size of the first section for autoload operation on L1-ICache0. Note that it should be used together with L1_ICACHE0_AUTOLOAD_SCT0_ADDR and L1_ICACHE_AUTOLOAD_SCT0_ENA.
          L1_ICACHE0_AUTOLOAD_SCT0_SIZE: u28,

          /// [28:31] 
          res0: u4,

        }), @ptrFromInt(0x600c80ec));

        /// L1 instruction Cache 0 autoload section 1 address configure register
        pub const L1_ICACHE0_AUTOLOAD_SCT1_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Those bits are used to configure the start virtual address of the second section for autoload operation on L1-ICache0. Note that it should be used together with L1_ICACHE0_AUTOLOAD_SCT1_SIZE and L1_ICACHE_AUTOLOAD_SCT1_ENA.
          L1_ICACHE0_AUTOLOAD_SCT1_ADDR: u32,

        }), @ptrFromInt(0x600c80f0));

        /// L1 instruction Cache 0 autoload section 1 size configure register
        pub const L1_ICACHE0_AUTOLOAD_SCT1_SIZE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:27] Those bits are used to configure the size of the second section for autoload operation on L1-ICache0. Note that it should be used together with L1_ICACHE0_AUTOLOAD_SCT1_ADDR and L1_ICACHE_AUTOLOAD_SCT1_ENA.
          L1_ICACHE0_AUTOLOAD_SCT1_SIZE: u28,

          /// [28:31] 
          res0: u4,

        }), @ptrFromInt(0x600c80f4));

        /// L1 instruction Cache 1 autoload-operation control register
        pub const L1_ICACHE1_AUTOLOAD_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] The bit is used to enable and disable autoload operation on L1-ICache1.1: enable, 0: disable.
          L1_ICACHE1_AUTOLOAD_ENA: u1,

          /// [1:1] The bit is used to indicate whether autoload operation on L1-ICache1 is finished or not. 0: not finished. 1: finished.
          L1_ICACHE1_AUTOLOAD_DONE: u1,

          /// [2:2] The bit is used to configure the direction of autoload operation on L1-ICache1. 0: ascending. 1: descending.
          L1_ICACHE1_AUTOLOAD_ORDER: u1,

          /// [3:4] The field is used to configure trigger mode of autoload operation on L1-ICache1. 0/3: miss-trigger, 1: hit-trigger, 2: miss-hit-trigger.
          L1_ICACHE1_AUTOLOAD_TRIGGER_MODE: u2,

          /// [5:7] 
          res0: u3,

          /// [8:8] The bit is used to enable the first section for autoload operation on L1-ICache1.
          L1_ICACHE1_AUTOLOAD_SCT0_ENA: u1,

          /// [9:9] The bit is used to enable the second section for autoload operation on L1-ICache1.
          L1_ICACHE1_AUTOLOAD_SCT1_ENA: u1,

          /// [10:13] The bit is used to setthe gid of l1 icache1 autoload.
          L1_ICACHE1_AUTOLOAD_RGID: u4,

          /// [14:31] 
          res1: u18,

        }), @ptrFromInt(0x600c80f8));

        /// L1 instruction Cache 1 autoload section 0 address configure register
        pub const L1_ICACHE1_AUTOLOAD_SCT0_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Those bits are used to configure the start virtual address of the first section for autoload operation on L1-ICache1. Note that it should be used together with L1_ICACHE1_AUTOLOAD_SCT0_SIZE and L1_ICACHE_AUTOLOAD_SCT0_ENA.
          L1_ICACHE1_AUTOLOAD_SCT0_ADDR: u32,

        }), @ptrFromInt(0x600c80fc));

        /// L1 instruction Cache 1 autoload section 0 size configure register
        pub const L1_ICACHE1_AUTOLOAD_SCT0_SIZE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:27] Those bits are used to configure the size of the first section for autoload operation on L1-ICache1. Note that it should be used together with L1_ICACHE1_AUTOLOAD_SCT0_ADDR and L1_ICACHE_AUTOLOAD_SCT0_ENA.
          L1_ICACHE1_AUTOLOAD_SCT0_SIZE: u28,

          /// [28:31] 
          res0: u4,

        }), @ptrFromInt(0x600c8100));

        /// L1 instruction Cache 1 autoload section 1 address configure register
        pub const L1_ICACHE1_AUTOLOAD_SCT1_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Those bits are used to configure the start virtual address of the second section for autoload operation on L1-ICache1. Note that it should be used together with L1_ICACHE1_AUTOLOAD_SCT1_SIZE and L1_ICACHE_AUTOLOAD_SCT1_ENA.
          L1_ICACHE1_AUTOLOAD_SCT1_ADDR: u32,

        }), @ptrFromInt(0x600c8104));

        /// L1 instruction Cache 1 autoload section 1 size configure register
        pub const L1_ICACHE1_AUTOLOAD_SCT1_SIZE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:27] Those bits are used to configure the size of the second section for autoload operation on L1-ICache1. Note that it should be used together with L1_ICACHE1_AUTOLOAD_SCT1_ADDR and L1_ICACHE_AUTOLOAD_SCT1_ENA.
          L1_ICACHE1_AUTOLOAD_SCT1_SIZE: u28,

          /// [28:31] 
          res0: u4,

        }), @ptrFromInt(0x600c8108));

        /// L1 instruction Cache 2 autoload-operation control register
        pub const L1_ICACHE2_AUTOLOAD_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] The bit is used to enable and disable autoload operation on L1-ICache2.1: enable, 0: disable.
          L1_ICACHE2_AUTOLOAD_ENA: u1,

          /// [1:1] The bit is used to indicate whether autoload operation on L1-ICache2 is finished or not. 0: not finished. 1: finished.
          L1_ICACHE2_AUTOLOAD_DONE: u1,

          /// [2:2] The bit is used to configure the direction of autoload operation on L1-ICache2. 0: ascending. 1: descending.
          L1_ICACHE2_AUTOLOAD_ORDER: u1,

          /// [3:4] The field is used to configure trigger mode of autoload operation on L1-ICache2. 0/3: miss-trigger, 1: hit-trigger, 2: miss-hit-trigger.
          L1_ICACHE2_AUTOLOAD_TRIGGER_MODE: u2,

          /// [5:7] 
          res0: u3,

          /// [8:8] The bit is used to enable the first section for autoload operation on L1-ICache2.
          L1_ICACHE2_AUTOLOAD_SCT0_ENA: u1,

          /// [9:9] The bit is used to enable the second section for autoload operation on L1-ICache2.
          L1_ICACHE2_AUTOLOAD_SCT1_ENA: u1,

          /// [10:13] The bit is used to setthe gid of l1 icache2 autoload.
          L1_ICACHE2_AUTOLOAD_RGID: u4,

          /// [14:31] 
          res1: u18,

        }), @ptrFromInt(0x600c810c));

        /// L1 instruction Cache 2 autoload section 0 address configure register
        pub const L1_ICACHE2_AUTOLOAD_SCT0_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Those bits are used to configure the start virtual address of the first section for autoload operation on L1-ICache2. Note that it should be used together with L1_ICACHE2_AUTOLOAD_SCT0_SIZE and L1_ICACHE_AUTOLOAD_SCT0_ENA.
          L1_ICACHE2_AUTOLOAD_SCT0_ADDR: u32,

        }), @ptrFromInt(0x600c8110));

        /// L1 instruction Cache 2 autoload section 0 size configure register
        pub const L1_ICACHE2_AUTOLOAD_SCT0_SIZE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:27] Those bits are used to configure the size of the first section for autoload operation on L1-ICache2. Note that it should be used together with L1_ICACHE2_AUTOLOAD_SCT0_ADDR and L1_ICACHE_AUTOLOAD_SCT0_ENA.
          L1_ICACHE2_AUTOLOAD_SCT0_SIZE: u28,

          /// [28:31] 
          res0: u4,

        }), @ptrFromInt(0x600c8114));

        /// L1 instruction Cache 2 autoload section 1 address configure register
        pub const L1_ICACHE2_AUTOLOAD_SCT1_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Those bits are used to configure the start virtual address of the second section for autoload operation on L1-ICache2. Note that it should be used together with L1_ICACHE2_AUTOLOAD_SCT1_SIZE and L1_ICACHE_AUTOLOAD_SCT1_ENA.
          L1_ICACHE2_AUTOLOAD_SCT1_ADDR: u32,

        }), @ptrFromInt(0x600c8118));

        /// L1 instruction Cache 2 autoload section 1 size configure register
        pub const L1_ICACHE2_AUTOLOAD_SCT1_SIZE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:27] Those bits are used to configure the size of the second section for autoload operation on L1-ICache2. Note that it should be used together with L1_ICACHE2_AUTOLOAD_SCT1_ADDR and L1_ICACHE_AUTOLOAD_SCT1_ENA.
          L1_ICACHE2_AUTOLOAD_SCT1_SIZE: u28,

          /// [28:31] 
          res0: u4,

        }), @ptrFromInt(0x600c811c));

        /// L1 instruction Cache 3 autoload-operation control register
        pub const L1_ICACHE3_AUTOLOAD_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] The bit is used to enable and disable autoload operation on L1-ICache3.1: enable, 0: disable.
          L1_ICACHE3_AUTOLOAD_ENA: u1,

          /// [1:1] The bit is used to indicate whether autoload operation on L1-ICache3 is finished or not. 0: not finished. 1: finished.
          L1_ICACHE3_AUTOLOAD_DONE: u1,

          /// [2:2] The bit is used to configure the direction of autoload operation on L1-ICache3. 0: ascending. 1: descending.
          L1_ICACHE3_AUTOLOAD_ORDER: u1,

          /// [3:4] The field is used to configure trigger mode of autoload operation on L1-ICache3. 0/3: miss-trigger, 1: hit-trigger, 2: miss-hit-trigger.
          L1_ICACHE3_AUTOLOAD_TRIGGER_MODE: u2,

          /// [5:7] 
          res0: u3,

          /// [8:8] The bit is used to enable the first section for autoload operation on L1-ICache3.
          L1_ICACHE3_AUTOLOAD_SCT0_ENA: u1,

          /// [9:9] The bit is used to enable the second section for autoload operation on L1-ICache3.
          L1_ICACHE3_AUTOLOAD_SCT1_ENA: u1,

          /// [10:13] The bit is used to setthe gid of l1 icache3 autoload.
          L1_ICACHE3_AUTOLOAD_RGID: u4,

          /// [14:31] 
          res1: u18,

        }), @ptrFromInt(0x600c8120));

        /// L1 instruction Cache 3 autoload section 0 address configure register
        pub const L1_ICACHE3_AUTOLOAD_SCT0_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Those bits are used to configure the start virtual address of the first section for autoload operation on L1-ICache3. Note that it should be used together with L1_ICACHE3_AUTOLOAD_SCT0_SIZE and L1_ICACHE_AUTOLOAD_SCT0_ENA.
          L1_ICACHE3_AUTOLOAD_SCT0_ADDR: u32,

        }), @ptrFromInt(0x600c8124));

        /// L1 instruction Cache 3 autoload section 0 size configure register
        pub const L1_ICACHE3_AUTOLOAD_SCT0_SIZE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:27] Those bits are used to configure the size of the first section for autoload operation on L1-ICache3. Note that it should be used together with L1_ICACHE3_AUTOLOAD_SCT0_ADDR and L1_ICACHE_AUTOLOAD_SCT0_ENA.
          L1_ICACHE3_AUTOLOAD_SCT0_SIZE: u28,

          /// [28:31] 
          res0: u4,

        }), @ptrFromInt(0x600c8128));

        /// L1 instruction Cache 3 autoload section 1 address configure register
        pub const L1_ICACHE3_AUTOLOAD_SCT1_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Those bits are used to configure the start virtual address of the second section for autoload operation on L1-ICache3. Note that it should be used together with L1_ICACHE3_AUTOLOAD_SCT1_SIZE and L1_ICACHE_AUTOLOAD_SCT1_ENA.
          L1_ICACHE3_AUTOLOAD_SCT1_ADDR: u32,

        }), @ptrFromInt(0x600c812c));

        /// L1 instruction Cache 3 autoload section 1 size configure register
        pub const L1_ICACHE3_AUTOLOAD_SCT1_SIZE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:27] Reserved
          L1_ICACHE3_AUTOLOAD_SCT1_SIZE: u28,

          /// [28:31] 
          res0: u4,

        }), @ptrFromInt(0x600c8130));

        /// L1 Cache autoload-operation control register
        pub const L1_CACHE_AUTOLOAD_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] The bit is used to enable and disable autoload operation on L1-Cache.1: enable, 0: disable.
          L1_CACHE_AUTOLOAD_ENA: u1,

          /// [1:1] The bit is used to indicate whether autoload operation on L1-Cache is finished or not. 0: not finished. 1: finished.
          L1_CACHE_AUTOLOAD_DONE: u1,

          /// [2:2] The bit is used to configure the direction of autoload operation on L1-Cache. 0: ascending. 1: descending.
          L1_CACHE_AUTOLOAD_ORDER: u1,

          /// [3:4] The field is used to configure trigger mode of autoload operation on L1-Cache. 0/3: miss-trigger, 1: hit-trigger, 2: miss-hit-trigger.
          L1_CACHE_AUTOLOAD_TRIGGER_MODE: u2,

          /// [5:7] 
          res0: u3,

          /// [8:8] The bit is used to enable the first section for autoload operation on L1-Cache.
          L1_CACHE_AUTOLOAD_SCT0_ENA: u1,

          /// [9:9] The bit is used to enable the second section for autoload operation on L1-Cache.
          L1_CACHE_AUTOLOAD_SCT1_ENA: u1,

          /// [10:10] The bit is used to enable the third section for autoload operation on L1-Cache.
          L1_CACHE_AUTOLOAD_SCT2_ENA: u1,

          /// [11:11] The bit is used to enable the fourth section for autoload operation on L1-Cache.
          L1_CACHE_AUTOLOAD_SCT3_ENA: u1,

          /// [12:15] The bit is used to setthe gid of l1 cache autoload.
          L1_CACHE_AUTOLOAD_RGID: u4,

          /// [16:31] 
          res1: u16,

        }), @ptrFromInt(0x600c8134));

        /// L1 Cache autoload section 0 address configure register
        pub const L1_CACHE_AUTOLOAD_SCT0_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Those bits are used to configure the start virtual address of the first section for autoload operation on L1-Cache. Note that it should be used together with L1_CACHE_AUTOLOAD_SCT0_SIZE and L1_CACHE_AUTOLOAD_SCT0_ENA.
          L1_CACHE_AUTOLOAD_SCT0_ADDR: u32,

        }), @ptrFromInt(0x600c8138));

        /// L1 Cache autoload section 0 size configure register
        pub const L1_CACHE_AUTOLOAD_SCT0_SIZE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:27] Those bits are used to configure the size of the first section for autoload operation on L1-Cache. Note that it should be used together with L1_CACHE_AUTOLOAD_SCT0_ADDR and L1_CACHE_AUTOLOAD_SCT0_ENA.
          L1_CACHE_AUTOLOAD_SCT0_SIZE: u28,

          /// [28:31] 
          res0: u4,

        }), @ptrFromInt(0x600c813c));

        /// L1 Cache autoload section 1 address configure register
        pub const L1_CACHE_AUTOLOAD_SCT1_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Those bits are used to configure the start virtual address of the second section for autoload operation on L1-Cache. Note that it should be used together with L1_CACHE_AUTOLOAD_SCT1_SIZE and L1_CACHE_AUTOLOAD_SCT1_ENA.
          L1_CACHE_AUTOLOAD_SCT1_ADDR: u32,

        }), @ptrFromInt(0x600c8140));

        /// L1 Cache autoload section 1 size configure register
        pub const L1_CACHE_AUTOLOAD_SCT1_SIZE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:27] Those bits are used to configure the size of the second section for autoload operation on L1-Cache. Note that it should be used together with L1_CACHE_AUTOLOAD_SCT1_ADDR and L1_CACHE_AUTOLOAD_SCT1_ENA.
          L1_CACHE_AUTOLOAD_SCT1_SIZE: u28,

          /// [28:31] 
          res0: u4,

        }), @ptrFromInt(0x600c8144));

        /// L1 Cache autoload section 2 address configure register
        pub const L1_CACHE_AUTOLOAD_SCT2_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Those bits are used to configure the start virtual address of the third section for autoload operation on L1-Cache. Note that it should be used together with L1_CACHE_AUTOLOAD_SCT2_SIZE and L1_CACHE_AUTOLOAD_SCT2_ENA.
          L1_CACHE_AUTOLOAD_SCT2_ADDR: u32,

        }), @ptrFromInt(0x600c8148));

        /// L1 Cache autoload section 2 size configure register
        pub const L1_CACHE_AUTOLOAD_SCT2_SIZE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:27] Those bits are used to configure the size of the third section for autoload operation on L1-Cache. Note that it should be used together with L1_CACHE_AUTOLOAD_SCT2_ADDR and L1_CACHE_AUTOLOAD_SCT2_ENA.
          L1_CACHE_AUTOLOAD_SCT2_SIZE: u28,

          /// [28:31] 
          res0: u4,

        }), @ptrFromInt(0x600c814c));

        /// L1 Cache autoload section 1 address configure register
        pub const L1_CACHE_AUTOLOAD_SCT3_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Those bits are used to configure the start virtual address of the fourth section for autoload operation on L1-Cache. Note that it should be used together with L1_CACHE_AUTOLOAD_SCT3_SIZE and L1_CACHE_AUTOLOAD_SCT3_ENA.
          L1_CACHE_AUTOLOAD_SCT3_ADDR: u32,

        }), @ptrFromInt(0x600c8150));

        /// L1 Cache autoload section 1 size configure register
        pub const L1_CACHE_AUTOLOAD_SCT3_SIZE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:27] Those bits are used to configure the size of the fourth section for autoload operation on L1-Cache. Note that it should be used together with L1_CACHE_AUTOLOAD_SCT3_ADDR and L1_CACHE_AUTOLOAD_SCT3_ENA.
          L1_CACHE_AUTOLOAD_SCT3_SIZE: u28,

          /// [28:31] 
          res0: u4,

        }), @ptrFromInt(0x600c8154));

        /// Cache Access Counter Interrupt enable register
        pub const L1_CACHE_ACS_CNT_INT_ENA = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] The bit is used to enable interrupt of one of counters overflow that occurs in L1-ICache0 due to bus0 accesses L1-ICache0.
          L1_IBUS0_OVF_INT_ENA: u1,

          /// [1:1] The bit is used to enable interrupt of one of counters overflow that occurs in L1-ICache1 due to bus1 accesses L1-ICache1.
          L1_IBUS1_OVF_INT_ENA: u1,

          /// [2:2] Reserved
          L1_IBUS2_OVF_INT_ENA: u1,

          /// [3:3] Reserved
          L1_IBUS3_OVF_INT_ENA: u1,

          /// [4:4] The bit is used to enable interrupt of one of counters overflow that occurs in L1-DCache due to bus0 accesses L1-DCache.
          L1_BUS0_OVF_INT_ENA: u1,

          /// [5:5] The bit is used to enable interrupt of one of counters overflow that occurs in L1-DCache due to bus1 accesses L1-DCache.
          L1_BUS1_OVF_INT_ENA: u1,

          /// [6:6] Reserved
          L1_DBUS2_OVF_INT_ENA: u1,

          /// [7:7] Reserved
          L1_DBUS3_OVF_INT_ENA: u1,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x600c8158));

        /// Cache Access Counter Interrupt clear register
        pub const L1_CACHE_ACS_CNT_INT_CLR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] The bit is used to clear counters overflow interrupt and counters in L1-ICache0 due to bus0 accesses L1-ICache0.
          L1_IBUS0_OVF_INT_CLR: u1,

          /// [1:1] The bit is used to clear counters overflow interrupt and counters in L1-ICache1 due to bus1 accesses L1-ICache1.
          L1_IBUS1_OVF_INT_CLR: u1,

          /// [2:2] Reserved
          L1_IBUS2_OVF_INT_CLR: u1,

          /// [3:3] Reserved
          L1_IBUS3_OVF_INT_CLR: u1,

          /// [4:4] The bit is used to clear counters overflow interrupt and counters in L1-DCache due to bus0 accesses L1-DCache.
          L1_BUS0_OVF_INT_CLR: u1,

          /// [5:5] The bit is used to clear counters overflow interrupt and counters in L1-DCache due to bus1 accesses L1-DCache.
          L1_BUS1_OVF_INT_CLR: u1,

          /// [6:6] Reserved
          L1_DBUS2_OVF_INT_CLR: u1,

          /// [7:7] Reserved
          L1_DBUS3_OVF_INT_CLR: u1,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x600c815c));

        /// Cache Access Counter Interrupt raw register
        pub const L1_CACHE_ACS_CNT_INT_RAW = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] The raw bit of the interrupt of one of counters overflow that occurs in L1-ICache0 due to bus0 accesses L1-ICache0.
          L1_IBUS0_OVF_INT_RAW: u1,

          /// [1:1] The raw bit of the interrupt of one of counters overflow that occurs in L1-ICache1 due to bus1 accesses L1-ICache1.
          L1_IBUS1_OVF_INT_RAW: u1,

          /// [2:2] The raw bit of the interrupt of one of counters overflow that occurs in L1-ICache2 due to bus2 accesses L1-ICache2.
          L1_IBUS2_OVF_INT_RAW: u1,

          /// [3:3] The raw bit of the interrupt of one of counters overflow that occurs in L1-ICache3 due to bus3 accesses L1-ICache3.
          L1_IBUS3_OVF_INT_RAW: u1,

          /// [4:4] The raw bit of the interrupt of one of counters overflow that occurs in L1-DCache due to bus0 accesses L1-DCache.
          L1_BUS0_OVF_INT_RAW: u1,

          /// [5:5] The raw bit of the interrupt of one of counters overflow that occurs in L1-DCache due to bus1 accesses L1-DCache.
          L1_BUS1_OVF_INT_RAW: u1,

          /// [6:6] The raw bit of the interrupt of one of counters overflow that occurs in L1-DCache due to bus2 accesses L1-DCache.
          L1_DBUS2_OVF_INT_RAW: u1,

          /// [7:7] The raw bit of the interrupt of one of counters overflow that occurs in L1-DCache due to bus3 accesses L1-DCache.
          L1_DBUS3_OVF_INT_RAW: u1,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x600c8160));

        /// Cache Access Counter Interrupt status register
        pub const L1_CACHE_ACS_CNT_INT_ST = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] The bit indicates the interrupt status of one of counters overflow that occurs in L1-ICache0 due to bus0 accesses L1-ICache0.
          L1_IBUS0_OVF_INT_ST: u1,

          /// [1:1] The bit indicates the interrupt status of one of counters overflow that occurs in L1-ICache1 due to bus1 accesses L1-ICache1.
          L1_IBUS1_OVF_INT_ST: u1,

          /// [2:2] Reserved
          L1_IBUS2_OVF_INT_ST: u1,

          /// [3:3] Reserved
          L1_IBUS3_OVF_INT_ST: u1,

          /// [4:4] The bit indicates the interrupt status of one of counters overflow that occurs in L1-DCache due to bus0 accesses L1-DCache.
          L1_BUS0_OVF_INT_ST: u1,

          /// [5:5] The bit indicates the interrupt status of one of counters overflow that occurs in L1-DCache due to bus1 accesses L1-DCache.
          L1_BUS1_OVF_INT_ST: u1,

          /// [6:6] Reserved
          L1_DBUS2_OVF_INT_ST: u1,

          /// [7:7] Reserved
          L1_DBUS3_OVF_INT_ST: u1,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x600c8164));

        /// Cache Access Fail Interrupt enable register
        pub const L1_CACHE_ACS_FAIL_INT_ENA = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] The bit is used to enable interrupt of access fail that occurs in L1-ICache0 due to cpu accesses L1-ICache0.
          L1_ICACHE0_FAIL_INT_ENA: u1,

          /// [1:1] The bit is used to enable interrupt of access fail that occurs in L1-ICache1 due to cpu accesses L1-ICache1.
          L1_ICACHE1_FAIL_INT_ENA: u1,

          /// [2:2] Reserved
          L1_ICACHE2_FAIL_INT_ENA: u1,

          /// [3:3] Reserved
          L1_ICACHE3_FAIL_INT_ENA: u1,

          /// [4:4] The bit is used to enable interrupt of access fail that occurs in L1-DCache due to cpu accesses L1-DCache.
          L1_CACHE_FAIL_INT_ENA: u1,

          /// [5:31] 
          res0: u27,

        }), @ptrFromInt(0x600c8168));

        /// L1-Cache Access Fail Interrupt clear register
        pub const L1_CACHE_ACS_FAIL_INT_CLR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] The bit is used to clear interrupt of access fail that occurs in L1-ICache0 due to cpu accesses L1-ICache0.
          L1_ICACHE0_FAIL_INT_CLR: u1,

          /// [1:1] The bit is used to clear interrupt of access fail that occurs in L1-ICache1 due to cpu accesses L1-ICache1.
          L1_ICACHE1_FAIL_INT_CLR: u1,

          /// [2:2] Reserved
          L1_ICACHE2_FAIL_INT_CLR: u1,

          /// [3:3] Reserved
          L1_ICACHE3_FAIL_INT_CLR: u1,

          /// [4:4] The bit is used to clear interrupt of access fail that occurs in L1-DCache due to cpu accesses L1-DCache.
          L1_CACHE_FAIL_INT_CLR: u1,

          /// [5:31] 
          res0: u27,

        }), @ptrFromInt(0x600c816c));

        /// Cache Access Fail Interrupt raw register
        pub const L1_CACHE_ACS_FAIL_INT_RAW = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] The raw bit of the interrupt of access fail that occurs in L1-ICache0.
          L1_ICACHE0_FAIL_INT_RAW: u1,

          /// [1:1] The raw bit of the interrupt of access fail that occurs in L1-ICache1.
          L1_ICACHE1_FAIL_INT_RAW: u1,

          /// [2:2] The raw bit of the interrupt of access fail that occurs in L1-ICache2.
          L1_ICACHE2_FAIL_INT_RAW: u1,

          /// [3:3] The raw bit of the interrupt of access fail that occurs in L1-ICache3.
          L1_ICACHE3_FAIL_INT_RAW: u1,

          /// [4:4] The raw bit of the interrupt of access fail that occurs in L1-DCache.
          L1_CACHE_FAIL_INT_RAW: u1,

          /// [5:31] 
          res0: u27,

        }), @ptrFromInt(0x600c8170));

        /// Cache Access Fail Interrupt status register
        pub const L1_CACHE_ACS_FAIL_INT_ST = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] The bit indicates the interrupt status of access fail that occurs in L1-ICache0 due to cpu accesses L1-ICache.
          L1_ICACHE0_FAIL_INT_ST: u1,

          /// [1:1] The bit indicates the interrupt status of access fail that occurs in L1-ICache1 due to cpu accesses L1-ICache.
          L1_ICACHE1_FAIL_INT_ST: u1,

          /// [2:2] Reserved
          L1_ICACHE2_FAIL_INT_ST: u1,

          /// [3:3] Reserved
          L1_ICACHE3_FAIL_INT_ST: u1,

          /// [4:4] The bit indicates the interrupt status of access fail that occurs in L1-DCache due to cpu accesses L1-DCache.
          L1_CACHE_FAIL_INT_ST: u1,

          /// [5:31] 
          res0: u27,

        }), @ptrFromInt(0x600c8174));

        /// Cache Access Counter enable and clear register
        pub const L1_CACHE_ACS_CNT_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] The bit is used to enable ibus0 counter in L1-ICache0.
          L1_IBUS0_CNT_ENA: u1,

          /// [1:1] The bit is used to enable ibus1 counter in L1-ICache1.
          L1_IBUS1_CNT_ENA: u1,

          /// [2:2] Reserved
          L1_IBUS2_CNT_ENA: u1,

          /// [3:3] Reserved
          L1_IBUS3_CNT_ENA: u1,

          /// [4:4] The bit is used to enable dbus0 counter in L1-DCache.
          L1_BUS0_CNT_ENA: u1,

          /// [5:5] The bit is used to enable dbus1 counter in L1-DCache.
          L1_BUS1_CNT_ENA: u1,

          /// [6:6] Reserved
          L1_DBUS2_CNT_ENA: u1,

          /// [7:7] Reserved
          L1_DBUS3_CNT_ENA: u1,

          /// [8:15] 
          res0: u8,

          /// [16:16] The bit is used to clear ibus0 counter in L1-ICache0.
          L1_IBUS0_CNT_CLR: u1,

          /// [17:17] The bit is used to clear ibus1 counter in L1-ICache1.
          L1_IBUS1_CNT_CLR: u1,

          /// [18:18] Reserved
          L1_IBUS2_CNT_CLR: u1,

          /// [19:19] Reserved
          L1_IBUS3_CNT_CLR: u1,

          /// [20:20] The bit is used to clear dbus0 counter in L1-DCache.
          L1_BUS0_CNT_CLR: u1,

          /// [21:21] The bit is used to clear dbus1 counter in L1-DCache.
          L1_BUS1_CNT_CLR: u1,

          /// [22:22] Reserved
          L1_DBUS2_CNT_CLR: u1,

          /// [23:23] Reserved
          L1_DBUS3_CNT_CLR: u1,

          /// [24:31] 
          res1: u8,

        }), @ptrFromInt(0x600c8178));

        /// L1-ICache bus0 Hit-Access Counter register
        pub const L1_IBUS0_ACS_HIT_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] The register records the number of hits when bus0 accesses L1-ICache0.
          L1_IBUS0_HIT_CNT: u32,

        }), @ptrFromInt(0x600c817c));

        /// L1-ICache bus0 Miss-Access Counter register
        pub const L1_IBUS0_ACS_MISS_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] The register records the number of missing when bus0 accesses L1-ICache0.
          L1_IBUS0_MISS_CNT: u32,

        }), @ptrFromInt(0x600c8180));

        /// L1-ICache bus0 Conflict-Access Counter register
        pub const L1_IBUS0_ACS_CONFLICT_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] The register records the number of access-conflicts when bus0 accesses L1-ICache0.
          L1_IBUS0_CONFLICT_CNT: u32,

        }), @ptrFromInt(0x600c8184));

        /// L1-ICache bus0 Next-Level-Access Counter register
        pub const L1_IBUS0_ACS_NXTLVL_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] The register records the number of times that L1-ICache accesses L2-Cache due to bus0 accessing L1-ICache0.
          L1_IBUS0_NXTLVL_CNT: u32,

        }), @ptrFromInt(0x600c8188));

        /// L1-ICache bus1 Hit-Access Counter register
        pub const L1_IBUS1_ACS_HIT_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] The register records the number of hits when bus1 accesses L1-ICache1.
          L1_IBUS1_HIT_CNT: u32,

        }), @ptrFromInt(0x600c818c));

        /// L1-ICache bus1 Miss-Access Counter register
        pub const L1_IBUS1_ACS_MISS_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] The register records the number of missing when bus1 accesses L1-ICache1.
          L1_IBUS1_MISS_CNT: u32,

        }), @ptrFromInt(0x600c8190));

        /// L1-ICache bus1 Conflict-Access Counter register
        pub const L1_IBUS1_ACS_CONFLICT_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] The register records the number of access-conflicts when bus1 accesses L1-ICache1.
          L1_IBUS1_CONFLICT_CNT: u32,

        }), @ptrFromInt(0x600c8194));

        /// L1-ICache bus1 Next-Level-Access Counter register
        pub const L1_IBUS1_ACS_NXTLVL_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] The register records the number of times that L1-ICache accesses L2-Cache due to bus1 accessing L1-ICache1.
          L1_IBUS1_NXTLVL_CNT: u32,

        }), @ptrFromInt(0x600c8198));

        /// L1-ICache bus2 Hit-Access Counter register
        pub const L1_IBUS2_ACS_HIT_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] The register records the number of hits when bus2 accesses L1-ICache2.
          L1_IBUS2_HIT_CNT: u32,

        }), @ptrFromInt(0x600c819c));

        /// L1-ICache bus2 Miss-Access Counter register
        pub const L1_IBUS2_ACS_MISS_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] The register records the number of missing when bus2 accesses L1-ICache2.
          L1_IBUS2_MISS_CNT: u32,

        }), @ptrFromInt(0x600c81a0));

        /// L1-ICache bus2 Conflict-Access Counter register
        pub const L1_IBUS2_ACS_CONFLICT_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] The register records the number of access-conflicts when bus2 accesses L1-ICache2.
          L1_IBUS2_CONFLICT_CNT: u32,

        }), @ptrFromInt(0x600c81a4));

        /// L1-ICache bus2 Next-Level-Access Counter register
        pub const L1_IBUS2_ACS_NXTLVL_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] The register records the number of times that L1-ICache accesses L2-Cache due to bus2 accessing L1-ICache2.
          L1_IBUS2_NXTLVL_CNT: u32,

        }), @ptrFromInt(0x600c81a8));

        /// L1-ICache bus3 Hit-Access Counter register
        pub const L1_IBUS3_ACS_HIT_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] The register records the number of hits when bus3 accesses L1-ICache3.
          L1_IBUS3_HIT_CNT: u32,

        }), @ptrFromInt(0x600c81ac));

        /// L1-ICache bus3 Miss-Access Counter register
        pub const L1_IBUS3_ACS_MISS_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] The register records the number of missing when bus3 accesses L1-ICache3.
          L1_IBUS3_MISS_CNT: u32,

        }), @ptrFromInt(0x600c81b0));

        /// L1-ICache bus3 Conflict-Access Counter register
        pub const L1_IBUS3_ACS_CONFLICT_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] The register records the number of access-conflicts when bus3 accesses L1-ICache3.
          L1_IBUS3_CONFLICT_CNT: u32,

        }), @ptrFromInt(0x600c81b4));

        /// L1-ICache bus3 Next-Level-Access Counter register
        pub const L1_IBUS3_ACS_NXTLVL_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] The register records the number of times that L1-ICache accesses L2-Cache due to bus3 accessing L1-ICache3.
          L1_IBUS3_NXTLVL_CNT: u32,

        }), @ptrFromInt(0x600c81b8));

        /// L1-Cache bus0 Hit-Access Counter register
        pub const L1_BUS0_ACS_HIT_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] The register records the number of hits when bus0 accesses L1-Cache.
          L1_BUS0_HIT_CNT: u32,

        }), @ptrFromInt(0x600c81bc));

        /// L1-Cache bus0 Miss-Access Counter register
        pub const L1_BUS0_ACS_MISS_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] The register records the number of missing when bus0 accesses L1-Cache.
          L1_BUS0_MISS_CNT: u32,

        }), @ptrFromInt(0x600c81c0));

        /// L1-Cache bus0 Conflict-Access Counter register
        pub const L1_BUS0_ACS_CONFLICT_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] The register records the number of access-conflicts when bus0 accesses L1-Cache.
          L1_BUS0_CONFLICT_CNT: u32,

        }), @ptrFromInt(0x600c81c4));

        /// L1-Cache bus0 Next-Level-Access Counter register
        pub const L1_BUS0_ACS_NXTLVL_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] The register records the number of times that L1-Cache accesses L2-Cache due to bus0 accessing L1-Cache.
          L1_BUS0_NXTLVL_CNT: u32,

        }), @ptrFromInt(0x600c81c8));

        /// L1-Cache bus1 Hit-Access Counter register
        pub const L1_BUS1_ACS_HIT_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] The register records the number of hits when bus1 accesses L1-Cache.
          L1_BUS1_HIT_CNT: u32,

        }), @ptrFromInt(0x600c81cc));

        /// L1-Cache bus1 Miss-Access Counter register
        pub const L1_BUS1_ACS_MISS_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] The register records the number of missing when bus1 accesses L1-Cache.
          L1_BUS1_MISS_CNT: u32,

        }), @ptrFromInt(0x600c81d0));

        /// L1-Cache bus1 Conflict-Access Counter register
        pub const L1_BUS1_ACS_CONFLICT_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] The register records the number of access-conflicts when bus1 accesses L1-Cache.
          L1_BUS1_CONFLICT_CNT: u32,

        }), @ptrFromInt(0x600c81d4));

        /// L1-Cache bus1 Next-Level-Access Counter register
        pub const L1_BUS1_ACS_NXTLVL_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] The register records the number of times that L1-Cache accesses L2-Cache due to bus1 accessing L1-Cache.
          L1_BUS1_NXTLVL_CNT: u32,

        }), @ptrFromInt(0x600c81d8));

        /// L1-DCache bus2 Hit-Access Counter register
        pub const L1_DBUS2_ACS_HIT_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] The register records the number of hits when bus2 accesses L1-DCache.
          L1_DBUS2_HIT_CNT: u32,

        }), @ptrFromInt(0x600c81dc));

        /// L1-DCache bus2 Miss-Access Counter register
        pub const L1_DBUS2_ACS_MISS_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] The register records the number of missing when bus2 accesses L1-DCache.
          L1_DBUS2_MISS_CNT: u32,

        }), @ptrFromInt(0x600c81e0));

        /// L1-DCache bus2 Conflict-Access Counter register
        pub const L1_DBUS2_ACS_CONFLICT_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] The register records the number of access-conflicts when bus2 accesses L1-DCache.
          L1_DBUS2_CONFLICT_CNT: u32,

        }), @ptrFromInt(0x600c81e4));

        /// L1-DCache bus2 Next-Level-Access Counter register
        pub const L1_DBUS2_ACS_NXTLVL_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] The register records the number of times that L1-DCache accesses L2-Cache due to bus2 accessing L1-DCache.
          L1_DBUS2_NXTLVL_CNT: u32,

        }), @ptrFromInt(0x600c81e8));

        /// L1-DCache bus3 Hit-Access Counter register
        pub const L1_DBUS3_ACS_HIT_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] The register records the number of hits when bus3 accesses L1-DCache.
          L1_DBUS3_HIT_CNT: u32,

        }), @ptrFromInt(0x600c81ec));

        /// L1-DCache bus3 Miss-Access Counter register
        pub const L1_DBUS3_ACS_MISS_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] The register records the number of missing when bus3 accesses L1-DCache.
          L1_DBUS3_MISS_CNT: u32,

        }), @ptrFromInt(0x600c81f0));

        /// L1-DCache bus3 Conflict-Access Counter register
        pub const L1_DBUS3_ACS_CONFLICT_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] The register records the number of access-conflicts when bus3 accesses L1-DCache.
          L1_DBUS3_CONFLICT_CNT: u32,

        }), @ptrFromInt(0x600c81f4));

        /// L1-DCache bus3 Next-Level-Access Counter register
        pub const L1_DBUS3_ACS_NXTLVL_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] The register records the number of times that L1-DCache accesses L2-Cache due to bus3 accessing L1-DCache.
          L1_DBUS3_NXTLVL_CNT: u32,

        }), @ptrFromInt(0x600c81f8));

        /// L1-ICache0 Access Fail ID/attribution information register
        pub const L1_ICACHE0_ACS_FAIL_ID_ATTR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:15] The register records the ID of fail-access when cache0 accesses L1-ICache.
          L1_ICACHE0_FAIL_ID: u16,

          /// [16:31] The register records the attribution of fail-access when cache0 accesses L1-ICache.
          L1_ICACHE0_FAIL_ATTR: u16,

        }), @ptrFromInt(0x600c81fc));

        /// L1-ICache0 Access Fail Address information register
        pub const L1_ICACHE0_ACS_FAIL_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] The register records the address of fail-access when cache0 accesses L1-ICache.
          L1_ICACHE0_FAIL_ADDR: u32,

        }), @ptrFromInt(0x600c8200));

        /// L1-ICache0 Access Fail ID/attribution information register
        pub const L1_ICACHE1_ACS_FAIL_ID_ATTR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:15] The register records the ID of fail-access when cache1 accesses L1-ICache.
          L1_ICACHE1_FAIL_ID: u16,

          /// [16:31] The register records the attribution of fail-access when cache1 accesses L1-ICache.
          L1_ICACHE1_FAIL_ATTR: u16,

        }), @ptrFromInt(0x600c8204));

        /// L1-ICache0 Access Fail Address information register
        pub const L1_ICACHE1_ACS_FAIL_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] The register records the address of fail-access when cache1 accesses L1-ICache.
          L1_ICACHE1_FAIL_ADDR: u32,

        }), @ptrFromInt(0x600c8208));

        /// L1-ICache0 Access Fail ID/attribution information register
        pub const L1_ICACHE2_ACS_FAIL_ID_ATTR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:15] The register records the ID of fail-access when cache2 accesses L1-ICache.
          L1_ICACHE2_FAIL_ID: u16,

          /// [16:31] The register records the attribution of fail-access when cache2 accesses L1-ICache.
          L1_ICACHE2_FAIL_ATTR: u16,

        }), @ptrFromInt(0x600c820c));

        /// L1-ICache0 Access Fail Address information register
        pub const L1_ICACHE2_ACS_FAIL_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] The register records the address of fail-access when cache2 accesses L1-ICache.
          L1_ICACHE2_FAIL_ADDR: u32,

        }), @ptrFromInt(0x600c8210));

        /// L1-ICache0 Access Fail ID/attribution information register
        pub const L1_ICACHE3_ACS_FAIL_ID_ATTR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:15] The register records the ID of fail-access when cache3 accesses L1-ICache.
          L1_ICACHE3_FAIL_ID: u16,

          /// [16:31] The register records the attribution of fail-access when cache3 accesses L1-ICache.
          L1_ICACHE3_FAIL_ATTR: u16,

        }), @ptrFromInt(0x600c8214));

        /// L1-ICache0 Access Fail Address information register
        pub const L1_ICACHE3_ACS_FAIL_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] The register records the address of fail-access when cache3 accesses L1-ICache.
          L1_ICACHE3_FAIL_ADDR: u32,

        }), @ptrFromInt(0x600c8218));

        /// L1-Cache Access Fail ID/attribution information register
        pub const L1_CACHE_ACS_FAIL_ID_ATTR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:15] The register records the ID of fail-access when cache accesses L1-Cache.
          L1_CACHE_FAIL_ID: u16,

          /// [16:31] The register records the attribution of fail-access when cache accesses L1-Cache.
          L1_CACHE_FAIL_ATTR: u16,

        }), @ptrFromInt(0x600c821c));

        /// L1-Cache Access Fail Address information register
        pub const L1_DCACHE_ACS_FAIL_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] The register records the address of fail-access when cache accesses L1-Cache.
          L1_CACHE_FAIL_ADDR: u32,

        }), @ptrFromInt(0x600c8220));

        /// L1-Cache Access Fail Interrupt enable register
        pub const L1_CACHE_SYNC_PRELOAD_INT_ENA = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] The bit is used to enable interrupt of L1-ICache0 preload-operation. If preload operation is done, interrupt occurs.
          L1_ICACHE0_PLD_DONE_INT_ENA: u1,

          /// [1:1] The bit is used to enable interrupt of L1-ICache1 preload-operation. If preload operation is done, interrupt occurs.
          L1_ICACHE1_PLD_DONE_INT_ENA: u1,

          /// [2:2] Reserved
          L1_ICACHE2_PLD_DONE_INT_ENA: u1,

          /// [3:3] Reserved
          L1_ICACHE3_PLD_DONE_INT_ENA: u1,

          /// [4:4] The bit is used to enable interrupt of L1-Cache preload-operation. If preload operation is done, interrupt occurs.
          L1_CACHE_PLD_DONE_INT_ENA: u1,

          /// [5:5] 
          res0: u1,

          /// [6:6] The bit is used to enable interrupt of Cache sync-operation done.
          CACHE_SYNC_DONE_INT_ENA: u1,

          /// [7:7] The bit is used to enable interrupt of L1-ICache0 preload-operation error.
          L1_ICACHE0_PLD_ERR_INT_ENA: u1,

          /// [8:8] The bit is used to enable interrupt of L1-ICache1 preload-operation error.
          L1_ICACHE1_PLD_ERR_INT_ENA: u1,

          /// [9:9] Reserved
          L1_ICACHE2_PLD_ERR_INT_ENA: u1,

          /// [10:10] Reserved
          L1_ICACHE3_PLD_ERR_INT_ENA: u1,

          /// [11:11] The bit is used to enable interrupt of L1-Cache preload-operation error.
          L1_CACHE_PLD_ERR_INT_ENA: u1,

          /// [12:12] 
          res1: u1,

          /// [13:13] The bit is used to enable interrupt of Cache sync-operation error.
          CACHE_SYNC_ERR_INT_ENA: u1,

          /// [14:31] 
          res2: u18,

        }), @ptrFromInt(0x600c8224));

        /// Sync Preload operation Interrupt clear register
        pub const L1_CACHE_SYNC_PRELOAD_INT_CLR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] The bit is used to clear interrupt that occurs only when L1-ICache0 preload-operation is done.
          L1_ICACHE0_PLD_DONE_INT_CLR: u1,

          /// [1:1] The bit is used to clear interrupt that occurs only when L1-ICache1 preload-operation is done.
          L1_ICACHE1_PLD_DONE_INT_CLR: u1,

          /// [2:2] Reserved
          L1_ICACHE2_PLD_DONE_INT_CLR: u1,

          /// [3:3] Reserved
          L1_ICACHE3_PLD_DONE_INT_CLR: u1,

          /// [4:4] The bit is used to clear interrupt that occurs only when L1-Cache preload-operation is done.
          L1_CACHE_PLD_DONE_INT_CLR: u1,

          /// [5:5] 
          res0: u1,

          /// [6:6] The bit is used to clear interrupt that occurs only when Cache sync-operation is done.
          CACHE_SYNC_DONE_INT_CLR: u1,

          /// [7:7] The bit is used to clear interrupt of L1-ICache0 preload-operation error.
          L1_ICACHE0_PLD_ERR_INT_CLR: u1,

          /// [8:8] The bit is used to clear interrupt of L1-ICache1 preload-operation error.
          L1_ICACHE1_PLD_ERR_INT_CLR: u1,

          /// [9:9] Reserved
          L1_ICACHE2_PLD_ERR_INT_CLR: u1,

          /// [10:10] Reserved
          L1_ICACHE3_PLD_ERR_INT_CLR: u1,

          /// [11:11] The bit is used to clear interrupt of L1-Cache preload-operation error.
          L1_CACHE_PLD_ERR_INT_CLR: u1,

          /// [12:12] 
          res1: u1,

          /// [13:13] The bit is used to clear interrupt of Cache sync-operation error.
          CACHE_SYNC_ERR_INT_CLR: u1,

          /// [14:31] 
          res2: u18,

        }), @ptrFromInt(0x600c8228));

        /// Sync Preload operation Interrupt raw register
        pub const L1_CACHE_SYNC_PRELOAD_INT_RAW = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] The raw bit of the interrupt that occurs only when L1-ICache0 preload-operation is done.
          L1_ICACHE0_PLD_DONE_INT_RAW: u1,

          /// [1:1] The raw bit of the interrupt that occurs only when L1-ICache1 preload-operation is done.
          L1_ICACHE1_PLD_DONE_INT_RAW: u1,

          /// [2:2] Reserved
          L1_ICACHE2_PLD_DONE_INT_RAW: u1,

          /// [3:3] Reserved
          L1_ICACHE3_PLD_DONE_INT_RAW: u1,

          /// [4:4] The raw bit of the interrupt that occurs only when L1-Cache preload-operation is done.
          L1_CACHE_PLD_DONE_INT_RAW: u1,

          /// [5:5] 
          res0: u1,

          /// [6:6] The raw bit of the interrupt that occurs only when Cache sync-operation is done.
          CACHE_SYNC_DONE_INT_RAW: u1,

          /// [7:7] The raw bit of the interrupt that occurs only when L1-ICache0 preload-operation error occurs.
          L1_ICACHE0_PLD_ERR_INT_RAW: u1,

          /// [8:8] The raw bit of the interrupt that occurs only when L1-ICache1 preload-operation error occurs.
          L1_ICACHE1_PLD_ERR_INT_RAW: u1,

          /// [9:9] Reserved
          L1_ICACHE2_PLD_ERR_INT_RAW: u1,

          /// [10:10] Reserved
          L1_ICACHE3_PLD_ERR_INT_RAW: u1,

          /// [11:11] The raw bit of the interrupt that occurs only when L1-Cache preload-operation error occurs.
          L1_CACHE_PLD_ERR_INT_RAW: u1,

          /// [12:12] 
          res1: u1,

          /// [13:13] The raw bit of the interrupt that occurs only when Cache sync-operation error occurs.
          CACHE_SYNC_ERR_INT_RAW: u1,

          /// [14:31] 
          res2: u18,

        }), @ptrFromInt(0x600c822c));

        /// L1-Cache Access Fail Interrupt status register
        pub const L1_CACHE_SYNC_PRELOAD_INT_ST = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] The bit indicates the status of the interrupt that occurs only when L1-ICache0 preload-operation is done.
          L1_ICACHE0_PLD_DONE_INT_ST: u1,

          /// [1:1] The bit indicates the status of the interrupt that occurs only when L1-ICache1 preload-operation is done.
          L1_ICACHE1_PLD_DONE_INT_ST: u1,

          /// [2:2] Reserved
          L1_ICACHE2_PLD_DONE_INT_ST: u1,

          /// [3:3] Reserved
          L1_ICACHE3_PLD_DONE_INT_ST: u1,

          /// [4:4] The bit indicates the status of the interrupt that occurs only when L1-Cache preload-operation is done.
          L1_CACHE_PLD_DONE_INT_ST: u1,

          /// [5:5] 
          res0: u1,

          /// [6:6] The bit indicates the status of the interrupt that occurs only when Cache sync-operation is done.
          CACHE_SYNC_DONE_INT_ST: u1,

          /// [7:7] The bit indicates the status of the interrupt of L1-ICache0 preload-operation error.
          L1_ICACHE0_PLD_ERR_INT_ST: u1,

          /// [8:8] The bit indicates the status of the interrupt of L1-ICache1 preload-operation error.
          L1_ICACHE1_PLD_ERR_INT_ST: u1,

          /// [9:9] Reserved
          L1_ICACHE2_PLD_ERR_INT_ST: u1,

          /// [10:10] Reserved
          L1_ICACHE3_PLD_ERR_INT_ST: u1,

          /// [11:11] The bit indicates the status of the interrupt of L1-Cache preload-operation error.
          L1_CACHE_PLD_ERR_INT_ST: u1,

          /// [12:12] 
          res1: u1,

          /// [13:13] The bit indicates the status of the interrupt of Cache sync-operation error.
          CACHE_SYNC_ERR_INT_ST: u1,

          /// [14:31] 
          res2: u18,

        }), @ptrFromInt(0x600c8230));

        /// Cache Sync/Preload Operation exception register
        pub const L1_CACHE_SYNC_PRELOAD_EXCEPTION = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:1] The value 2 is Only available which means preload size is error in L1-ICache0.
          L1_ICACHE0_PLD_ERR_CODE: u2,

          /// [2:3] The value 2 is Only available which means preload size is error in L1-ICache1.
          L1_ICACHE1_PLD_ERR_CODE: u2,

          /// [4:5] Reserved
          L1_ICACHE2_PLD_ERR_CODE: u2,

          /// [6:7] Reserved
          L1_ICACHE3_PLD_ERR_CODE: u2,

          /// [8:9] The value 2 is Only available which means preload size is error in L1-Cache.
          L1_CACHE_PLD_ERR_CODE: u2,

          /// [10:11] 
          res0: u2,

          /// [12:13] The values 0-2 are available which means sync map, command conflict and size are error in Cache System.
          CACHE_SYNC_ERR_CODE: u2,

          /// [14:31] 
          res1: u18,

        }), @ptrFromInt(0x600c8234));

        /// Cache Sync Reset control register
        pub const L1_CACHE_SYNC_RST_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] set this bit to reset sync-logic inside L1-ICache0. Recommend that this should only be used to initialize sync-logic when some fatal error of sync-logic occurs.
          L1_ICACHE0_SYNC_RST: u1,

          /// [1:1] set this bit to reset sync-logic inside L1-ICache1. Recommend that this should only be used to initialize sync-logic when some fatal error of sync-logic occurs.
          L1_ICACHE1_SYNC_RST: u1,

          /// [2:2] Reserved
          L1_ICACHE2_SYNC_RST: u1,

          /// [3:3] Reserved
          L1_ICACHE3_SYNC_RST: u1,

          /// [4:4] set this bit to reset sync-logic inside L1-Cache. Recommend that this should only be used to initialize sync-logic when some fatal error of sync-logic occurs.
          L1_CACHE_SYNC_RST: u1,

          /// [5:31] 
          res0: u27,

        }), @ptrFromInt(0x600c8238));

        /// Cache Preload Reset control register
        pub const L1_CACHE_PRELOAD_RST_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] set this bit to reset preload-logic inside L1-ICache0. Recommend that this should only be used to initialize preload-logic when some fatal error of preload-logic occurs.
          L1_ICACHE0_PLD_RST: u1,

          /// [1:1] set this bit to reset preload-logic inside L1-ICache1. Recommend that this should only be used to initialize preload-logic when some fatal error of preload-logic occurs.
          L1_ICACHE1_PLD_RST: u1,

          /// [2:2] Reserved
          L1_ICACHE2_PLD_RST: u1,

          /// [3:3] Reserved
          L1_ICACHE3_PLD_RST: u1,

          /// [4:4] set this bit to reset preload-logic inside L1-Cache. Recommend that this should only be used to initialize preload-logic when some fatal error of preload-logic occurs.
          L1_CACHE_PLD_RST: u1,

          /// [5:31] 
          res0: u27,

        }), @ptrFromInt(0x600c823c));

        /// Cache Autoload buffer clear control register
        pub const L1_CACHE_AUTOLOAD_BUF_CLR_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] set this bit to clear autoload-buffer inside L1-ICache0. If this bit is active, autoload will not work in L1-ICache0. This bit should not be active when autoload works in L1-ICache0.
          L1_ICACHE0_ALD_BUF_CLR: u1,

          /// [1:1] set this bit to clear autoload-buffer inside L1-ICache1. If this bit is active, autoload will not work in L1-ICache1. This bit should not be active when autoload works in L1-ICache1.
          L1_ICACHE1_ALD_BUF_CLR: u1,

          /// [2:2] Reserved
          L1_ICACHE2_ALD_BUF_CLR: u1,

          /// [3:3] Reserved
          L1_ICACHE3_ALD_BUF_CLR: u1,

          /// [4:4] set this bit to clear autoload-buffer inside L1-Cache. If this bit is active, autoload will not work in L1-Cache. This bit should not be active when autoload works in L1-Cache.
          L1_CACHE_ALD_BUF_CLR: u1,

          /// [5:31] 
          res0: u27,

        }), @ptrFromInt(0x600c8240));

        /// Unallocate request buffer clear registers
        pub const L1_UNALLOCATE_BUFFER_CLEAR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] The bit is used to clear the unallocate request buffer of l1 icache0 where the unallocate request is responsed but not completed.
          L1_ICACHE0_UNALLOC_CLR: u1,

          /// [1:1] The bit is used to clear the unallocate request buffer of l1 icache1 where the unallocate request is responsed but not completed.
          L1_ICACHE1_UNALLOC_CLR: u1,

          /// [2:2] Reserved
          L1_ICACHE2_UNALLOC_CLR: u1,

          /// [3:3] Reserved
          L1_ICACHE3_UNALLOC_CLR: u1,

          /// [4:4] The bit is used to clear the unallocate request buffer of l1 cache where the unallocate request is responsed but not completed.
          L1_CACHE_UNALLOC_CLR: u1,

          /// [5:31] 
          res0: u27,

        }), @ptrFromInt(0x600c8244));

        /// Cache Tag and Data memory Object control register
        pub const L1_CACHE_OBJECT_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Set this bit to set L1-ICache0 tag memory as object. This bit should be onehot with the others fields inside this register.
          L1_ICACHE0_TAG_OBJECT: u1,

          /// [1:1] Set this bit to set L1-ICache1 tag memory as object. This bit should be onehot with the others fields inside this register.
          L1_ICACHE1_TAG_OBJECT: u1,

          /// [2:2] Reserved
          L1_ICACHE2_TAG_OBJECT: u1,

          /// [3:3] Reserved
          L1_ICACHE3_TAG_OBJECT: u1,

          /// [4:4] Set this bit to set L1-Cache tag memory as object. This bit should be onehot with the others fields inside this register.
          L1_CACHE_TAG_OBJECT: u1,

          /// [5:5] 
          res0: u1,

          /// [6:6] Set this bit to set L1-ICache0 data memory as object. This bit should be onehot with the others fields inside this register.
          L1_ICACHE0_MEM_OBJECT: u1,

          /// [7:7] Set this bit to set L1-ICache1 data memory as object. This bit should be onehot with the others fields inside this register.
          L1_ICACHE1_MEM_OBJECT: u1,

          /// [8:8] Reserved
          L1_ICACHE2_MEM_OBJECT: u1,

          /// [9:9] Reserved
          L1_ICACHE3_MEM_OBJECT: u1,

          /// [10:10] Set this bit to set L1-Cache data memory as object. This bit should be onehot with the others fields inside this register.
          L1_CACHE_MEM_OBJECT: u1,

          /// [11:31] 
          res1: u21,

        }), @ptrFromInt(0x600c8248));

        /// Cache Tag and Data memory way register
        pub const L1_CACHE_WAY_OBJECT = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:2] Set this bits to select which way of the tag-object will be accessed. 0: way0, 1: way1, 2: way2, 3: way3, ?, 7: way7.
          L1_CACHE_WAY_OBJECT: u3,

          /// [3:31] 
          res0: u29,

        }), @ptrFromInt(0x600c824c));

        /// Cache Vaddr register
        pub const L1_CACHE_VADDR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Those bits stores the virtual address which will decide where inside the specified tag memory object will be accessed.
          L1_CACHE_VADDR: u32,

        }), @ptrFromInt(0x600c8250));

        /// Cache Tag/data memory content register
        pub const L1_CACHE_DEBUG_BUS = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] This is a constant place where we can write data to or read data from the tag/data memory on the specified cache.
          L1_CACHE_DEBUG_BUS: u32,

        }), @ptrFromInt(0x600c8254));

        /// USED TO SPLIT L1 CACHE AND L2 CACHE
        pub const LEVEL_SPLIT0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Reserved
          LEVEL_SPLIT0: u32,

        }), @ptrFromInt(0x600c8258));

        /// L2 Cache(L2-Cache) control register
        pub const L2_CACHE_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:3] 
          res0: u4,

          /// [4:4] The bit is used to disable DMA access L2-Cache, 0: enable, 1: disable
          L2_CACHE_SHUT_DMA: u1,

          /// [5:8] Reserved
          L2_CACHE_UNDEF_OP: u4,

          /// [9:31] 
          res1: u23,

        }), @ptrFromInt(0x600c825c));

        /// Bypass Cache configure register
        pub const L2_BYPASS_CACHE_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:4] 
          res0: u5,

          /// [5:5] The bit is used to enable bypass L2-Cache. 0: disable bypass, 1: enable bypass.
          BYPASS_L2_CACHE_EN: u1,

          /// [6:31] 
          res1: u26,

        }), @ptrFromInt(0x600c8260));

        /// L2 Cache CacheSize mode configure register
        pub const L2_CACHE_CACHESIZE_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] The field is used to configure cachesize of L2-Cache as 1k bytes. This field and all other fields within this register is onehot.
          L2_CACHE_CACHESIZE_1K: u1,

          /// [1:1] The field is used to configure cachesize of L2-Cache as 2k bytes. This field and all other fields within this register is onehot.
          L2_CACHE_CACHESIZE_2K: u1,

          /// [2:2] The field is used to configure cachesize of L2-Cache as 4k bytes. This field and all other fields within this register is onehot.
          L2_CACHE_CACHESIZE_4K: u1,

          /// [3:3] The field is used to configure cachesize of L2-Cache as 8k bytes. This field and all other fields within this register is onehot.
          L2_CACHE_CACHESIZE_8K: u1,

          /// [4:4] The field is used to configure cachesize of L2-Cache as 16k bytes. This field and all other fields within this register is onehot.
          L2_CACHE_CACHESIZE_16K: u1,

          /// [5:5] The field is used to configure cachesize of L2-Cache as 32k bytes. This field and all other fields within this register is onehot.
          L2_CACHE_CACHESIZE_32K: u1,

          /// [6:6] The field is used to configure cachesize of L2-Cache as 64k bytes. This field and all other fields within this register is onehot.
          L2_CACHE_CACHESIZE_64K: u1,

          /// [7:7] The field is used to configure cachesize of L2-Cache as 128k bytes. This field and all other fields within this register is onehot.
          L2_CACHE_CACHESIZE_128K: u1,

          /// [8:8] The field is used to configure cachesize of L2-Cache as 256k bytes. This field and all other fields within this register is onehot.
          L2_CACHE_CACHESIZE_256K: u1,

          /// [9:9] The field is used to configure cachesize of L2-Cache as 512k bytes. This field and all other fields within this register is onehot.
          L2_CACHE_CACHESIZE_512K: u1,

          /// [10:10] The field is used to configure cachesize of L2-Cache as 1024k bytes. This field and all other fields within this register is onehot.
          L2_CACHE_CACHESIZE_1024K: u1,

          /// [11:11] The field is used to configure cachesize of L2-Cache as 2048k bytes. This field and all other fields within this register is onehot.
          L2_CACHE_CACHESIZE_2048K: u1,

          /// [12:12] The field is used to configure cachesize of L2-Cache as 4096k bytes. This field and all other fields within this register is onehot.
          L2_CACHE_CACHESIZE_4096K: u1,

          /// [13:31] 
          res0: u19,

        }), @ptrFromInt(0x600c8264));

        /// L2 Cache BlockSize mode configure register
        pub const L2_CACHE_BLOCKSIZE_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] The field is used to configureblocksize of L2-Cache as 8 bytes. This field and all other fields within this register is onehot.
          L2_CACHE_BLOCKSIZE_8: u1,

          /// [1:1] The field is used to configureblocksize of L2-Cache as 16 bytes. This field and all other fields within this register is onehot.
          L2_CACHE_BLOCKSIZE_16: u1,

          /// [2:2] The field is used to configureblocksize of L2-Cache as 32 bytes. This field and all other fields within this register is onehot.
          L2_CACHE_BLOCKSIZE_32: u1,

          /// [3:3] The field is used to configureblocksize of L2-Cache as 64 bytes. This field and all other fields within this register is onehot.
          L2_CACHE_BLOCKSIZE_64: u1,

          /// [4:4] The field is used to configureblocksize of L2-Cache as 128 bytes. This field and all other fields within this register is onehot.
          L2_CACHE_BLOCKSIZE_128: u1,

          /// [5:5] The field is used to configureblocksize of L2-Cache as 256 bytes. This field and all other fields within this register is onehot.
          L2_CACHE_BLOCKSIZE_256: u1,

          /// [6:31] 
          res0: u26,

        }), @ptrFromInt(0x600c8268));

        /// Cache wrap around control register
        pub const L2_CACHE_WRAP_AROUND_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:4] 
          res0: u5,

          /// [5:5] Set this bit as 1 to enable L2-Cache wrap around mode.
          L2_CACHE_WRAP: u1,

          /// [6:31] 
          res1: u26,

        }), @ptrFromInt(0x600c826c));

        /// Cache tag memory power control register
        pub const L2_CACHE_TAG_MEM_POWER_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:19] 
          res0: u20,

          /// [20:20] The bit is used to close clock gating ofL2-Cache tag memory. 1: close gating, 0: open clock gating.
          L2_CACHE_TAG_MEM_FORCE_ON: u1,

          /// [21:21] The bit is used to power L2-Cache tag memory down. 0: follow rtc_lslp, 1: power down
          L2_CACHE_TAG_MEM_FORCE_PD: u1,

          /// [22:22] The bit is used to power L2-Cache tag memory up. 0: follow rtc_lslp, 1: power up
          L2_CACHE_TAG_MEM_FORCE_PU: u1,

          /// [23:31] 
          res1: u9,

        }), @ptrFromInt(0x600c8270));

        /// Cache data memory power control register
        pub const L2_CACHE_DATA_MEM_POWER_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:19] 
          res0: u20,

          /// [20:20] The bit is used to close clock gating ofL2-Cache data memory. 1: close gating, 0: open clock gating.
          L2_CACHE_DATA_MEM_FORCE_ON: u1,

          /// [21:21] The bit is used to power L2-Cache data memory down. 0: follow rtc_lslp, 1: power down
          L2_CACHE_DATA_MEM_FORCE_PD: u1,

          /// [22:22] The bit is used to power L2-Cache data memory up. 0: follow rtc_lslp, 1: power up
          L2_CACHE_DATA_MEM_FORCE_PU: u1,

          /// [23:31] 
          res1: u9,

        }), @ptrFromInt(0x600c8274));

        /// Cache Freeze control register
        pub const L2_CACHE_FREEZE_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:19] 
          res0: u20,

          /// [20:20] The bit is used to enable freeze operation on L2-Cache. It can be cleared by software.
          L2_CACHE_FREEZE_EN: u1,

          /// [21:21] The bit is used to configure mode of freeze operation L2-Cache. 0: a miss-access will not stuck. 1: a miss-access will stuck.
          L2_CACHE_FREEZE_MODE: u1,

          /// [22:22] The bit is used to indicate whether freeze operation on L2-Cache is finished or not. 0: not finished. 1: finished.
          L2_CACHE_FREEZE_DONE: u1,

          /// [23:31] 
          res1: u9,

        }), @ptrFromInt(0x600c8278));

        /// Cache data memory access configure register
        pub const L2_CACHE_DATA_MEM_ACS_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:19] 
          res0: u20,

          /// [20:20] The bit is used to enable config-bus read L2-Cache data memoryory. 0: disable, 1: enable.
          L2_CACHE_DATA_MEM_RD_EN: u1,

          /// [21:21] The bit is used to enable config-bus write L2-Cache data memoryory. 0: disable, 1: enable.
          L2_CACHE_DATA_MEM_WR_EN: u1,

          /// [22:31] 
          res1: u10,

        }), @ptrFromInt(0x600c827c));

        /// Cache tag memory access configure register
        pub const L2_CACHE_TAG_MEM_ACS_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:19] 
          res0: u20,

          /// [20:20] The bit is used to enable config-bus read L2-Cache tag memoryory. 0: disable, 1: enable.
          L2_CACHE_TAG_MEM_RD_EN: u1,

          /// [21:21] The bit is used to enable config-bus write L2-Cache tag memoryory. 0: disable, 1: enable.
          L2_CACHE_TAG_MEM_WR_EN: u1,

          /// [22:31] 
          res1: u10,

        }), @ptrFromInt(0x600c8280));

        /// L2 Cache prelock configure register
        pub const L2_CACHE_PRELOCK_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] The bit is used to enable the first section of prelock function on L2-Cache.
          L2_CACHE_PRELOCK_SCT0_EN: u1,

          /// [1:1] The bit is used to enable the second section of prelock function on L2-Cache.
          L2_CACHE_PRELOCK_SCT1_EN: u1,

          /// [2:5] The bit is used to setthe gid of l2 cache prelock.
          L2_CACHE_PRELOCK_RGID: u4,

          /// [6:31] 
          res0: u26,

        }), @ptrFromInt(0x600c8284));

        /// L2 Cache prelock section0 address configure register
        pub const L2_CACHE_PRELOCK_SCT0_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Those bits are used to configure the start virtual address of the first section of prelock on L2-Cache, which should be used together with L2_CACHE_PRELOCK_SCT0_SIZE_REG
          L2_CACHE_PRELOCK_SCT0_ADDR: u32,

        }), @ptrFromInt(0x600c8288));

        /// L2 Cache prelock section1 address configure register
        pub const L2_CACHE_PRELOCK_SCT1_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Those bits are used to configure the start virtual address of the second section of prelock on L2-Cache, which should be used together with L2_CACHE_PRELOCK_SCT1_SIZE_REG
          L2_CACHE_PRELOCK_SCT1_ADDR: u32,

        }), @ptrFromInt(0x600c828c));

        /// L2 Cache prelock section size configure register
        pub const L2_CACHE_PRELOCK_SCT_SIZE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:15] Those bits are used to configure the size of the first section of prelock on L2-Cache, which should be used together with L2_CACHE_PRELOCK_SCT0_ADDR_REG
          L2_CACHE_PRELOCK_SCT0_SIZE: u16,

          /// [16:31] Those bits are used to configure the size of the second section of prelock on L2-Cache, which should be used together with L2_CACHE_PRELOCK_SCT1_ADDR_REG
          L2_CACHE_PRELOCK_SCT1_SIZE: u16,

        }), @ptrFromInt(0x600c8290));

        /// L2 Cache preload-operation control register
        pub const L2_CACHE_PRELOAD_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] The bit is used to enable preload operation on L2-Cache. It will be cleared by hardware automatically after preload operation is done.
          L2_CACHE_PRELOAD_ENA: u1,

          /// [1:1] The bit is used to indicate whether preload operation is finished or not. 0: not finished. 1: finished.
          L2_CACHE_PRELOAD_DONE: u1,

          /// [2:2] The bit is used to configure the direction of preload operation. 0: ascending, 1: descending.
          L2_CACHE_PRELOAD_ORDER: u1,

          /// [3:6] The bit is used to setthe gid of l2 cache preload.
          L2_CACHE_PRELOAD_RGID: u4,

          /// [7:31] 
          res0: u25,

        }), @ptrFromInt(0x600c8294));

        /// L2 Cache preload address configure register
        pub const L2_CACHE_PRELOAD_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Those bits are used to configure the start virtual address of preload on L2-Cache, which should be used together with L2_CACHE_PRELOAD_SIZE_REG
          L2_CACHE_PRELOAD_ADDR: u32,

        }), @ptrFromInt(0x600c8298));

        /// L2 Cache preload size configure register
        pub const L2_CACHE_PRELOAD_SIZE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:15] Those bits are used to configure the size of the first section of prelock on L2-Cache, which should be used together with L2_CACHE_PRELOAD_ADDR_REG
          L2_CACHE_PRELOAD_SIZE: u16,

          /// [16:31] 
          res0: u16,

        }), @ptrFromInt(0x600c829c));

        /// L2 Cache autoload-operation control register
        pub const L2_CACHE_AUTOLOAD_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] The bit is used to enable and disable autoload operation on L2-Cache.1: enable, 0: disable.
          L2_CACHE_AUTOLOAD_ENA: u1,

          /// [1:1] The bit is used to indicate whether autoload operation on L2-Cache is finished or not. 0: not finished. 1: finished.
          L2_CACHE_AUTOLOAD_DONE: u1,

          /// [2:2] The bit is used to configure the direction of autoload operation on L2-Cache. 0: ascending. 1: descending.
          L2_CACHE_AUTOLOAD_ORDER: u1,

          /// [3:4] The field is used to configure trigger mode of autoload operation on L2-Cache. 0/3: miss-trigger, 1: hit-trigger, 2: miss-hit-trigger.
          L2_CACHE_AUTOLOAD_TRIGGER_MODE: u2,

          /// [5:7] 
          res0: u3,

          /// [8:8] The bit is used to enable the first section for autoload operation on L2-Cache.
          L2_CACHE_AUTOLOAD_SCT0_ENA: u1,

          /// [9:9] The bit is used to enable the second section for autoload operation on L2-Cache.
          L2_CACHE_AUTOLOAD_SCT1_ENA: u1,

          /// [10:10] The bit is used to enable the third section for autoload operation on L2-Cache.
          L2_CACHE_AUTOLOAD_SCT2_ENA: u1,

          /// [11:11] The bit is used to enable the fourth section for autoload operation on L2-Cache.
          L2_CACHE_AUTOLOAD_SCT3_ENA: u1,

          /// [12:15] The bit is used to setthe gid of l2 cache autoload.
          L2_CACHE_AUTOLOAD_RGID: u4,

          /// [16:31] 
          res1: u16,

        }), @ptrFromInt(0x600c82a0));

        /// L2 Cache autoload section 0 address configure register
        pub const L2_CACHE_AUTOLOAD_SCT0_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Those bits are used to configure the start virtual address of the first section for autoload operation on L2-Cache. Note that it should be used together with L2_CACHE_AUTOLOAD_SCT0_SIZE and L2_CACHE_AUTOLOAD_SCT0_ENA.
          L2_CACHE_AUTOLOAD_SCT0_ADDR: u32,

        }), @ptrFromInt(0x600c82a4));

        /// L2 Cache autoload section 0 size configure register
        pub const L2_CACHE_AUTOLOAD_SCT0_SIZE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:27] Those bits are used to configure the size of the first section for autoload operation on L2-Cache. Note that it should be used together with L2_CACHE_AUTOLOAD_SCT0_ADDR and L2_CACHE_AUTOLOAD_SCT0_ENA.
          L2_CACHE_AUTOLOAD_SCT0_SIZE: u28,

          /// [28:31] 
          res0: u4,

        }), @ptrFromInt(0x600c82a8));

        /// L2 Cache autoload section 1 address configure register
        pub const L2_CACHE_AUTOLOAD_SCT1_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Those bits are used to configure the start virtual address of the second section for autoload operation on L2-Cache. Note that it should be used together with L2_CACHE_AUTOLOAD_SCT1_SIZE and L2_CACHE_AUTOLOAD_SCT1_ENA.
          L2_CACHE_AUTOLOAD_SCT1_ADDR: u32,

        }), @ptrFromInt(0x600c82ac));

        /// L2 Cache autoload section 1 size configure register
        pub const L2_CACHE_AUTOLOAD_SCT1_SIZE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:27] Those bits are used to configure the size of the second section for autoload operation on L2-Cache. Note that it should be used together with L2_CACHE_AUTOLOAD_SCT1_ADDR and L2_CACHE_AUTOLOAD_SCT1_ENA.
          L2_CACHE_AUTOLOAD_SCT1_SIZE: u28,

          /// [28:31] 
          res0: u4,

        }), @ptrFromInt(0x600c82b0));

        /// L2 Cache autoload section 2 address configure register
        pub const L2_CACHE_AUTOLOAD_SCT2_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Those bits are used to configure the start virtual address of the third section for autoload operation on L2-Cache. Note that it should be used together with L2_CACHE_AUTOLOAD_SCT2_SIZE and L2_CACHE_AUTOLOAD_SCT2_ENA.
          L2_CACHE_AUTOLOAD_SCT2_ADDR: u32,

        }), @ptrFromInt(0x600c82b4));

        /// L2 Cache autoload section 2 size configure register
        pub const L2_CACHE_AUTOLOAD_SCT2_SIZE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:27] Those bits are used to configure the size of the third section for autoload operation on L2-Cache. Note that it should be used together with L2_CACHE_AUTOLOAD_SCT2_ADDR and L2_CACHE_AUTOLOAD_SCT2_ENA.
          L2_CACHE_AUTOLOAD_SCT2_SIZE: u28,

          /// [28:31] 
          res0: u4,

        }), @ptrFromInt(0x600c82b8));

        /// L2 Cache autoload section 3 address configure register
        pub const L2_CACHE_AUTOLOAD_SCT3_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Those bits are used to configure the start virtual address of the fourth section for autoload operation on L2-Cache. Note that it should be used together with L2_CACHE_AUTOLOAD_SCT3_SIZE and L2_CACHE_AUTOLOAD_SCT3_ENA.
          L2_CACHE_AUTOLOAD_SCT3_ADDR: u32,

        }), @ptrFromInt(0x600c82bc));

        /// L2 Cache autoload section 3 size configure register
        pub const L2_CACHE_AUTOLOAD_SCT3_SIZE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:27] Those bits are used to configure the size of the fourth section for autoload operation on L2-Cache. Note that it should be used together with L2_CACHE_AUTOLOAD_SCT3_ADDR and L2_CACHE_AUTOLOAD_SCT3_ENA.
          L2_CACHE_AUTOLOAD_SCT3_SIZE: u28,

          /// [28:31] 
          res0: u4,

        }), @ptrFromInt(0x600c82c0));

        /// Cache Access Counter Interrupt enable register
        pub const L2_CACHE_ACS_CNT_INT_ENA = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] 
          res0: u8,

          /// [8:8] The bit is used to enable interrupt of one of counters overflow that occurs in L2-Cache due to bus0 accesses L2-Cache.
          L2_IBUS0_OVF_INT_ENA: u1,

          /// [9:9] The bit is used to enable interrupt of one of counters overflow that occurs in L2-Cache due to bus1 accesses L2-Cache.
          L2_IBUS1_OVF_INT_ENA: u1,

          /// [10:10] Reserved
          L2_IBUS2_OVF_INT_ENA: u1,

          /// [11:11] Reserved
          L2_IBUS3_OVF_INT_ENA: u1,

          /// [12:12] The bit is used to enable interrupt of one of counters overflow that occurs in L2-Cache due to bus0 accesses L2-Cache.
          L2_DBUS0_OVF_INT_ENA: u1,

          /// [13:13] The bit is used to enable interrupt of one of counters overflow that occurs in L2-Cache due to bus1 accesses L2-Cache.
          L2_DBUS1_OVF_INT_ENA: u1,

          /// [14:14] Reserved
          L2_DBUS2_OVF_INT_ENA: u1,

          /// [15:15] Reserved
          L2_DBUS3_OVF_INT_ENA: u1,

          /// [16:31] 
          res1: u16,

        }), @ptrFromInt(0x600c82c4));

        /// Cache Access Counter Interrupt clear register
        pub const L2_CACHE_ACS_CNT_INT_CLR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] 
          res0: u8,

          /// [8:8] The bit is used to clear counters overflow interrupt and counters in L2-Cache due to bus0 accesses L2-Cache.
          L2_IBUS0_OVF_INT_CLR: u1,

          /// [9:9] The bit is used to clear counters overflow interrupt and counters in L2-Cache due to bus1 accesses L2-Cache.
          L2_IBUS1_OVF_INT_CLR: u1,

          /// [10:10] Reserved
          L2_IBUS2_OVF_INT_CLR: u1,

          /// [11:11] Reserved
          L2_IBUS3_OVF_INT_CLR: u1,

          /// [12:12] The bit is used to clear counters overflow interrupt and counters in L2-Cache due to bus0 accesses L2-Cache.
          L2_DBUS0_OVF_INT_CLR: u1,

          /// [13:13] The bit is used to clear counters overflow interrupt and counters in L2-Cache due to bus1 accesses L2-Cache.
          L2_DBUS1_OVF_INT_CLR: u1,

          /// [14:14] Reserved
          L2_DBUS2_OVF_INT_CLR: u1,

          /// [15:15] Reserved
          L2_DBUS3_OVF_INT_CLR: u1,

          /// [16:31] 
          res1: u16,

        }), @ptrFromInt(0x600c82c8));

        /// Cache Access Counter Interrupt raw register
        pub const L2_CACHE_ACS_CNT_INT_RAW = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] 
          res0: u8,

          /// [8:8] The raw bit of the interrupt of one of counters overflow that occurs in L2-Cache due to bus0 accesses L2-ICache0.
          L2_IBUS0_OVF_INT_RAW: u1,

          /// [9:9] The raw bit of the interrupt of one of counters overflow that occurs in L2-Cache due to bus1 accesses L2-ICache1.
          L2_IBUS1_OVF_INT_RAW: u1,

          /// [10:10] The raw bit of the interrupt of one of counters overflow that occurs in L2-Cache due to bus2 accesses L2-ICache2.
          L2_IBUS2_OVF_INT_RAW: u1,

          /// [11:11] The raw bit of the interrupt of one of counters overflow that occurs in L2-Cache due to bus3 accesses L2-ICache3.
          L2_IBUS3_OVF_INT_RAW: u1,

          /// [12:12] The raw bit of the interrupt of one of counters overflow that occurs in L2-Cache due to bus0 accesses L2-DCache.
          L2_DBUS0_OVF_INT_RAW: u1,

          /// [13:13] The raw bit of the interrupt of one of counters overflow that occurs in L2-Cache due to bus1 accesses L2-DCache.
          L2_DBUS1_OVF_INT_RAW: u1,

          /// [14:14] The raw bit of the interrupt of one of counters overflow that occurs in L2-Cache due to bus2 accesses L2-DCache.
          L2_DBUS2_OVF_INT_RAW: u1,

          /// [15:15] The raw bit of the interrupt of one of counters overflow that occurs in L2-Cache due to bus3 accesses L2-DCache.
          L2_DBUS3_OVF_INT_RAW: u1,

          /// [16:31] 
          res1: u16,

        }), @ptrFromInt(0x600c82cc));

        /// Cache Access Counter Interrupt status register
        pub const L2_CACHE_ACS_CNT_INT_ST = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] 
          res0: u8,

          /// [8:8] The bit indicates the interrupt status of one of counters overflow that occurs in L2-Cache due to bus0 accesses L2-Cache.
          L2_IBUS0_OVF_INT_ST: u1,

          /// [9:9] The bit indicates the interrupt status of one of counters overflow that occurs in L2-Cache due to bus1 accesses L2-Cache.
          L2_IBUS1_OVF_INT_ST: u1,

          /// [10:10] Reserved
          L2_IBUS2_OVF_INT_ST: u1,

          /// [11:11] Reserved
          L2_IBUS3_OVF_INT_ST: u1,

          /// [12:12] The bit indicates the interrupt status of one of counters overflow that occurs in L2-Cache due to bus0 accesses L2-Cache.
          L2_DBUS0_OVF_INT_ST: u1,

          /// [13:13] The bit indicates the interrupt status of one of counters overflow that occurs in L2-Cache due to bus1 accesses L2-Cache.
          L2_DBUS1_OVF_INT_ST: u1,

          /// [14:14] Reserved
          L2_DBUS2_OVF_INT_ST: u1,

          /// [15:15] Reserved
          L2_DBUS3_OVF_INT_ST: u1,

          /// [16:31] 
          res1: u16,

        }), @ptrFromInt(0x600c82d0));

        /// Cache Access Fail Interrupt enable register
        pub const L2_CACHE_ACS_FAIL_INT_ENA = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:4] 
          res0: u5,

          /// [5:5] The bit is used to enable interrupt of access fail that occurs in L2-Cache due to l1 cache accesses L2-Cache.
          L2_CACHE_FAIL_INT_ENA: u1,

          /// [6:31] 
          res1: u26,

        }), @ptrFromInt(0x600c82d4));

        /// L1-Cache Access Fail Interrupt clear register
        pub const L2_CACHE_ACS_FAIL_INT_CLR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:4] 
          res0: u5,

          /// [5:5] The bit is used to clear interrupt of access fail that occurs in L2-Cache due to l1 cache accesses L2-Cache.
          L2_CACHE_FAIL_INT_CLR: u1,

          /// [6:31] 
          res1: u26,

        }), @ptrFromInt(0x600c82d8));

        /// Cache Access Fail Interrupt raw register
        pub const L2_CACHE_ACS_FAIL_INT_RAW = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:4] 
          res0: u5,

          /// [5:5] The raw bit of the interrupt of access fail that occurs in L2-Cache.
          L2_CACHE_FAIL_INT_RAW: u1,

          /// [6:31] 
          res1: u26,

        }), @ptrFromInt(0x600c82dc));

        /// Cache Access Fail Interrupt status register
        pub const L2_CACHE_ACS_FAIL_INT_ST = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:4] 
          res0: u5,

          /// [5:5] The bit indicates the interrupt status of access fail that occurs in L2-Cache due to l1 cache accesses L2-Cache.
          L2_CACHE_FAIL_INT_ST: u1,

          /// [6:31] 
          res1: u26,

        }), @ptrFromInt(0x600c82e0));

        /// Cache Access Counter enable and clear register
        pub const L2_CACHE_ACS_CNT_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] 
          res0: u8,

          /// [8:8] The bit is used to enable ibus0 counter in L2-Cache.
          L2_IBUS0_CNT_ENA: u1,

          /// [9:9] The bit is used to enable ibus1 counter in L2-Cache.
          L2_IBUS1_CNT_ENA: u1,

          /// [10:10] Reserved
          L2_IBUS2_CNT_ENA: u1,

          /// [11:11] Reserved
          L2_IBUS3_CNT_ENA: u1,

          /// [12:12] The bit is used to enable dbus0 counter in L2-Cache.
          L2_DBUS0_CNT_ENA: u1,

          /// [13:13] The bit is used to enable dbus1 counter in L2-Cache.
          L2_DBUS1_CNT_ENA: u1,

          /// [14:14] Reserved
          L2_DBUS2_CNT_ENA: u1,

          /// [15:15] Reserved
          L2_DBUS3_CNT_ENA: u1,

          /// [16:23] 
          res1: u8,

          /// [24:24] The bit is used to clear ibus0 counter in L2-Cache.
          L2_IBUS0_CNT_CLR: u1,

          /// [25:25] The bit is used to clear ibus1 counter in L2-Cache.
          L2_IBUS1_CNT_CLR: u1,

          /// [26:26] Reserved
          L2_IBUS2_CNT_CLR: u1,

          /// [27:27] Reserved
          L2_IBUS3_CNT_CLR: u1,

          /// [28:28] The bit is used to clear dbus0 counter in L2-Cache.
          L2_DBUS0_CNT_CLR: u1,

          /// [29:29] The bit is used to clear dbus1 counter in L2-Cache.
          L2_DBUS1_CNT_CLR: u1,

          /// [30:30] Reserved
          L2_DBUS2_CNT_CLR: u1,

          /// [31:31] Reserved
          L2_DBUS3_CNT_CLR: u1,

        }), @ptrFromInt(0x600c82e4));

        /// L2-Cache bus0 Hit-Access Counter register
        pub const L2_IBUS0_ACS_HIT_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] The register records the number of hits when L1-ICache0 accesses L2-Cache due to bus0 accessing L1-ICache0.
          L2_IBUS0_HIT_CNT: u32,

        }), @ptrFromInt(0x600c82e8));

        /// L2-Cache bus0 Miss-Access Counter register
        pub const L2_IBUS0_ACS_MISS_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] The register records the number of missing when L1-ICache0 accesses L2-Cache due to bus0 accessing L1-ICache0.
          L2_IBUS0_MISS_CNT: u32,

        }), @ptrFromInt(0x600c82ec));

        /// L2-Cache bus0 Conflict-Access Counter register
        pub const L2_IBUS0_ACS_CONFLICT_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] The register records the number of access-conflicts when L1-ICache0 accesses L2-Cache due to bus0 accessing L1-ICache0.
          L2_IBUS0_CONFLICT_CNT: u32,

        }), @ptrFromInt(0x600c82f0));

        /// L2-Cache bus0 Next-Level-Access Counter register
        pub const L2_IBUS0_ACS_NXTLVL_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] The register records the number of times that L2-Cache accesses external memory due to L1-ICache0 accessing L2-Cache due to bus0 accessing L1-ICache0.
          L2_IBUS0_NXTLVL_CNT: u32,

        }), @ptrFromInt(0x600c82f4));

        /// L2-Cache bus1 Hit-Access Counter register
        pub const L2_IBUS1_ACS_HIT_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] The register records the number of hits when L1-ICache1 accesses L2-Cache due to bus1 accessing L1-ICache1.
          L2_IBUS1_HIT_CNT: u32,

        }), @ptrFromInt(0x600c82f8));

        /// L2-Cache bus1 Miss-Access Counter register
        pub const L2_IBUS1_ACS_MISS_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] The register records the number of missing when L1-ICache1 accesses L2-Cache due to bus1 accessing L1-ICache1.
          L2_IBUS1_MISS_CNT: u32,

        }), @ptrFromInt(0x600c82fc));

        /// L2-Cache bus1 Conflict-Access Counter register
        pub const L2_IBUS1_ACS_CONFLICT_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] The register records the number of access-conflicts when L1-ICache1 accesses L2-Cache due to bus1 accessing L1-ICache1.
          L2_IBUS1_CONFLICT_CNT: u32,

        }), @ptrFromInt(0x600c8300));

        /// L2-Cache bus1 Next-Level-Access Counter register
        pub const L2_IBUS1_ACS_NXTLVL_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] The register records the number of times that L2-Cache accesses external memory due to L1-ICache1 accessing L2-Cache due to bus1 accessing L1-ICache1.
          L2_IBUS1_NXTLVL_CNT: u32,

        }), @ptrFromInt(0x600c8304));

        /// L2-Cache bus2 Hit-Access Counter register
        pub const L2_IBUS2_ACS_HIT_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] The register records the number of hits when L1-ICache2 accesses L2-Cache due to bus2 accessing L1-ICache2.
          L2_IBUS2_HIT_CNT: u32,

        }), @ptrFromInt(0x600c8308));

        /// L2-Cache bus2 Miss-Access Counter register
        pub const L2_IBUS2_ACS_MISS_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] The register records the number of missing when L1-ICache2 accesses L2-Cache due to bus2 accessing L1-ICache2.
          L2_IBUS2_MISS_CNT: u32,

        }), @ptrFromInt(0x600c830c));

        /// L2-Cache bus2 Conflict-Access Counter register
        pub const L2_IBUS2_ACS_CONFLICT_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] The register records the number of access-conflicts when L1-ICache2 accesses L2-Cache due to bus2 accessing L1-ICache2.
          L2_IBUS2_CONFLICT_CNT: u32,

        }), @ptrFromInt(0x600c8310));

        /// L2-Cache bus2 Next-Level-Access Counter register
        pub const L2_IBUS2_ACS_NXTLVL_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] The register records the number of times that L2-Cache accesses external memory due to L1-ICache2 accessing L2-Cache due to bus2 accessing L1-ICache2.
          L2_IBUS2_NXTLVL_CNT: u32,

        }), @ptrFromInt(0x600c8314));

        /// L2-Cache bus3 Hit-Access Counter register
        pub const L2_IBUS3_ACS_HIT_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] The register records the number of hits when L1-ICache3 accesses L2-Cache due to bus3 accessing L1-ICache3.
          L2_IBUS3_HIT_CNT: u32,

        }), @ptrFromInt(0x600c8318));

        /// L2-Cache bus3 Miss-Access Counter register
        pub const L2_IBUS3_ACS_MISS_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] The register records the number of missing when L1-ICache3 accesses L2-Cache due to bus3 accessing L1-ICache3.
          L2_IBUS3_MISS_CNT: u32,

        }), @ptrFromInt(0x600c831c));

        /// L2-Cache bus3 Conflict-Access Counter register
        pub const L2_IBUS3_ACS_CONFLICT_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] The register records the number of access-conflicts when L1-ICache3 accesses L2-Cache due to bus3 accessing L1-ICache3.
          L2_IBUS3_CONFLICT_CNT: u32,

        }), @ptrFromInt(0x600c8320));

        /// L2-Cache bus3 Next-Level-Access Counter register
        pub const L2_IBUS3_ACS_NXTLVL_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] The register records the number of times that L2-Cache accesses external memory due to L1-ICache3 accessing L2-Cache due to bus3 accessing L1-ICache3.
          L2_IBUS3_NXTLVL_CNT: u32,

        }), @ptrFromInt(0x600c8324));

        /// L2-Cache bus0 Hit-Access Counter register
        pub const L2_DBUS0_ACS_HIT_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] The register records the number of hits when L1-DCache accesses L2-Cache due to bus0 accessing L1-DCache.
          L2_DBUS0_HIT_CNT: u32,

        }), @ptrFromInt(0x600c8328));

        /// L2-Cache bus0 Miss-Access Counter register
        pub const L2_DBUS0_ACS_MISS_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] The register records the number of missing when L1-DCache accesses L2-Cache due to bus0 accessing L1-DCache.
          L2_DBUS0_MISS_CNT: u32,

        }), @ptrFromInt(0x600c832c));

        /// L2-Cache bus0 Conflict-Access Counter register
        pub const L2_DBUS0_ACS_CONFLICT_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] The register records the number of access-conflicts when L1-DCache accesses L2-Cache due to bus0 accessing L1-DCache.
          L2_DBUS0_CONFLICT_CNT: u32,

        }), @ptrFromInt(0x600c8330));

        /// L2-Cache bus0 Next-Level-Access Counter register
        pub const L2_DBUS0_ACS_NXTLVL_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] The register records the number of times that L2-Cache accesses external memory due to L1-DCache accessing L2-Cache due to bus0 accessing L1-DCache.
          L2_DBUS0_NXTLVL_CNT: u32,

        }), @ptrFromInt(0x600c8334));

        /// L2-Cache bus1 Hit-Access Counter register
        pub const L2_DBUS1_ACS_HIT_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] The register records the number of hits when L1-DCache accesses L2-Cache due to bus1 accessing L1-DCache.
          L2_DBUS1_HIT_CNT: u32,

        }), @ptrFromInt(0x600c8338));

        /// L2-Cache bus1 Miss-Access Counter register
        pub const L2_DBUS1_ACS_MISS_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] The register records the number of missing when L1-DCache accesses L2-Cache due to bus1 accessing L1-DCache.
          L2_DBUS1_MISS_CNT: u32,

        }), @ptrFromInt(0x600c833c));

        /// L2-Cache bus1 Conflict-Access Counter register
        pub const L2_DBUS1_ACS_CONFLICT_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] The register records the number of access-conflicts when L1-DCache accesses L2-Cache due to bus1 accessing L1-DCache.
          L2_DBUS1_CONFLICT_CNT: u32,

        }), @ptrFromInt(0x600c8340));

        /// L2-Cache bus1 Next-Level-Access Counter register
        pub const L2_DBUS1_ACS_NXTLVL_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] The register records the number of times that L2-Cache accesses external memory due to L1-DCache accessing L2-Cache due to bus1 accessing L1-DCache.
          L2_DBUS1_NXTLVL_CNT: u32,

        }), @ptrFromInt(0x600c8344));

        /// L2-Cache bus2 Hit-Access Counter register
        pub const L2_DBUS2_ACS_HIT_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] The register records the number of hits when L1-DCache accesses L2-Cache due to bus2 accessing L1-DCache.
          L2_DBUS2_HIT_CNT: u32,

        }), @ptrFromInt(0x600c8348));

        /// L2-Cache bus2 Miss-Access Counter register
        pub const L2_DBUS2_ACS_MISS_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] The register records the number of missing when L1-DCache accesses L2-Cache due to bus2 accessing L1-DCache.
          L2_DBUS2_MISS_CNT: u32,

        }), @ptrFromInt(0x600c834c));

        /// L2-Cache bus2 Conflict-Access Counter register
        pub const L2_DBUS2_ACS_CONFLICT_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] The register records the number of access-conflicts when L1-DCache accesses L2-Cache due to bus2 accessing L1-DCache.
          L2_DBUS2_CONFLICT_CNT: u32,

        }), @ptrFromInt(0x600c8350));

        /// L2-Cache bus2 Next-Level-Access Counter register
        pub const L2_DBUS2_ACS_NXTLVL_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] The register records the number of times that L2-Cache accesses external memory due to L1-DCache accessing L2-Cache due to bus2 accessing L1-DCache.
          L2_DBUS2_NXTLVL_CNT: u32,

        }), @ptrFromInt(0x600c8354));

        /// L2-Cache bus3 Hit-Access Counter register
        pub const L2_DBUS3_ACS_HIT_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] The register records the number of hits when L1-DCache accesses L2-Cache due to bus3 accessing L1-DCache.
          L2_DBUS3_HIT_CNT: u32,

        }), @ptrFromInt(0x600c8358));

        /// L2-Cache bus3 Miss-Access Counter register
        pub const L2_DBUS3_ACS_MISS_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] The register records the number of missing when L1-DCache accesses L2-Cache due to bus3 accessing L1-DCache.
          L2_DBUS3_MISS_CNT: u32,

        }), @ptrFromInt(0x600c835c));

        /// L2-Cache bus3 Conflict-Access Counter register
        pub const L2_DBUS3_ACS_CONFLICT_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] The register records the number of access-conflicts when L1-DCache accesses L2-Cache due to bus3 accessing L1-DCache.
          L2_DBUS3_CONFLICT_CNT: u32,

        }), @ptrFromInt(0x600c8360));

        /// L2-Cache bus3 Next-Level-Access Counter register
        pub const L2_DBUS3_ACS_NXTLVL_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] The register records the number of times that L2-Cache accesses external memory due to L1-DCache accessing L2-Cache due to bus3 accessing L1-DCache.
          L2_DBUS3_NXTLVL_CNT: u32,

        }), @ptrFromInt(0x600c8364));

        /// L2-Cache Access Fail ID/attribution information register
        pub const L2_CACHE_ACS_FAIL_ID_ATTR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:15] The register records the ID of fail-access when L1-Cache accesses L2-Cache.
          L2_CACHE_FAIL_ID: u16,

          /// [16:31] The register records the attribution of fail-access when L1-Cache accesses L2-Cache due to cache accessing L1-Cache.
          L2_CACHE_FAIL_ATTR: u16,

        }), @ptrFromInt(0x600c8368));

        /// L2-Cache Access Fail Address information register
        pub const L2_CACHE_ACS_FAIL_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] The register records the address of fail-access when L1-Cache accesses L2-Cache.
          L2_CACHE_FAIL_ADDR: u32,

        }), @ptrFromInt(0x600c836c));

        /// L1-Cache Access Fail Interrupt enable register
        pub const L2_CACHE_SYNC_PRELOAD_INT_ENA = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:4] 
          res0: u5,

          /// [5:5] The bit is used to enable interrupt of L2-Cache preload-operation done.
          L2_CACHE_PLD_DONE_INT_ENA: u1,

          /// [6:11] 
          res1: u6,

          /// [12:12] The bit is used to enable interrupt of L2-Cache preload-operation error.
          L2_CACHE_PLD_ERR_INT_ENA: u1,

          /// [13:31] 
          res2: u19,

        }), @ptrFromInt(0x600c8370));

        /// Sync Preload operation Interrupt clear register
        pub const L2_CACHE_SYNC_PRELOAD_INT_CLR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:4] 
          res0: u5,

          /// [5:5] The bit is used to clear interrupt that occurs only when L2-Cache preload-operation is done.
          L2_CACHE_PLD_DONE_INT_CLR: u1,

          /// [6:11] 
          res1: u6,

          /// [12:12] The bit is used to clear interrupt of L2-Cache preload-operation error.
          L2_CACHE_PLD_ERR_INT_CLR: u1,

          /// [13:31] 
          res2: u19,

        }), @ptrFromInt(0x600c8374));

        /// Sync Preload operation Interrupt raw register
        pub const L2_CACHE_SYNC_PRELOAD_INT_RAW = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:4] 
          res0: u5,

          /// [5:5] The raw bit of the interrupt that occurs only when L2-Cache preload-operation is done.
          L2_CACHE_PLD_DONE_INT_RAW: u1,

          /// [6:11] 
          res1: u6,

          /// [12:12] The raw bit of the interrupt that occurs only when L2-Cache preload-operation error occurs.
          L2_CACHE_PLD_ERR_INT_RAW: u1,

          /// [13:31] 
          res2: u19,

        }), @ptrFromInt(0x600c8378));

        /// L1-Cache Access Fail Interrupt status register
        pub const L2_CACHE_SYNC_PRELOAD_INT_ST = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:4] 
          res0: u5,

          /// [5:5] The bit indicates the status of the interrupt that occurs only when L2-Cache preload-operation is done.
          L2_CACHE_PLD_DONE_INT_ST: u1,

          /// [6:11] 
          res1: u6,

          /// [12:12] The bit indicates the status of the interrupt of L2-Cache preload-operation error.
          L2_CACHE_PLD_ERR_INT_ST: u1,

          /// [13:31] 
          res2: u19,

        }), @ptrFromInt(0x600c837c));

        /// Cache Sync/Preload Operation exception register
        pub const L2_CACHE_SYNC_PRELOAD_EXCEPTION = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:9] 
          res0: u10,

          /// [10:11] The value 2 is Only available which means preload size is error in L2-Cache.
          L2_CACHE_PLD_ERR_CODE: u2,

          /// [12:31] 
          res1: u20,

        }), @ptrFromInt(0x600c8380));

        /// Cache Sync Reset control register
        pub const L2_CACHE_SYNC_RST_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:4] 
          res0: u5,

          /// [5:5] set this bit to reset sync-logic inside L2-Cache. Recommend that this should only be used to initialize sync-logic when some fatal error of sync-logic occurs.
          L2_CACHE_SYNC_RST: u1,

          /// [6:31] 
          res1: u26,

        }), @ptrFromInt(0x600c8384));

        /// Cache Preload Reset control register
        pub const L2_CACHE_PRELOAD_RST_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:4] 
          res0: u5,

          /// [5:5] set this bit to reset preload-logic inside L2-Cache. Recommend that this should only be used to initialize preload-logic when some fatal error of preload-logic occurs.
          L2_CACHE_PLD_RST: u1,

          /// [6:31] 
          res1: u26,

        }), @ptrFromInt(0x600c8388));

        /// Cache Autoload buffer clear control register
        pub const L2_CACHE_AUTOLOAD_BUF_CLR_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:4] 
          res0: u5,

          /// [5:5] set this bit to clear autoload-buffer inside L2-Cache. If this bit is active, autoload will not work in L2-Cache. This bit should not be active when autoload works in L2-Cache.
          L2_CACHE_ALD_BUF_CLR: u1,

          /// [6:31] 
          res1: u26,

        }), @ptrFromInt(0x600c838c));

        /// Unallocate request buffer clear registers
        pub const L2_UNALLOCATE_BUFFER_CLEAR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:4] 
          res0: u5,

          /// [5:5] The bit is used to clear the unallocate request buffer of l2 icache where the unallocate request is responsed but not completed.
          L2_CACHE_UNALLOC_CLR: u1,

          /// [6:31] 
          res1: u26,

        }), @ptrFromInt(0x600c8390));

        /// L1 Cache access Attribute propagation control register
        pub const L2_CACHE_ACCESS_ATTR_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Set this bit to force the request to l2 cache with cacheable attribute, otherwise, the attribute is propagated from L1 cache or CPU, it could be one of cacheable and non-cacheable.
          L2_CACHE_ACCESS_FORCE_CC: u1,

          /// [1:1] Set this bit to force the request to l2 cache with write-back attribute, otherwise, the attribute is propagated from L1 cache or CPU, it could be one of write-back and write-through.
          L2_CACHE_ACCESS_FORCE_WB: u1,

          /// [2:2] Set this bit to force the request to l2 cache with write-miss-allocate attribute, otherwise, the attribute is propagated from L1 cache or CPU, it could be one of write-miss-allocate and write-miss-no-allocate.
          L2_CACHE_ACCESS_FORCE_WMA: u1,

          /// [3:3] Set this bit to force the request to l2 cache with read-miss-allocate attribute, otherwise, the attribute is propagated from L1 cache or CPU, it could be one of read-miss-allocate and read-miss-no-allocate.
          L2_CACHE_ACCESS_FORCE_RMA: u1,

          /// [4:31] 
          res0: u28,

        }), @ptrFromInt(0x600c8394));

        /// Cache Tag and Data memory Object control register
        pub const L2_CACHE_OBJECT_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:4] 
          res0: u5,

          /// [5:5] Set this bit to set L2-Cache tag memory as object. This bit should be onehot with the others fields inside this register.
          L2_CACHE_TAG_OBJECT: u1,

          /// [6:10] 
          res1: u5,

          /// [11:11] Set this bit to set L2-Cache data memory as object. This bit should be onehot with the others fields inside this register.
          L2_CACHE_MEM_OBJECT: u1,

          /// [12:31] 
          res2: u20,

        }), @ptrFromInt(0x600c8398));

        /// Cache Tag and Data memory way register
        pub const L2_CACHE_WAY_OBJECT = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:2] Set this bits to select which way of the tag-object will be accessed. 0: way0, 1: way1, 2: way2, 3: way3, ?, 7: way7.
          L2_CACHE_WAY_OBJECT: u3,

          /// [3:31] 
          res0: u29,

        }), @ptrFromInt(0x600c839c));

        /// Cache Vaddr register
        pub const L2_CACHE_VADDR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Those bits stores the virtual address which will decide where inside the specified tag memory object will be accessed.
          L2_CACHE_VADDR: u32,

        }), @ptrFromInt(0x600c83a0));

        /// Cache Tag/data memory content register
        pub const L2_CACHE_DEBUG_BUS = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] This is a constant place where we can write data to or read data from the tag/data memory on the specified cache.
          L2_CACHE_DEBUG_BUS: u32,

        }), @ptrFromInt(0x600c83a4));

        /// USED TO SPLIT L1 CACHE AND L2 CACHE
        pub const LEVEL_SPLIT1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Reserved
          LEVEL_SPLIT1: u32,

        }), @ptrFromInt(0x600c83a8));

        /// Clock gate control register
        pub const CLOCK_GATE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] The bit is used to enable clock gate when access all registers in this module.
          CLK_EN: u1,

          /// [1:31] 
          res0: u31,

        }), @ptrFromInt(0x600c83ac));

        /// Cache redundancy signal 0 register
        pub const REDUNDANCY_SIG0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Those bits are prepared for ECO.
          CACHE_REDCY_SIG0: u32,

        }), @ptrFromInt(0x600c83b0));

        /// Cache redundancy signal 1 register
        pub const REDUNDANCY_SIG1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Those bits are prepared for ECO.
          CACHE_REDCY_SIG1: u32,

        }), @ptrFromInt(0x600c83b4));

        /// Cache redundancy signal 2 register
        pub const REDUNDANCY_SIG2 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Those bits are prepared for ECO.
          CACHE_REDCY_SIG2: u32,

        }), @ptrFromInt(0x600c83b8));

        /// Cache redundancy signal 3 register
        pub const REDUNDANCY_SIG3 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Those bits are prepared for ECO.
          CACHE_REDCY_SIG3: u32,

        }), @ptrFromInt(0x600c83bc));

        /// Cache redundancy signal 0 register
        pub const REDUNDANCY_SIG4 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:3] Those bits are prepared for ECO.
          CACHE_REDCY_SIG4: u4,

          /// [4:31] 
          res0: u28,

        }), @ptrFromInt(0x600c83c0));

        /// Version control register
        pub const DATE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:27] version control register. Note that this default value stored is the latest date when the hardware logic was updated.
          DATE: u28,

          /// [28:31] 
          res0: u4,

        }), @ptrFromInt(0x600c83fc));

      };

      /// General Purpose Input/Output
      pub const GPIO = struct {

        /// GPIO bit select register
        pub const BT_SELECT = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] GPIO bit select register
          BT_SEL: u32,

        }), @ptrFromInt(0x60091000));

        /// GPIO output register for GPIO0-31
        pub const OUT = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] GPIO output register for GPIO0-31
          DATA_ORIG: u32,

        }), @ptrFromInt(0x60091004));

        /// GPIO output set register for GPIO0-31
        pub const OUT_W1TS = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] GPIO output set register for GPIO0-31
          OUT_W1TS: u32,

        }), @ptrFromInt(0x60091008));

        /// GPIO output clear register for GPIO0-31
        pub const OUT_W1TC = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] GPIO output clear register for GPIO0-31
          OUT_W1TC: u32,

        }), @ptrFromInt(0x6009100c));

        /// GPIO output register for GPIO32-34
        pub const OUT1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:2] GPIO output register for GPIO32-34
          DATA_ORIG: u3,

          /// [3:31] 
          res0: u29,

        }), @ptrFromInt(0x60091010));

        /// GPIO output set register for GPIO32-34
        pub const OUT1_W1TS = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:2] GPIO output set register for GPIO32-34
          OUT1_W1TS: u3,

          /// [3:31] 
          res0: u29,

        }), @ptrFromInt(0x60091014));

        /// GPIO output clear register for GPIO32-34
        pub const OUT1_W1TC = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:2] GPIO output clear register for GPIO32-34
          OUT1_W1TC: u3,

          /// [3:31] 
          res0: u29,

        }), @ptrFromInt(0x60091018));

        /// GPIO sdio select register
        pub const SDIO_SELECT = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] GPIO sdio select register
          SDIO_SEL: u8,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x6009101c));

        /// GPIO output enable register for GPIO0-31
        pub const ENABLE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] GPIO output enable register for GPIO0-31
          DATA: u32,

        }), @ptrFromInt(0x60091020));

        /// GPIO output enable set register for GPIO0-31
        pub const ENABLE_W1TS = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] GPIO output enable set register for GPIO0-31
          ENABLE_W1TS: u32,

        }), @ptrFromInt(0x60091024));

        /// GPIO output enable clear register for GPIO0-31
        pub const ENABLE_W1TC = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] GPIO output enable clear register for GPIO0-31
          ENABLE_W1TC: u32,

        }), @ptrFromInt(0x60091028));

        /// GPIO output enable register for GPIO32-34
        pub const ENABLE1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:2] GPIO output enable register for GPIO32-34
          DATA: u3,

          /// [3:31] 
          res0: u29,

        }), @ptrFromInt(0x6009102c));

        /// GPIO output enable set register for GPIO32-34
        pub const ENABLE1_W1TS = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:2] GPIO output enable set register for GPIO32-34
          ENABLE1_W1TS: u3,

          /// [3:31] 
          res0: u29,

        }), @ptrFromInt(0x60091030));

        /// GPIO output enable clear register for GPIO32-34
        pub const ENABLE1_W1TC = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:2] GPIO output enable clear register for GPIO32-34
          ENABLE1_W1TC: u3,

          /// [3:31] 
          res0: u29,

        }), @ptrFromInt(0x60091034));

        /// pad strapping register
        pub const STRAP = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:15] pad strapping register
          STRAPPING: u16,

          /// [16:31] 
          res0: u16,

        }), @ptrFromInt(0x60091038));

        /// GPIO input register for GPIO0-31
        pub const IN = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] GPIO input register for GPIO0-31
          DATA_NEXT: u32,

        }), @ptrFromInt(0x6009103c));

        /// GPIO input register for GPIO32-34
        pub const IN1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:2] GPIO input register for GPIO32-34
          DATA_NEXT: u3,

          /// [3:31] 
          res0: u29,

        }), @ptrFromInt(0x60091040));

        /// GPIO interrupt status register for GPIO0-31
        pub const STATUS = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] GPIO interrupt status register for GPIO0-31
          INTERRUPT: u32,

        }), @ptrFromInt(0x60091044));

        /// GPIO interrupt status set register for GPIO0-31
        pub const STATUS_W1TS = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] GPIO interrupt status set register for GPIO0-31
          STATUS_W1TS: u32,

        }), @ptrFromInt(0x60091048));

        /// GPIO interrupt status clear register for GPIO0-31
        pub const STATUS_W1TC = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] GPIO interrupt status clear register for GPIO0-31
          STATUS_W1TC: u32,

        }), @ptrFromInt(0x6009104c));

        /// GPIO interrupt status register for GPIO32-34
        pub const STATUS1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:2] GPIO interrupt status register for GPIO32-34
          INTERRUPT: u3,

          /// [3:31] 
          res0: u29,

        }), @ptrFromInt(0x60091050));

        /// GPIO interrupt status set register for GPIO32-34
        pub const STATUS1_W1TS = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:2] GPIO interrupt status set register for GPIO32-34
          STATUS1_W1TS: u3,

          /// [3:31] 
          res0: u29,

        }), @ptrFromInt(0x60091054));

        /// GPIO interrupt status clear register for GPIO32-34
        pub const STATUS1_W1TC = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:2] GPIO interrupt status clear register for GPIO32-34
          STATUS1_W1TC: u3,

          /// [3:31] 
          res0: u29,

        }), @ptrFromInt(0x60091058));

        /// GPIO PRO_CPU interrupt status register for GPIO0-31
        pub const PCPU_INT = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] GPIO PRO_CPU interrupt status register for GPIO0-31
          PROCPU_INT: u32,

        }), @ptrFromInt(0x6009105c));

        /// GPIO PRO_CPU(not shielded) interrupt status register for GPIO0-31
        pub const PCPU_NMI_INT = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] GPIO PRO_CPU(not shielded) interrupt status register for GPIO0-31
          PROCPU_NMI_INT: u32,

        }), @ptrFromInt(0x60091060));

        /// GPIO CPUSDIO interrupt status register for GPIO0-31
        pub const CPUSDIO_INT = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] GPIO CPUSDIO interrupt status register for GPIO0-31
          SDIO_INT: u32,

        }), @ptrFromInt(0x60091064));

        /// GPIO PRO_CPU interrupt status register for GPIO32-34
        pub const PCPU_INT1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:2] GPIO PRO_CPU interrupt status register for GPIO32-34
          PROCPU_INT1: u3,

          /// [3:31] 
          res0: u29,

        }), @ptrFromInt(0x60091068));

        /// GPIO PRO_CPU(not shielded) interrupt status register for GPIO32-34
        pub const PCPU_NMI_INT1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:2] GPIO PRO_CPU(not shielded) interrupt status register for GPIO32-34
          PROCPU_NMI_INT1: u3,

          /// [3:31] 
          res0: u29,

        }), @ptrFromInt(0x6009106c));

        /// GPIO CPUSDIO interrupt status register for GPIO32-34
        pub const CPUSDIO_INT1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:2] GPIO CPUSDIO interrupt status register for GPIO32-34
          SDIO_INT1: u3,

          /// [3:31] 
          res0: u29,

        }), @ptrFromInt(0x60091070));

        /// GPIO pin configuration register
        pub const PIN0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:1] set GPIO input_sync2 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
          SYNC2_BYPASS: u2,

          /// [2:2] set this bit to select pad driver. 1:open-drain. 0:normal.
          PAD_DRIVER: u1,

          /// [3:4] set GPIO input_sync1 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
          SYNC1_BYPASS: u2,

          /// [5:6] 
          res0: u2,

          /// [7:9] set this value to choose interrupt mode. 0:disable GPIO interrupt. 1:trigger at posedge. 2:trigger at negedge. 3:trigger at any edge. 4:valid at low level. 5:valid at high level
          INT_TYPE: u3,

          /// [10:10] set this bit to enable GPIO wakeup.(can only wakeup CPU from Light-sleep Mode)
          WAKEUP_ENABLE: u1,

          /// [11:12] reserved
          CONFIG: u2,

          /// [13:17] set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not shielded) interrupt.
          INT_ENA: u5,

          /// [18:31] 
          res1: u14,

        }), @ptrFromInt(0x60091074));

        /// GPIO pin configuration register
        pub const PIN1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:1] set GPIO input_sync2 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
          SYNC2_BYPASS: u2,

          /// [2:2] set this bit to select pad driver. 1:open-drain. 0:normal.
          PAD_DRIVER: u1,

          /// [3:4] set GPIO input_sync1 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
          SYNC1_BYPASS: u2,

          /// [5:6] 
          res0: u2,

          /// [7:9] set this value to choose interrupt mode. 0:disable GPIO interrupt. 1:trigger at posedge. 2:trigger at negedge. 3:trigger at any edge. 4:valid at low level. 5:valid at high level
          INT_TYPE: u3,

          /// [10:10] set this bit to enable GPIO wakeup.(can only wakeup CPU from Light-sleep Mode)
          WAKEUP_ENABLE: u1,

          /// [11:12] reserved
          CONFIG: u2,

          /// [13:17] set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not shielded) interrupt.
          INT_ENA: u5,

          /// [18:31] 
          res1: u14,

        }), @ptrFromInt(0x60091078));

        /// GPIO pin configuration register
        pub const PIN2 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:1] set GPIO input_sync2 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
          SYNC2_BYPASS: u2,

          /// [2:2] set this bit to select pad driver. 1:open-drain. 0:normal.
          PAD_DRIVER: u1,

          /// [3:4] set GPIO input_sync1 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
          SYNC1_BYPASS: u2,

          /// [5:6] 
          res0: u2,

          /// [7:9] set this value to choose interrupt mode. 0:disable GPIO interrupt. 1:trigger at posedge. 2:trigger at negedge. 3:trigger at any edge. 4:valid at low level. 5:valid at high level
          INT_TYPE: u3,

          /// [10:10] set this bit to enable GPIO wakeup.(can only wakeup CPU from Light-sleep Mode)
          WAKEUP_ENABLE: u1,

          /// [11:12] reserved
          CONFIG: u2,

          /// [13:17] set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not shielded) interrupt.
          INT_ENA: u5,

          /// [18:31] 
          res1: u14,

        }), @ptrFromInt(0x6009107c));

        /// GPIO pin configuration register
        pub const PIN3 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:1] set GPIO input_sync2 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
          SYNC2_BYPASS: u2,

          /// [2:2] set this bit to select pad driver. 1:open-drain. 0:normal.
          PAD_DRIVER: u1,

          /// [3:4] set GPIO input_sync1 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
          SYNC1_BYPASS: u2,

          /// [5:6] 
          res0: u2,

          /// [7:9] set this value to choose interrupt mode. 0:disable GPIO interrupt. 1:trigger at posedge. 2:trigger at negedge. 3:trigger at any edge. 4:valid at low level. 5:valid at high level
          INT_TYPE: u3,

          /// [10:10] set this bit to enable GPIO wakeup.(can only wakeup CPU from Light-sleep Mode)
          WAKEUP_ENABLE: u1,

          /// [11:12] reserved
          CONFIG: u2,

          /// [13:17] set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not shielded) interrupt.
          INT_ENA: u5,

          /// [18:31] 
          res1: u14,

        }), @ptrFromInt(0x60091080));

        /// GPIO pin configuration register
        pub const PIN4 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:1] set GPIO input_sync2 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
          SYNC2_BYPASS: u2,

          /// [2:2] set this bit to select pad driver. 1:open-drain. 0:normal.
          PAD_DRIVER: u1,

          /// [3:4] set GPIO input_sync1 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
          SYNC1_BYPASS: u2,

          /// [5:6] 
          res0: u2,

          /// [7:9] set this value to choose interrupt mode. 0:disable GPIO interrupt. 1:trigger at posedge. 2:trigger at negedge. 3:trigger at any edge. 4:valid at low level. 5:valid at high level
          INT_TYPE: u3,

          /// [10:10] set this bit to enable GPIO wakeup.(can only wakeup CPU from Light-sleep Mode)
          WAKEUP_ENABLE: u1,

          /// [11:12] reserved
          CONFIG: u2,

          /// [13:17] set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not shielded) interrupt.
          INT_ENA: u5,

          /// [18:31] 
          res1: u14,

        }), @ptrFromInt(0x60091084));

        /// GPIO pin configuration register
        pub const PIN5 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:1] set GPIO input_sync2 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
          SYNC2_BYPASS: u2,

          /// [2:2] set this bit to select pad driver. 1:open-drain. 0:normal.
          PAD_DRIVER: u1,

          /// [3:4] set GPIO input_sync1 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
          SYNC1_BYPASS: u2,

          /// [5:6] 
          res0: u2,

          /// [7:9] set this value to choose interrupt mode. 0:disable GPIO interrupt. 1:trigger at posedge. 2:trigger at negedge. 3:trigger at any edge. 4:valid at low level. 5:valid at high level
          INT_TYPE: u3,

          /// [10:10] set this bit to enable GPIO wakeup.(can only wakeup CPU from Light-sleep Mode)
          WAKEUP_ENABLE: u1,

          /// [11:12] reserved
          CONFIG: u2,

          /// [13:17] set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not shielded) interrupt.
          INT_ENA: u5,

          /// [18:31] 
          res1: u14,

        }), @ptrFromInt(0x60091088));

        /// GPIO pin configuration register
        pub const PIN6 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:1] set GPIO input_sync2 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
          SYNC2_BYPASS: u2,

          /// [2:2] set this bit to select pad driver. 1:open-drain. 0:normal.
          PAD_DRIVER: u1,

          /// [3:4] set GPIO input_sync1 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
          SYNC1_BYPASS: u2,

          /// [5:6] 
          res0: u2,

          /// [7:9] set this value to choose interrupt mode. 0:disable GPIO interrupt. 1:trigger at posedge. 2:trigger at negedge. 3:trigger at any edge. 4:valid at low level. 5:valid at high level
          INT_TYPE: u3,

          /// [10:10] set this bit to enable GPIO wakeup.(can only wakeup CPU from Light-sleep Mode)
          WAKEUP_ENABLE: u1,

          /// [11:12] reserved
          CONFIG: u2,

          /// [13:17] set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not shielded) interrupt.
          INT_ENA: u5,

          /// [18:31] 
          res1: u14,

        }), @ptrFromInt(0x6009108c));

        /// GPIO pin configuration register
        pub const PIN7 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:1] set GPIO input_sync2 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
          SYNC2_BYPASS: u2,

          /// [2:2] set this bit to select pad driver. 1:open-drain. 0:normal.
          PAD_DRIVER: u1,

          /// [3:4] set GPIO input_sync1 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
          SYNC1_BYPASS: u2,

          /// [5:6] 
          res0: u2,

          /// [7:9] set this value to choose interrupt mode. 0:disable GPIO interrupt. 1:trigger at posedge. 2:trigger at negedge. 3:trigger at any edge. 4:valid at low level. 5:valid at high level
          INT_TYPE: u3,

          /// [10:10] set this bit to enable GPIO wakeup.(can only wakeup CPU from Light-sleep Mode)
          WAKEUP_ENABLE: u1,

          /// [11:12] reserved
          CONFIG: u2,

          /// [13:17] set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not shielded) interrupt.
          INT_ENA: u5,

          /// [18:31] 
          res1: u14,

        }), @ptrFromInt(0x60091090));

        /// GPIO pin configuration register
        pub const PIN8 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:1] set GPIO input_sync2 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
          SYNC2_BYPASS: u2,

          /// [2:2] set this bit to select pad driver. 1:open-drain. 0:normal.
          PAD_DRIVER: u1,

          /// [3:4] set GPIO input_sync1 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
          SYNC1_BYPASS: u2,

          /// [5:6] 
          res0: u2,

          /// [7:9] set this value to choose interrupt mode. 0:disable GPIO interrupt. 1:trigger at posedge. 2:trigger at negedge. 3:trigger at any edge. 4:valid at low level. 5:valid at high level
          INT_TYPE: u3,

          /// [10:10] set this bit to enable GPIO wakeup.(can only wakeup CPU from Light-sleep Mode)
          WAKEUP_ENABLE: u1,

          /// [11:12] reserved
          CONFIG: u2,

          /// [13:17] set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not shielded) interrupt.
          INT_ENA: u5,

          /// [18:31] 
          res1: u14,

        }), @ptrFromInt(0x60091094));

        /// GPIO pin configuration register
        pub const PIN9 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:1] set GPIO input_sync2 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
          SYNC2_BYPASS: u2,

          /// [2:2] set this bit to select pad driver. 1:open-drain. 0:normal.
          PAD_DRIVER: u1,

          /// [3:4] set GPIO input_sync1 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
          SYNC1_BYPASS: u2,

          /// [5:6] 
          res0: u2,

          /// [7:9] set this value to choose interrupt mode. 0:disable GPIO interrupt. 1:trigger at posedge. 2:trigger at negedge. 3:trigger at any edge. 4:valid at low level. 5:valid at high level
          INT_TYPE: u3,

          /// [10:10] set this bit to enable GPIO wakeup.(can only wakeup CPU from Light-sleep Mode)
          WAKEUP_ENABLE: u1,

          /// [11:12] reserved
          CONFIG: u2,

          /// [13:17] set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not shielded) interrupt.
          INT_ENA: u5,

          /// [18:31] 
          res1: u14,

        }), @ptrFromInt(0x60091098));

        /// GPIO pin configuration register
        pub const PIN10 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:1] set GPIO input_sync2 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
          SYNC2_BYPASS: u2,

          /// [2:2] set this bit to select pad driver. 1:open-drain. 0:normal.
          PAD_DRIVER: u1,

          /// [3:4] set GPIO input_sync1 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
          SYNC1_BYPASS: u2,

          /// [5:6] 
          res0: u2,

          /// [7:9] set this value to choose interrupt mode. 0:disable GPIO interrupt. 1:trigger at posedge. 2:trigger at negedge. 3:trigger at any edge. 4:valid at low level. 5:valid at high level
          INT_TYPE: u3,

          /// [10:10] set this bit to enable GPIO wakeup.(can only wakeup CPU from Light-sleep Mode)
          WAKEUP_ENABLE: u1,

          /// [11:12] reserved
          CONFIG: u2,

          /// [13:17] set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not shielded) interrupt.
          INT_ENA: u5,

          /// [18:31] 
          res1: u14,

        }), @ptrFromInt(0x6009109c));

        /// GPIO pin configuration register
        pub const PIN11 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:1] set GPIO input_sync2 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
          SYNC2_BYPASS: u2,

          /// [2:2] set this bit to select pad driver. 1:open-drain. 0:normal.
          PAD_DRIVER: u1,

          /// [3:4] set GPIO input_sync1 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
          SYNC1_BYPASS: u2,

          /// [5:6] 
          res0: u2,

          /// [7:9] set this value to choose interrupt mode. 0:disable GPIO interrupt. 1:trigger at posedge. 2:trigger at negedge. 3:trigger at any edge. 4:valid at low level. 5:valid at high level
          INT_TYPE: u3,

          /// [10:10] set this bit to enable GPIO wakeup.(can only wakeup CPU from Light-sleep Mode)
          WAKEUP_ENABLE: u1,

          /// [11:12] reserved
          CONFIG: u2,

          /// [13:17] set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not shielded) interrupt.
          INT_ENA: u5,

          /// [18:31] 
          res1: u14,

        }), @ptrFromInt(0x600910a0));

        /// GPIO pin configuration register
        pub const PIN12 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:1] set GPIO input_sync2 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
          SYNC2_BYPASS: u2,

          /// [2:2] set this bit to select pad driver. 1:open-drain. 0:normal.
          PAD_DRIVER: u1,

          /// [3:4] set GPIO input_sync1 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
          SYNC1_BYPASS: u2,

          /// [5:6] 
          res0: u2,

          /// [7:9] set this value to choose interrupt mode. 0:disable GPIO interrupt. 1:trigger at posedge. 2:trigger at negedge. 3:trigger at any edge. 4:valid at low level. 5:valid at high level
          INT_TYPE: u3,

          /// [10:10] set this bit to enable GPIO wakeup.(can only wakeup CPU from Light-sleep Mode)
          WAKEUP_ENABLE: u1,

          /// [11:12] reserved
          CONFIG: u2,

          /// [13:17] set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not shielded) interrupt.
          INT_ENA: u5,

          /// [18:31] 
          res1: u14,

        }), @ptrFromInt(0x600910a4));

        /// GPIO pin configuration register
        pub const PIN13 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:1] set GPIO input_sync2 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
          SYNC2_BYPASS: u2,

          /// [2:2] set this bit to select pad driver. 1:open-drain. 0:normal.
          PAD_DRIVER: u1,

          /// [3:4] set GPIO input_sync1 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
          SYNC1_BYPASS: u2,

          /// [5:6] 
          res0: u2,

          /// [7:9] set this value to choose interrupt mode. 0:disable GPIO interrupt. 1:trigger at posedge. 2:trigger at negedge. 3:trigger at any edge. 4:valid at low level. 5:valid at high level
          INT_TYPE: u3,

          /// [10:10] set this bit to enable GPIO wakeup.(can only wakeup CPU from Light-sleep Mode)
          WAKEUP_ENABLE: u1,

          /// [11:12] reserved
          CONFIG: u2,

          /// [13:17] set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not shielded) interrupt.
          INT_ENA: u5,

          /// [18:31] 
          res1: u14,

        }), @ptrFromInt(0x600910a8));

        /// GPIO pin configuration register
        pub const PIN14 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:1] set GPIO input_sync2 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
          SYNC2_BYPASS: u2,

          /// [2:2] set this bit to select pad driver. 1:open-drain. 0:normal.
          PAD_DRIVER: u1,

          /// [3:4] set GPIO input_sync1 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
          SYNC1_BYPASS: u2,

          /// [5:6] 
          res0: u2,

          /// [7:9] set this value to choose interrupt mode. 0:disable GPIO interrupt. 1:trigger at posedge. 2:trigger at negedge. 3:trigger at any edge. 4:valid at low level. 5:valid at high level
          INT_TYPE: u3,

          /// [10:10] set this bit to enable GPIO wakeup.(can only wakeup CPU from Light-sleep Mode)
          WAKEUP_ENABLE: u1,

          /// [11:12] reserved
          CONFIG: u2,

          /// [13:17] set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not shielded) interrupt.
          INT_ENA: u5,

          /// [18:31] 
          res1: u14,

        }), @ptrFromInt(0x600910ac));

        /// GPIO pin configuration register
        pub const PIN15 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:1] set GPIO input_sync2 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
          SYNC2_BYPASS: u2,

          /// [2:2] set this bit to select pad driver. 1:open-drain. 0:normal.
          PAD_DRIVER: u1,

          /// [3:4] set GPIO input_sync1 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
          SYNC1_BYPASS: u2,

          /// [5:6] 
          res0: u2,

          /// [7:9] set this value to choose interrupt mode. 0:disable GPIO interrupt. 1:trigger at posedge. 2:trigger at negedge. 3:trigger at any edge. 4:valid at low level. 5:valid at high level
          INT_TYPE: u3,

          /// [10:10] set this bit to enable GPIO wakeup.(can only wakeup CPU from Light-sleep Mode)
          WAKEUP_ENABLE: u1,

          /// [11:12] reserved
          CONFIG: u2,

          /// [13:17] set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not shielded) interrupt.
          INT_ENA: u5,

          /// [18:31] 
          res1: u14,

        }), @ptrFromInt(0x600910b0));

        /// GPIO pin configuration register
        pub const PIN16 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:1] set GPIO input_sync2 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
          SYNC2_BYPASS: u2,

          /// [2:2] set this bit to select pad driver. 1:open-drain. 0:normal.
          PAD_DRIVER: u1,

          /// [3:4] set GPIO input_sync1 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
          SYNC1_BYPASS: u2,

          /// [5:6] 
          res0: u2,

          /// [7:9] set this value to choose interrupt mode. 0:disable GPIO interrupt. 1:trigger at posedge. 2:trigger at negedge. 3:trigger at any edge. 4:valid at low level. 5:valid at high level
          INT_TYPE: u3,

          /// [10:10] set this bit to enable GPIO wakeup.(can only wakeup CPU from Light-sleep Mode)
          WAKEUP_ENABLE: u1,

          /// [11:12] reserved
          CONFIG: u2,

          /// [13:17] set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not shielded) interrupt.
          INT_ENA: u5,

          /// [18:31] 
          res1: u14,

        }), @ptrFromInt(0x600910b4));

        /// GPIO pin configuration register
        pub const PIN17 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:1] set GPIO input_sync2 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
          SYNC2_BYPASS: u2,

          /// [2:2] set this bit to select pad driver. 1:open-drain. 0:normal.
          PAD_DRIVER: u1,

          /// [3:4] set GPIO input_sync1 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
          SYNC1_BYPASS: u2,

          /// [5:6] 
          res0: u2,

          /// [7:9] set this value to choose interrupt mode. 0:disable GPIO interrupt. 1:trigger at posedge. 2:trigger at negedge. 3:trigger at any edge. 4:valid at low level. 5:valid at high level
          INT_TYPE: u3,

          /// [10:10] set this bit to enable GPIO wakeup.(can only wakeup CPU from Light-sleep Mode)
          WAKEUP_ENABLE: u1,

          /// [11:12] reserved
          CONFIG: u2,

          /// [13:17] set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not shielded) interrupt.
          INT_ENA: u5,

          /// [18:31] 
          res1: u14,

        }), @ptrFromInt(0x600910b8));

        /// GPIO pin configuration register
        pub const PIN18 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:1] set GPIO input_sync2 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
          SYNC2_BYPASS: u2,

          /// [2:2] set this bit to select pad driver. 1:open-drain. 0:normal.
          PAD_DRIVER: u1,

          /// [3:4] set GPIO input_sync1 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
          SYNC1_BYPASS: u2,

          /// [5:6] 
          res0: u2,

          /// [7:9] set this value to choose interrupt mode. 0:disable GPIO interrupt. 1:trigger at posedge. 2:trigger at negedge. 3:trigger at any edge. 4:valid at low level. 5:valid at high level
          INT_TYPE: u3,

          /// [10:10] set this bit to enable GPIO wakeup.(can only wakeup CPU from Light-sleep Mode)
          WAKEUP_ENABLE: u1,

          /// [11:12] reserved
          CONFIG: u2,

          /// [13:17] set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not shielded) interrupt.
          INT_ENA: u5,

          /// [18:31] 
          res1: u14,

        }), @ptrFromInt(0x600910bc));

        /// GPIO pin configuration register
        pub const PIN19 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:1] set GPIO input_sync2 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
          SYNC2_BYPASS: u2,

          /// [2:2] set this bit to select pad driver. 1:open-drain. 0:normal.
          PAD_DRIVER: u1,

          /// [3:4] set GPIO input_sync1 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
          SYNC1_BYPASS: u2,

          /// [5:6] 
          res0: u2,

          /// [7:9] set this value to choose interrupt mode. 0:disable GPIO interrupt. 1:trigger at posedge. 2:trigger at negedge. 3:trigger at any edge. 4:valid at low level. 5:valid at high level
          INT_TYPE: u3,

          /// [10:10] set this bit to enable GPIO wakeup.(can only wakeup CPU from Light-sleep Mode)
          WAKEUP_ENABLE: u1,

          /// [11:12] reserved
          CONFIG: u2,

          /// [13:17] set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not shielded) interrupt.
          INT_ENA: u5,

          /// [18:31] 
          res1: u14,

        }), @ptrFromInt(0x600910c0));

        /// GPIO pin configuration register
        pub const PIN20 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:1] set GPIO input_sync2 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
          SYNC2_BYPASS: u2,

          /// [2:2] set this bit to select pad driver. 1:open-drain. 0:normal.
          PAD_DRIVER: u1,

          /// [3:4] set GPIO input_sync1 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
          SYNC1_BYPASS: u2,

          /// [5:6] 
          res0: u2,

          /// [7:9] set this value to choose interrupt mode. 0:disable GPIO interrupt. 1:trigger at posedge. 2:trigger at negedge. 3:trigger at any edge. 4:valid at low level. 5:valid at high level
          INT_TYPE: u3,

          /// [10:10] set this bit to enable GPIO wakeup.(can only wakeup CPU from Light-sleep Mode)
          WAKEUP_ENABLE: u1,

          /// [11:12] reserved
          CONFIG: u2,

          /// [13:17] set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not shielded) interrupt.
          INT_ENA: u5,

          /// [18:31] 
          res1: u14,

        }), @ptrFromInt(0x600910c4));

        /// GPIO pin configuration register
        pub const PIN21 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:1] set GPIO input_sync2 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
          SYNC2_BYPASS: u2,

          /// [2:2] set this bit to select pad driver. 1:open-drain. 0:normal.
          PAD_DRIVER: u1,

          /// [3:4] set GPIO input_sync1 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
          SYNC1_BYPASS: u2,

          /// [5:6] 
          res0: u2,

          /// [7:9] set this value to choose interrupt mode. 0:disable GPIO interrupt. 1:trigger at posedge. 2:trigger at negedge. 3:trigger at any edge. 4:valid at low level. 5:valid at high level
          INT_TYPE: u3,

          /// [10:10] set this bit to enable GPIO wakeup.(can only wakeup CPU from Light-sleep Mode)
          WAKEUP_ENABLE: u1,

          /// [11:12] reserved
          CONFIG: u2,

          /// [13:17] set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not shielded) interrupt.
          INT_ENA: u5,

          /// [18:31] 
          res1: u14,

        }), @ptrFromInt(0x600910c8));

        /// GPIO pin configuration register
        pub const PIN22 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:1] set GPIO input_sync2 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
          SYNC2_BYPASS: u2,

          /// [2:2] set this bit to select pad driver. 1:open-drain. 0:normal.
          PAD_DRIVER: u1,

          /// [3:4] set GPIO input_sync1 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
          SYNC1_BYPASS: u2,

          /// [5:6] 
          res0: u2,

          /// [7:9] set this value to choose interrupt mode. 0:disable GPIO interrupt. 1:trigger at posedge. 2:trigger at negedge. 3:trigger at any edge. 4:valid at low level. 5:valid at high level
          INT_TYPE: u3,

          /// [10:10] set this bit to enable GPIO wakeup.(can only wakeup CPU from Light-sleep Mode)
          WAKEUP_ENABLE: u1,

          /// [11:12] reserved
          CONFIG: u2,

          /// [13:17] set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not shielded) interrupt.
          INT_ENA: u5,

          /// [18:31] 
          res1: u14,

        }), @ptrFromInt(0x600910cc));

        /// GPIO pin configuration register
        pub const PIN23 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:1] set GPIO input_sync2 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
          SYNC2_BYPASS: u2,

          /// [2:2] set this bit to select pad driver. 1:open-drain. 0:normal.
          PAD_DRIVER: u1,

          /// [3:4] set GPIO input_sync1 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
          SYNC1_BYPASS: u2,

          /// [5:6] 
          res0: u2,

          /// [7:9] set this value to choose interrupt mode. 0:disable GPIO interrupt. 1:trigger at posedge. 2:trigger at negedge. 3:trigger at any edge. 4:valid at low level. 5:valid at high level
          INT_TYPE: u3,

          /// [10:10] set this bit to enable GPIO wakeup.(can only wakeup CPU from Light-sleep Mode)
          WAKEUP_ENABLE: u1,

          /// [11:12] reserved
          CONFIG: u2,

          /// [13:17] set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not shielded) interrupt.
          INT_ENA: u5,

          /// [18:31] 
          res1: u14,

        }), @ptrFromInt(0x600910d0));

        /// GPIO pin configuration register
        pub const PIN24 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:1] set GPIO input_sync2 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
          SYNC2_BYPASS: u2,

          /// [2:2] set this bit to select pad driver. 1:open-drain. 0:normal.
          PAD_DRIVER: u1,

          /// [3:4] set GPIO input_sync1 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
          SYNC1_BYPASS: u2,

          /// [5:6] 
          res0: u2,

          /// [7:9] set this value to choose interrupt mode. 0:disable GPIO interrupt. 1:trigger at posedge. 2:trigger at negedge. 3:trigger at any edge. 4:valid at low level. 5:valid at high level
          INT_TYPE: u3,

          /// [10:10] set this bit to enable GPIO wakeup.(can only wakeup CPU from Light-sleep Mode)
          WAKEUP_ENABLE: u1,

          /// [11:12] reserved
          CONFIG: u2,

          /// [13:17] set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not shielded) interrupt.
          INT_ENA: u5,

          /// [18:31] 
          res1: u14,

        }), @ptrFromInt(0x600910d4));

        /// GPIO pin configuration register
        pub const PIN25 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:1] set GPIO input_sync2 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
          SYNC2_BYPASS: u2,

          /// [2:2] set this bit to select pad driver. 1:open-drain. 0:normal.
          PAD_DRIVER: u1,

          /// [3:4] set GPIO input_sync1 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
          SYNC1_BYPASS: u2,

          /// [5:6] 
          res0: u2,

          /// [7:9] set this value to choose interrupt mode. 0:disable GPIO interrupt. 1:trigger at posedge. 2:trigger at negedge. 3:trigger at any edge. 4:valid at low level. 5:valid at high level
          INT_TYPE: u3,

          /// [10:10] set this bit to enable GPIO wakeup.(can only wakeup CPU from Light-sleep Mode)
          WAKEUP_ENABLE: u1,

          /// [11:12] reserved
          CONFIG: u2,

          /// [13:17] set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not shielded) interrupt.
          INT_ENA: u5,

          /// [18:31] 
          res1: u14,

        }), @ptrFromInt(0x600910d8));

        /// GPIO pin configuration register
        pub const PIN26 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:1] set GPIO input_sync2 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
          SYNC2_BYPASS: u2,

          /// [2:2] set this bit to select pad driver. 1:open-drain. 0:normal.
          PAD_DRIVER: u1,

          /// [3:4] set GPIO input_sync1 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
          SYNC1_BYPASS: u2,

          /// [5:6] 
          res0: u2,

          /// [7:9] set this value to choose interrupt mode. 0:disable GPIO interrupt. 1:trigger at posedge. 2:trigger at negedge. 3:trigger at any edge. 4:valid at low level. 5:valid at high level
          INT_TYPE: u3,

          /// [10:10] set this bit to enable GPIO wakeup.(can only wakeup CPU from Light-sleep Mode)
          WAKEUP_ENABLE: u1,

          /// [11:12] reserved
          CONFIG: u2,

          /// [13:17] set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not shielded) interrupt.
          INT_ENA: u5,

          /// [18:31] 
          res1: u14,

        }), @ptrFromInt(0x600910dc));

        /// GPIO pin configuration register
        pub const PIN27 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:1] set GPIO input_sync2 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
          SYNC2_BYPASS: u2,

          /// [2:2] set this bit to select pad driver. 1:open-drain. 0:normal.
          PAD_DRIVER: u1,

          /// [3:4] set GPIO input_sync1 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
          SYNC1_BYPASS: u2,

          /// [5:6] 
          res0: u2,

          /// [7:9] set this value to choose interrupt mode. 0:disable GPIO interrupt. 1:trigger at posedge. 2:trigger at negedge. 3:trigger at any edge. 4:valid at low level. 5:valid at high level
          INT_TYPE: u3,

          /// [10:10] set this bit to enable GPIO wakeup.(can only wakeup CPU from Light-sleep Mode)
          WAKEUP_ENABLE: u1,

          /// [11:12] reserved
          CONFIG: u2,

          /// [13:17] set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not shielded) interrupt.
          INT_ENA: u5,

          /// [18:31] 
          res1: u14,

        }), @ptrFromInt(0x600910e0));

        /// GPIO pin configuration register
        pub const PIN28 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:1] set GPIO input_sync2 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
          SYNC2_BYPASS: u2,

          /// [2:2] set this bit to select pad driver. 1:open-drain. 0:normal.
          PAD_DRIVER: u1,

          /// [3:4] set GPIO input_sync1 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
          SYNC1_BYPASS: u2,

          /// [5:6] 
          res0: u2,

          /// [7:9] set this value to choose interrupt mode. 0:disable GPIO interrupt. 1:trigger at posedge. 2:trigger at negedge. 3:trigger at any edge. 4:valid at low level. 5:valid at high level
          INT_TYPE: u3,

          /// [10:10] set this bit to enable GPIO wakeup.(can only wakeup CPU from Light-sleep Mode)
          WAKEUP_ENABLE: u1,

          /// [11:12] reserved
          CONFIG: u2,

          /// [13:17] set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not shielded) interrupt.
          INT_ENA: u5,

          /// [18:31] 
          res1: u14,

        }), @ptrFromInt(0x600910e4));

        /// GPIO pin configuration register
        pub const PIN29 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:1] set GPIO input_sync2 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
          SYNC2_BYPASS: u2,

          /// [2:2] set this bit to select pad driver. 1:open-drain. 0:normal.
          PAD_DRIVER: u1,

          /// [3:4] set GPIO input_sync1 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
          SYNC1_BYPASS: u2,

          /// [5:6] 
          res0: u2,

          /// [7:9] set this value to choose interrupt mode. 0:disable GPIO interrupt. 1:trigger at posedge. 2:trigger at negedge. 3:trigger at any edge. 4:valid at low level. 5:valid at high level
          INT_TYPE: u3,

          /// [10:10] set this bit to enable GPIO wakeup.(can only wakeup CPU from Light-sleep Mode)
          WAKEUP_ENABLE: u1,

          /// [11:12] reserved
          CONFIG: u2,

          /// [13:17] set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not shielded) interrupt.
          INT_ENA: u5,

          /// [18:31] 
          res1: u14,

        }), @ptrFromInt(0x600910e8));

        /// GPIO pin configuration register
        pub const PIN30 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:1] set GPIO input_sync2 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
          SYNC2_BYPASS: u2,

          /// [2:2] set this bit to select pad driver. 1:open-drain. 0:normal.
          PAD_DRIVER: u1,

          /// [3:4] set GPIO input_sync1 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
          SYNC1_BYPASS: u2,

          /// [5:6] 
          res0: u2,

          /// [7:9] set this value to choose interrupt mode. 0:disable GPIO interrupt. 1:trigger at posedge. 2:trigger at negedge. 3:trigger at any edge. 4:valid at low level. 5:valid at high level
          INT_TYPE: u3,

          /// [10:10] set this bit to enable GPIO wakeup.(can only wakeup CPU from Light-sleep Mode)
          WAKEUP_ENABLE: u1,

          /// [11:12] reserved
          CONFIG: u2,

          /// [13:17] set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not shielded) interrupt.
          INT_ENA: u5,

          /// [18:31] 
          res1: u14,

        }), @ptrFromInt(0x600910ec));

        /// GPIO pin configuration register
        pub const PIN31 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:1] set GPIO input_sync2 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
          SYNC2_BYPASS: u2,

          /// [2:2] set this bit to select pad driver. 1:open-drain. 0:normal.
          PAD_DRIVER: u1,

          /// [3:4] set GPIO input_sync1 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
          SYNC1_BYPASS: u2,

          /// [5:6] 
          res0: u2,

          /// [7:9] set this value to choose interrupt mode. 0:disable GPIO interrupt. 1:trigger at posedge. 2:trigger at negedge. 3:trigger at any edge. 4:valid at low level. 5:valid at high level
          INT_TYPE: u3,

          /// [10:10] set this bit to enable GPIO wakeup.(can only wakeup CPU from Light-sleep Mode)
          WAKEUP_ENABLE: u1,

          /// [11:12] reserved
          CONFIG: u2,

          /// [13:17] set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not shielded) interrupt.
          INT_ENA: u5,

          /// [18:31] 
          res1: u14,

        }), @ptrFromInt(0x600910f0));

        /// GPIO pin configuration register
        pub const PIN32 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:1] set GPIO input_sync2 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
          SYNC2_BYPASS: u2,

          /// [2:2] set this bit to select pad driver. 1:open-drain. 0:normal.
          PAD_DRIVER: u1,

          /// [3:4] set GPIO input_sync1 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
          SYNC1_BYPASS: u2,

          /// [5:6] 
          res0: u2,

          /// [7:9] set this value to choose interrupt mode. 0:disable GPIO interrupt. 1:trigger at posedge. 2:trigger at negedge. 3:trigger at any edge. 4:valid at low level. 5:valid at high level
          INT_TYPE: u3,

          /// [10:10] set this bit to enable GPIO wakeup.(can only wakeup CPU from Light-sleep Mode)
          WAKEUP_ENABLE: u1,

          /// [11:12] reserved
          CONFIG: u2,

          /// [13:17] set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not shielded) interrupt.
          INT_ENA: u5,

          /// [18:31] 
          res1: u14,

        }), @ptrFromInt(0x600910f4));

        /// GPIO pin configuration register
        pub const PIN33 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:1] set GPIO input_sync2 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
          SYNC2_BYPASS: u2,

          /// [2:2] set this bit to select pad driver. 1:open-drain. 0:normal.
          PAD_DRIVER: u1,

          /// [3:4] set GPIO input_sync1 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
          SYNC1_BYPASS: u2,

          /// [5:6] 
          res0: u2,

          /// [7:9] set this value to choose interrupt mode. 0:disable GPIO interrupt. 1:trigger at posedge. 2:trigger at negedge. 3:trigger at any edge. 4:valid at low level. 5:valid at high level
          INT_TYPE: u3,

          /// [10:10] set this bit to enable GPIO wakeup.(can only wakeup CPU from Light-sleep Mode)
          WAKEUP_ENABLE: u1,

          /// [11:12] reserved
          CONFIG: u2,

          /// [13:17] set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not shielded) interrupt.
          INT_ENA: u5,

          /// [18:31] 
          res1: u14,

        }), @ptrFromInt(0x600910f8));

        /// GPIO pin configuration register
        pub const PIN34 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:1] set GPIO input_sync2 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
          SYNC2_BYPASS: u2,

          /// [2:2] set this bit to select pad driver. 1:open-drain. 0:normal.
          PAD_DRIVER: u1,

          /// [3:4] set GPIO input_sync1 signal mode. 0:disable. 1:trigger at negedge. 2or3:trigger at posedge.
          SYNC1_BYPASS: u2,

          /// [5:6] 
          res0: u2,

          /// [7:9] set this value to choose interrupt mode. 0:disable GPIO interrupt. 1:trigger at posedge. 2:trigger at negedge. 3:trigger at any edge. 4:valid at low level. 5:valid at high level
          INT_TYPE: u3,

          /// [10:10] set this bit to enable GPIO wakeup.(can only wakeup CPU from Light-sleep Mode)
          WAKEUP_ENABLE: u1,

          /// [11:12] reserved
          CONFIG: u2,

          /// [13:17] set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not shielded) interrupt.
          INT_ENA: u5,

          /// [18:31] 
          res1: u14,

        }), @ptrFromInt(0x600910fc));

        /// GPIO interrupt source register for GPIO0-31
        pub const STATUS_NEXT = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] GPIO interrupt source register for GPIO0-31
          STATUS_INTERRUPT_NEXT: u32,

        }), @ptrFromInt(0x6009114c));

        /// GPIO interrupt source register for GPIO32-34
        pub const STATUS_NEXT1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:2] GPIO interrupt source register for GPIO32-34
          STATUS_INTERRUPT_NEXT1: u3,

          /// [3:31] 
          res0: u29,

        }), @ptrFromInt(0x60091150));

        /// GPIO input function configuration register
        pub const FUNC0_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
          IN_SEL: u6,

          /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
          IN_INV_SEL: u1,

          /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
          SEL: u1,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x60091154));

        /// GPIO input function configuration register
        pub const FUNC1_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
          IN_SEL: u6,

          /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
          IN_INV_SEL: u1,

          /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
          SEL: u1,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x60091158));

        /// GPIO input function configuration register
        pub const FUNC2_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
          IN_SEL: u6,

          /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
          IN_INV_SEL: u1,

          /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
          SEL: u1,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x6009115c));

        /// GPIO input function configuration register
        pub const FUNC3_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
          IN_SEL: u6,

          /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
          IN_INV_SEL: u1,

          /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
          SEL: u1,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x60091160));

        /// GPIO input function configuration register
        pub const FUNC4_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
          IN_SEL: u6,

          /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
          IN_INV_SEL: u1,

          /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
          SEL: u1,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x60091164));

        /// GPIO input function configuration register
        pub const FUNC5_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
          IN_SEL: u6,

          /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
          IN_INV_SEL: u1,

          /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
          SEL: u1,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x60091168));

        /// GPIO input function configuration register
        pub const FUNC6_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
          IN_SEL: u6,

          /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
          IN_INV_SEL: u1,

          /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
          SEL: u1,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x6009116c));

        /// GPIO input function configuration register
        pub const FUNC7_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
          IN_SEL: u6,

          /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
          IN_INV_SEL: u1,

          /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
          SEL: u1,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x60091170));

        /// GPIO input function configuration register
        pub const FUNC8_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
          IN_SEL: u6,

          /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
          IN_INV_SEL: u1,

          /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
          SEL: u1,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x60091174));

        /// GPIO input function configuration register
        pub const FUNC9_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
          IN_SEL: u6,

          /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
          IN_INV_SEL: u1,

          /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
          SEL: u1,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x60091178));

        /// GPIO input function configuration register
        pub const FUNC10_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
          IN_SEL: u6,

          /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
          IN_INV_SEL: u1,

          /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
          SEL: u1,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x6009117c));

        /// GPIO input function configuration register
        pub const FUNC11_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
          IN_SEL: u6,

          /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
          IN_INV_SEL: u1,

          /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
          SEL: u1,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x60091180));

        /// GPIO input function configuration register
        pub const FUNC12_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
          IN_SEL: u6,

          /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
          IN_INV_SEL: u1,

          /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
          SEL: u1,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x60091184));

        /// GPIO input function configuration register
        pub const FUNC13_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
          IN_SEL: u6,

          /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
          IN_INV_SEL: u1,

          /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
          SEL: u1,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x60091188));

        /// GPIO input function configuration register
        pub const FUNC14_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
          IN_SEL: u6,

          /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
          IN_INV_SEL: u1,

          /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
          SEL: u1,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x6009118c));

        /// GPIO input function configuration register
        pub const FUNC15_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
          IN_SEL: u6,

          /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
          IN_INV_SEL: u1,

          /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
          SEL: u1,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x60091190));

        /// GPIO input function configuration register
        pub const FUNC16_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
          IN_SEL: u6,

          /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
          IN_INV_SEL: u1,

          /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
          SEL: u1,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x60091194));

        /// GPIO input function configuration register
        pub const FUNC17_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
          IN_SEL: u6,

          /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
          IN_INV_SEL: u1,

          /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
          SEL: u1,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x60091198));

        /// GPIO input function configuration register
        pub const FUNC18_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
          IN_SEL: u6,

          /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
          IN_INV_SEL: u1,

          /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
          SEL: u1,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x6009119c));

        /// GPIO input function configuration register
        pub const FUNC19_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
          IN_SEL: u6,

          /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
          IN_INV_SEL: u1,

          /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
          SEL: u1,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x600911a0));

        /// GPIO input function configuration register
        pub const FUNC20_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
          IN_SEL: u6,

          /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
          IN_INV_SEL: u1,

          /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
          SEL: u1,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x600911a4));

        /// GPIO input function configuration register
        pub const FUNC21_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
          IN_SEL: u6,

          /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
          IN_INV_SEL: u1,

          /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
          SEL: u1,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x600911a8));

        /// GPIO input function configuration register
        pub const FUNC22_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
          IN_SEL: u6,

          /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
          IN_INV_SEL: u1,

          /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
          SEL: u1,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x600911ac));

        /// GPIO input function configuration register
        pub const FUNC23_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
          IN_SEL: u6,

          /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
          IN_INV_SEL: u1,

          /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
          SEL: u1,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x600911b0));

        /// GPIO input function configuration register
        pub const FUNC24_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
          IN_SEL: u6,

          /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
          IN_INV_SEL: u1,

          /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
          SEL: u1,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x600911b4));

        /// GPIO input function configuration register
        pub const FUNC25_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
          IN_SEL: u6,

          /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
          IN_INV_SEL: u1,

          /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
          SEL: u1,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x600911b8));

        /// GPIO input function configuration register
        pub const FUNC26_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
          IN_SEL: u6,

          /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
          IN_INV_SEL: u1,

          /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
          SEL: u1,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x600911bc));

        /// GPIO input function configuration register
        pub const FUNC27_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
          IN_SEL: u6,

          /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
          IN_INV_SEL: u1,

          /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
          SEL: u1,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x600911c0));

        /// GPIO input function configuration register
        pub const FUNC28_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
          IN_SEL: u6,

          /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
          IN_INV_SEL: u1,

          /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
          SEL: u1,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x600911c4));

        /// GPIO input function configuration register
        pub const FUNC29_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
          IN_SEL: u6,

          /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
          IN_INV_SEL: u1,

          /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
          SEL: u1,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x600911c8));

        /// GPIO input function configuration register
        pub const FUNC30_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
          IN_SEL: u6,

          /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
          IN_INV_SEL: u1,

          /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
          SEL: u1,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x600911cc));

        /// GPIO input function configuration register
        pub const FUNC31_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
          IN_SEL: u6,

          /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
          IN_INV_SEL: u1,

          /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
          SEL: u1,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x600911d0));

        /// GPIO input function configuration register
        pub const FUNC32_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
          IN_SEL: u6,

          /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
          IN_INV_SEL: u1,

          /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
          SEL: u1,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x600911d4));

        /// GPIO input function configuration register
        pub const FUNC33_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
          IN_SEL: u6,

          /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
          IN_INV_SEL: u1,

          /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
          SEL: u1,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x600911d8));

        /// GPIO input function configuration register
        pub const FUNC34_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
          IN_SEL: u6,

          /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
          IN_INV_SEL: u1,

          /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
          SEL: u1,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x600911dc));

        /// GPIO input function configuration register
        pub const FUNC35_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
          IN_SEL: u6,

          /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
          IN_INV_SEL: u1,

          /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
          SEL: u1,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x600911e0));

        /// GPIO input function configuration register
        pub const FUNC36_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
          IN_SEL: u6,

          /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
          IN_INV_SEL: u1,

          /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
          SEL: u1,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x600911e4));

        /// GPIO input function configuration register
        pub const FUNC37_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
          IN_SEL: u6,

          /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
          IN_INV_SEL: u1,

          /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
          SEL: u1,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x600911e8));

        /// GPIO input function configuration register
        pub const FUNC38_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
          IN_SEL: u6,

          /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
          IN_INV_SEL: u1,

          /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
          SEL: u1,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x600911ec));

        /// GPIO input function configuration register
        pub const FUNC39_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
          IN_SEL: u6,

          /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
          IN_INV_SEL: u1,

          /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
          SEL: u1,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x600911f0));

        /// GPIO input function configuration register
        pub const FUNC40_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
          IN_SEL: u6,

          /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
          IN_INV_SEL: u1,

          /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
          SEL: u1,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x600911f4));

        /// GPIO input function configuration register
        pub const FUNC41_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
          IN_SEL: u6,

          /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
          IN_INV_SEL: u1,

          /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
          SEL: u1,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x600911f8));

        /// GPIO input function configuration register
        pub const FUNC42_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
          IN_SEL: u6,

          /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
          IN_INV_SEL: u1,

          /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
          SEL: u1,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x600911fc));

        /// GPIO input function configuration register
        pub const FUNC43_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
          IN_SEL: u6,

          /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
          IN_INV_SEL: u1,

          /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
          SEL: u1,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x60091200));

        /// GPIO input function configuration register
        pub const FUNC44_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
          IN_SEL: u6,

          /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
          IN_INV_SEL: u1,

          /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
          SEL: u1,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x60091204));

        /// GPIO input function configuration register
        pub const FUNC45_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
          IN_SEL: u6,

          /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
          IN_INV_SEL: u1,

          /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
          SEL: u1,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x60091208));

        /// GPIO input function configuration register
        pub const FUNC46_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
          IN_SEL: u6,

          /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
          IN_INV_SEL: u1,

          /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
          SEL: u1,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x6009120c));

        /// GPIO input function configuration register
        pub const FUNC47_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
          IN_SEL: u6,

          /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
          IN_INV_SEL: u1,

          /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
          SEL: u1,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x60091210));

        /// GPIO input function configuration register
        pub const FUNC48_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
          IN_SEL: u6,

          /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
          IN_INV_SEL: u1,

          /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
          SEL: u1,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x60091214));

        /// GPIO input function configuration register
        pub const FUNC49_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
          IN_SEL: u6,

          /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
          IN_INV_SEL: u1,

          /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
          SEL: u1,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x60091218));

        /// GPIO input function configuration register
        pub const FUNC50_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
          IN_SEL: u6,

          /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
          IN_INV_SEL: u1,

          /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
          SEL: u1,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x6009121c));

        /// GPIO input function configuration register
        pub const FUNC51_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
          IN_SEL: u6,

          /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
          IN_INV_SEL: u1,

          /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
          SEL: u1,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x60091220));

        /// GPIO input function configuration register
        pub const FUNC52_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
          IN_SEL: u6,

          /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
          IN_INV_SEL: u1,

          /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
          SEL: u1,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x60091224));

        /// GPIO input function configuration register
        pub const FUNC53_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
          IN_SEL: u6,

          /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
          IN_INV_SEL: u1,

          /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
          SEL: u1,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x60091228));

        /// GPIO input function configuration register
        pub const FUNC54_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
          IN_SEL: u6,

          /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
          IN_INV_SEL: u1,

          /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
          SEL: u1,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x6009122c));

        /// GPIO input function configuration register
        pub const FUNC55_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
          IN_SEL: u6,

          /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
          IN_INV_SEL: u1,

          /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
          SEL: u1,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x60091230));

        /// GPIO input function configuration register
        pub const FUNC56_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
          IN_SEL: u6,

          /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
          IN_INV_SEL: u1,

          /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
          SEL: u1,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x60091234));

        /// GPIO input function configuration register
        pub const FUNC57_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
          IN_SEL: u6,

          /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
          IN_INV_SEL: u1,

          /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
          SEL: u1,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x60091238));

        /// GPIO input function configuration register
        pub const FUNC58_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
          IN_SEL: u6,

          /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
          IN_INV_SEL: u1,

          /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
          SEL: u1,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x6009123c));

        /// GPIO input function configuration register
        pub const FUNC59_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
          IN_SEL: u6,

          /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
          IN_INV_SEL: u1,

          /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
          SEL: u1,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x60091240));

        /// GPIO input function configuration register
        pub const FUNC60_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
          IN_SEL: u6,

          /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
          IN_INV_SEL: u1,

          /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
          SEL: u1,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x60091244));

        /// GPIO input function configuration register
        pub const FUNC61_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
          IN_SEL: u6,

          /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
          IN_INV_SEL: u1,

          /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
          SEL: u1,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x60091248));

        /// GPIO input function configuration register
        pub const FUNC62_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
          IN_SEL: u6,

          /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
          IN_INV_SEL: u1,

          /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
          SEL: u1,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x6009124c));

        /// GPIO input function configuration register
        pub const FUNC63_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
          IN_SEL: u6,

          /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
          IN_INV_SEL: u1,

          /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
          SEL: u1,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x60091250));

        /// GPIO input function configuration register
        pub const FUNC64_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
          IN_SEL: u6,

          /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
          IN_INV_SEL: u1,

          /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
          SEL: u1,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x60091254));

        /// GPIO input function configuration register
        pub const FUNC65_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
          IN_SEL: u6,

          /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
          IN_INV_SEL: u1,

          /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
          SEL: u1,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x60091258));

        /// GPIO input function configuration register
        pub const FUNC66_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
          IN_SEL: u6,

          /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
          IN_INV_SEL: u1,

          /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
          SEL: u1,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x6009125c));

        /// GPIO input function configuration register
        pub const FUNC67_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
          IN_SEL: u6,

          /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
          IN_INV_SEL: u1,

          /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
          SEL: u1,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x60091260));

        /// GPIO input function configuration register
        pub const FUNC68_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
          IN_SEL: u6,

          /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
          IN_INV_SEL: u1,

          /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
          SEL: u1,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x60091264));

        /// GPIO input function configuration register
        pub const FUNC69_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
          IN_SEL: u6,

          /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
          IN_INV_SEL: u1,

          /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
          SEL: u1,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x60091268));

        /// GPIO input function configuration register
        pub const FUNC70_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
          IN_SEL: u6,

          /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
          IN_INV_SEL: u1,

          /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
          SEL: u1,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x6009126c));

        /// GPIO input function configuration register
        pub const FUNC71_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
          IN_SEL: u6,

          /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
          IN_INV_SEL: u1,

          /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
          SEL: u1,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x60091270));

        /// GPIO input function configuration register
        pub const FUNC72_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
          IN_SEL: u6,

          /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
          IN_INV_SEL: u1,

          /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
          SEL: u1,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x60091274));

        /// GPIO input function configuration register
        pub const FUNC73_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
          IN_SEL: u6,

          /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
          IN_INV_SEL: u1,

          /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
          SEL: u1,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x60091278));

        /// GPIO input function configuration register
        pub const FUNC74_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
          IN_SEL: u6,

          /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
          IN_INV_SEL: u1,

          /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
          SEL: u1,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x6009127c));

        /// GPIO input function configuration register
        pub const FUNC75_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
          IN_SEL: u6,

          /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
          IN_INV_SEL: u1,

          /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
          SEL: u1,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x60091280));

        /// GPIO input function configuration register
        pub const FUNC76_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
          IN_SEL: u6,

          /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
          IN_INV_SEL: u1,

          /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
          SEL: u1,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x60091284));

        /// GPIO input function configuration register
        pub const FUNC77_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
          IN_SEL: u6,

          /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
          IN_INV_SEL: u1,

          /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
          SEL: u1,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x60091288));

        /// GPIO input function configuration register
        pub const FUNC78_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
          IN_SEL: u6,

          /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
          IN_INV_SEL: u1,

          /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
          SEL: u1,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x6009128c));

        /// GPIO input function configuration register
        pub const FUNC79_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
          IN_SEL: u6,

          /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
          IN_INV_SEL: u1,

          /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
          SEL: u1,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x60091290));

        /// GPIO input function configuration register
        pub const FUNC80_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
          IN_SEL: u6,

          /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
          IN_INV_SEL: u1,

          /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
          SEL: u1,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x60091294));

        /// GPIO input function configuration register
        pub const FUNC81_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
          IN_SEL: u6,

          /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
          IN_INV_SEL: u1,

          /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
          SEL: u1,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x60091298));

        /// GPIO input function configuration register
        pub const FUNC82_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
          IN_SEL: u6,

          /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
          IN_INV_SEL: u1,

          /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
          SEL: u1,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x6009129c));

        /// GPIO input function configuration register
        pub const FUNC83_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
          IN_SEL: u6,

          /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
          IN_INV_SEL: u1,

          /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
          SEL: u1,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x600912a0));

        /// GPIO input function configuration register
        pub const FUNC84_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
          IN_SEL: u6,

          /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
          IN_INV_SEL: u1,

          /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
          SEL: u1,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x600912a4));

        /// GPIO input function configuration register
        pub const FUNC85_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
          IN_SEL: u6,

          /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
          IN_INV_SEL: u1,

          /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
          SEL: u1,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x600912a8));

        /// GPIO input function configuration register
        pub const FUNC86_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
          IN_SEL: u6,

          /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
          IN_INV_SEL: u1,

          /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
          SEL: u1,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x600912ac));

        /// GPIO input function configuration register
        pub const FUNC87_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
          IN_SEL: u6,

          /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
          IN_INV_SEL: u1,

          /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
          SEL: u1,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x600912b0));

        /// GPIO input function configuration register
        pub const FUNC88_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
          IN_SEL: u6,

          /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
          IN_INV_SEL: u1,

          /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
          SEL: u1,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x600912b4));

        /// GPIO input function configuration register
        pub const FUNC89_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
          IN_SEL: u6,

          /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
          IN_INV_SEL: u1,

          /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
          SEL: u1,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x600912b8));

        /// GPIO input function configuration register
        pub const FUNC90_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
          IN_SEL: u6,

          /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
          IN_INV_SEL: u1,

          /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
          SEL: u1,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x600912bc));

        /// GPIO input function configuration register
        pub const FUNC91_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
          IN_SEL: u6,

          /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
          IN_INV_SEL: u1,

          /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
          SEL: u1,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x600912c0));

        /// GPIO input function configuration register
        pub const FUNC92_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
          IN_SEL: u6,

          /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
          IN_INV_SEL: u1,

          /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
          SEL: u1,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x600912c4));

        /// GPIO input function configuration register
        pub const FUNC93_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
          IN_SEL: u6,

          /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
          IN_INV_SEL: u1,

          /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
          SEL: u1,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x600912c8));

        /// GPIO input function configuration register
        pub const FUNC94_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
          IN_SEL: u6,

          /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
          IN_INV_SEL: u1,

          /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
          SEL: u1,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x600912cc));

        /// GPIO input function configuration register
        pub const FUNC95_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
          IN_SEL: u6,

          /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
          IN_INV_SEL: u1,

          /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
          SEL: u1,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x600912d0));

        /// GPIO input function configuration register
        pub const FUNC96_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
          IN_SEL: u6,

          /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
          IN_INV_SEL: u1,

          /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
          SEL: u1,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x600912d4));

        /// GPIO input function configuration register
        pub const FUNC97_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
          IN_SEL: u6,

          /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
          IN_INV_SEL: u1,

          /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
          SEL: u1,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x600912d8));

        /// GPIO input function configuration register
        pub const FUNC98_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
          IN_SEL: u6,

          /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
          IN_INV_SEL: u1,

          /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
          SEL: u1,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x600912dc));

        /// GPIO input function configuration register
        pub const FUNC99_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
          IN_SEL: u6,

          /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
          IN_INV_SEL: u1,

          /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
          SEL: u1,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x600912e0));

        /// GPIO input function configuration register
        pub const FUNC100_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
          IN_SEL: u6,

          /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
          IN_INV_SEL: u1,

          /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
          SEL: u1,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x600912e4));

        /// GPIO input function configuration register
        pub const FUNC101_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
          IN_SEL: u6,

          /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
          IN_INV_SEL: u1,

          /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
          SEL: u1,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x600912e8));

        /// GPIO input function configuration register
        pub const FUNC102_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
          IN_SEL: u6,

          /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
          IN_INV_SEL: u1,

          /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
          SEL: u1,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x600912ec));

        /// GPIO input function configuration register
        pub const FUNC103_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
          IN_SEL: u6,

          /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
          IN_INV_SEL: u1,

          /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
          SEL: u1,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x600912f0));

        /// GPIO input function configuration register
        pub const FUNC104_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
          IN_SEL: u6,

          /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
          IN_INV_SEL: u1,

          /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
          SEL: u1,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x600912f4));

        /// GPIO input function configuration register
        pub const FUNC105_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
          IN_SEL: u6,

          /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
          IN_INV_SEL: u1,

          /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
          SEL: u1,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x600912f8));

        /// GPIO input function configuration register
        pub const FUNC106_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
          IN_SEL: u6,

          /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
          IN_INV_SEL: u1,

          /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
          SEL: u1,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x600912fc));

        /// GPIO input function configuration register
        pub const FUNC107_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
          IN_SEL: u6,

          /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
          IN_INV_SEL: u1,

          /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
          SEL: u1,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x60091300));

        /// GPIO input function configuration register
        pub const FUNC108_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
          IN_SEL: u6,

          /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
          IN_INV_SEL: u1,

          /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
          SEL: u1,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x60091304));

        /// GPIO input function configuration register
        pub const FUNC109_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
          IN_SEL: u6,

          /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
          IN_INV_SEL: u1,

          /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
          SEL: u1,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x60091308));

        /// GPIO input function configuration register
        pub const FUNC110_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
          IN_SEL: u6,

          /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
          IN_INV_SEL: u1,

          /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
          SEL: u1,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x6009130c));

        /// GPIO input function configuration register
        pub const FUNC111_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
          IN_SEL: u6,

          /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
          IN_INV_SEL: u1,

          /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
          SEL: u1,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x60091310));

        /// GPIO input function configuration register
        pub const FUNC112_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
          IN_SEL: u6,

          /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
          IN_INV_SEL: u1,

          /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
          SEL: u1,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x60091314));

        /// GPIO input function configuration register
        pub const FUNC113_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
          IN_SEL: u6,

          /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
          IN_INV_SEL: u1,

          /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
          SEL: u1,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x60091318));

        /// GPIO input function configuration register
        pub const FUNC114_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
          IN_SEL: u6,

          /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
          IN_INV_SEL: u1,

          /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
          SEL: u1,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x6009131c));

        /// GPIO input function configuration register
        pub const FUNC115_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
          IN_SEL: u6,

          /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
          IN_INV_SEL: u1,

          /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
          SEL: u1,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x60091320));

        /// GPIO input function configuration register
        pub const FUNC116_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
          IN_SEL: u6,

          /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
          IN_INV_SEL: u1,

          /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
          SEL: u1,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x60091324));

        /// GPIO input function configuration register
        pub const FUNC117_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
          IN_SEL: u6,

          /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
          IN_INV_SEL: u1,

          /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
          SEL: u1,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x60091328));

        /// GPIO input function configuration register
        pub const FUNC118_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
          IN_SEL: u6,

          /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
          IN_INV_SEL: u1,

          /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
          SEL: u1,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x6009132c));

        /// GPIO input function configuration register
        pub const FUNC119_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
          IN_SEL: u6,

          /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
          IN_INV_SEL: u1,

          /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
          SEL: u1,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x60091330));

        /// GPIO input function configuration register
        pub const FUNC120_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
          IN_SEL: u6,

          /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
          IN_INV_SEL: u1,

          /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
          SEL: u1,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x60091334));

        /// GPIO input function configuration register
        pub const FUNC121_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
          IN_SEL: u6,

          /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
          IN_INV_SEL: u1,

          /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
          SEL: u1,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x60091338));

        /// GPIO input function configuration register
        pub const FUNC122_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
          IN_SEL: u6,

          /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
          IN_INV_SEL: u1,

          /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
          SEL: u1,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x6009133c));

        /// GPIO input function configuration register
        pub const FUNC123_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
          IN_SEL: u6,

          /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
          IN_INV_SEL: u1,

          /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
          SEL: u1,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x60091340));

        /// GPIO input function configuration register
        pub const FUNC124_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
          IN_SEL: u6,

          /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
          IN_INV_SEL: u1,

          /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
          SEL: u1,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x60091344));

        /// GPIO input function configuration register
        pub const FUNC125_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
          IN_SEL: u6,

          /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
          IN_INV_SEL: u1,

          /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
          SEL: u1,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x60091348));

        /// GPIO input function configuration register
        pub const FUNC126_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
          IN_SEL: u6,

          /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
          IN_INV_SEL: u1,

          /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
          SEL: u1,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x6009134c));

        /// GPIO input function configuration register
        pub const FUNC127_IN_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] set this value: s=0-34: connect GPIO[s] to this port. s=0x38: set this port always high level. s=0x3C: set this port always low level.
          IN_SEL: u6,

          /// [6:6] set this bit to invert input signal. 1:invert. 0:not invert.
          IN_INV_SEL: u1,

          /// [7:7] set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass GPIO.
          SEL: u1,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x60091350));

        /// GPIO output function select register
        pub const FUNC0_OUT_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] The value of the bits: 0<=s<=256. Set the value to select output signal. s=0-127: output of GPIO[n] equals input of peripheral[s]. s=128: output of GPIO[n] equals GPIO_OUT_REG[n].
          OUT_SEL: u8,

          /// [8:8] set this bit to invert output signal.1:invert.0:not invert.
          INV_SEL: u1,

          /// [9:9] set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n] as output enable signal.0:use peripheral output enable signal.
          OEN_SEL: u1,

          /// [10:10] set this bit to invert output enable signal.1:invert.0:not invert.
          OEN_INV_SEL: u1,

          /// [11:31] 
          res0: u21,

        }), @ptrFromInt(0x60091554));

        /// GPIO output function select register
        pub const FUNC1_OUT_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] The value of the bits: 0<=s<=256. Set the value to select output signal. s=0-127: output of GPIO[n] equals input of peripheral[s]. s=128: output of GPIO[n] equals GPIO_OUT_REG[n].
          OUT_SEL: u8,

          /// [8:8] set this bit to invert output signal.1:invert.0:not invert.
          INV_SEL: u1,

          /// [9:9] set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n] as output enable signal.0:use peripheral output enable signal.
          OEN_SEL: u1,

          /// [10:10] set this bit to invert output enable signal.1:invert.0:not invert.
          OEN_INV_SEL: u1,

          /// [11:31] 
          res0: u21,

        }), @ptrFromInt(0x60091558));

        /// GPIO output function select register
        pub const FUNC2_OUT_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] The value of the bits: 0<=s<=256. Set the value to select output signal. s=0-127: output of GPIO[n] equals input of peripheral[s]. s=128: output of GPIO[n] equals GPIO_OUT_REG[n].
          OUT_SEL: u8,

          /// [8:8] set this bit to invert output signal.1:invert.0:not invert.
          INV_SEL: u1,

          /// [9:9] set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n] as output enable signal.0:use peripheral output enable signal.
          OEN_SEL: u1,

          /// [10:10] set this bit to invert output enable signal.1:invert.0:not invert.
          OEN_INV_SEL: u1,

          /// [11:31] 
          res0: u21,

        }), @ptrFromInt(0x6009155c));

        /// GPIO output function select register
        pub const FUNC3_OUT_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] The value of the bits: 0<=s<=256. Set the value to select output signal. s=0-127: output of GPIO[n] equals input of peripheral[s]. s=128: output of GPIO[n] equals GPIO_OUT_REG[n].
          OUT_SEL: u8,

          /// [8:8] set this bit to invert output signal.1:invert.0:not invert.
          INV_SEL: u1,

          /// [9:9] set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n] as output enable signal.0:use peripheral output enable signal.
          OEN_SEL: u1,

          /// [10:10] set this bit to invert output enable signal.1:invert.0:not invert.
          OEN_INV_SEL: u1,

          /// [11:31] 
          res0: u21,

        }), @ptrFromInt(0x60091560));

        /// GPIO output function select register
        pub const FUNC4_OUT_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] The value of the bits: 0<=s<=256. Set the value to select output signal. s=0-127: output of GPIO[n] equals input of peripheral[s]. s=128: output of GPIO[n] equals GPIO_OUT_REG[n].
          OUT_SEL: u8,

          /// [8:8] set this bit to invert output signal.1:invert.0:not invert.
          INV_SEL: u1,

          /// [9:9] set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n] as output enable signal.0:use peripheral output enable signal.
          OEN_SEL: u1,

          /// [10:10] set this bit to invert output enable signal.1:invert.0:not invert.
          OEN_INV_SEL: u1,

          /// [11:31] 
          res0: u21,

        }), @ptrFromInt(0x60091564));

        /// GPIO output function select register
        pub const FUNC5_OUT_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] The value of the bits: 0<=s<=256. Set the value to select output signal. s=0-127: output of GPIO[n] equals input of peripheral[s]. s=128: output of GPIO[n] equals GPIO_OUT_REG[n].
          OUT_SEL: u8,

          /// [8:8] set this bit to invert output signal.1:invert.0:not invert.
          INV_SEL: u1,

          /// [9:9] set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n] as output enable signal.0:use peripheral output enable signal.
          OEN_SEL: u1,

          /// [10:10] set this bit to invert output enable signal.1:invert.0:not invert.
          OEN_INV_SEL: u1,

          /// [11:31] 
          res0: u21,

        }), @ptrFromInt(0x60091568));

        /// GPIO output function select register
        pub const FUNC6_OUT_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] The value of the bits: 0<=s<=256. Set the value to select output signal. s=0-127: output of GPIO[n] equals input of peripheral[s]. s=128: output of GPIO[n] equals GPIO_OUT_REG[n].
          OUT_SEL: u8,

          /// [8:8] set this bit to invert output signal.1:invert.0:not invert.
          INV_SEL: u1,

          /// [9:9] set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n] as output enable signal.0:use peripheral output enable signal.
          OEN_SEL: u1,

          /// [10:10] set this bit to invert output enable signal.1:invert.0:not invert.
          OEN_INV_SEL: u1,

          /// [11:31] 
          res0: u21,

        }), @ptrFromInt(0x6009156c));

        /// GPIO output function select register
        pub const FUNC7_OUT_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] The value of the bits: 0<=s<=256. Set the value to select output signal. s=0-127: output of GPIO[n] equals input of peripheral[s]. s=128: output of GPIO[n] equals GPIO_OUT_REG[n].
          OUT_SEL: u8,

          /// [8:8] set this bit to invert output signal.1:invert.0:not invert.
          INV_SEL: u1,

          /// [9:9] set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n] as output enable signal.0:use peripheral output enable signal.
          OEN_SEL: u1,

          /// [10:10] set this bit to invert output enable signal.1:invert.0:not invert.
          OEN_INV_SEL: u1,

          /// [11:31] 
          res0: u21,

        }), @ptrFromInt(0x60091570));

        /// GPIO output function select register
        pub const FUNC8_OUT_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] The value of the bits: 0<=s<=256. Set the value to select output signal. s=0-127: output of GPIO[n] equals input of peripheral[s]. s=128: output of GPIO[n] equals GPIO_OUT_REG[n].
          OUT_SEL: u8,

          /// [8:8] set this bit to invert output signal.1:invert.0:not invert.
          INV_SEL: u1,

          /// [9:9] set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n] as output enable signal.0:use peripheral output enable signal.
          OEN_SEL: u1,

          /// [10:10] set this bit to invert output enable signal.1:invert.0:not invert.
          OEN_INV_SEL: u1,

          /// [11:31] 
          res0: u21,

        }), @ptrFromInt(0x60091574));

        /// GPIO output function select register
        pub const FUNC9_OUT_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] The value of the bits: 0<=s<=256. Set the value to select output signal. s=0-127: output of GPIO[n] equals input of peripheral[s]. s=128: output of GPIO[n] equals GPIO_OUT_REG[n].
          OUT_SEL: u8,

          /// [8:8] set this bit to invert output signal.1:invert.0:not invert.
          INV_SEL: u1,

          /// [9:9] set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n] as output enable signal.0:use peripheral output enable signal.
          OEN_SEL: u1,

          /// [10:10] set this bit to invert output enable signal.1:invert.0:not invert.
          OEN_INV_SEL: u1,

          /// [11:31] 
          res0: u21,

        }), @ptrFromInt(0x60091578));

        /// GPIO output function select register
        pub const FUNC10_OUT_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] The value of the bits: 0<=s<=256. Set the value to select output signal. s=0-127: output of GPIO[n] equals input of peripheral[s]. s=128: output of GPIO[n] equals GPIO_OUT_REG[n].
          OUT_SEL: u8,

          /// [8:8] set this bit to invert output signal.1:invert.0:not invert.
          INV_SEL: u1,

          /// [9:9] set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n] as output enable signal.0:use peripheral output enable signal.
          OEN_SEL: u1,

          /// [10:10] set this bit to invert output enable signal.1:invert.0:not invert.
          OEN_INV_SEL: u1,

          /// [11:31] 
          res0: u21,

        }), @ptrFromInt(0x6009157c));

        /// GPIO output function select register
        pub const FUNC11_OUT_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] The value of the bits: 0<=s<=256. Set the value to select output signal. s=0-127: output of GPIO[n] equals input of peripheral[s]. s=128: output of GPIO[n] equals GPIO_OUT_REG[n].
          OUT_SEL: u8,

          /// [8:8] set this bit to invert output signal.1:invert.0:not invert.
          INV_SEL: u1,

          /// [9:9] set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n] as output enable signal.0:use peripheral output enable signal.
          OEN_SEL: u1,

          /// [10:10] set this bit to invert output enable signal.1:invert.0:not invert.
          OEN_INV_SEL: u1,

          /// [11:31] 
          res0: u21,

        }), @ptrFromInt(0x60091580));

        /// GPIO output function select register
        pub const FUNC12_OUT_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] The value of the bits: 0<=s<=256. Set the value to select output signal. s=0-127: output of GPIO[n] equals input of peripheral[s]. s=128: output of GPIO[n] equals GPIO_OUT_REG[n].
          OUT_SEL: u8,

          /// [8:8] set this bit to invert output signal.1:invert.0:not invert.
          INV_SEL: u1,

          /// [9:9] set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n] as output enable signal.0:use peripheral output enable signal.
          OEN_SEL: u1,

          /// [10:10] set this bit to invert output enable signal.1:invert.0:not invert.
          OEN_INV_SEL: u1,

          /// [11:31] 
          res0: u21,

        }), @ptrFromInt(0x60091584));

        /// GPIO output function select register
        pub const FUNC13_OUT_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] The value of the bits: 0<=s<=256. Set the value to select output signal. s=0-127: output of GPIO[n] equals input of peripheral[s]. s=128: output of GPIO[n] equals GPIO_OUT_REG[n].
          OUT_SEL: u8,

          /// [8:8] set this bit to invert output signal.1:invert.0:not invert.
          INV_SEL: u1,

          /// [9:9] set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n] as output enable signal.0:use peripheral output enable signal.
          OEN_SEL: u1,

          /// [10:10] set this bit to invert output enable signal.1:invert.0:not invert.
          OEN_INV_SEL: u1,

          /// [11:31] 
          res0: u21,

        }), @ptrFromInt(0x60091588));

        /// GPIO output function select register
        pub const FUNC14_OUT_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] The value of the bits: 0<=s<=256. Set the value to select output signal. s=0-127: output of GPIO[n] equals input of peripheral[s]. s=128: output of GPIO[n] equals GPIO_OUT_REG[n].
          OUT_SEL: u8,

          /// [8:8] set this bit to invert output signal.1:invert.0:not invert.
          INV_SEL: u1,

          /// [9:9] set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n] as output enable signal.0:use peripheral output enable signal.
          OEN_SEL: u1,

          /// [10:10] set this bit to invert output enable signal.1:invert.0:not invert.
          OEN_INV_SEL: u1,

          /// [11:31] 
          res0: u21,

        }), @ptrFromInt(0x6009158c));

        /// GPIO output function select register
        pub const FUNC15_OUT_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] The value of the bits: 0<=s<=256. Set the value to select output signal. s=0-127: output of GPIO[n] equals input of peripheral[s]. s=128: output of GPIO[n] equals GPIO_OUT_REG[n].
          OUT_SEL: u8,

          /// [8:8] set this bit to invert output signal.1:invert.0:not invert.
          INV_SEL: u1,

          /// [9:9] set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n] as output enable signal.0:use peripheral output enable signal.
          OEN_SEL: u1,

          /// [10:10] set this bit to invert output enable signal.1:invert.0:not invert.
          OEN_INV_SEL: u1,

          /// [11:31] 
          res0: u21,

        }), @ptrFromInt(0x60091590));

        /// GPIO output function select register
        pub const FUNC16_OUT_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] The value of the bits: 0<=s<=256. Set the value to select output signal. s=0-127: output of GPIO[n] equals input of peripheral[s]. s=128: output of GPIO[n] equals GPIO_OUT_REG[n].
          OUT_SEL: u8,

          /// [8:8] set this bit to invert output signal.1:invert.0:not invert.
          INV_SEL: u1,

          /// [9:9] set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n] as output enable signal.0:use peripheral output enable signal.
          OEN_SEL: u1,

          /// [10:10] set this bit to invert output enable signal.1:invert.0:not invert.
          OEN_INV_SEL: u1,

          /// [11:31] 
          res0: u21,

        }), @ptrFromInt(0x60091594));

        /// GPIO output function select register
        pub const FUNC17_OUT_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] The value of the bits: 0<=s<=256. Set the value to select output signal. s=0-127: output of GPIO[n] equals input of peripheral[s]. s=128: output of GPIO[n] equals GPIO_OUT_REG[n].
          OUT_SEL: u8,

          /// [8:8] set this bit to invert output signal.1:invert.0:not invert.
          INV_SEL: u1,

          /// [9:9] set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n] as output enable signal.0:use peripheral output enable signal.
          OEN_SEL: u1,

          /// [10:10] set this bit to invert output enable signal.1:invert.0:not invert.
          OEN_INV_SEL: u1,

          /// [11:31] 
          res0: u21,

        }), @ptrFromInt(0x60091598));

        /// GPIO output function select register
        pub const FUNC18_OUT_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] The value of the bits: 0<=s<=256. Set the value to select output signal. s=0-127: output of GPIO[n] equals input of peripheral[s]. s=128: output of GPIO[n] equals GPIO_OUT_REG[n].
          OUT_SEL: u8,

          /// [8:8] set this bit to invert output signal.1:invert.0:not invert.
          INV_SEL: u1,

          /// [9:9] set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n] as output enable signal.0:use peripheral output enable signal.
          OEN_SEL: u1,

          /// [10:10] set this bit to invert output enable signal.1:invert.0:not invert.
          OEN_INV_SEL: u1,

          /// [11:31] 
          res0: u21,

        }), @ptrFromInt(0x6009159c));

        /// GPIO output function select register
        pub const FUNC19_OUT_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] The value of the bits: 0<=s<=256. Set the value to select output signal. s=0-127: output of GPIO[n] equals input of peripheral[s]. s=128: output of GPIO[n] equals GPIO_OUT_REG[n].
          OUT_SEL: u8,

          /// [8:8] set this bit to invert output signal.1:invert.0:not invert.
          INV_SEL: u1,

          /// [9:9] set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n] as output enable signal.0:use peripheral output enable signal.
          OEN_SEL: u1,

          /// [10:10] set this bit to invert output enable signal.1:invert.0:not invert.
          OEN_INV_SEL: u1,

          /// [11:31] 
          res0: u21,

        }), @ptrFromInt(0x600915a0));

        /// GPIO output function select register
        pub const FUNC20_OUT_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] The value of the bits: 0<=s<=256. Set the value to select output signal. s=0-127: output of GPIO[n] equals input of peripheral[s]. s=128: output of GPIO[n] equals GPIO_OUT_REG[n].
          OUT_SEL: u8,

          /// [8:8] set this bit to invert output signal.1:invert.0:not invert.
          INV_SEL: u1,

          /// [9:9] set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n] as output enable signal.0:use peripheral output enable signal.
          OEN_SEL: u1,

          /// [10:10] set this bit to invert output enable signal.1:invert.0:not invert.
          OEN_INV_SEL: u1,

          /// [11:31] 
          res0: u21,

        }), @ptrFromInt(0x600915a4));

        /// GPIO output function select register
        pub const FUNC21_OUT_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] The value of the bits: 0<=s<=256. Set the value to select output signal. s=0-127: output of GPIO[n] equals input of peripheral[s]. s=128: output of GPIO[n] equals GPIO_OUT_REG[n].
          OUT_SEL: u8,

          /// [8:8] set this bit to invert output signal.1:invert.0:not invert.
          INV_SEL: u1,

          /// [9:9] set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n] as output enable signal.0:use peripheral output enable signal.
          OEN_SEL: u1,

          /// [10:10] set this bit to invert output enable signal.1:invert.0:not invert.
          OEN_INV_SEL: u1,

          /// [11:31] 
          res0: u21,

        }), @ptrFromInt(0x600915a8));

        /// GPIO output function select register
        pub const FUNC22_OUT_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] The value of the bits: 0<=s<=256. Set the value to select output signal. s=0-127: output of GPIO[n] equals input of peripheral[s]. s=128: output of GPIO[n] equals GPIO_OUT_REG[n].
          OUT_SEL: u8,

          /// [8:8] set this bit to invert output signal.1:invert.0:not invert.
          INV_SEL: u1,

          /// [9:9] set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n] as output enable signal.0:use peripheral output enable signal.
          OEN_SEL: u1,

          /// [10:10] set this bit to invert output enable signal.1:invert.0:not invert.
          OEN_INV_SEL: u1,

          /// [11:31] 
          res0: u21,

        }), @ptrFromInt(0x600915ac));

        /// GPIO output function select register
        pub const FUNC23_OUT_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] The value of the bits: 0<=s<=256. Set the value to select output signal. s=0-127: output of GPIO[n] equals input of peripheral[s]. s=128: output of GPIO[n] equals GPIO_OUT_REG[n].
          OUT_SEL: u8,

          /// [8:8] set this bit to invert output signal.1:invert.0:not invert.
          INV_SEL: u1,

          /// [9:9] set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n] as output enable signal.0:use peripheral output enable signal.
          OEN_SEL: u1,

          /// [10:10] set this bit to invert output enable signal.1:invert.0:not invert.
          OEN_INV_SEL: u1,

          /// [11:31] 
          res0: u21,

        }), @ptrFromInt(0x600915b0));

        /// GPIO output function select register
        pub const FUNC24_OUT_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] The value of the bits: 0<=s<=256. Set the value to select output signal. s=0-127: output of GPIO[n] equals input of peripheral[s]. s=128: output of GPIO[n] equals GPIO_OUT_REG[n].
          OUT_SEL: u8,

          /// [8:8] set this bit to invert output signal.1:invert.0:not invert.
          INV_SEL: u1,

          /// [9:9] set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n] as output enable signal.0:use peripheral output enable signal.
          OEN_SEL: u1,

          /// [10:10] set this bit to invert output enable signal.1:invert.0:not invert.
          OEN_INV_SEL: u1,

          /// [11:31] 
          res0: u21,

        }), @ptrFromInt(0x600915b4));

        /// GPIO output function select register
        pub const FUNC25_OUT_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] The value of the bits: 0<=s<=256. Set the value to select output signal. s=0-127: output of GPIO[n] equals input of peripheral[s]. s=128: output of GPIO[n] equals GPIO_OUT_REG[n].
          OUT_SEL: u8,

          /// [8:8] set this bit to invert output signal.1:invert.0:not invert.
          INV_SEL: u1,

          /// [9:9] set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n] as output enable signal.0:use peripheral output enable signal.
          OEN_SEL: u1,

          /// [10:10] set this bit to invert output enable signal.1:invert.0:not invert.
          OEN_INV_SEL: u1,

          /// [11:31] 
          res0: u21,

        }), @ptrFromInt(0x600915b8));

        /// GPIO output function select register
        pub const FUNC26_OUT_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] The value of the bits: 0<=s<=256. Set the value to select output signal. s=0-127: output of GPIO[n] equals input of peripheral[s]. s=128: output of GPIO[n] equals GPIO_OUT_REG[n].
          OUT_SEL: u8,

          /// [8:8] set this bit to invert output signal.1:invert.0:not invert.
          INV_SEL: u1,

          /// [9:9] set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n] as output enable signal.0:use peripheral output enable signal.
          OEN_SEL: u1,

          /// [10:10] set this bit to invert output enable signal.1:invert.0:not invert.
          OEN_INV_SEL: u1,

          /// [11:31] 
          res0: u21,

        }), @ptrFromInt(0x600915bc));

        /// GPIO output function select register
        pub const FUNC27_OUT_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] The value of the bits: 0<=s<=256. Set the value to select output signal. s=0-127: output of GPIO[n] equals input of peripheral[s]. s=128: output of GPIO[n] equals GPIO_OUT_REG[n].
          OUT_SEL: u8,

          /// [8:8] set this bit to invert output signal.1:invert.0:not invert.
          INV_SEL: u1,

          /// [9:9] set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n] as output enable signal.0:use peripheral output enable signal.
          OEN_SEL: u1,

          /// [10:10] set this bit to invert output enable signal.1:invert.0:not invert.
          OEN_INV_SEL: u1,

          /// [11:31] 
          res0: u21,

        }), @ptrFromInt(0x600915c0));

        /// GPIO output function select register
        pub const FUNC28_OUT_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] The value of the bits: 0<=s<=256. Set the value to select output signal. s=0-127: output of GPIO[n] equals input of peripheral[s]. s=128: output of GPIO[n] equals GPIO_OUT_REG[n].
          OUT_SEL: u8,

          /// [8:8] set this bit to invert output signal.1:invert.0:not invert.
          INV_SEL: u1,

          /// [9:9] set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n] as output enable signal.0:use peripheral output enable signal.
          OEN_SEL: u1,

          /// [10:10] set this bit to invert output enable signal.1:invert.0:not invert.
          OEN_INV_SEL: u1,

          /// [11:31] 
          res0: u21,

        }), @ptrFromInt(0x600915c4));

        /// GPIO output function select register
        pub const FUNC29_OUT_SEL_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] The value of the bits: 0<=s<=256. Set the value to select output signal. s=0-127: output of GPIO[n] equals input of peripheral[s]. s=128: output of GPIO[n] equals GPIO_OUT_REG[n].
          OUT_SEL: u8,

          /// [8:8] set this bit to invert output signal.1:invert.0:not invert.
          INV_SEL: u1,

          /// [9:9] set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n] as output enable signal.0:use peripheral output enable signal.
          OEN_SEL: u1,

          /// [10:10] set this bit to invert output enable signal.1:invert.0:not invert.
          OEN_INV_SEL: u1,

          /// [11:31] 
          res0: u21,

        }), @ptrFromInt(0x600915c8));

        /// GPIO clock gate register
        pub const CLOCK_GATE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] set this bit to enable GPIO clock gate
          CLK_EN: u1,

          /// [1:31] 
          res0: u31,

        }), @ptrFromInt(0x6009162c));

        /// GPIO version register
        pub const DATE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:27] version register
          DATE: u28,

          /// [28:31] 
          res0: u4,

        }), @ptrFromInt(0x600916fc));

      };

      /// Sigma-Delta Modulation
      pub const GPIO_SD = struct {

        /// Duty Cycle Configure Register of SDM%s
        pub const SIGMADELTA0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] This field is used to configure the duty cycle of sigma delta modulation output.
          SD0_IN: u8,

          /// [8:15] This field is used to set a divider value to divide APB clock.
          SD0_PRESCALE: u8,

          /// [16:31] 
          res0: u16,

        }), @ptrFromInt(0x60004f00));

        /// Duty Cycle Configure Register of SDM%s
        pub const SIGMADELTA1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] This field is used to configure the duty cycle of sigma delta modulation output.
          SD0_IN: u8,

          /// [8:15] This field is used to set a divider value to divide APB clock.
          SD0_PRESCALE: u8,

          /// [16:31] 
          res0: u16,

        }), @ptrFromInt(0x60004f04));

        /// Duty Cycle Configure Register of SDM%s
        pub const SIGMADELTA2 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] This field is used to configure the duty cycle of sigma delta modulation output.
          SD0_IN: u8,

          /// [8:15] This field is used to set a divider value to divide APB clock.
          SD0_PRESCALE: u8,

          /// [16:31] 
          res0: u16,

        }), @ptrFromInt(0x60004f08));

        /// Duty Cycle Configure Register of SDM%s
        pub const SIGMADELTA3 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] This field is used to configure the duty cycle of sigma delta modulation output.
          SD0_IN: u8,

          /// [8:15] This field is used to set a divider value to divide APB clock.
          SD0_PRESCALE: u8,

          /// [16:31] 
          res0: u16,

        }), @ptrFromInt(0x60004f0c));

        /// Clock Gating Configure Register
        pub const CLOCK_GATE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Clock enable bit of configuration registers for sigma delta modulation.
          CLK_EN: u1,

          /// [1:31] 
          res0: u31,

        }), @ptrFromInt(0x60004f20));

        /// MISC Register
        pub const SIGMADELTA_MISC = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:29] 
          res0: u30,

          /// [30:30] Clock enable bit of sigma delta modulation.
          FUNCTION_CLK_EN: u1,

          /// [31:31] Reserved.
          SPI_SWAP: u1,

        }), @ptrFromInt(0x60004f24));

        /// Glitch Filter Configure Register of Channel%s
        pub const GLITCH_FILTER_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Glitch Filter channel enable bit.
          FILTER_CH0_EN: u1,

          /// [1:6] Glitch Filter input io number.
          FILTER_CH0_INPUT_IO_NUM: u6,

          /// [7:12] Glitch Filter window threshold.
          FILTER_CH0_WINDOW_THRES: u6,

          /// [13:18] Glitch Filter window width.
          FILTER_CH0_WINDOW_WIDTH: u6,

          /// [19:31] 
          res0: u13,

        }), @ptrFromInt(0x60004f30));

        /// Glitch Filter Configure Register of Channel%s
        pub const GLITCH_FILTER_CH1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Glitch Filter channel enable bit.
          FILTER_CH0_EN: u1,

          /// [1:6] Glitch Filter input io number.
          FILTER_CH0_INPUT_IO_NUM: u6,

          /// [7:12] Glitch Filter window threshold.
          FILTER_CH0_WINDOW_THRES: u6,

          /// [13:18] Glitch Filter window width.
          FILTER_CH0_WINDOW_WIDTH: u6,

          /// [19:31] 
          res0: u13,

        }), @ptrFromInt(0x60004f34));

        /// Glitch Filter Configure Register of Channel%s
        pub const GLITCH_FILTER_CH2 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Glitch Filter channel enable bit.
          FILTER_CH0_EN: u1,

          /// [1:6] Glitch Filter input io number.
          FILTER_CH0_INPUT_IO_NUM: u6,

          /// [7:12] Glitch Filter window threshold.
          FILTER_CH0_WINDOW_THRES: u6,

          /// [13:18] Glitch Filter window width.
          FILTER_CH0_WINDOW_WIDTH: u6,

          /// [19:31] 
          res0: u13,

        }), @ptrFromInt(0x60004f38));

        /// Glitch Filter Configure Register of Channel%s
        pub const GLITCH_FILTER_CH3 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Glitch Filter channel enable bit.
          FILTER_CH0_EN: u1,

          /// [1:6] Glitch Filter input io number.
          FILTER_CH0_INPUT_IO_NUM: u6,

          /// [7:12] Glitch Filter window threshold.
          FILTER_CH0_WINDOW_THRES: u6,

          /// [13:18] Glitch Filter window width.
          FILTER_CH0_WINDOW_WIDTH: u6,

          /// [19:31] 
          res0: u13,

        }), @ptrFromInt(0x60004f3c));

        /// Glitch Filter Configure Register of Channel%s
        pub const GLITCH_FILTER_CH4 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Glitch Filter channel enable bit.
          FILTER_CH0_EN: u1,

          /// [1:6] Glitch Filter input io number.
          FILTER_CH0_INPUT_IO_NUM: u6,

          /// [7:12] Glitch Filter window threshold.
          FILTER_CH0_WINDOW_THRES: u6,

          /// [13:18] Glitch Filter window width.
          FILTER_CH0_WINDOW_WIDTH: u6,

          /// [19:31] 
          res0: u13,

        }), @ptrFromInt(0x60004f40));

        /// Glitch Filter Configure Register of Channel%s
        pub const GLITCH_FILTER_CH5 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Glitch Filter channel enable bit.
          FILTER_CH0_EN: u1,

          /// [1:6] Glitch Filter input io number.
          FILTER_CH0_INPUT_IO_NUM: u6,

          /// [7:12] Glitch Filter window threshold.
          FILTER_CH0_WINDOW_THRES: u6,

          /// [13:18] Glitch Filter window width.
          FILTER_CH0_WINDOW_WIDTH: u6,

          /// [19:31] 
          res0: u13,

        }), @ptrFromInt(0x60004f44));

        /// Glitch Filter Configure Register of Channel%s
        pub const GLITCH_FILTER_CH6 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Glitch Filter channel enable bit.
          FILTER_CH0_EN: u1,

          /// [1:6] Glitch Filter input io number.
          FILTER_CH0_INPUT_IO_NUM: u6,

          /// [7:12] Glitch Filter window threshold.
          FILTER_CH0_WINDOW_THRES: u6,

          /// [13:18] Glitch Filter window width.
          FILTER_CH0_WINDOW_WIDTH: u6,

          /// [19:31] 
          res0: u13,

        }), @ptrFromInt(0x60004f48));

        /// Glitch Filter Configure Register of Channel%s
        pub const GLITCH_FILTER_CH7 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Glitch Filter channel enable bit.
          FILTER_CH0_EN: u1,

          /// [1:6] Glitch Filter input io number.
          FILTER_CH0_INPUT_IO_NUM: u6,

          /// [7:12] Glitch Filter window threshold.
          FILTER_CH0_WINDOW_THRES: u6,

          /// [13:18] Glitch Filter window width.
          FILTER_CH0_WINDOW_WIDTH: u6,

          /// [19:31] 
          res0: u13,

        }), @ptrFromInt(0x60004f4c));

        /// Etm Config register of Channel%s
        pub const ETM_EVENT_CH0_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:4] Etm event channel select gpio.
          ETM_CH0_EVENT_SEL: u5,

          /// [5:6] 
          res0: u2,

          /// [7:7] Etm event send enable bit.
          ETM_CH0_EVENT_EN: u1,

          /// [8:31] 
          res1: u24,

        }), @ptrFromInt(0x60004f60));

        /// Etm Config register of Channel%s
        pub const ETM_EVENT_CH1_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:4] Etm event channel select gpio.
          ETM_CH0_EVENT_SEL: u5,

          /// [5:6] 
          res0: u2,

          /// [7:7] Etm event send enable bit.
          ETM_CH0_EVENT_EN: u1,

          /// [8:31] 
          res1: u24,

        }), @ptrFromInt(0x60004f64));

        /// Etm Config register of Channel%s
        pub const ETM_EVENT_CH2_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:4] Etm event channel select gpio.
          ETM_CH0_EVENT_SEL: u5,

          /// [5:6] 
          res0: u2,

          /// [7:7] Etm event send enable bit.
          ETM_CH0_EVENT_EN: u1,

          /// [8:31] 
          res1: u24,

        }), @ptrFromInt(0x60004f68));

        /// Etm Config register of Channel%s
        pub const ETM_EVENT_CH3_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:4] Etm event channel select gpio.
          ETM_CH0_EVENT_SEL: u5,

          /// [5:6] 
          res0: u2,

          /// [7:7] Etm event send enable bit.
          ETM_CH0_EVENT_EN: u1,

          /// [8:31] 
          res1: u24,

        }), @ptrFromInt(0x60004f6c));

        /// Etm Config register of Channel%s
        pub const ETM_EVENT_CH4_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:4] Etm event channel select gpio.
          ETM_CH0_EVENT_SEL: u5,

          /// [5:6] 
          res0: u2,

          /// [7:7] Etm event send enable bit.
          ETM_CH0_EVENT_EN: u1,

          /// [8:31] 
          res1: u24,

        }), @ptrFromInt(0x60004f70));

        /// Etm Config register of Channel%s
        pub const ETM_EVENT_CH5_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:4] Etm event channel select gpio.
          ETM_CH0_EVENT_SEL: u5,

          /// [5:6] 
          res0: u2,

          /// [7:7] Etm event send enable bit.
          ETM_CH0_EVENT_EN: u1,

          /// [8:31] 
          res1: u24,

        }), @ptrFromInt(0x60004f74));

        /// Etm Config register of Channel%s
        pub const ETM_EVENT_CH6_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:4] Etm event channel select gpio.
          ETM_CH0_EVENT_SEL: u5,

          /// [5:6] 
          res0: u2,

          /// [7:7] Etm event send enable bit.
          ETM_CH0_EVENT_EN: u1,

          /// [8:31] 
          res1: u24,

        }), @ptrFromInt(0x60004f78));

        /// Etm Config register of Channel%s
        pub const ETM_EVENT_CH7_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:4] Etm event channel select gpio.
          ETM_CH0_EVENT_SEL: u5,

          /// [5:6] 
          res0: u2,

          /// [7:7] Etm event send enable bit.
          ETM_CH0_EVENT_EN: u1,

          /// [8:31] 
          res1: u24,

        }), @ptrFromInt(0x60004f7c));

        /// Etm Configure Register to decide which GPIO been chosen
        pub const ETM_TASK_P0_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Enable bit of GPIO response etm task.
          ETM_TASK_GPIO0_EN: u1,

          /// [1:3] GPIO choose a etm task channel.
          ETM_TASK_GPIO0_SEL: u3,

          /// [4:7] 
          res0: u4,

          /// [8:8] Enable bit of GPIO response etm task.
          ETM_TASK_GPIO1_EN: u1,

          /// [9:11] GPIO choose a etm task channel.
          ETM_TASK_GPIO1_SEL: u3,

          /// [12:15] 
          res1: u4,

          /// [16:16] Enable bit of GPIO response etm task.
          ETM_TASK_GPIO2_EN: u1,

          /// [17:19] GPIO choose a etm task channel.
          ETM_TASK_GPIO2_SEL: u3,

          /// [20:23] 
          res2: u4,

          /// [24:24] Enable bit of GPIO response etm task.
          ETM_TASK_GPIO3_EN: u1,

          /// [25:27] GPIO choose a etm task channel.
          ETM_TASK_GPIO3_SEL: u3,

          /// [28:31] 
          res3: u4,

        }), @ptrFromInt(0x60004fa0));

        /// Etm Configure Register to decide which GPIO been chosen
        pub const ETM_TASK_P1_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Enable bit of GPIO response etm task.
          ETM_TASK_GPIO4_EN: u1,

          /// [1:3] GPIO choose a etm task channel.
          ETM_TASK_GPIO4_SEL: u3,

          /// [4:7] 
          res0: u4,

          /// [8:8] Enable bit of GPIO response etm task.
          ETM_TASK_GPIO5_EN: u1,

          /// [9:11] GPIO choose a etm task channel.
          ETM_TASK_GPIO5_SEL: u3,

          /// [12:15] 
          res1: u4,

          /// [16:16] Enable bit of GPIO response etm task.
          ETM_TASK_GPIO6_EN: u1,

          /// [17:19] GPIO choose a etm task channel.
          ETM_TASK_GPIO6_SEL: u3,

          /// [20:23] 
          res2: u4,

          /// [24:24] Enable bit of GPIO response etm task.
          ETM_TASK_GPIO7_EN: u1,

          /// [25:27] GPIO choose a etm task channel.
          ETM_TASK_GPIO7_SEL: u3,

          /// [28:31] 
          res3: u4,

        }), @ptrFromInt(0x60004fa4));

        /// Etm Configure Register to decide which GPIO been chosen
        pub const ETM_TASK_P2_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Enable bit of GPIO response etm task.
          ETM_TASK_GPIO8_EN: u1,

          /// [1:3] GPIO choose a etm task channel.
          ETM_TASK_GPIO8_SEL: u3,

          /// [4:7] 
          res0: u4,

          /// [8:8] Enable bit of GPIO response etm task.
          ETM_TASK_GPIO9_EN: u1,

          /// [9:11] GPIO choose a etm task channel.
          ETM_TASK_GPIO9_SEL: u3,

          /// [12:15] 
          res1: u4,

          /// [16:16] Enable bit of GPIO response etm task.
          ETM_TASK_GPIO10_EN: u1,

          /// [17:19] GPIO choose a etm task channel.
          ETM_TASK_GPIO10_SEL: u3,

          /// [20:23] 
          res2: u4,

          /// [24:24] Enable bit of GPIO response etm task.
          ETM_TASK_GPIO11_EN: u1,

          /// [25:27] GPIO choose a etm task channel.
          ETM_TASK_GPIO11_SEL: u3,

          /// [28:31] 
          res3: u4,

        }), @ptrFromInt(0x60004fa8));

        /// Etm Configure Register to decide which GPIO been chosen
        pub const ETM_TASK_P3_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Enable bit of GPIO response etm task.
          ETM_TASK_GPIO12_EN: u1,

          /// [1:3] GPIO choose a etm task channel.
          ETM_TASK_GPIO12_SEL: u3,

          /// [4:7] 
          res0: u4,

          /// [8:8] Enable bit of GPIO response etm task.
          ETM_TASK_GPIO13_EN: u1,

          /// [9:11] GPIO choose a etm task channel.
          ETM_TASK_GPIO13_SEL: u3,

          /// [12:15] 
          res1: u4,

          /// [16:16] Enable bit of GPIO response etm task.
          ETM_TASK_GPIO14_EN: u1,

          /// [17:19] GPIO choose a etm task channel.
          ETM_TASK_GPIO14_SEL: u3,

          /// [20:23] 
          res2: u4,

          /// [24:24] Enable bit of GPIO response etm task.
          ETM_TASK_GPIO15_EN: u1,

          /// [25:27] GPIO choose a etm task channel.
          ETM_TASK_GPIO15_SEL: u3,

          /// [28:31] 
          res3: u4,

        }), @ptrFromInt(0x60004fac));

        /// Etm Configure Register to decide which GPIO been chosen
        pub const ETM_TASK_P4_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Enable bit of GPIO response etm task.
          ETM_TASK_GPIO16_EN: u1,

          /// [1:3] GPIO choose a etm task channel.
          ETM_TASK_GPIO16_SEL: u3,

          /// [4:7] 
          res0: u4,

          /// [8:8] Enable bit of GPIO response etm task.
          ETM_TASK_GPIO17_EN: u1,

          /// [9:11] GPIO choose a etm task channel.
          ETM_TASK_GPIO17_SEL: u3,

          /// [12:15] 
          res1: u4,

          /// [16:16] Enable bit of GPIO response etm task.
          ETM_TASK_GPIO18_EN: u1,

          /// [17:19] GPIO choose a etm task channel.
          ETM_TASK_GPIO18_SEL: u3,

          /// [20:23] 
          res2: u4,

          /// [24:24] Enable bit of GPIO response etm task.
          ETM_TASK_GPIO19_EN: u1,

          /// [25:27] GPIO choose a etm task channel.
          ETM_TASK_GPIO19_SEL: u3,

          /// [28:31] 
          res3: u4,

        }), @ptrFromInt(0x60004fb0));

        /// Etm Configure Register to decide which GPIO been chosen
        pub const ETM_TASK_P5_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Enable bit of GPIO response etm task.
          ETM_TASK_GPIO20_EN: u1,

          /// [1:3] GPIO choose a etm task channel.
          ETM_TASK_GPIO20_SEL: u3,

          /// [4:7] 
          res0: u4,

          /// [8:8] Enable bit of GPIO response etm task.
          ETM_TASK_GPIO21_EN: u1,

          /// [9:11] GPIO choose a etm task channel.
          ETM_TASK_GPIO21_SEL: u3,

          /// [12:15] 
          res1: u4,

          /// [16:16] Enable bit of GPIO response etm task.
          ETM_TASK_GPIO22_EN: u1,

          /// [17:19] GPIO choose a etm task channel.
          ETM_TASK_GPIO22_SEL: u3,

          /// [20:23] 
          res2: u4,

          /// [24:24] Enable bit of GPIO response etm task.
          ETM_TASK_GPIO23_EN: u1,

          /// [25:27] GPIO choose a etm task channel.
          ETM_TASK_GPIO23_SEL: u3,

          /// [28:31] 
          res3: u4,

        }), @ptrFromInt(0x60004fb4));

        /// Etm Configure Register to decide which GPIO been chosen
        pub const ETM_TASK_P6_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Enable bit of GPIO response etm task.
          ETM_TASK_GPIO24_EN: u1,

          /// [1:3] GPIO choose a etm task channel.
          ETM_TASK_GPIO24_SEL: u3,

          /// [4:7] 
          res0: u4,

          /// [8:8] Enable bit of GPIO response etm task.
          ETM_TASK_GPIO25_EN: u1,

          /// [9:11] GPIO choose a etm task channel.
          ETM_TASK_GPIO25_SEL: u3,

          /// [12:15] 
          res1: u4,

          /// [16:16] Enable bit of GPIO response etm task.
          ETM_TASK_GPIO26_EN: u1,

          /// [17:19] GPIO choose a etm task channel.
          ETM_TASK_GPIO26_SEL: u3,

          /// [20:23] 
          res2: u4,

          /// [24:24] Enable bit of GPIO response etm task.
          ETM_TASK_GPIO27_EN: u1,

          /// [25:27] GPIO choose a etm task channel.
          ETM_TASK_GPIO27_SEL: u3,

          /// [28:31] 
          res3: u4,

        }), @ptrFromInt(0x60004fb8));

        /// Etm Configure Register to decide which GPIO been chosen
        pub const ETM_TASK_P7_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Enable bit of GPIO response etm task.
          ETM_TASK_GPIO28_EN: u1,

          /// [1:3] GPIO choose a etm task channel.
          ETM_TASK_GPIO28_SEL: u3,

          /// [4:7] 
          res0: u4,

          /// [8:8] Enable bit of GPIO response etm task.
          ETM_TASK_GPIO29_EN: u1,

          /// [9:11] GPIO choose a etm task channel.
          ETM_TASK_GPIO29_SEL: u3,

          /// [12:15] 
          res1: u4,

          /// [16:16] Enable bit of GPIO response etm task.
          ETM_TASK_GPIO30_EN: u1,

          /// [17:19] GPIO choose a etm task channel.
          ETM_TASK_GPIO30_SEL: u3,

          /// [20:31] 
          res2: u12,

        }), @ptrFromInt(0x60004fbc));

        /// Version Control Register
        pub const VERSION = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:27] Version control register.
          GPIO_SD_DATE: u28,

          /// [28:31] 
          res0: u4,

        }), @ptrFromInt(0x60004ffc));

      };

      /// HINF Peripheral
      pub const HINF = struct {

        /// Configure sdio cis content
        pub const CFG_DATA0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:15] configure device id of function1 in cis
          DEVICE_ID_FN1: u16,

          /// [16:31] configure user id of function1 in cis
          USER_ID_FN1: u16,

        }), @ptrFromInt(0x60016000));

        /// SDIO configuration register
        pub const CFG_DATA1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Sdio clock enable
          SDIO_ENABLE: u1,

          /// [1:1] sdio function1 io ready signal in cis
          SDIO_IOREADY1: u1,

          /// [2:2] Highspeed enable in cccr
          HIGHSPEED_ENABLE: u1,

          /// [3:3] highspeed mode status in cccr
          HIGHSPEED_MODE: u1,

          /// [4:4] sdio card detect enable
          SDIO_CD_ENABLE: u1,

          /// [5:5] sdio function1 io ready signal in cis
          SDIO_IOREADY2: u1,

          /// [6:6] mask sdio interrupt in cccr, high active
          SDIO_INT_MASK: u1,

          /// [7:7] ioe2 status in cccr
          IOENABLE2: u1,

          /// [8:8] card disable status in cccr
          CD_DISABLE: u1,

          /// [9:9] function1 eps status in fbr
          FUNC1_EPS: u1,

          /// [10:10] empc status in cccr
          EMP: u1,

          /// [11:11] ioe1 status in cccr
          IOENABLE1: u1,

          /// [12:23] sdio version in cccr
          SDIO_VER: u12,

          /// [24:24] function2 eps status in fbr
          FUNC2_EPS: u1,

          /// [25:31] [29],sdio negedge sample enablel.[30],sdio posedge sample enable.[31],sdio cmd/dat in delayed cycles control,0:no delay, 1:delay 1 cycle.[25]: sdio1.1 dat/cmd sending out edge control,1:negedge,0:posedge when highseed mode. [26]: sdio2.0 dat/cmd sending out edge control,1:negedge when [12]=0,0:negedge when [12]=0,posedge when highspeed mode enable.[27]: sdio interrupt sending out delay control,1:delay one cycle, 0: no delay.[28]: sdio data pad pull up enable
          SDIO20_CONF: u7,

        }), @ptrFromInt(0x60016004));

        /// Timing configuration registers
        pub const CFG_TIMING = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:2] configure Ncrc parameter in sdr50/104 mode, no more than 6.
          NCRC: u3,

          /// [3:9] configure cycles to lower cmd after voltage is changed to 1.8V.
          PST_END_CMD_LOW_VALUE: u7,

          /// [10:15] configure cycles to lower data after voltage is changed to 1.8V.
          PST_END_DATA_LOW_VALUE: u6,

          /// [16:26] Configure the number of cycles of module clk to judge sdclk has stopped
          SDCLK_STOP_THRES: u11,

          /// [27:27] 
          res0: u1,

          /// [28:31] module clk divider to sample sdclk
          SAMPLE_CLK_DIVIDER: u4,

        }), @ptrFromInt(0x60016008));

        /// update sdio configurations
        pub const CFG_UPDATE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] update the timing configurations
          CONF_UPDATE: u1,

          /// [1:31] 
          res0: u31,

        }), @ptrFromInt(0x6001600c));

        /// SDIO configuration register
        pub const CFG_DATA7 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] configure cis addr 318 and 574
          PIN_STATE: u8,

          /// [8:15] configure cis addr 312, 315, 568 and 571
          CHIP_STATE: u8,

          /// [16:16] soft reset control for sdio module
          SDIO_RST: u1,

          /// [17:17] sdio io ready, high enable
          SDIO_IOREADY0: u1,

          /// [18:18] sdio memory power down, high active
          SDIO_MEM_PD: u1,

          /// [19:19] enable sdio interrupt on data1 line
          ESDIO_DATA1_INT_EN: u1,

          /// [20:20] control switch voltage change to 1.8V by software. 0:3.3V,1:1.8V
          SDIO_SWITCH_VOLT_SW: u1,

          /// [21:21] enable block length to be fixed to 512 bytes in ddr50 mode
          DDR50_BLK_LEN_FIX_EN: u1,

          /// [22:22] sdio apb clock for configuration force on control:0-gating,1-force on.
          CLK_EN: u1,

          /// [23:23] configure if support sdr50 mode in cccr
          SDDR50: u1,

          /// [24:24] configure if support sdr104 mode in cccr
          SSDR104: u1,

          /// [25:25] configure if support ddr50 mode in cccr
          SSDR50: u1,

          /// [26:26] configure if support driver type D in cccr
          SDTD: u1,

          /// [27:27] configure if support driver type A in cccr
          SDTA: u1,

          /// [28:28] configure if support driver type C in cccr
          SDTC: u1,

          /// [29:29] configure if support asynchronous interrupt in cccr
          SAI: u1,

          /// [30:30] clear sdio_wake_up signal after the chip wakes up
          SDIO_WAKEUP_CLR: u1,

          /// [31:31] 
          res0: u1,

        }), @ptrFromInt(0x6001601c));

        /// SDIO cis configuration register
        pub const CIS_CONF_W0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Configure cis addr 39~36
          CIS_CONF_W0: u32,

        }), @ptrFromInt(0x60016020));

        /// SDIO cis configuration register
        pub const CIS_CONF_W1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Configure cis addr 43~40
          CIS_CONF_W1: u32,

        }), @ptrFromInt(0x60016024));

        /// SDIO cis configuration register
        pub const CIS_CONF_W2 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Configure cis addr 47~44
          CIS_CONF_W2: u32,

        }), @ptrFromInt(0x60016028));

        /// SDIO cis configuration register
        pub const CIS_CONF_W3 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Configure cis addr 51~48
          CIS_CONF_W3: u32,

        }), @ptrFromInt(0x6001602c));

        /// SDIO cis configuration register
        pub const CIS_CONF_W4 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Configure cis addr 55~52
          CIS_CONF_W4: u32,

        }), @ptrFromInt(0x60016030));

        /// SDIO cis configuration register
        pub const CIS_CONF_W5 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Configure cis addr 59~56
          CIS_CONF_W5: u32,

        }), @ptrFromInt(0x60016034));

        /// SDIO cis configuration register
        pub const CIS_CONF_W6 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Configure cis addr 63~60
          CIS_CONF_W6: u32,

        }), @ptrFromInt(0x60016038));

        /// SDIO cis configuration register
        pub const CIS_CONF_W7 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Configure cis addr 67~64
          CIS_CONF_W7: u32,

        }), @ptrFromInt(0x6001603c));

        /// SDIO cis configuration register
        pub const CFG_DATA16 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:15] configure device id of function2 in cis
          DEVICE_ID_FN2: u16,

          /// [16:31] configure user id of function2 in cis
          USER_ID_FN2: u16,

        }), @ptrFromInt(0x60016040));

        /// configure int to start and end ahead of time in uhs1 mode
        pub const CFG_UHS1_INT_MODE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:1] intoe on dat1 end ahead of time: 0/3-no, 1-ahead 1sdclk, 2-ahead 2sdclk
          INTOE_END_AHEAD_MODE: u2,

          /// [2:3] int on dat1 end ahead of time: 0/3-no, 1-ahead 1sdclk, 2-ahead 2sdclk
          INT_END_AHEAD_MODE: u2,

          /// [4:5] intoe on dat1 start ahead of time: 0/3-no, 1-ahead 1sdclk, 2-ahead 2sdclk
          INTOE_ST_AHEAD_MODE: u2,

          /// [6:7] int on dat1 start ahead of time: 0/3-no, 1-ahead 1sdclk, 2-ahead 2sdclk
          INT_ST_AHEAD_MODE: u2,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x60016044));

        /// func0 config0 status
        pub const CONF_STATUS = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] func0 config0 (addr: 0x20f0 ) status
          FUNC0_CONFIG0: u8,

          /// [8:8] sdr25 status
          SDR25_ST: u1,

          /// [9:9] sdr50 status
          SDR50_ST: u1,

          /// [10:10] sdr104 status
          SDR104_ST: u1,

          /// [11:11] ddr50 status
          DDR50_ST: u1,

          /// [12:14] tune_st fsm status
          TUNE_ST: u3,

          /// [15:15] sdio switch voltage status:0-3.3V, 1-1.8V.
          SDIO_SWITCH_VOLT_ST: u1,

          /// [16:16] sdio switch voltage ldo ready
          SDIO_SWITCH_END: u1,

          /// [17:31] 
          res0: u15,

        }), @ptrFromInt(0x60016054));

        /// sdio_slave redundant control registers
        pub const SDIO_SLAVE_ECO_LOW = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] redundant registers for sdio_slave
          RDN_ECO_LOW: u32,

        }), @ptrFromInt(0x600160a4));

        /// sdio_slave redundant control registers
        pub const SDIO_SLAVE_ECO_HIGH = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] redundant registers for sdio_slave
          RDN_ECO_HIGH: u32,

        }), @ptrFromInt(0x600160a8));

        /// sdio_slave redundant control registers
        pub const SDIO_SLAVE_ECO_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] redundant registers for sdio_slave
          SDIO_SLAVE_RDN_RESULT: u1,

          /// [1:1] redundant registers for sdio_slave
          SDIO_SLAVE_RDN_ENA: u1,

          /// [2:2] redundant registers for sdio_slave
          SDIO_SLAVE_SDIO_CLK_RDN_RESULT: u1,

          /// [3:3] redundant registers for sdio_slave
          SDIO_SLAVE_SDIO_CLK_RDN_ENA: u1,

          /// [4:4] redundant registers for sdio_slave
          SDIO_SLAVE_SDCLK_PAD_RDN_RESULT: u1,

          /// [5:5] redundant registers for sdio_slave
          SDIO_SLAVE_SDCLK_PAD_RDN_ENA: u1,

          /// [6:31] 
          res0: u26,

        }), @ptrFromInt(0x600160ac));

        /// sdio slave ldo control register
        pub const SDIO_SLAVE_LDO_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] control ldo ready signal by sdio slave itself
          LDO_READY_CTL_IN_EN: u1,

          /// [1:5] configure ldo ready counting threshold value, the actual counting target is 2^(ldo_ready_thres)-1
          LDO_READY_THRES: u5,

          /// [6:6] ignore ldo ready signal
          LDO_READY_IGNORE_EN: u1,

          /// [7:31] 
          res0: u25,

        }), @ptrFromInt(0x600160b0));

        /// ******* Description ***********
        pub const SDIO_DATE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] sdio version date.
          SDIO_DATE: u32,

        }), @ptrFromInt(0x600160fc));

      };

      /// HMAC (Hash-based Message Authentication Code) Accelerator
      pub const HMAC = struct {

        /// Process control register 0.
        pub const SET_START = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Start hmac operation.
          SET_START: u1,

          /// [1:31] 
          res0: u31,

        }), @ptrFromInt(0x6008d040));

        /// Configure purpose.
        pub const SET_PARA_PURPOSE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:3] Set hmac parameter purpose.
          PURPOSE_SET: u4,

          /// [4:31] 
          res0: u28,

        }), @ptrFromInt(0x6008d044));

        /// Configure key.
        pub const SET_PARA_KEY = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:2] Set hmac parameter key.
          KEY_SET: u3,

          /// [3:31] 
          res0: u29,

        }), @ptrFromInt(0x6008d048));

        /// Finish initial configuration.
        pub const SET_PARA_FINISH = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Finish hmac configuration.
          SET_PARA_END: u1,

          /// [1:31] 
          res0: u31,

        }), @ptrFromInt(0x6008d04c));

        /// Process control register 1.
        pub const SET_MESSAGE_ONE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Call SHA to calculate one message block.
          SET_TEXT_ONE: u1,

          /// [1:31] 
          res0: u31,

        }), @ptrFromInt(0x6008d050));

        /// Process control register 2.
        pub const SET_MESSAGE_ING = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Continue typical hmac.
          SET_TEXT_ING: u1,

          /// [1:31] 
          res0: u31,

        }), @ptrFromInt(0x6008d054));

        /// Process control register 3.
        pub const SET_MESSAGE_END = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Start hardware padding.
          SET_TEXT_END: u1,

          /// [1:31] 
          res0: u31,

        }), @ptrFromInt(0x6008d058));

        /// Process control register 4.
        pub const SET_RESULT_FINISH = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] After read result from upstream, then let hmac back to idle.
          SET_RESULT_END: u1,

          /// [1:31] 
          res0: u31,

        }), @ptrFromInt(0x6008d05c));

        /// Invalidate register 0.
        pub const SET_INVALIDATE_JTAG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Clear result from hmac downstream JTAG.
          SET_INVALIDATE_JTAG: u1,

          /// [1:31] 
          res0: u31,

        }), @ptrFromInt(0x6008d060));

        /// Invalidate register 1.
        pub const SET_INVALIDATE_DS = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Clear result from hmac downstream DS.
          SET_INVALIDATE_DS: u1,

          /// [1:31] 
          res0: u31,

        }), @ptrFromInt(0x6008d064));

        /// Error register.
        pub const QUERY_ERROR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Hmac configuration state. 0: key are agree with purpose. 1: error
          QUREY_CHECK: u1,

          /// [1:31] 
          res0: u31,

        }), @ptrFromInt(0x6008d068));

        /// Busy register.
        pub const QUERY_BUSY = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Hmac state. 1'b0: idle. 1'b1: busy
          BUSY_STATE: u1,

          /// [1:31] 
          res0: u31,

        }), @ptrFromInt(0x6008d06c));

        /// Message block memory.
        pub const WR_MESSAGE_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008d080));

        /// Message block memory.
        pub const WR_MESSAGE_MEM1 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008d081));

        /// Message block memory.
        pub const WR_MESSAGE_MEM2 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008d082));

        /// Message block memory.
        pub const WR_MESSAGE_MEM3 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008d083));

        /// Message block memory.
        pub const WR_MESSAGE_MEM4 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008d084));

        /// Message block memory.
        pub const WR_MESSAGE_MEM5 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008d085));

        /// Message block memory.
        pub const WR_MESSAGE_MEM6 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008d086));

        /// Message block memory.
        pub const WR_MESSAGE_MEM7 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008d087));

        /// Message block memory.
        pub const WR_MESSAGE_MEM8 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008d088));

        /// Message block memory.
        pub const WR_MESSAGE_MEM9 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008d089));

        /// Message block memory.
        pub const WR_MESSAGE_MEM10 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008d08a));

        /// Message block memory.
        pub const WR_MESSAGE_MEM11 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008d08b));

        /// Message block memory.
        pub const WR_MESSAGE_MEM12 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008d08c));

        /// Message block memory.
        pub const WR_MESSAGE_MEM13 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008d08d));

        /// Message block memory.
        pub const WR_MESSAGE_MEM14 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008d08e));

        /// Message block memory.
        pub const WR_MESSAGE_MEM15 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008d08f));

        /// Message block memory.
        pub const WR_MESSAGE_MEM16 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008d090));

        /// Message block memory.
        pub const WR_MESSAGE_MEM17 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008d091));

        /// Message block memory.
        pub const WR_MESSAGE_MEM18 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008d092));

        /// Message block memory.
        pub const WR_MESSAGE_MEM19 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008d093));

        /// Message block memory.
        pub const WR_MESSAGE_MEM20 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008d094));

        /// Message block memory.
        pub const WR_MESSAGE_MEM21 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008d095));

        /// Message block memory.
        pub const WR_MESSAGE_MEM22 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008d096));

        /// Message block memory.
        pub const WR_MESSAGE_MEM23 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008d097));

        /// Message block memory.
        pub const WR_MESSAGE_MEM24 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008d098));

        /// Message block memory.
        pub const WR_MESSAGE_MEM25 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008d099));

        /// Message block memory.
        pub const WR_MESSAGE_MEM26 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008d09a));

        /// Message block memory.
        pub const WR_MESSAGE_MEM27 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008d09b));

        /// Message block memory.
        pub const WR_MESSAGE_MEM28 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008d09c));

        /// Message block memory.
        pub const WR_MESSAGE_MEM29 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008d09d));

        /// Message block memory.
        pub const WR_MESSAGE_MEM30 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008d09e));

        /// Message block memory.
        pub const WR_MESSAGE_MEM31 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008d09f));

        /// Message block memory.
        pub const WR_MESSAGE_MEM32 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008d0a0));

        /// Message block memory.
        pub const WR_MESSAGE_MEM33 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008d0a1));

        /// Message block memory.
        pub const WR_MESSAGE_MEM34 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008d0a2));

        /// Message block memory.
        pub const WR_MESSAGE_MEM35 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008d0a3));

        /// Message block memory.
        pub const WR_MESSAGE_MEM36 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008d0a4));

        /// Message block memory.
        pub const WR_MESSAGE_MEM37 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008d0a5));

        /// Message block memory.
        pub const WR_MESSAGE_MEM38 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008d0a6));

        /// Message block memory.
        pub const WR_MESSAGE_MEM39 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008d0a7));

        /// Message block memory.
        pub const WR_MESSAGE_MEM40 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008d0a8));

        /// Message block memory.
        pub const WR_MESSAGE_MEM41 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008d0a9));

        /// Message block memory.
        pub const WR_MESSAGE_MEM42 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008d0aa));

        /// Message block memory.
        pub const WR_MESSAGE_MEM43 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008d0ab));

        /// Message block memory.
        pub const WR_MESSAGE_MEM44 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008d0ac));

        /// Message block memory.
        pub const WR_MESSAGE_MEM45 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008d0ad));

        /// Message block memory.
        pub const WR_MESSAGE_MEM46 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008d0ae));

        /// Message block memory.
        pub const WR_MESSAGE_MEM47 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008d0af));

        /// Message block memory.
        pub const WR_MESSAGE_MEM48 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008d0b0));

        /// Message block memory.
        pub const WR_MESSAGE_MEM49 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008d0b1));

        /// Message block memory.
        pub const WR_MESSAGE_MEM50 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008d0b2));

        /// Message block memory.
        pub const WR_MESSAGE_MEM51 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008d0b3));

        /// Message block memory.
        pub const WR_MESSAGE_MEM52 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008d0b4));

        /// Message block memory.
        pub const WR_MESSAGE_MEM53 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008d0b5));

        /// Message block memory.
        pub const WR_MESSAGE_MEM54 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008d0b6));

        /// Message block memory.
        pub const WR_MESSAGE_MEM55 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008d0b7));

        /// Message block memory.
        pub const WR_MESSAGE_MEM56 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008d0b8));

        /// Message block memory.
        pub const WR_MESSAGE_MEM57 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008d0b9));

        /// Message block memory.
        pub const WR_MESSAGE_MEM58 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008d0ba));

        /// Message block memory.
        pub const WR_MESSAGE_MEM59 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008d0bb));

        /// Message block memory.
        pub const WR_MESSAGE_MEM60 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008d0bc));

        /// Message block memory.
        pub const WR_MESSAGE_MEM61 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008d0bd));

        /// Message block memory.
        pub const WR_MESSAGE_MEM62 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008d0be));

        /// Message block memory.
        pub const WR_MESSAGE_MEM63 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008d0bf));

        /// Result from upstream.
        pub const RD_RESULT_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008d0c0));

        /// Result from upstream.
        pub const RD_RESULT_MEM1 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008d0c1));

        /// Result from upstream.
        pub const RD_RESULT_MEM2 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008d0c2));

        /// Result from upstream.
        pub const RD_RESULT_MEM3 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008d0c3));

        /// Result from upstream.
        pub const RD_RESULT_MEM4 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008d0c4));

        /// Result from upstream.
        pub const RD_RESULT_MEM5 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008d0c5));

        /// Result from upstream.
        pub const RD_RESULT_MEM6 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008d0c6));

        /// Result from upstream.
        pub const RD_RESULT_MEM7 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008d0c7));

        /// Result from upstream.
        pub const RD_RESULT_MEM8 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008d0c8));

        /// Result from upstream.
        pub const RD_RESULT_MEM9 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008d0c9));

        /// Result from upstream.
        pub const RD_RESULT_MEM10 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008d0ca));

        /// Result from upstream.
        pub const RD_RESULT_MEM11 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008d0cb));

        /// Result from upstream.
        pub const RD_RESULT_MEM12 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008d0cc));

        /// Result from upstream.
        pub const RD_RESULT_MEM13 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008d0cd));

        /// Result from upstream.
        pub const RD_RESULT_MEM14 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008d0ce));

        /// Result from upstream.
        pub const RD_RESULT_MEM15 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008d0cf));

        /// Result from upstream.
        pub const RD_RESULT_MEM16 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008d0d0));

        /// Result from upstream.
        pub const RD_RESULT_MEM17 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008d0d1));

        /// Result from upstream.
        pub const RD_RESULT_MEM18 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008d0d2));

        /// Result from upstream.
        pub const RD_RESULT_MEM19 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008d0d3));

        /// Result from upstream.
        pub const RD_RESULT_MEM20 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008d0d4));

        /// Result from upstream.
        pub const RD_RESULT_MEM21 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008d0d5));

        /// Result from upstream.
        pub const RD_RESULT_MEM22 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008d0d6));

        /// Result from upstream.
        pub const RD_RESULT_MEM23 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008d0d7));

        /// Result from upstream.
        pub const RD_RESULT_MEM24 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008d0d8));

        /// Result from upstream.
        pub const RD_RESULT_MEM25 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008d0d9));

        /// Result from upstream.
        pub const RD_RESULT_MEM26 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008d0da));

        /// Result from upstream.
        pub const RD_RESULT_MEM27 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008d0db));

        /// Result from upstream.
        pub const RD_RESULT_MEM28 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008d0dc));

        /// Result from upstream.
        pub const RD_RESULT_MEM29 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008d0dd));

        /// Result from upstream.
        pub const RD_RESULT_MEM30 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008d0de));

        /// Result from upstream.
        pub const RD_RESULT_MEM31 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008d0df));

        /// Process control register 5.
        pub const SET_MESSAGE_PAD = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Start software padding.
          SET_TEXT_PAD: u1,

          /// [1:31] 
          res0: u31,

        }), @ptrFromInt(0x6008d0f0));

        /// Process control register 6.
        pub const ONE_BLOCK = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Don't have to do padding.
          SET_ONE_BLOCK: u1,

          /// [1:31] 
          res0: u31,

        }), @ptrFromInt(0x6008d0f4));

        /// Jtag register 0.
        pub const SOFT_JTAG_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Turn on JTAG verification.
          SOFT_JTAG_CTRL: u1,

          /// [1:31] 
          res0: u31,

        }), @ptrFromInt(0x6008d0f8));

        /// Jtag register 1.
        pub const WR_JTAG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] 32-bit of key to be compared.
          WR_JTAG: u32,

        }), @ptrFromInt(0x6008d0fc));

        /// Date register.
        pub const DATE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:29] Hmac date information/ hmac version information.
          DATE: u30,

          /// [30:31] 
          res0: u2,

        }), @ptrFromInt(0x6008d1fc));

      };

      /// HP_APM Peripheral
      pub const HP_APM = struct {

        /// Region filter enable register
        pub const REGION_FILTER_EN = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:15] Region filter enable
          REGION_FILTER_EN: u16,

          /// [16:31] 
          res0: u16,

        }), @ptrFromInt(0x60099000));

        /// Region address register
        pub const REGION0_ADDR_START = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Start address of region0
          REGION0_ADDR_START: u32,

        }), @ptrFromInt(0x60099004));

        /// Region address register
        pub const REGION0_ADDR_END = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] End address of region0
          REGION0_ADDR_END: u32,

        }), @ptrFromInt(0x60099008));

        /// Region access authority attribute register
        pub const REGION0_PMS_ATTR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Region execute authority in REE_MODE0
          REGION0_R0_PMS_X: u1,

          /// [1:1] Region write authority in REE_MODE0
          REGION0_R0_PMS_W: u1,

          /// [2:2] Region read authority in REE_MODE0
          REGION0_R0_PMS_R: u1,

          /// [3:3] 
          res0: u1,

          /// [4:4] Region execute authority in REE_MODE1
          REGION0_R1_PMS_X: u1,

          /// [5:5] Region write authority in REE_MODE1
          REGION0_R1_PMS_W: u1,

          /// [6:6] Region read authority in REE_MODE1
          REGION0_R1_PMS_R: u1,

          /// [7:7] 
          res1: u1,

          /// [8:8] Region execute authority in REE_MODE2
          REGION0_R2_PMS_X: u1,

          /// [9:9] Region write authority in REE_MODE2
          REGION0_R2_PMS_W: u1,

          /// [10:10] Region read authority in REE_MODE2
          REGION0_R2_PMS_R: u1,

          /// [11:31] 
          res2: u21,

        }), @ptrFromInt(0x6009900c));

        /// Region address register
        pub const REGION1_ADDR_START = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Start address of region1
          REGION1_ADDR_START: u32,

        }), @ptrFromInt(0x60099010));

        /// Region address register
        pub const REGION1_ADDR_END = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] End address of region1
          REGION1_ADDR_END: u32,

        }), @ptrFromInt(0x60099014));

        /// Region access authority attribute register
        pub const REGION1_PMS_ATTR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Region execute authority in REE_MODE0
          REGION1_R0_PMS_X: u1,

          /// [1:1] Region write authority in REE_MODE0
          REGION1_R0_PMS_W: u1,

          /// [2:2] Region read authority in REE_MODE0
          REGION1_R0_PMS_R: u1,

          /// [3:3] 
          res0: u1,

          /// [4:4] Region execute authority in REE_MODE1
          REGION1_R1_PMS_X: u1,

          /// [5:5] Region write authority in REE_MODE1
          REGION1_R1_PMS_W: u1,

          /// [6:6] Region read authority in REE_MODE1
          REGION1_R1_PMS_R: u1,

          /// [7:7] 
          res1: u1,

          /// [8:8] Region execute authority in REE_MODE2
          REGION1_R2_PMS_X: u1,

          /// [9:9] Region write authority in REE_MODE2
          REGION1_R2_PMS_W: u1,

          /// [10:10] Region read authority in REE_MODE2
          REGION1_R2_PMS_R: u1,

          /// [11:31] 
          res2: u21,

        }), @ptrFromInt(0x60099018));

        /// Region address register
        pub const REGION2_ADDR_START = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Start address of region2
          REGION2_ADDR_START: u32,

        }), @ptrFromInt(0x6009901c));

        /// Region address register
        pub const REGION2_ADDR_END = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] End address of region2
          REGION2_ADDR_END: u32,

        }), @ptrFromInt(0x60099020));

        /// Region access authority attribute register
        pub const REGION2_PMS_ATTR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Region execute authority in REE_MODE0
          REGION2_R0_PMS_X: u1,

          /// [1:1] Region write authority in REE_MODE0
          REGION2_R0_PMS_W: u1,

          /// [2:2] Region read authority in REE_MODE0
          REGION2_R0_PMS_R: u1,

          /// [3:3] 
          res0: u1,

          /// [4:4] Region execute authority in REE_MODE1
          REGION2_R1_PMS_X: u1,

          /// [5:5] Region write authority in REE_MODE1
          REGION2_R1_PMS_W: u1,

          /// [6:6] Region read authority in REE_MODE1
          REGION2_R1_PMS_R: u1,

          /// [7:7] 
          res1: u1,

          /// [8:8] Region execute authority in REE_MODE2
          REGION2_R2_PMS_X: u1,

          /// [9:9] Region write authority in REE_MODE2
          REGION2_R2_PMS_W: u1,

          /// [10:10] Region read authority in REE_MODE2
          REGION2_R2_PMS_R: u1,

          /// [11:31] 
          res2: u21,

        }), @ptrFromInt(0x60099024));

        /// Region address register
        pub const REGION3_ADDR_START = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Start address of region3
          REGION3_ADDR_START: u32,

        }), @ptrFromInt(0x60099028));

        /// Region address register
        pub const REGION3_ADDR_END = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] End address of region3
          REGION3_ADDR_END: u32,

        }), @ptrFromInt(0x6009902c));

        /// Region access authority attribute register
        pub const REGION3_PMS_ATTR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Region execute authority in REE_MODE0
          REGION3_R0_PMS_X: u1,

          /// [1:1] Region write authority in REE_MODE0
          REGION3_R0_PMS_W: u1,

          /// [2:2] Region read authority in REE_MODE0
          REGION3_R0_PMS_R: u1,

          /// [3:3] 
          res0: u1,

          /// [4:4] Region execute authority in REE_MODE1
          REGION3_R1_PMS_X: u1,

          /// [5:5] Region write authority in REE_MODE1
          REGION3_R1_PMS_W: u1,

          /// [6:6] Region read authority in REE_MODE1
          REGION3_R1_PMS_R: u1,

          /// [7:7] 
          res1: u1,

          /// [8:8] Region execute authority in REE_MODE2
          REGION3_R2_PMS_X: u1,

          /// [9:9] Region write authority in REE_MODE2
          REGION3_R2_PMS_W: u1,

          /// [10:10] Region read authority in REE_MODE2
          REGION3_R2_PMS_R: u1,

          /// [11:31] 
          res2: u21,

        }), @ptrFromInt(0x60099030));

        /// Region address register
        pub const REGION4_ADDR_START = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Start address of region4
          REGION4_ADDR_START: u32,

        }), @ptrFromInt(0x60099034));

        /// Region address register
        pub const REGION4_ADDR_END = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] End address of region4
          REGION4_ADDR_END: u32,

        }), @ptrFromInt(0x60099038));

        /// Region access authority attribute register
        pub const REGION4_PMS_ATTR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Region execute authority in REE_MODE0
          REGION4_R0_PMS_X: u1,

          /// [1:1] Region write authority in REE_MODE0
          REGION4_R0_PMS_W: u1,

          /// [2:2] Region read authority in REE_MODE0
          REGION4_R0_PMS_R: u1,

          /// [3:3] 
          res0: u1,

          /// [4:4] Region execute authority in REE_MODE1
          REGION4_R1_PMS_X: u1,

          /// [5:5] Region write authority in REE_MODE1
          REGION4_R1_PMS_W: u1,

          /// [6:6] Region read authority in REE_MODE1
          REGION4_R1_PMS_R: u1,

          /// [7:7] 
          res1: u1,

          /// [8:8] Region execute authority in REE_MODE2
          REGION4_R2_PMS_X: u1,

          /// [9:9] Region write authority in REE_MODE2
          REGION4_R2_PMS_W: u1,

          /// [10:10] Region read authority in REE_MODE2
          REGION4_R2_PMS_R: u1,

          /// [11:31] 
          res2: u21,

        }), @ptrFromInt(0x6009903c));

        /// Region address register
        pub const REGION5_ADDR_START = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Start address of region5
          REGION5_ADDR_START: u32,

        }), @ptrFromInt(0x60099040));

        /// Region address register
        pub const REGION5_ADDR_END = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] End address of region5
          REGION5_ADDR_END: u32,

        }), @ptrFromInt(0x60099044));

        /// Region access authority attribute register
        pub const REGION5_PMS_ATTR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Region execute authority in REE_MODE0
          REGION5_R0_PMS_X: u1,

          /// [1:1] Region write authority in REE_MODE0
          REGION5_R0_PMS_W: u1,

          /// [2:2] Region read authority in REE_MODE0
          REGION5_R0_PMS_R: u1,

          /// [3:3] 
          res0: u1,

          /// [4:4] Region execute authority in REE_MODE1
          REGION5_R1_PMS_X: u1,

          /// [5:5] Region write authority in REE_MODE1
          REGION5_R1_PMS_W: u1,

          /// [6:6] Region read authority in REE_MODE1
          REGION5_R1_PMS_R: u1,

          /// [7:7] 
          res1: u1,

          /// [8:8] Region execute authority in REE_MODE2
          REGION5_R2_PMS_X: u1,

          /// [9:9] Region write authority in REE_MODE2
          REGION5_R2_PMS_W: u1,

          /// [10:10] Region read authority in REE_MODE2
          REGION5_R2_PMS_R: u1,

          /// [11:31] 
          res2: u21,

        }), @ptrFromInt(0x60099048));

        /// Region address register
        pub const REGION6_ADDR_START = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Start address of region6
          REGION6_ADDR_START: u32,

        }), @ptrFromInt(0x6009904c));

        /// Region address register
        pub const REGION6_ADDR_END = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] End address of region6
          REGION6_ADDR_END: u32,

        }), @ptrFromInt(0x60099050));

        /// Region access authority attribute register
        pub const REGION6_PMS_ATTR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Region execute authority in REE_MODE0
          REGION6_R0_PMS_X: u1,

          /// [1:1] Region write authority in REE_MODE0
          REGION6_R0_PMS_W: u1,

          /// [2:2] Region read authority in REE_MODE0
          REGION6_R0_PMS_R: u1,

          /// [3:3] 
          res0: u1,

          /// [4:4] Region execute authority in REE_MODE1
          REGION6_R1_PMS_X: u1,

          /// [5:5] Region write authority in REE_MODE1
          REGION6_R1_PMS_W: u1,

          /// [6:6] Region read authority in REE_MODE1
          REGION6_R1_PMS_R: u1,

          /// [7:7] 
          res1: u1,

          /// [8:8] Region execute authority in REE_MODE2
          REGION6_R2_PMS_X: u1,

          /// [9:9] Region write authority in REE_MODE2
          REGION6_R2_PMS_W: u1,

          /// [10:10] Region read authority in REE_MODE2
          REGION6_R2_PMS_R: u1,

          /// [11:31] 
          res2: u21,

        }), @ptrFromInt(0x60099054));

        /// Region address register
        pub const REGION7_ADDR_START = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Start address of region7
          REGION7_ADDR_START: u32,

        }), @ptrFromInt(0x60099058));

        /// Region address register
        pub const REGION7_ADDR_END = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] End address of region7
          REGION7_ADDR_END: u32,

        }), @ptrFromInt(0x6009905c));

        /// Region access authority attribute register
        pub const REGION7_PMS_ATTR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Region execute authority in REE_MODE0
          REGION7_R0_PMS_X: u1,

          /// [1:1] Region write authority in REE_MODE0
          REGION7_R0_PMS_W: u1,

          /// [2:2] Region read authority in REE_MODE0
          REGION7_R0_PMS_R: u1,

          /// [3:3] 
          res0: u1,

          /// [4:4] Region execute authority in REE_MODE1
          REGION7_R1_PMS_X: u1,

          /// [5:5] Region write authority in REE_MODE1
          REGION7_R1_PMS_W: u1,

          /// [6:6] Region read authority in REE_MODE1
          REGION7_R1_PMS_R: u1,

          /// [7:7] 
          res1: u1,

          /// [8:8] Region execute authority in REE_MODE2
          REGION7_R2_PMS_X: u1,

          /// [9:9] Region write authority in REE_MODE2
          REGION7_R2_PMS_W: u1,

          /// [10:10] Region read authority in REE_MODE2
          REGION7_R2_PMS_R: u1,

          /// [11:31] 
          res2: u21,

        }), @ptrFromInt(0x60099060));

        /// Region address register
        pub const REGION8_ADDR_START = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Start address of region8
          REGION8_ADDR_START: u32,

        }), @ptrFromInt(0x60099064));

        /// Region address register
        pub const REGION8_ADDR_END = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] End address of region8
          REGION8_ADDR_END: u32,

        }), @ptrFromInt(0x60099068));

        /// Region access authority attribute register
        pub const REGION8_PMS_ATTR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Region execute authority in REE_MODE0
          REGION8_R0_PMS_X: u1,

          /// [1:1] Region write authority in REE_MODE0
          REGION8_R0_PMS_W: u1,

          /// [2:2] Region read authority in REE_MODE0
          REGION8_R0_PMS_R: u1,

          /// [3:3] 
          res0: u1,

          /// [4:4] Region execute authority in REE_MODE1
          REGION8_R1_PMS_X: u1,

          /// [5:5] Region write authority in REE_MODE1
          REGION8_R1_PMS_W: u1,

          /// [6:6] Region read authority in REE_MODE1
          REGION8_R1_PMS_R: u1,

          /// [7:7] 
          res1: u1,

          /// [8:8] Region execute authority in REE_MODE2
          REGION8_R2_PMS_X: u1,

          /// [9:9] Region write authority in REE_MODE2
          REGION8_R2_PMS_W: u1,

          /// [10:10] Region read authority in REE_MODE2
          REGION8_R2_PMS_R: u1,

          /// [11:31] 
          res2: u21,

        }), @ptrFromInt(0x6009906c));

        /// Region address register
        pub const REGION9_ADDR_START = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Start address of region9
          REGION9_ADDR_START: u32,

        }), @ptrFromInt(0x60099070));

        /// Region address register
        pub const REGION9_ADDR_END = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] End address of region9
          REGION9_ADDR_END: u32,

        }), @ptrFromInt(0x60099074));

        /// Region access authority attribute register
        pub const REGION9_PMS_ATTR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Region execute authority in REE_MODE0
          REGION9_R0_PMS_X: u1,

          /// [1:1] Region write authority in REE_MODE0
          REGION9_R0_PMS_W: u1,

          /// [2:2] Region read authority in REE_MODE0
          REGION9_R0_PMS_R: u1,

          /// [3:3] 
          res0: u1,

          /// [4:4] Region execute authority in REE_MODE1
          REGION9_R1_PMS_X: u1,

          /// [5:5] Region write authority in REE_MODE1
          REGION9_R1_PMS_W: u1,

          /// [6:6] Region read authority in REE_MODE1
          REGION9_R1_PMS_R: u1,

          /// [7:7] 
          res1: u1,

          /// [8:8] Region execute authority in REE_MODE2
          REGION9_R2_PMS_X: u1,

          /// [9:9] Region write authority in REE_MODE2
          REGION9_R2_PMS_W: u1,

          /// [10:10] Region read authority in REE_MODE2
          REGION9_R2_PMS_R: u1,

          /// [11:31] 
          res2: u21,

        }), @ptrFromInt(0x60099078));

        /// Region address register
        pub const REGION10_ADDR_START = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Start address of region10
          REGION10_ADDR_START: u32,

        }), @ptrFromInt(0x6009907c));

        /// Region address register
        pub const REGION10_ADDR_END = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] End address of region10
          REGION10_ADDR_END: u32,

        }), @ptrFromInt(0x60099080));

        /// Region access authority attribute register
        pub const REGION10_PMS_ATTR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Region execute authority in REE_MODE0
          REGION10_R0_PMS_X: u1,

          /// [1:1] Region write authority in REE_MODE0
          REGION10_R0_PMS_W: u1,

          /// [2:2] Region read authority in REE_MODE0
          REGION10_R0_PMS_R: u1,

          /// [3:3] 
          res0: u1,

          /// [4:4] Region execute authority in REE_MODE1
          REGION10_R1_PMS_X: u1,

          /// [5:5] Region write authority in REE_MODE1
          REGION10_R1_PMS_W: u1,

          /// [6:6] Region read authority in REE_MODE1
          REGION10_R1_PMS_R: u1,

          /// [7:7] 
          res1: u1,

          /// [8:8] Region execute authority in REE_MODE2
          REGION10_R2_PMS_X: u1,

          /// [9:9] Region write authority in REE_MODE2
          REGION10_R2_PMS_W: u1,

          /// [10:10] Region read authority in REE_MODE2
          REGION10_R2_PMS_R: u1,

          /// [11:31] 
          res2: u21,

        }), @ptrFromInt(0x60099084));

        /// Region address register
        pub const REGION11_ADDR_START = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Start address of region11
          REGION11_ADDR_START: u32,

        }), @ptrFromInt(0x60099088));

        /// Region address register
        pub const REGION11_ADDR_END = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] End address of region11
          REGION11_ADDR_END: u32,

        }), @ptrFromInt(0x6009908c));

        /// Region access authority attribute register
        pub const REGION11_PMS_ATTR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Region execute authority in REE_MODE0
          REGION11_R0_PMS_X: u1,

          /// [1:1] Region write authority in REE_MODE0
          REGION11_R0_PMS_W: u1,

          /// [2:2] Region read authority in REE_MODE0
          REGION11_R0_PMS_R: u1,

          /// [3:3] 
          res0: u1,

          /// [4:4] Region execute authority in REE_MODE1
          REGION11_R1_PMS_X: u1,

          /// [5:5] Region write authority in REE_MODE1
          REGION11_R1_PMS_W: u1,

          /// [6:6] Region read authority in REE_MODE1
          REGION11_R1_PMS_R: u1,

          /// [7:7] 
          res1: u1,

          /// [8:8] Region execute authority in REE_MODE2
          REGION11_R2_PMS_X: u1,

          /// [9:9] Region write authority in REE_MODE2
          REGION11_R2_PMS_W: u1,

          /// [10:10] Region read authority in REE_MODE2
          REGION11_R2_PMS_R: u1,

          /// [11:31] 
          res2: u21,

        }), @ptrFromInt(0x60099090));

        /// Region address register
        pub const REGION12_ADDR_START = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Start address of region12
          REGION12_ADDR_START: u32,

        }), @ptrFromInt(0x60099094));

        /// Region address register
        pub const REGION12_ADDR_END = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] End address of region12
          REGION12_ADDR_END: u32,

        }), @ptrFromInt(0x60099098));

        /// Region access authority attribute register
        pub const REGION12_PMS_ATTR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Region execute authority in REE_MODE0
          REGION12_R0_PMS_X: u1,

          /// [1:1] Region write authority in REE_MODE0
          REGION12_R0_PMS_W: u1,

          /// [2:2] Region read authority in REE_MODE0
          REGION12_R0_PMS_R: u1,

          /// [3:3] 
          res0: u1,

          /// [4:4] Region execute authority in REE_MODE1
          REGION12_R1_PMS_X: u1,

          /// [5:5] Region write authority in REE_MODE1
          REGION12_R1_PMS_W: u1,

          /// [6:6] Region read authority in REE_MODE1
          REGION12_R1_PMS_R: u1,

          /// [7:7] 
          res1: u1,

          /// [8:8] Region execute authority in REE_MODE2
          REGION12_R2_PMS_X: u1,

          /// [9:9] Region write authority in REE_MODE2
          REGION12_R2_PMS_W: u1,

          /// [10:10] Region read authority in REE_MODE2
          REGION12_R2_PMS_R: u1,

          /// [11:31] 
          res2: u21,

        }), @ptrFromInt(0x6009909c));

        /// Region address register
        pub const REGION13_ADDR_START = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Start address of region13
          REGION13_ADDR_START: u32,

        }), @ptrFromInt(0x600990a0));

        /// Region address register
        pub const REGION13_ADDR_END = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] End address of region13
          REGION13_ADDR_END: u32,

        }), @ptrFromInt(0x600990a4));

        /// Region access authority attribute register
        pub const REGION13_PMS_ATTR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Region execute authority in REE_MODE0
          REGION13_R0_PMS_X: u1,

          /// [1:1] Region write authority in REE_MODE0
          REGION13_R0_PMS_W: u1,

          /// [2:2] Region read authority in REE_MODE0
          REGION13_R0_PMS_R: u1,

          /// [3:3] 
          res0: u1,

          /// [4:4] Region execute authority in REE_MODE1
          REGION13_R1_PMS_X: u1,

          /// [5:5] Region write authority in REE_MODE1
          REGION13_R1_PMS_W: u1,

          /// [6:6] Region read authority in REE_MODE1
          REGION13_R1_PMS_R: u1,

          /// [7:7] 
          res1: u1,

          /// [8:8] Region execute authority in REE_MODE2
          REGION13_R2_PMS_X: u1,

          /// [9:9] Region write authority in REE_MODE2
          REGION13_R2_PMS_W: u1,

          /// [10:10] Region read authority in REE_MODE2
          REGION13_R2_PMS_R: u1,

          /// [11:31] 
          res2: u21,

        }), @ptrFromInt(0x600990a8));

        /// Region address register
        pub const REGION14_ADDR_START = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Start address of region14
          REGION14_ADDR_START: u32,

        }), @ptrFromInt(0x600990ac));

        /// Region address register
        pub const REGION14_ADDR_END = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] End address of region14
          REGION14_ADDR_END: u32,

        }), @ptrFromInt(0x600990b0));

        /// Region access authority attribute register
        pub const REGION14_PMS_ATTR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Region execute authority in REE_MODE0
          REGION14_R0_PMS_X: u1,

          /// [1:1] Region write authority in REE_MODE0
          REGION14_R0_PMS_W: u1,

          /// [2:2] Region read authority in REE_MODE0
          REGION14_R0_PMS_R: u1,

          /// [3:3] 
          res0: u1,

          /// [4:4] Region execute authority in REE_MODE1
          REGION14_R1_PMS_X: u1,

          /// [5:5] Region write authority in REE_MODE1
          REGION14_R1_PMS_W: u1,

          /// [6:6] Region read authority in REE_MODE1
          REGION14_R1_PMS_R: u1,

          /// [7:7] 
          res1: u1,

          /// [8:8] Region execute authority in REE_MODE2
          REGION14_R2_PMS_X: u1,

          /// [9:9] Region write authority in REE_MODE2
          REGION14_R2_PMS_W: u1,

          /// [10:10] Region read authority in REE_MODE2
          REGION14_R2_PMS_R: u1,

          /// [11:31] 
          res2: u21,

        }), @ptrFromInt(0x600990b4));

        /// Region address register
        pub const REGION15_ADDR_START = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Start address of region15
          REGION15_ADDR_START: u32,

        }), @ptrFromInt(0x600990b8));

        /// Region address register
        pub const REGION15_ADDR_END = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] End address of region15
          REGION15_ADDR_END: u32,

        }), @ptrFromInt(0x600990bc));

        /// Region access authority attribute register
        pub const REGION15_PMS_ATTR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Region execute authority in REE_MODE0
          REGION15_R0_PMS_X: u1,

          /// [1:1] Region write authority in REE_MODE0
          REGION15_R0_PMS_W: u1,

          /// [2:2] Region read authority in REE_MODE0
          REGION15_R0_PMS_R: u1,

          /// [3:3] 
          res0: u1,

          /// [4:4] Region execute authority in REE_MODE1
          REGION15_R1_PMS_X: u1,

          /// [5:5] Region write authority in REE_MODE1
          REGION15_R1_PMS_W: u1,

          /// [6:6] Region read authority in REE_MODE1
          REGION15_R1_PMS_R: u1,

          /// [7:7] 
          res1: u1,

          /// [8:8] Region execute authority in REE_MODE2
          REGION15_R2_PMS_X: u1,

          /// [9:9] Region write authority in REE_MODE2
          REGION15_R2_PMS_W: u1,

          /// [10:10] Region read authority in REE_MODE2
          REGION15_R2_PMS_R: u1,

          /// [11:31] 
          res2: u21,

        }), @ptrFromInt(0x600990c0));

        /// PMS function control register
        pub const FUNC_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] PMS M0 function enable
          M0_PMS_FUNC_EN: u1,

          /// [1:1] PMS M1 function enable
          M1_PMS_FUNC_EN: u1,

          /// [2:2] PMS M2 function enable
          M2_PMS_FUNC_EN: u1,

          /// [3:3] PMS M3 function enable
          M3_PMS_FUNC_EN: u1,

          /// [4:31] 
          res0: u28,

        }), @ptrFromInt(0x600990c4));

        /// M0 status register
        pub const M0_STATUS = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:1] Exception status
          M0_EXCEPTION_STATUS: u2,

          /// [2:31] 
          res0: u30,

        }), @ptrFromInt(0x600990c8));

        /// M0 status clear register
        pub const M0_STATUS_CLR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Clear exception status
          M0_REGION_STATUS_CLR: u1,

          /// [1:31] 
          res0: u31,

        }), @ptrFromInt(0x600990cc));

        /// M0 exception_info0 register
        pub const M0_EXCEPTION_INFO0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:15] Exception region
          M0_EXCEPTION_REGION: u16,

          /// [16:17] Exception mode
          M0_EXCEPTION_MODE: u2,

          /// [18:22] Exception id information
          M0_EXCEPTION_ID: u5,

          /// [23:31] 
          res0: u9,

        }), @ptrFromInt(0x600990d0));

        /// M0 exception_info1 register
        pub const M0_EXCEPTION_INFO1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Exception addr
          M0_EXCEPTION_ADDR: u32,

        }), @ptrFromInt(0x600990d4));

        /// M1 status register
        pub const M1_STATUS = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:1] Exception status
          M1_EXCEPTION_STATUS: u2,

          /// [2:31] 
          res0: u30,

        }), @ptrFromInt(0x600990d8));

        /// M1 status clear register
        pub const M1_STATUS_CLR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Clear exception status
          M1_REGION_STATUS_CLR: u1,

          /// [1:31] 
          res0: u31,

        }), @ptrFromInt(0x600990dc));

        /// M1 exception_info0 register
        pub const M1_EXCEPTION_INFO0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:15] Exception region
          M1_EXCEPTION_REGION: u16,

          /// [16:17] Exception mode
          M1_EXCEPTION_MODE: u2,

          /// [18:22] Exception id information
          M1_EXCEPTION_ID: u5,

          /// [23:31] 
          res0: u9,

        }), @ptrFromInt(0x600990e0));

        /// M1 exception_info1 register
        pub const M1_EXCEPTION_INFO1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Exception addr
          M1_EXCEPTION_ADDR: u32,

        }), @ptrFromInt(0x600990e4));

        /// M2 status register
        pub const M2_STATUS = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:1] Exception status
          M2_EXCEPTION_STATUS: u2,

          /// [2:31] 
          res0: u30,

        }), @ptrFromInt(0x600990e8));

        /// M2 status clear register
        pub const M2_STATUS_CLR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Clear exception status
          M2_REGION_STATUS_CLR: u1,

          /// [1:31] 
          res0: u31,

        }), @ptrFromInt(0x600990ec));

        /// M2 exception_info0 register
        pub const M2_EXCEPTION_INFO0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:15] Exception region
          M2_EXCEPTION_REGION: u16,

          /// [16:17] Exception mode
          M2_EXCEPTION_MODE: u2,

          /// [18:22] Exception id information
          M2_EXCEPTION_ID: u5,

          /// [23:31] 
          res0: u9,

        }), @ptrFromInt(0x600990f0));

        /// M2 exception_info1 register
        pub const M2_EXCEPTION_INFO1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Exception addr
          M2_EXCEPTION_ADDR: u32,

        }), @ptrFromInt(0x600990f4));

        /// M3 status register
        pub const M3_STATUS = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:1] Exception status
          M3_EXCEPTION_STATUS: u2,

          /// [2:31] 
          res0: u30,

        }), @ptrFromInt(0x600990f8));

        /// M3 status clear register
        pub const M3_STATUS_CLR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Clear exception status
          M3_REGION_STATUS_CLR: u1,

          /// [1:31] 
          res0: u31,

        }), @ptrFromInt(0x600990fc));

        /// M3 exception_info0 register
        pub const M3_EXCEPTION_INFO0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:15] Exception region
          M3_EXCEPTION_REGION: u16,

          /// [16:17] Exception mode
          M3_EXCEPTION_MODE: u2,

          /// [18:22] Exception id information
          M3_EXCEPTION_ID: u5,

          /// [23:31] 
          res0: u9,

        }), @ptrFromInt(0x60099100));

        /// M3 exception_info1 register
        pub const M3_EXCEPTION_INFO1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Exception addr
          M3_EXCEPTION_ADDR: u32,

        }), @ptrFromInt(0x60099104));

        /// APM interrupt enable register
        pub const INT_EN = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] APM M0 interrupt enable
          M0_APM_INT_EN: u1,

          /// [1:1] APM M1 interrupt enable
          M1_APM_INT_EN: u1,

          /// [2:2] APM M2 interrupt enable
          M2_APM_INT_EN: u1,

          /// [3:3] APM M3 interrupt enable
          M3_APM_INT_EN: u1,

          /// [4:31] 
          res0: u28,

        }), @ptrFromInt(0x60099108));

        /// clock gating register
        pub const CLOCK_GATE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] reg_clk_en
          CLK_EN: u1,

          /// [1:31] 
          res0: u31,

        }), @ptrFromInt(0x6009910c));

        /// Version register
        pub const DATE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:27] reg_date
          DATE: u28,

          /// [28:31] 
          res0: u4,

        }), @ptrFromInt(0x600997fc));

      };

      /// High-Power System
      pub const HP_SYS = struct {

        /// EXTERNAL DEVICE ENCRYPTION/DECRYPTION configuration register
        pub const EXTERNAL_DEVICE_ENCRYPT_DECRYPT_CONTROL = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Set this bit as 1 to enable mspi xts manual encrypt in spi boot mode.
          ENABLE_SPI_MANUAL_ENCRYPT: u1,

          /// [1:1] reserved
          ENABLE_DOWNLOAD_DB_ENCRYPT: u1,

          /// [2:2] Set this bit as 1 to enable mspi xts auto decrypt in download boot mode.
          ENABLE_DOWNLOAD_G0CB_DECRYPT: u1,

          /// [3:3] Set this bit as 1 to enable mspi xts manual encrypt in download boot mode.
          ENABLE_DOWNLOAD_MANUAL_ENCRYPT: u1,

          /// [4:31] 
          res0: u28,

        }), @ptrFromInt(0x60095000));

        /// HP memory usage configuration register
        pub const SRAM_USAGE_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] reserved
          CACHE_USAGE: u1,

          /// [1:7] 
          res0: u7,

          /// [8:11] 0: cpu use hp-memory. 1:mac-dump accessing hp-memory.
          SRAM_USAGE: u4,

          /// [12:15] 
          res1: u4,

          /// [16:16] Set this bit as 1 to add an offset (64KB) when mac-dump accessing hp-memory.
          MAC_DUMP_ALLOC: u1,

          /// [17:31] 
          res2: u15,

        }), @ptrFromInt(0x60095004));

        /// HP anti-DPA security configuration register
        pub const SEC_DPA_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:1] 0: anti-DPA disable. 1~3: anti-DPA enable with different security level. The larger the number, the stronger the ability to resist DPA attacks and the higher the security level, but it will increase the computational overhead of the hardware crypto-accelerators. Only avaliable if HP_SYS_SEC_DPA_CFG_SEL is 0.
          SEC_DPA_LEVEL: u2,

          /// [2:2] This field is used to select either HP_SYS_SEC_DPA_LEVEL or EFUSE_SEC_DPA_LEVEL (from efuse) to control dpa_level. 0: EFUSE_SEC_DPA_LEVEL, 1: HP_SYS_SEC_DPA_LEVEL.
          SEC_DPA_CFG_SEL: u1,

          /// [3:31] 
          res0: u29,

        }), @ptrFromInt(0x60095008));

        /// CPU_PERI_TIMEOUT configuration register
        pub const CPU_PERI_TIMEOUT_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:15] Set the timeout threshold for bus access, corresponding to the number of clock cycles of the clock domain.
          CPU_PERI_TIMEOUT_THRES: u16,

          /// [16:16] Set this bit as 1 to clear timeout interrupt
          CPU_PERI_TIMEOUT_INT_CLEAR: u1,

          /// [17:17] Set this bit as 1 to enable timeout protection for accessing cpu peripheral registers
          CPU_PERI_TIMEOUT_PROTECT_EN: u1,

          /// [18:31] 
          res0: u14,

        }), @ptrFromInt(0x6009500c));

        /// CPU_PERI_TIMEOUT_ADDR register
        pub const CPU_PERI_TIMEOUT_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Record the address information of abnormal access
          CPU_PERI_TIMEOUT_ADDR: u32,

        }), @ptrFromInt(0x60095010));

        /// CPU_PERI_TIMEOUT_UID register
        pub const CPU_PERI_TIMEOUT_UID = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:6] Record master id[4:0] & master permission[6:5] when trigger timeout. This register will be cleared after the interrupt is cleared.
          CPU_PERI_TIMEOUT_UID: u7,

          /// [7:31] 
          res0: u25,

        }), @ptrFromInt(0x60095014));

        /// HP_PERI_TIMEOUT configuration register
        pub const HP_PERI_TIMEOUT_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:15] Set the timeout threshold for bus access, corresponding to the number of clock cycles of the clock domain.
          HP_PERI_TIMEOUT_THRES: u16,

          /// [16:16] Set this bit as 1 to clear timeout interrupt
          HP_PERI_TIMEOUT_INT_CLEAR: u1,

          /// [17:17] Set this bit as 1 to enable timeout protection for accessing hp peripheral registers
          HP_PERI_TIMEOUT_PROTECT_EN: u1,

          /// [18:31] 
          res0: u14,

        }), @ptrFromInt(0x60095018));

        /// HP_PERI_TIMEOUT_ADDR register
        pub const HP_PERI_TIMEOUT_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Record the address information of abnormal access
          HP_PERI_TIMEOUT_ADDR: u32,

        }), @ptrFromInt(0x6009501c));

        /// HP_PERI_TIMEOUT_UID register
        pub const HP_PERI_TIMEOUT_UID = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:6] Record master id[4:0] & master permission[6:5] when trigger timeout. This register will be cleared after the interrupt is cleared.
          HP_PERI_TIMEOUT_UID: u7,

          /// [7:31] 
          res0: u25,

        }), @ptrFromInt(0x60095020));

        /// MODEM_PERI_TIMEOUT configuration register
        pub const MODEM_PERI_TIMEOUT_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:15] Set the timeout threshold for bus access, corresponding to the number of clock cycles of the clock domain.
          MODEM_PERI_TIMEOUT_THRES: u16,

          /// [16:16] Set this bit as 1 to clear timeout interrupt
          MODEM_PERI_TIMEOUT_INT_CLEAR: u1,

          /// [17:17] Set this bit as 1 to enable timeout protection for accessing modem registers
          MODEM_PERI_TIMEOUT_PROTECT_EN: u1,

          /// [18:31] 
          res0: u14,

        }), @ptrFromInt(0x60095024));

        /// MODEM_PERI_TIMEOUT_ADDR register
        pub const MODEM_PERI_TIMEOUT_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Record the address information of abnormal access
          MODEM_PERI_TIMEOUT_ADDR: u32,

        }), @ptrFromInt(0x60095028));

        /// MODEM_PERI_TIMEOUT_UID register
        pub const MODEM_PERI_TIMEOUT_UID = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:6] Record master id[4:0] & master permission[6:5] when trigger timeout. This register will be cleared after the interrupt is cleared.
          MODEM_PERI_TIMEOUT_UID: u7,

          /// [7:31] 
          res0: u25,

        }), @ptrFromInt(0x6009502c));

        /// SDIO Control configuration register
        pub const SDIO_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Set this bit as 1 to disable SDIO_PROB function. disable by default.
          DIS_SDIO_PROB: u1,

          /// [1:1] Enable sdio slave to access other peripherals on the chip
          SDIO_WIN_ACCESS_EN: u1,

          /// [2:31] 
          res0: u30,

        }), @ptrFromInt(0x60095030));

        /// Retention configuration register
        pub const RETENTION_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Set this bit as 1 to disable retention function. Not disable by default.
          RETENTION_DISABLE: u1,

          /// [1:31] 
          res0: u31,

        }), @ptrFromInt(0x60095034));

        /// Rom-Table lock register
        pub const ROM_TABLE_LOCK = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] XXXX
          ROM_TABLE_LOCK: u1,

          /// [1:31] 
          res0: u31,

        }), @ptrFromInt(0x60095038));

        /// Rom-Table register
        pub const ROM_TABLE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] XXXX
          ROM_TABLE: u32,

        }), @ptrFromInt(0x6009503c));

        /// Core Debug runstall configure register
        pub const CORE_DEBUG_RUNSTALL_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Set this field to 1 to enable debug runstall feature between HP-core and LP-core.
          CORE_DEBUG_RUNSTALL_ENABLE: u1,

          /// [1:31] 
          res0: u31,

        }), @ptrFromInt(0x60095040));

        /// MEM_TEST configuration register
        pub const MEM_TEST_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:2] This field controls hp system memory WPULSE parameter.
          HP_MEM_WPULSE: u3,

          /// [3:5] This field controls hp system memory WA parameter.
          HP_MEM_WA: u3,

          /// [6:7] This field controls hp system memory RA parameter.
          HP_MEM_RA: u2,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x60095044));

        /// redcy eco register.
        pub const RND_ECO = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Only reserved for ECO.
          REDCY_ENA: u1,

          /// [1:1] Only reserved for ECO.
          REDCY_RESULT: u1,

          /// [2:31] 
          res0: u30,

        }), @ptrFromInt(0x600953e0));

        /// redcy eco low register.
        pub const RND_ECO_LOW = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Only reserved for ECO.
          REDCY_LOW: u32,

        }), @ptrFromInt(0x600953e4));

        /// redcy eco high register.
        pub const RND_ECO_HIGH = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Only reserved for ECO.
          REDCY_HIGH: u32,

        }), @ptrFromInt(0x600953e8));

        /// HP-SYSTEM clock gating configure register
        pub const CLOCK_GATE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Set this bit as 1 to force on clock gating.
          CLK_EN: u1,

          /// [1:31] 
          res0: u31,

        }), @ptrFromInt(0x600953f8));

        /// Date register.
        pub const DATE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:27] HP-SYSTEM date information/ HP-SYSTEM version information.
          DATE: u28,

          /// [28:31] 
          res0: u4,

        }), @ptrFromInt(0x600953fc));

      };

      /// I2C (Inter-Integrated Circuit) Controller 0
      pub const I2C0 = struct {

        /// Configures the low level width of the SCLClock
        pub const SCL_LOW_PERIOD = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:8] This register is used to configure for how long SCL remains low in master mode, in I2C module clock cycles.
          SCL_LOW_PERIOD: u9,

          /// [9:31] 
          res0: u23,

        }), @ptrFromInt(0x60004000));

        /// Transmission setting
        pub const CTR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] 1: direct output, 0: open drain output.
          SDA_FORCE_OUT: u1,

          /// [1:1] 1: direct output, 0: open drain output.
          SCL_FORCE_OUT: u1,

          /// [2:2] This register is used to select the sample mode.1: sample SDA data on the SCL low level.0: sample SDA data on the SCL high level.
          SAMPLE_SCL_LEVEL: u1,

          /// [3:3] This register is used to configure the ACK value that need to sent by master when the rx_fifo_cnt has reached the threshold.
          RX_FULL_ACK_LEVEL: u1,

          /// [4:4] Set this bit to configure the module as an I2C Master. Clear this bit to configure themodule as an I2C Slave.
          MS_MODE: u1,

          /// [5:5] Set this bit to start sending the data in txfifo.
          TRANS_START: u1,

          /// [6:6] This bit is used to control the sending mode for data needing to be sent. 1: send data from the least significant bit,0: send data from the most significant bit.
          TX_LSB_FIRST: u1,

          /// [7:7] This bit is used to control the storage mode for received data.1: receive data from the least significant bit,0: receive data from the most significant bit.
          RX_LSB_FIRST: u1,

          /// [8:8] Reserved
          CLK_EN: u1,

          /// [9:9] This is the enable bit for arbitration_lost.
          ARBITRATION_EN: u1,

          /// [10:10] This register is used to reset the scl FMS.
          FSM_RST: u1,

          /// [11:11] synchronization bit
          CONF_UPGATE: u1,

          /// [12:12] This is the enable bit for slave to send data automatically
          SLV_TX_AUTO_START_EN: u1,

          /// [13:13] This is the enable bit to check if the r/w bit of 10bit addressing consists with I2C protocol
          ADDR_10BIT_RW_CHECK_EN: u1,

          /// [14:14] This is the enable bit to support the 7bit general call function.
          ADDR_BROADCASTING_EN: u1,

          /// [15:31] 
          res0: u17,

        }), @ptrFromInt(0x60004004));

        /// Describe I2C work status.
        pub const SR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] The received ACK value in master mode or slave mode. 0: ACK, 1: NACK.
          RESP_REC: u1,

          /// [1:1] When in slave mode, 1: master reads from slave, 0: master writes to slave.
          SLAVE_RW: u1,

          /// [2:2] 
          res0: u1,

          /// [3:3] When the I2C controller loses control of SCL line, this register changes to 1.
          ARB_LOST: u1,

          /// [4:4] 1: the I2C bus is busy transferring data, 0: the I2C bus is in idle state.
          BUS_BUSY: u1,

          /// [5:5] When configured as an I2C Slave, and the address sent by the master isequal to the address of the slave, then this bit will be of high level.
          SLAVE_ADDRESSED: u1,

          /// [6:7] 
          res1: u2,

          /// [8:13] This field represents the amount of data needed to be sent.
          RXFIFO_CNT: u6,

          /// [14:15] The cause of stretching SCL low in slave mode. 0:stretching SCL low at the beginning of I2C read data state. 1: stretching SCL low when I2C Tx FIFO is empty in slave mode. 2: stretching SCL low when I2C Rx FIFO is full in slave mode.
          STRETCH_CAUSE: u2,

          /// [16:17] 
          res2: u2,

          /// [18:23] This field stores the amount of received data in RAM.
          TXFIFO_CNT: u6,

          /// [24:26] This field indicates the states of the I2C module state machine. 0: Idle, 1: Address shift, 2: ACK address, 3: Rx data, 4: Tx data, 5: Send ACK, 6: Wait ACK
          SCL_MAIN_STATE_LAST: u3,

          /// [27:27] 
          res3: u1,

          /// [28:30] This field indicates the states of the state machine used to produce SCL.0: Idle, 1: Start, 2: Negative edge, 3: Low, 4: Positive edge, 5: High, 6: Stop
          SCL_STATE_LAST: u3,

          /// [31:31] 
          res4: u1,

        }), @ptrFromInt(0x60004008));

        /// Setting time out control for receiving data.
        pub const TO = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:4] This register is used to configure the timeout for receiving a data bit in APBclock cycles.
          TIME_OUT_VALUE: u5,

          /// [5:5] This is the enable bit for time out control.
          TIME_OUT_EN: u1,

          /// [6:31] 
          res0: u26,

        }), @ptrFromInt(0x6000400c));

        /// Local slave address setting
        pub const SLAVE_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:14] When configured as an I2C Slave, this field is used to configure the slave address.
          SLAVE_ADDR: u15,

          /// [15:30] 
          res0: u16,

          /// [31:31] This field is used to enable the slave 10-bit addressing mode in master mode.
          ADDR_10BIT_EN: u1,

        }), @ptrFromInt(0x60004010));

        /// FIFO status register.
        pub const FIFO_ST = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:4] This is the offset address of the APB reading from rxfifo
          RXFIFO_RADDR: u5,

          /// [5:9] This is the offset address of i2c module receiving data and writing to rxfifo.
          RXFIFO_WADDR: u5,

          /// [10:14] This is the offset address of i2c module reading from txfifo.
          TXFIFO_RADDR: u5,

          /// [15:19] This is the offset address of APB bus writing to txfifo.
          TXFIFO_WADDR: u5,

          /// [20:21] 
          res0: u2,

          /// [22:29] The received data in I2C slave mode.
          SLAVE_RW_POINT: u8,

          /// [30:31] 
          res1: u2,

        }), @ptrFromInt(0x60004014));

        /// FIFO configuration register.
        pub const FIFO_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:4] The water mark threshold of rx FIFO in nonfifo access mode. When reg_reg_fifo_prt_en is 1 and rx FIFO counter is bigger than reg_rxfifo_wm_thrhd[4:0], reg_rxfifo_wm_int_raw bit will be valid.
          RXFIFO_WM_THRHD: u5,

          /// [5:9] The water mark threshold of tx FIFO in nonfifo access mode. When reg_reg_fifo_prt_en is 1 and tx FIFO counter is smaller than reg_txfifo_wm_thrhd[4:0], reg_txfifo_wm_int_raw bit will be valid.
          TXFIFO_WM_THRHD: u5,

          /// [10:10] Set this bit to enable APB nonfifo access.
          NONFIFO_EN: u1,

          /// [11:11] When this bit is set to 1, the byte received after the I2C address byte represents the offset address in the I2C Slave RAM.
          FIFO_ADDR_CFG_EN: u1,

          /// [12:12] Set this bit to reset rx-fifo.
          RX_FIFO_RST: u1,

          /// [13:13] Set this bit to reset tx-fifo.
          TX_FIFO_RST: u1,

          /// [14:14] The control enable bit of FIFO pointer in non-fifo access mode. This bit controls the valid bits and the interrupts of tx/rx_fifo overflow, underflow, full and empty.
          FIFO_PRT_EN: u1,

          /// [15:31] 
          res0: u17,

        }), @ptrFromInt(0x60004018));

        /// Rx FIFO read data.
        pub const DATA = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] The value of rx FIFO read data.
          FIFO_RDATA: u8,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x6000401c));

        /// Raw interrupt status
        pub const INT_RAW = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] The raw interrupt bit for I2C_RXFIFO_WM_INT interrupt.
          RXFIFO_WM_INT_RAW: u1,

          /// [1:1] The raw interrupt bit for I2C_TXFIFO_WM_INT interrupt.
          TXFIFO_WM_INT_RAW: u1,

          /// [2:2] The raw interrupt bit for I2C_RXFIFO_OVF_INT interrupt.
          RXFIFO_OVF_INT_RAW: u1,

          /// [3:3] The raw interrupt bit for the I2C_END_DETECT_INT interrupt.
          END_DETECT_INT_RAW: u1,

          /// [4:4] The raw interrupt bit for the I2C_END_DETECT_INT interrupt.
          BYTE_TRANS_DONE_INT_RAW: u1,

          /// [5:5] The raw interrupt bit for the I2C_ARBITRATION_LOST_INT interrupt.
          ARBITRATION_LOST_INT_RAW: u1,

          /// [6:6] The raw interrupt bit for I2C_TRANS_COMPLETE_INT interrupt.
          MST_TXFIFO_UDF_INT_RAW: u1,

          /// [7:7] The raw interrupt bit for the I2C_TRANS_COMPLETE_INT interrupt.
          TRANS_COMPLETE_INT_RAW: u1,

          /// [8:8] The raw interrupt bit for the I2C_TIME_OUT_INT interrupt.
          TIME_OUT_INT_RAW: u1,

          /// [9:9] The raw interrupt bit for the I2C_TRANS_START_INT interrupt.
          TRANS_START_INT_RAW: u1,

          /// [10:10] The raw interrupt bit for I2C_SLAVE_STRETCH_INT interrupt.
          NACK_INT_RAW: u1,

          /// [11:11] The raw interrupt bit for I2C_TXFIFO_OVF_INT interrupt.
          TXFIFO_OVF_INT_RAW: u1,

          /// [12:12] The raw interrupt bit for I2C_RXFIFO_UDF_INTinterrupt.
          RXFIFO_UDF_INT_RAW: u1,

          /// [13:13] The raw interrupt bit for I2C_SCL_ST_TO_INT interrupt.
          SCL_ST_TO_INT_RAW: u1,

          /// [14:14] The raw interrupt bit for I2C_SCL_MAIN_ST_TO_INT interrupt.
          SCL_MAIN_ST_TO_INT_RAW: u1,

          /// [15:15] The raw interrupt bit for I2C_DET_START_INT interrupt.
          DET_START_INT_RAW: u1,

          /// [16:16] The raw interrupt bit for I2C_SLAVE_STRETCH_INT interrupt.
          SLAVE_STRETCH_INT_RAW: u1,

          /// [17:17] The raw interrupt bit for I2C_GENARAL_CALL_INT interrupt.
          GENERAL_CALL_INT_RAW: u1,

          /// [18:18] The raw interrupt bit for I2C_SLAVE_ADDR_UNMATCH_INT_RAW interrupt.
          SLAVE_ADDR_UNMATCH_INT_RAW: u1,

          /// [19:31] 
          res0: u13,

        }), @ptrFromInt(0x60004020));

        /// Interrupt clear bits
        pub const INT_CLR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Set this bit to clear I2C_RXFIFO_WM_INT interrupt.
          RXFIFO_WM_INT_CLR: u1,

          /// [1:1] Set this bit to clear I2C_TXFIFO_WM_INT interrupt.
          TXFIFO_WM_INT_CLR: u1,

          /// [2:2] Set this bit to clear I2C_RXFIFO_OVF_INT interrupt.
          RXFIFO_OVF_INT_CLR: u1,

          /// [3:3] Set this bit to clear the I2C_END_DETECT_INT interrupt.
          END_DETECT_INT_CLR: u1,

          /// [4:4] Set this bit to clear the I2C_END_DETECT_INT interrupt.
          BYTE_TRANS_DONE_INT_CLR: u1,

          /// [5:5] Set this bit to clear the I2C_ARBITRATION_LOST_INT interrupt.
          ARBITRATION_LOST_INT_CLR: u1,

          /// [6:6] Set this bit to clear I2C_TRANS_COMPLETE_INT interrupt.
          MST_TXFIFO_UDF_INT_CLR: u1,

          /// [7:7] Set this bit to clear the I2C_TRANS_COMPLETE_INT interrupt.
          TRANS_COMPLETE_INT_CLR: u1,

          /// [8:8] Set this bit to clear the I2C_TIME_OUT_INT interrupt.
          TIME_OUT_INT_CLR: u1,

          /// [9:9] Set this bit to clear the I2C_TRANS_START_INT interrupt.
          TRANS_START_INT_CLR: u1,

          /// [10:10] Set this bit to clear I2C_SLAVE_STRETCH_INT interrupt.
          NACK_INT_CLR: u1,

          /// [11:11] Set this bit to clear I2C_TXFIFO_OVF_INT interrupt.
          TXFIFO_OVF_INT_CLR: u1,

          /// [12:12] Set this bit to clear I2C_RXFIFO_UDF_INTinterrupt.
          RXFIFO_UDF_INT_CLR: u1,

          /// [13:13] Set this bit to clear I2C_SCL_ST_TO_INT interrupt.
          SCL_ST_TO_INT_CLR: u1,

          /// [14:14] Set this bit to clear I2C_SCL_MAIN_ST_TO_INT interrupt.
          SCL_MAIN_ST_TO_INT_CLR: u1,

          /// [15:15] Set this bit to clear I2C_DET_START_INT interrupt.
          DET_START_INT_CLR: u1,

          /// [16:16] Set this bit to clear I2C_SLAVE_STRETCH_INT interrupt.
          SLAVE_STRETCH_INT_CLR: u1,

          /// [17:17] Set this bit to clear I2C_GENARAL_CALL_INT interrupt.
          GENERAL_CALL_INT_CLR: u1,

          /// [18:18] Set this bit to clear I2C_SLAVE_ADDR_UNMATCH_INT_RAW interrupt.
          SLAVE_ADDR_UNMATCH_INT_CLR: u1,

          /// [19:31] 
          res0: u13,

        }), @ptrFromInt(0x60004024));

        /// Interrupt enable bits
        pub const INT_ENA = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] The interrupt enable bit for I2C_RXFIFO_WM_INT interrupt.
          RXFIFO_WM_INT_ENA: u1,

          /// [1:1] The interrupt enable bit for I2C_TXFIFO_WM_INT interrupt.
          TXFIFO_WM_INT_ENA: u1,

          /// [2:2] The interrupt enable bit for I2C_RXFIFO_OVF_INT interrupt.
          RXFIFO_OVF_INT_ENA: u1,

          /// [3:3] The interrupt enable bit for the I2C_END_DETECT_INT interrupt.
          END_DETECT_INT_ENA: u1,

          /// [4:4] The interrupt enable bit for the I2C_END_DETECT_INT interrupt.
          BYTE_TRANS_DONE_INT_ENA: u1,

          /// [5:5] The interrupt enable bit for the I2C_ARBITRATION_LOST_INT interrupt.
          ARBITRATION_LOST_INT_ENA: u1,

          /// [6:6] The interrupt enable bit for I2C_TRANS_COMPLETE_INT interrupt.
          MST_TXFIFO_UDF_INT_ENA: u1,

          /// [7:7] The interrupt enable bit for the I2C_TRANS_COMPLETE_INT interrupt.
          TRANS_COMPLETE_INT_ENA: u1,

          /// [8:8] The interrupt enable bit for the I2C_TIME_OUT_INT interrupt.
          TIME_OUT_INT_ENA: u1,

          /// [9:9] The interrupt enable bit for the I2C_TRANS_START_INT interrupt.
          TRANS_START_INT_ENA: u1,

          /// [10:10] The interrupt enable bit for I2C_SLAVE_STRETCH_INT interrupt.
          NACK_INT_ENA: u1,

          /// [11:11] The interrupt enable bit for I2C_TXFIFO_OVF_INT interrupt.
          TXFIFO_OVF_INT_ENA: u1,

          /// [12:12] The interrupt enable bit for I2C_RXFIFO_UDF_INTinterrupt.
          RXFIFO_UDF_INT_ENA: u1,

          /// [13:13] The interrupt enable bit for I2C_SCL_ST_TO_INT interrupt.
          SCL_ST_TO_INT_ENA: u1,

          /// [14:14] The interrupt enable bit for I2C_SCL_MAIN_ST_TO_INT interrupt.
          SCL_MAIN_ST_TO_INT_ENA: u1,

          /// [15:15] The interrupt enable bit for I2C_DET_START_INT interrupt.
          DET_START_INT_ENA: u1,

          /// [16:16] The interrupt enable bit for I2C_SLAVE_STRETCH_INT interrupt.
          SLAVE_STRETCH_INT_ENA: u1,

          /// [17:17] The interrupt enable bit for I2C_GENARAL_CALL_INT interrupt.
          GENERAL_CALL_INT_ENA: u1,

          /// [18:18] The interrupt enable bit for I2C_SLAVE_ADDR_UNMATCH_INT interrupt.
          SLAVE_ADDR_UNMATCH_INT_ENA: u1,

          /// [19:31] 
          res0: u13,

        }), @ptrFromInt(0x60004028));

        /// Status of captured I2C communication events
        pub const INT_STATUS = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] The masked interrupt status bit for I2C_RXFIFO_WM_INT interrupt.
          RXFIFO_WM_INT_ST: u1,

          /// [1:1] The masked interrupt status bit for I2C_TXFIFO_WM_INT interrupt.
          TXFIFO_WM_INT_ST: u1,

          /// [2:2] The masked interrupt status bit for I2C_RXFIFO_OVF_INT interrupt.
          RXFIFO_OVF_INT_ST: u1,

          /// [3:3] The masked interrupt status bit for the I2C_END_DETECT_INT interrupt.
          END_DETECT_INT_ST: u1,

          /// [4:4] The masked interrupt status bit for the I2C_END_DETECT_INT interrupt.
          BYTE_TRANS_DONE_INT_ST: u1,

          /// [5:5] The masked interrupt status bit for the I2C_ARBITRATION_LOST_INT interrupt.
          ARBITRATION_LOST_INT_ST: u1,

          /// [6:6] The masked interrupt status bit for I2C_TRANS_COMPLETE_INT interrupt.
          MST_TXFIFO_UDF_INT_ST: u1,

          /// [7:7] The masked interrupt status bit for the I2C_TRANS_COMPLETE_INT interrupt.
          TRANS_COMPLETE_INT_ST: u1,

          /// [8:8] The masked interrupt status bit for the I2C_TIME_OUT_INT interrupt.
          TIME_OUT_INT_ST: u1,

          /// [9:9] The masked interrupt status bit for the I2C_TRANS_START_INT interrupt.
          TRANS_START_INT_ST: u1,

          /// [10:10] The masked interrupt status bit for I2C_SLAVE_STRETCH_INT interrupt.
          NACK_INT_ST: u1,

          /// [11:11] The masked interrupt status bit for I2C_TXFIFO_OVF_INT interrupt.
          TXFIFO_OVF_INT_ST: u1,

          /// [12:12] The masked interrupt status bit for I2C_RXFIFO_UDF_INTinterrupt.
          RXFIFO_UDF_INT_ST: u1,

          /// [13:13] The masked interrupt status bit for I2C_SCL_ST_TO_INT interrupt.
          SCL_ST_TO_INT_ST: u1,

          /// [14:14] The masked interrupt status bit for I2C_SCL_MAIN_ST_TO_INT interrupt.
          SCL_MAIN_ST_TO_INT_ST: u1,

          /// [15:15] The masked interrupt status bit for I2C_DET_START_INT interrupt.
          DET_START_INT_ST: u1,

          /// [16:16] The masked interrupt status bit for I2C_SLAVE_STRETCH_INT interrupt.
          SLAVE_STRETCH_INT_ST: u1,

          /// [17:17] The masked interrupt status bit for I2C_GENARAL_CALL_INT interrupt.
          GENERAL_CALL_INT_ST: u1,

          /// [18:18] The masked interrupt status bit for I2C_SLAVE_ADDR_UNMATCH_INT interrupt.
          SLAVE_ADDR_UNMATCH_INT_ST: u1,

          /// [19:31] 
          res0: u13,

        }), @ptrFromInt(0x6000402c));

        /// Configures the hold time after a negative SCL edge.
        pub const SDA_HOLD = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:8] This register is used to configure the time to hold the data after the negativeedge of SCL, in I2C module clock cycles.
          TIME: u9,

          /// [9:31] 
          res0: u23,

        }), @ptrFromInt(0x60004030));

        /// Configures the sample time after a positive SCL edge.
        pub const SDA_SAMPLE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:8] This register is used to configure for how long SDA is sampled, in I2C module clock cycles.
          TIME: u9,

          /// [9:31] 
          res0: u23,

        }), @ptrFromInt(0x60004034));

        /// Configures the high level width of SCL
        pub const SCL_HIGH_PERIOD = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:8] This register is used to configure for how long SCL remains high in master mode, in I2C module clock cycles.
          SCL_HIGH_PERIOD: u9,

          /// [9:15] This register is used to configure for the SCL_FSM's waiting period for SCL high level in master mode, in I2C module clock cycles.
          SCL_WAIT_HIGH_PERIOD: u7,

          /// [16:31] 
          res0: u16,

        }), @ptrFromInt(0x60004038));

        /// Configures the delay between the SDA and SCL negative edge for a start condition
        pub const SCL_START_HOLD = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:8] This register is used to configure the time between the negative edgeof SDA and the negative edge of SCL for a START condition, in I2C module clock cycles.
          TIME: u9,

          /// [9:31] 
          res0: u23,

        }), @ptrFromInt(0x60004040));

        /// Configures the delay between the positiveedge of SCL and the negative edge of SDA
        pub const SCL_RSTART_SETUP = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:8] This register is used to configure the time between the positiveedge of SCL and the negative edge of SDA for a RESTART condition, in I2C module clock cycles.
          TIME: u9,

          /// [9:31] 
          res0: u23,

        }), @ptrFromInt(0x60004044));

        /// Configures the delay after the SCL clockedge for a stop condition
        pub const SCL_STOP_HOLD = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:8] This register is used to configure the delay after the STOP condition,in I2C module clock cycles.
          TIME: u9,

          /// [9:31] 
          res0: u23,

        }), @ptrFromInt(0x60004048));

        /// Configures the delay between the SDA andSCL positive edge for a stop condition
        pub const SCL_STOP_SETUP = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:8] This register is used to configure the time between the positive edgeof SCL and the positive edge of SDA, in I2C module clock cycles.
          TIME: u9,

          /// [9:31] 
          res0: u23,

        }), @ptrFromInt(0x6000404c));

        /// SCL and SDA filter configuration register
        pub const FILTER_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:3] When a pulse on the SCL input has smaller width than this register valuein I2C module clock cycles, the I2C controller will ignore that pulse.
          SCL_FILTER_THRES: u4,

          /// [4:7] When a pulse on the SDA input has smaller width than this register valuein I2C module clock cycles, the I2C controller will ignore that pulse.
          SDA_FILTER_THRES: u4,

          /// [8:8] This is the filter enable bit for SCL.
          SCL_FILTER_EN: u1,

          /// [9:9] This is the filter enable bit for SDA.
          SDA_FILTER_EN: u1,

          /// [10:31] 
          res0: u22,

        }), @ptrFromInt(0x60004050));

        /// I2C CLK configuration register
        pub const CLK_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] the integral part of the fractional divisor for i2c module
          SCLK_DIV_NUM: u8,

          /// [8:13] the numerator of the fractional part of the fractional divisor for i2c module
          SCLK_DIV_A: u6,

          /// [14:19] the denominator of the fractional part of the fractional divisor for i2c module
          SCLK_DIV_B: u6,

          /// [20:20] The clock selection for i2c module:0-XTAL,1-CLK_8MHz.
          SCLK_SEL: u1,

          /// [21:21] The clock switch for i2c module
          SCLK_ACTIVE: u1,

          /// [22:31] 
          res0: u10,

        }), @ptrFromInt(0x60004054));

        /// I2C command register %s
        pub const COMD0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:13] This is the content of command 0. It consists of three parts: op_code is the command, 0: RSTART, 1: WRITE, 2: READ, 3: STOP, 4: END.Byte_num represents the number of bytes that need to be sent or received.ack_check_en, ack_exp and ack are used to control the ACK bit. See I2C cmd structure for moreInformation.
          COMMAND: u14,

          /// [14:30] 
          res0: u17,

          /// [31:31] When command 0 is done in I2C Master mode, this bit changes to highlevel.
          COMMAND_DONE: u1,

        }), @ptrFromInt(0x60004058));

        /// I2C command register %s
        pub const COMD1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:13] This is the content of command 0. It consists of three parts: op_code is the command, 0: RSTART, 1: WRITE, 2: READ, 3: STOP, 4: END.Byte_num represents the number of bytes that need to be sent or received.ack_check_en, ack_exp and ack are used to control the ACK bit. See I2C cmd structure for moreInformation.
          COMMAND: u14,

          /// [14:30] 
          res0: u17,

          /// [31:31] When command 0 is done in I2C Master mode, this bit changes to highlevel.
          COMMAND_DONE: u1,

        }), @ptrFromInt(0x6000405c));

        /// I2C command register %s
        pub const COMD2 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:13] This is the content of command 0. It consists of three parts: op_code is the command, 0: RSTART, 1: WRITE, 2: READ, 3: STOP, 4: END.Byte_num represents the number of bytes that need to be sent or received.ack_check_en, ack_exp and ack are used to control the ACK bit. See I2C cmd structure for moreInformation.
          COMMAND: u14,

          /// [14:30] 
          res0: u17,

          /// [31:31] When command 0 is done in I2C Master mode, this bit changes to highlevel.
          COMMAND_DONE: u1,

        }), @ptrFromInt(0x60004060));

        /// I2C command register %s
        pub const COMD3 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:13] This is the content of command 0. It consists of three parts: op_code is the command, 0: RSTART, 1: WRITE, 2: READ, 3: STOP, 4: END.Byte_num represents the number of bytes that need to be sent or received.ack_check_en, ack_exp and ack are used to control the ACK bit. See I2C cmd structure for moreInformation.
          COMMAND: u14,

          /// [14:30] 
          res0: u17,

          /// [31:31] When command 0 is done in I2C Master mode, this bit changes to highlevel.
          COMMAND_DONE: u1,

        }), @ptrFromInt(0x60004064));

        /// I2C command register %s
        pub const COMD4 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:13] This is the content of command 0. It consists of three parts: op_code is the command, 0: RSTART, 1: WRITE, 2: READ, 3: STOP, 4: END.Byte_num represents the number of bytes that need to be sent or received.ack_check_en, ack_exp and ack are used to control the ACK bit. See I2C cmd structure for moreInformation.
          COMMAND: u14,

          /// [14:30] 
          res0: u17,

          /// [31:31] When command 0 is done in I2C Master mode, this bit changes to highlevel.
          COMMAND_DONE: u1,

        }), @ptrFromInt(0x60004068));

        /// I2C command register %s
        pub const COMD5 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:13] This is the content of command 0. It consists of three parts: op_code is the command, 0: RSTART, 1: WRITE, 2: READ, 3: STOP, 4: END.Byte_num represents the number of bytes that need to be sent or received.ack_check_en, ack_exp and ack are used to control the ACK bit. See I2C cmd structure for moreInformation.
          COMMAND: u14,

          /// [14:30] 
          res0: u17,

          /// [31:31] When command 0 is done in I2C Master mode, this bit changes to highlevel.
          COMMAND_DONE: u1,

        }), @ptrFromInt(0x6000406c));

        /// I2C command register %s
        pub const COMD6 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:13] This is the content of command 0. It consists of three parts: op_code is the command, 0: RSTART, 1: WRITE, 2: READ, 3: STOP, 4: END.Byte_num represents the number of bytes that need to be sent or received.ack_check_en, ack_exp and ack are used to control the ACK bit. See I2C cmd structure for moreInformation.
          COMMAND: u14,

          /// [14:30] 
          res0: u17,

          /// [31:31] When command 0 is done in I2C Master mode, this bit changes to highlevel.
          COMMAND_DONE: u1,

        }), @ptrFromInt(0x60004070));

        /// I2C command register %s
        pub const COMD7 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:13] This is the content of command 0. It consists of three parts: op_code is the command, 0: RSTART, 1: WRITE, 2: READ, 3: STOP, 4: END.Byte_num represents the number of bytes that need to be sent or received.ack_check_en, ack_exp and ack are used to control the ACK bit. See I2C cmd structure for moreInformation.
          COMMAND: u14,

          /// [14:30] 
          res0: u17,

          /// [31:31] When command 0 is done in I2C Master mode, this bit changes to highlevel.
          COMMAND_DONE: u1,

        }), @ptrFromInt(0x60004074));

        /// SCL status time out register
        pub const SCL_ST_TIME_OUT = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:4] The threshold value of SCL_FSM state unchanged period. It should be o more than 23
          SCL_ST_TO_I2C: u5,

          /// [5:31] 
          res0: u27,

        }), @ptrFromInt(0x60004078));

        /// SCL main status time out register
        pub const SCL_MAIN_ST_TIME_OUT = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:4] The threshold value of SCL_MAIN_FSM state unchanged period.nIt should be o more than 23
          SCL_MAIN_ST_TO_I2C: u5,

          /// [5:31] 
          res0: u27,

        }), @ptrFromInt(0x6000407c));

        /// Power configuration register
        pub const SCL_SP_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] When I2C master is IDLE, set this bit to send out SCL pulses. The number of pulses equals to reg_scl_rst_slv_num[4:0].
          SCL_RST_SLV_EN: u1,

          /// [1:5] Configure the pulses of SCL generated in I2C master mode. Valid when reg_scl_rst_slv_en is 1.
          SCL_RST_SLV_NUM: u5,

          /// [6:6] The power down enable bit for the I2C output SCL line. 1: Power down. 0: Not power down. Set reg_scl_force_out and reg_scl_pd_en to 1 to stretch SCL low.
          SCL_PD_EN: u1,

          /// [7:7] The power down enable bit for the I2C output SDA line. 1: Power down. 0: Not power down. Set reg_sda_force_out and reg_sda_pd_en to 1 to stretch SDA low.
          SDA_PD_EN: u1,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x60004080));

        /// Set SCL stretch of I2C slave
        pub const SCL_STRETCH_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:9] Configure the period of I2C slave stretching SCL line.
          STRETCH_PROTECT_NUM: u10,

          /// [10:10] The enable bit for slave SCL stretch function. 1: Enable. 0: Disable. The SCL output line will be stretched low when reg_slave_scl_stretch_en is 1 and stretch event happens. The stretch cause can be seen in reg_stretch_cause.
          SLAVE_SCL_STRETCH_EN: u1,

          /// [11:11] Set this bit to clear the I2C slave SCL stretch function.
          SLAVE_SCL_STRETCH_CLR: u1,

          /// [12:12] The enable bit for slave to control ACK level function.
          SLAVE_BYTE_ACK_CTL_EN: u1,

          /// [13:13] Set the ACK level when slave controlling ACK level function enables.
          SLAVE_BYTE_ACK_LVL: u1,

          /// [14:31] 
          res0: u18,

        }), @ptrFromInt(0x60004084));

        /// Version register
        pub const DATE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] This is the the version register.
          DATE: u32,

        }), @ptrFromInt(0x600040f8));

        /// I2C TXFIFO base address register
        pub const TXFIFO_START_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] This is the I2C txfifo first address.
          TXFIFO_START_ADDR: u32,

        }), @ptrFromInt(0x60004100));

        /// I2C RXFIFO base address register
        pub const RXFIFO_START_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] This is the I2C rxfifo first address.
          RXFIFO_START_ADDR: u32,

        }), @ptrFromInt(0x60004180));

      };

      /// I2S (Inter-IC Sound) Controller 0
      pub const I2S0 = struct {

        /// I2S interrupt raw register, valid in level.
        pub const INT_RAW = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] The raw interrupt status bitfor the i2s_rx_done_int interrupt
          RX_DONE_INT_RAW: u1,

          /// [1:1] The raw interrupt status bitfor the i2s_tx_done_int interrupt
          TX_DONE_INT_RAW: u1,

          /// [2:2] The raw interrupt status bitfor the i2s_rx_hung_int interrupt
          RX_HUNG_INT_RAW: u1,

          /// [3:3] The raw interrupt status bitfor the i2s_tx_hung_int interrupt
          TX_HUNG_INT_RAW: u1,

          /// [4:31] 
          res0: u28,

        }), @ptrFromInt(0x6000c00c));

        /// I2S interrupt status register.
        pub const INT_ST = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] The masked interrupt status bitfor the i2s_rx_done_int interrupt
          RX_DONE_INT_ST: u1,

          /// [1:1] The masked interrupt status bitfor the i2s_tx_done_int interrupt
          TX_DONE_INT_ST: u1,

          /// [2:2] The masked interrupt status bitfor the i2s_rx_hung_int interrupt
          RX_HUNG_INT_ST: u1,

          /// [3:3] The masked interrupt status bitfor the i2s_tx_hung_int interrupt
          TX_HUNG_INT_ST: u1,

          /// [4:31] 
          res0: u28,

        }), @ptrFromInt(0x6000c010));

        /// I2S interrupt enable register.
        pub const INT_ENA = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] The interrupt enable bitfor the i2s_rx_done_int interrupt
          RX_DONE_INT_ENA: u1,

          /// [1:1] The interrupt enable bitfor the i2s_tx_done_int interrupt
          TX_DONE_INT_ENA: u1,

          /// [2:2] The interrupt enable bitfor the i2s_rx_hung_int interrupt
          RX_HUNG_INT_ENA: u1,

          /// [3:3] The interrupt enable bitfor the i2s_tx_hung_int interrupt
          TX_HUNG_INT_ENA: u1,

          /// [4:31] 
          res0: u28,

        }), @ptrFromInt(0x6000c014));

        /// I2S interrupt clear register.
        pub const INT_CLR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Set this bit to clear the i2s_rx_done_int interrupt
          RX_DONE_INT_CLR: u1,

          /// [1:1] Set this bit to clear the i2s_tx_done_int interrupt
          TX_DONE_INT_CLR: u1,

          /// [2:2] Set this bit to clear the i2s_rx_hung_int interrupt
          RX_HUNG_INT_CLR: u1,

          /// [3:3] Set this bit to clear the i2s_tx_hung_int interrupt
          TX_HUNG_INT_CLR: u1,

          /// [4:31] 
          res0: u28,

        }), @ptrFromInt(0x6000c018));

        /// I2S RX configure register
        pub const RX_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Set this bit to reset receiver
          RX_RESET: u1,

          /// [1:1] Set this bit to reset Rx AFIFO
          RX_FIFO_RESET: u1,

          /// [2:2] Set this bit to start receiving data
          RX_START: u1,

          /// [3:3] Set this bit to enable slave receiver mode
          RX_SLAVE_MOD: u1,

          /// [4:4] 
          res0: u1,

          /// [5:5] Set this bit to enable receiverin mono mode
          RX_MONO: u1,

          /// [6:6] 
          res1: u1,

          /// [7:7] I2S Rx byte endian, 1: low addr value to high addr. 0: low addr with low addr value.
          RX_BIG_ENDIAN: u1,

          /// [8:8] Set 1 to update I2S RX registers from APB clock domain to I2S RX clock domain. This bit will be cleared by hardware after update register done.
          RX_UPDATE: u1,

          /// [9:9] 1: The first channel data value is valid in I2S RX mono mode. 0: The second channel data value is valid in I2S RX mono mode.
          RX_MONO_FST_VLD: u1,

          /// [10:11] I2S RX compress/decompress configuration bit. & 0 (atol): A-Law decompress, 1 (ltoa) : A-Law compress, 2 (utol) : u-Law decompress, 3 (ltou) : u-Law compress. &
          RX_PCM_CONF: u2,

          /// [12:12] Set this bit to bypass Compress/Decompress module for received data.
          RX_PCM_BYPASS: u1,

          /// [13:14] 0: I2S Rx only stop when reg_rx_start is cleared. 1: Stop when reg_rx_start is 0 or in_suc_eof is 1. 2:Stop I2S RX when reg_rx_start is 0 or RX FIFO is full.
          RX_STOP_MODE: u2,

          /// [15:15] 1: I2S RX left alignment mode. 0: I2S RX right alignment mode.
          RX_LEFT_ALIGN: u1,

          /// [16:16] 1: store 24 channel bits to 32 bits. 0:store 24 channel bits to 24 bits.
          RX_24_FILL_EN: u1,

          /// [17:17] 0: WS should be 0 when receiving left channel data, and WS is 1in right channel.1: WS should be 1 when receiving left channel data, and WS is 0in right channel.
          RX_WS_IDLE_POL: u1,

          /// [18:18] I2S Rx bit endian. 1:small endian, the LSB is received first. 0:big endian, the MSB is received first.
          RX_BIT_ORDER: u1,

          /// [19:19] 1: Enable I2S TDM Rx mode . 0: Disable.
          RX_TDM_EN: u1,

          /// [20:20] 1: Enable I2S PDM Rx mode . 0: Disable.
          RX_PDM_EN: u1,

          /// [21:31] 
          res2: u11,

        }), @ptrFromInt(0x6000c020));

        /// I2S TX configure register
        pub const TX_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Set this bit to reset transmitter
          TX_RESET: u1,

          /// [1:1] Set this bit to reset Tx AFIFO
          TX_FIFO_RESET: u1,

          /// [2:2] Set this bit to start transmitting data
          TX_START: u1,

          /// [3:3] Set this bit to enable slave transmitter mode
          TX_SLAVE_MOD: u1,

          /// [4:4] 
          res0: u1,

          /// [5:5] Set this bit to enable transmitter in mono mode
          TX_MONO: u1,

          /// [6:6] 1: The value of Left channel data is equal to the value of right channel data in I2S TX mono mode or TDM channel select mode. 0: The invalid channel data is reg_i2s_single_data in I2S TX mono mode or TDM channel select mode.
          TX_CHAN_EQUAL: u1,

          /// [7:7] I2S Tx byte endian, 1: low addr value to high addr.0: low addr with low addr value.
          TX_BIG_ENDIAN: u1,

          /// [8:8] Set 1 to update I2S TX registers from APB clock domain to I2S TX clock domain. This bit will be cleared by hardware after update register done.
          TX_UPDATE: u1,

          /// [9:9] 1: The first channel data value is valid in I2S TX mono mode. 0: The second channel data value is valid in I2S TX mono mode.
          TX_MONO_FST_VLD: u1,

          /// [10:11] I2S TX compress/decompress configuration bit. & 0 (atol): A-Law decompress, 1 (ltoa) : A-Law compress, 2 (utol) : u-Law decompress, 3 (ltou) : u-Law compress. &
          TX_PCM_CONF: u2,

          /// [12:12] Set this bit to bypassCompress/Decompress module for transmitted data.
          TX_PCM_BYPASS: u1,

          /// [13:13] Set this bit to stop disable output BCK signal and WS signal when tx FIFO is emtpy
          TX_STOP_EN: u1,

          /// [14:14] 
          res1: u1,

          /// [15:15] 1: I2S TX left alignment mode. 0: I2S TX right alignment mode.
          TX_LEFT_ALIGN: u1,

          /// [16:16] 1: Sent 32 bits in 24 channel bits mode. 0: Sent 24 bits in 24 channel bits mode
          TX_24_FILL_EN: u1,

          /// [17:17] 0: WS should be 0 when sending left channel data, and WS is 1in right channel.1: WS should be 1 when sending left channel data, and WS is 0in right channel.
          TX_WS_IDLE_POL: u1,

          /// [18:18] I2S Tx bit endian. 1:small endian, the LSB is sent first. 0:big endian, the MSB is sent first.
          TX_BIT_ORDER: u1,

          /// [19:19] 1: Enable I2S TDM Tx mode . 0: Disable.
          TX_TDM_EN: u1,

          /// [20:20] 1: Enable I2S PDM Tx mode . 0: Disable.
          TX_PDM_EN: u1,

          /// [21:23] 
          res2: u3,

          /// [24:26] I2S transmitter channel mode configuration bits.
          TX_CHAN_MOD: u3,

          /// [27:27] Enable signal loop back mode with transmitter module and receiver module sharing the same WS and BCK signals.
          SIG_LOOPBACK: u1,

          /// [28:31] 
          res3: u4,

        }), @ptrFromInt(0x6000c024));

        /// I2S RX configure register 1
        pub const RX_CONF1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:6] The width of rx_ws_out in TDM mode is (I2S_RX_TDM_WS_WIDTH[6:0] +1) * T_bck
          RX_TDM_WS_WIDTH: u7,

          /// [7:12] Bit clock configuration bits in receiver mode.
          RX_BCK_DIV_NUM: u6,

          /// [13:17] Set the bits to configure the valid data bit length of I2S receiver channel. 7: all the valid channel data is in 8-bit-mode. 15: all the valid channel data is in 16-bit-mode. 23: all the valid channel data is in 24-bit-mode. 31:all the valid channel data is in 32-bit-mode.
          RX_BITS_MOD: u5,

          /// [18:23] I2S Rx half sample bits -1.
          RX_HALF_SAMPLE_BITS: u6,

          /// [24:28] The Rx bit number for each channel minus 1in TDM mode.
          RX_TDM_CHAN_BITS: u5,

          /// [29:29] Set this bit to enable receiver in Phillips standard mode
          RX_MSB_SHIFT: u1,

          /// [30:31] 
          res0: u2,

        }), @ptrFromInt(0x6000c028));

        /// I2S TX configure register 1
        pub const TX_CONF1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:6] The width of tx_ws_out in TDM mode is (I2S_TX_TDM_WS_WIDTH[6:0] +1) * T_bck
          TX_TDM_WS_WIDTH: u7,

          /// [7:12] Bit clock configuration bits in transmitter mode.
          TX_BCK_DIV_NUM: u6,

          /// [13:17] Set the bits to configure the valid data bit length of I2S transmitter channel. 7: all the valid channel data is in 8-bit-mode. 15: all the valid channel data is in 16-bit-mode. 23: all the valid channel data is in 24-bit-mode. 31:all the valid channel data is in 32-bit-mode.
          TX_BITS_MOD: u5,

          /// [18:23] I2S Tx half sample bits -1.
          TX_HALF_SAMPLE_BITS: u6,

          /// [24:28] The Tx bit number for each channel minus 1in TDM mode.
          TX_TDM_CHAN_BITS: u5,

          /// [29:29] Set this bit to enable transmitter in Phillips standard mode
          TX_MSB_SHIFT: u1,

          /// [30:30] 1: BCK is not delayed to generate pos/neg edge in master mode. 0: BCK is delayed to generate pos/neg edge in master mode.
          TX_BCK_NO_DLY: u1,

          /// [31:31] 
          res0: u1,

        }), @ptrFromInt(0x6000c02c));

        /// I2S RX clock configure register
        pub const RX_CLKM_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] Integral I2S clock divider value
          RX_CLKM_DIV_NUM: u8,

          /// [8:25] 
          res0: u18,

          /// [26:26] I2S Rx module clock enable signal.
          RX_CLK_ACTIVE: u1,

          /// [27:28] Select I2S Rx module source clock. 0: no clock. 1: APLL. 2: CLK160. 3: I2S_MCLK_in.
          RX_CLK_SEL: u2,

          /// [29:29] 0: UseI2S Tx module clock as I2S_MCLK_OUT.1: UseI2S Rx module clock as I2S_MCLK_OUT.
          MCLK_SEL: u1,

          /// [30:31] 
          res1: u2,

        }), @ptrFromInt(0x6000c030));

        /// I2S TX clock configure register
        pub const TX_CLKM_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] Integral I2S TX clock divider value. f_I2S_CLK = f_I2S_CLK_S/(N+b/a). There will be (a-b) * n-div and b * (n+1)-div.So the average combination will be:for b <= a/2, z * [x * n-div + (n+1)-div] + y * n-div. For b > a/2, z * [n-div + x * (n+1)-div] + y * (n+1)-div.
          TX_CLKM_DIV_NUM: u8,

          /// [8:25] 
          res0: u18,

          /// [26:26] I2S Tx module clock enable signal.
          TX_CLK_ACTIVE: u1,

          /// [27:28] Select I2S Tx module source clock. 0: XTAL clock. 1: APLL. 2: CLK160. 3: I2S_MCLK_in.
          TX_CLK_SEL: u2,

          /// [29:29] Set this bit to enable clk gate
          CLK_EN: u1,

          /// [30:31] 
          res1: u2,

        }), @ptrFromInt(0x6000c034));

        /// I2S RX module clock divider configure register
        pub const RX_CLKM_DIV_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:8] For b <= a/2, the value of I2S_RX_CLKM_DIV_Z is b. For b > a/2, the value of I2S_RX_CLKM_DIV_Z is (a-b).
          RX_CLKM_DIV_Z: u9,

          /// [9:17] For b <= a/2, the value of I2S_RX_CLKM_DIV_Y is (a%b) . For b > a/2, the value of I2S_RX_CLKM_DIV_Y is (a%(a-b)).
          RX_CLKM_DIV_Y: u9,

          /// [18:26] For b <= a/2, the value of I2S_RX_CLKM_DIV_X is (a/b) - 1. For b > a/2, the value of I2S_RX_CLKM_DIV_X is (a/(a-b)) - 1.
          RX_CLKM_DIV_X: u9,

          /// [27:27] For b <= a/2, the value of I2S_RX_CLKM_DIV_YN1 is 0 . For b > a/2, the value of I2S_RX_CLKM_DIV_YN1 is 1.
          RX_CLKM_DIV_YN1: u1,

          /// [28:31] 
          res0: u4,

        }), @ptrFromInt(0x6000c038));

        /// I2S TX module clock divider configure register
        pub const TX_CLKM_DIV_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:8] For b <= a/2, the value of I2S_TX_CLKM_DIV_Z is b. For b > a/2, the value of I2S_TX_CLKM_DIV_Z is (a-b).
          TX_CLKM_DIV_Z: u9,

          /// [9:17] For b <= a/2, the value of I2S_TX_CLKM_DIV_Y is (a%b) . For b > a/2, the value of I2S_TX_CLKM_DIV_Y is (a%(a-b)).
          TX_CLKM_DIV_Y: u9,

          /// [18:26] For b <= a/2, the value of I2S_TX_CLKM_DIV_X is (a/b) - 1. For b > a/2, the value of I2S_TX_CLKM_DIV_X is (a/(a-b)) - 1.
          TX_CLKM_DIV_X: u9,

          /// [27:27] For b <= a/2, the value of I2S_TX_CLKM_DIV_YN1 is 0 . For b > a/2, the value of I2S_TX_CLKM_DIV_YN1 is 1.
          TX_CLKM_DIV_YN1: u1,

          /// [28:31] 
          res0: u4,

        }), @ptrFromInt(0x6000c03c));

        /// I2S TX PCM2PDM configuration register
        pub const TX_PCM2PDM_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] I2S TX PDM bypass hp filter or not. The option has been removed.
          TX_PDM_HP_BYPASS: u1,

          /// [1:4] I2S TX PDM OSR2 value
          TX_PDM_SINC_OSR2: u4,

          /// [5:12] I2S TX PDM prescale for sigmadelta
          TX_PDM_PRESCALE: u8,

          /// [13:14] I2S TX PDM sigmadelta scale shift number: 0:/2 , 1:x1 , 2:x2 , 3: x4
          TX_PDM_HP_IN_SHIFT: u2,

          /// [15:16] I2S TX PDM sigmadelta scale shift number: 0:/2 , 1:x1 , 2:x2 , 3: x4
          TX_PDM_LP_IN_SHIFT: u2,

          /// [17:18] I2S TX PDM sigmadelta scale shift number: 0:/2 , 1:x1 , 2:x2 , 3: x4
          TX_PDM_SINC_IN_SHIFT: u2,

          /// [19:20] I2S TX PDM sigmadelta scale shift number: 0:/2 , 1:x1 , 2:x2 , 3: x4
          TX_PDM_SIGMADELTA_IN_SHIFT: u2,

          /// [21:21] I2S TX PDM sigmadelta dither2 value
          TX_PDM_SIGMADELTA_DITHER2: u1,

          /// [22:22] I2S TX PDM sigmadelta dither value
          TX_PDM_SIGMADELTA_DITHER: u1,

          /// [23:23] I2S TX PDM dac mode enable
          TX_PDM_DAC_2OUT_EN: u1,

          /// [24:24] I2S TX PDM dac 2channel enable
          TX_PDM_DAC_MODE_EN: u1,

          /// [25:25] I2S TX PDM Converter enable
          PCM2PDM_CONV_EN: u1,

          /// [26:31] 
          res0: u6,

        }), @ptrFromInt(0x6000c040));

        /// I2S TX PCM2PDM configuration register
        pub const TX_PCM2PDM_CONF1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:9] I2S TX PDM Fp
          TX_PDM_FP: u10,

          /// [10:19] I2S TX PDM Fs
          TX_PDM_FS: u10,

          /// [20:22] The fourth parameter of PDM TX IIR_HP filter stage 2 is (504 + I2S_TX_IIR_HP_MULT12_5[2:0])
          TX_IIR_HP_MULT12_5: u3,

          /// [23:25] The fourth parameter of PDM TX IIR_HP filter stage 1 is (504 + I2S_TX_IIR_HP_MULT12_0[2:0])
          TX_IIR_HP_MULT12_0: u3,

          /// [26:31] 
          res0: u6,

        }), @ptrFromInt(0x6000c044));

        /// I2S TX TDM mode control register
        pub const RX_TDM_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] 1: Enable the valid data input of I2S RX TDM or PDM channel 0. 0:Disable, just input 0 in this channel.
          RX_TDM_PDM_CHAN0_EN: u1,

          /// [1:1] 1: Enable the valid data input of I2S RX TDM or PDM channel 1. 0:Disable, just input 0 in this channel.
          RX_TDM_PDM_CHAN1_EN: u1,

          /// [2:2] 1: Enable the valid data input of I2S RX TDM or PDM channel 2. 0:Disable, just input 0 in this channel.
          RX_TDM_PDM_CHAN2_EN: u1,

          /// [3:3] 1: Enable the valid data input of I2S RX TDM or PDM channel 3. 0:Disable, just input 0 in this channel.
          RX_TDM_PDM_CHAN3_EN: u1,

          /// [4:4] 1: Enable the valid data input of I2S RX TDM or PDM channel 4. 0:Disable, just input 0 in this channel.
          RX_TDM_PDM_CHAN4_EN: u1,

          /// [5:5] 1: Enable the valid data input of I2S RX TDM or PDM channel 5. 0:Disable, just input 0 in this channel.
          RX_TDM_PDM_CHAN5_EN: u1,

          /// [6:6] 1: Enable the valid data input of I2S RX TDM or PDM channel 6. 0:Disable, just input 0 in this channel.
          RX_TDM_PDM_CHAN6_EN: u1,

          /// [7:7] 1: Enable the valid data input of I2S RX TDM or PDM channel 7. 0:Disable, just input 0 in this channel.
          RX_TDM_PDM_CHAN7_EN: u1,

          /// [8:8] 1: Enable the valid data input of I2S RX TDM channel 8. 0:Disable, just input 0 in this channel.
          RX_TDM_CHAN8_EN: u1,

          /// [9:9] 1: Enable the valid data input of I2S RX TDM channel 9. 0:Disable, just input 0 in this channel.
          RX_TDM_CHAN9_EN: u1,

          /// [10:10] 1: Enable the valid data input of I2S RX TDM channel 10. 0:Disable, just input 0 in this channel.
          RX_TDM_CHAN10_EN: u1,

          /// [11:11] 1: Enable the valid data input of I2S RX TDM channel 11. 0:Disable, just input 0 in this channel.
          RX_TDM_CHAN11_EN: u1,

          /// [12:12] 1: Enable the valid data input of I2S RX TDM channel 12. 0:Disable, just input 0 in this channel.
          RX_TDM_CHAN12_EN: u1,

          /// [13:13] 1: Enable the valid data input of I2S RX TDM channel 13. 0:Disable, just input 0 in this channel.
          RX_TDM_CHAN13_EN: u1,

          /// [14:14] 1: Enable the valid data input of I2S RX TDM channel 14. 0:Disable, just input 0 in this channel.
          RX_TDM_CHAN14_EN: u1,

          /// [15:15] 1: Enable the valid data input of I2S RX TDM channel 15. 0:Disable, just input 0 in this channel.
          RX_TDM_CHAN15_EN: u1,

          /// [16:19] The total channel number of I2S TX TDM mode.
          RX_TDM_TOT_CHAN_NUM: u4,

          /// [20:31] 
          res0: u12,

        }), @ptrFromInt(0x6000c050));

        /// I2S TX TDM mode control register
        pub const TX_TDM_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] 1: Enable the valid data output of I2S TX TDM channel 0. 0:Disable, just output 0 in this channel.
          TX_TDM_CHAN0_EN: u1,

          /// [1:1] 1: Enable the valid data output of I2S TX TDM channel 1. 0:Disable, just output 0 in this channel.
          TX_TDM_CHAN1_EN: u1,

          /// [2:2] 1: Enable the valid data output of I2S TX TDM channel 2. 0:Disable, just output 0 in this channel.
          TX_TDM_CHAN2_EN: u1,

          /// [3:3] 1: Enable the valid data output of I2S TX TDM channel 3. 0:Disable, just output 0 in this channel.
          TX_TDM_CHAN3_EN: u1,

          /// [4:4] 1: Enable the valid data output of I2S TX TDM channel 4. 0:Disable, just output 0 in this channel.
          TX_TDM_CHAN4_EN: u1,

          /// [5:5] 1: Enable the valid data output of I2S TX TDM channel 5. 0:Disable, just output 0 in this channel.
          TX_TDM_CHAN5_EN: u1,

          /// [6:6] 1: Enable the valid data output of I2S TX TDM channel 6. 0:Disable, just output 0 in this channel.
          TX_TDM_CHAN6_EN: u1,

          /// [7:7] 1: Enable the valid data output of I2S TX TDM channel 7. 0:Disable, just output 0 in this channel.
          TX_TDM_CHAN7_EN: u1,

          /// [8:8] 1: Enable the valid data output of I2S TX TDM channel 8. 0:Disable, just output 0 in this channel.
          TX_TDM_CHAN8_EN: u1,

          /// [9:9] 1: Enable the valid data output of I2S TX TDM channel 9. 0:Disable, just output 0 in this channel.
          TX_TDM_CHAN9_EN: u1,

          /// [10:10] 1: Enable the valid data output of I2S TX TDM channel 10. 0:Disable, just output 0 in this channel.
          TX_TDM_CHAN10_EN: u1,

          /// [11:11] 1: Enable the valid data output of I2S TX TDM channel 11. 0:Disable, just output 0 in this channel.
          TX_TDM_CHAN11_EN: u1,

          /// [12:12] 1: Enable the valid data output of I2S TX TDM channel 12. 0:Disable, just output 0 in this channel.
          TX_TDM_CHAN12_EN: u1,

          /// [13:13] 1: Enable the valid data output of I2S TX TDM channel 13. 0:Disable, just output 0 in this channel.
          TX_TDM_CHAN13_EN: u1,

          /// [14:14] 1: Enable the valid data output of I2S TX TDM channel 14. 0:Disable, just output 0 in this channel.
          TX_TDM_CHAN14_EN: u1,

          /// [15:15] 1: Enable the valid data output of I2S TX TDM channel 15. 0:Disable, just output 0 in this channel.
          TX_TDM_CHAN15_EN: u1,

          /// [16:19] The total channel number of I2S TX TDM mode.
          TX_TDM_TOT_CHAN_NUM: u4,

          /// [20:20] When DMA TX buffer stores the data of (REG_TX_TDM_TOT_CHAN_NUM + 1)channels, and only the data of the enabled channels is sent, then this bit should be set. Clear it when all the data stored in DMA TX buffer is for enabled channels.
          TX_TDM_SKIP_MSK_EN: u1,

          /// [21:31] 
          res0: u11,

        }), @ptrFromInt(0x6000c054));

        /// I2S RX timing control register
        pub const RX_TIMING = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:1] The delay mode of I2S Rx SD input signal. 0: bypass. 1: delay by pos edge.2: delay by neg edge. 3: not used.
          RX_SD_IN_DM: u2,

          /// [2:15] 
          res0: u14,

          /// [16:17] The delay mode of I2S Rx WS output signal. 0: bypass. 1: delay by pos edge.2: delay by neg edge. 3: not used.
          RX_WS_OUT_DM: u2,

          /// [18:19] 
          res1: u2,

          /// [20:21] The delay mode of I2S Rx BCK output signal. 0: bypass. 1: delay by pos edge.2: delay by neg edge. 3: not used.
          RX_BCK_OUT_DM: u2,

          /// [22:23] 
          res2: u2,

          /// [24:25] The delay mode of I2S Rx WS input signal. 0: bypass. 1: delay by pos edge.2: delay by neg edge. 3: not used.
          RX_WS_IN_DM: u2,

          /// [26:27] 
          res3: u2,

          /// [28:29] The delay mode of I2S Rx BCK input signal. 0: bypass. 1: delay by pos edge.2: delay by neg edge. 3: not used.
          RX_BCK_IN_DM: u2,

          /// [30:31] 
          res4: u2,

        }), @ptrFromInt(0x6000c058));

        /// I2S TX timing control register
        pub const TX_TIMING = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:1] The delay mode of I2S TX SD output signal. 0: bypass. 1: delay by pos edge.2: delay by neg edge. 3: not used.
          TX_SD_OUT_DM: u2,

          /// [2:3] 
          res0: u2,

          /// [4:5] The delay mode of I2S TX SD1 output signal. 0: bypass. 1: delay by pos edge.2: delay by neg edge. 3: not used.
          TX_SD1_OUT_DM: u2,

          /// [6:15] 
          res1: u10,

          /// [16:17] The delay mode of I2S TX WS output signal. 0: bypass. 1: delay by pos edge.2: delay by neg edge. 3: not used.
          TX_WS_OUT_DM: u2,

          /// [18:19] 
          res2: u2,

          /// [20:21] The delay mode of I2S TX BCK output signal. 0: bypass. 1: delay by pos edge.2: delay by neg edge. 3: not used.
          TX_BCK_OUT_DM: u2,

          /// [22:23] 
          res3: u2,

          /// [24:25] The delay mode of I2S TX WS input signal. 0: bypass. 1: delay by pos edge.2: delay by neg edge. 3: not used.
          TX_WS_IN_DM: u2,

          /// [26:27] 
          res4: u2,

          /// [28:29] The delay mode of I2S TX BCK input signal. 0: bypass. 1: delay by pos edge.2: delay by neg edge. 3: not used.
          TX_BCK_IN_DM: u2,

          /// [30:31] 
          res5: u2,

        }), @ptrFromInt(0x6000c05c));

        /// I2S HUNG configure register.
        pub const LC_HUNG_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] the i2s_tx_hung_int interrupt or the i2s_rx_hung_int interrupt will be triggered when fifo hung counter is equal to this value
          LC_FIFO_TIMEOUT: u8,

          /// [8:10] The bits are used to scale tick counter threshold. The tick counter is reset when counter value >= 88000/2^i2s_lc_fifo_timeout_shift
          LC_FIFO_TIMEOUT_SHIFT: u3,

          /// [11:11] The enable bit for FIFO timeout
          LC_FIFO_TIMEOUT_ENA: u1,

          /// [12:31] 
          res0: u20,

        }), @ptrFromInt(0x6000c060));

        /// I2S RX data number control register.
        pub const RXEOF_NUM = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:11] The receive data bit length is (I2S_RX_BITS_MOD[4:0] + 1) * (REG_RX_EOF_NUM[11:0] + 1) . It will trigger in_suc_eof interrupt in the configured DMA RX channel.
          RX_EOF_NUM: u12,

          /// [12:31] 
          res0: u20,

        }), @ptrFromInt(0x6000c064));

        /// I2S signal data register
        pub const CONF_SIGLE_DATA = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] The configured constant channel data to be sent out.
          SINGLE_DATA: u32,

        }), @ptrFromInt(0x6000c068));

        /// I2S TX status register
        pub const STATE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] 1: i2s_tx is idle state. 0: i2s_tx is working.
          TX_IDLE: u1,

          /// [1:31] 
          res0: u31,

        }), @ptrFromInt(0x6000c06c));

        /// I2S ETM configure register
        pub const ETM_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:9] I2S ETM send x words event. When sending word number of reg_etm_tx_send_word_num[9:0], i2s will trigger an etm event.
          ETM_TX_SEND_WORD_NUM: u10,

          /// [10:19] I2S ETM receive x words event. When receiving word number of reg_etm_rx_receive_word_num[9:0], i2s will trigger an etm event.
          ETM_RX_RECEIVE_WORD_NUM: u10,

          /// [20:31] 
          res0: u12,

        }), @ptrFromInt(0x6000c070));

        /// Version control register
        pub const DATE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:27] I2S version control register
          DATE: u28,

          /// [28:31] 
          res0: u4,

        }), @ptrFromInt(0x6000c080));

      };

      /// Interrupt Controller (Core 0)
      pub const INTERRUPT_CORE0 = struct {

        /// register description
        pub const WIFI_MAC_INTR_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:4] Need add description
          WIFI_MAC_INTR_MAP: u5,

          /// [5:31] 
          res0: u27,

        }), @ptrFromInt(0x60010000));

        /// register description
        pub const WIFI_MAC_NMI_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:4] Need add description
          WIFI_MAC_NMI_MAP: u5,

          /// [5:31] 
          res0: u27,

        }), @ptrFromInt(0x60010004));

        /// register description
        pub const WIFI_PWR_INTR_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:4] Need add description
          WIFI_PWR_INTR_MAP: u5,

          /// [5:31] 
          res0: u27,

        }), @ptrFromInt(0x60010008));

        /// register description
        pub const WIFI_BB_INTR_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:4] Need add description
          WIFI_BB_INTR_MAP: u5,

          /// [5:31] 
          res0: u27,

        }), @ptrFromInt(0x6001000c));

        /// register description
        pub const BT_MAC_INTR_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:4] Need add description
          BT_MAC_INTR_MAP: u5,

          /// [5:31] 
          res0: u27,

        }), @ptrFromInt(0x60010010));

        /// register description
        pub const BT_BB_INTR_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:4] Need add description
          BT_BB_INTR_MAP: u5,

          /// [5:31] 
          res0: u27,

        }), @ptrFromInt(0x60010014));

        /// register description
        pub const BT_BB_NMI_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:4] Need add description
          BT_BB_NMI_MAP: u5,

          /// [5:31] 
          res0: u27,

        }), @ptrFromInt(0x60010018));

        /// register description
        pub const LP_TIMER_INTR_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:4] Need add description
          LP_TIMER_INTR_MAP: u5,

          /// [5:31] 
          res0: u27,

        }), @ptrFromInt(0x6001001c));

        /// register description
        pub const COEX_INTR_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:4] Need add description
          COEX_INTR_MAP: u5,

          /// [5:31] 
          res0: u27,

        }), @ptrFromInt(0x60010020));

        /// register description
        pub const BLE_TIMER_INTR_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:4] Need add description
          BLE_TIMER_INTR_MAP: u5,

          /// [5:31] 
          res0: u27,

        }), @ptrFromInt(0x60010024));

        /// register description
        pub const BLE_SEC_INTR_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:4] Need add description
          BLE_SEC_INTR_MAP: u5,

          /// [5:31] 
          res0: u27,

        }), @ptrFromInt(0x60010028));

        /// register description
        pub const I2C_MST_INTR_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:4] Need add description
          I2C_MST_INTR_MAP: u5,

          /// [5:31] 
          res0: u27,

        }), @ptrFromInt(0x6001002c));

        /// register description
        pub const ZB_MAC_INTR_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:4] Need add description
          ZB_MAC_INTR_MAP: u5,

          /// [5:31] 
          res0: u27,

        }), @ptrFromInt(0x60010030));

        /// register description
        pub const PMU_INTR_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:4] Need add description
          PMU_INTR_MAP: u5,

          /// [5:31] 
          res0: u27,

        }), @ptrFromInt(0x60010034));

        /// register description
        pub const EFUSE_INTR_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:4] Need add description
          EFUSE_INTR_MAP: u5,

          /// [5:31] 
          res0: u27,

        }), @ptrFromInt(0x60010038));

        /// register description
        pub const LP_RTC_TIMER_INTR_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:4] Need add description
          LP_RTC_TIMER_INTR_MAP: u5,

          /// [5:31] 
          res0: u27,

        }), @ptrFromInt(0x6001003c));

        /// register description
        pub const LP_UART_INTR_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:4] Need add description
          LP_UART_INTR_MAP: u5,

          /// [5:31] 
          res0: u27,

        }), @ptrFromInt(0x60010040));

        /// register description
        pub const LP_I2C_INTR_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:4] Need add description
          LP_I2C_INTR_MAP: u5,

          /// [5:31] 
          res0: u27,

        }), @ptrFromInt(0x60010044));

        /// register description
        pub const LP_WDT_INTR_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:4] Need add description
          LP_WDT_INTR_MAP: u5,

          /// [5:31] 
          res0: u27,

        }), @ptrFromInt(0x60010048));

        /// register description
        pub const LP_PERI_TIMEOUT_INTR_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:4] Need add description
          LP_PERI_TIMEOUT_INTR_MAP: u5,

          /// [5:31] 
          res0: u27,

        }), @ptrFromInt(0x6001004c));

        /// register description
        pub const LP_APM_M0_INTR_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:4] Need add description
          LP_APM_M0_INTR_MAP: u5,

          /// [5:31] 
          res0: u27,

        }), @ptrFromInt(0x60010050));

        /// register description
        pub const LP_APM_M1_INTR_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:4] Need add description
          LP_APM_M1_INTR_MAP: u5,

          /// [5:31] 
          res0: u27,

        }), @ptrFromInt(0x60010054));

        /// register description
        pub const CPU_INTR_FROM_CPU_0_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:4] Need add description
          CPU_INTR_FROM_CPU_0_MAP: u5,

          /// [5:31] 
          res0: u27,

        }), @ptrFromInt(0x60010058));

        /// register description
        pub const CPU_INTR_FROM_CPU_1_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:4] Need add description
          CPU_INTR_FROM_CPU_1_MAP: u5,

          /// [5:31] 
          res0: u27,

        }), @ptrFromInt(0x6001005c));

        /// register description
        pub const CPU_INTR_FROM_CPU_2_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:4] Need add description
          CPU_INTR_FROM_CPU_2_MAP: u5,

          /// [5:31] 
          res0: u27,

        }), @ptrFromInt(0x60010060));

        /// register description
        pub const CPU_INTR_FROM_CPU_3_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:4] Need add description
          CPU_INTR_FROM_CPU_3_MAP: u5,

          /// [5:31] 
          res0: u27,

        }), @ptrFromInt(0x60010064));

        /// register description
        pub const ASSIST_DEBUG_INTR_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:4] Need add description
          ASSIST_DEBUG_INTR_MAP: u5,

          /// [5:31] 
          res0: u27,

        }), @ptrFromInt(0x60010068));

        /// register description
        pub const TRACE_INTR_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:4] Need add description
          TRACE_INTR_MAP: u5,

          /// [5:31] 
          res0: u27,

        }), @ptrFromInt(0x6001006c));

        /// register description
        pub const CACHE_INTR_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:4] Need add description
          CACHE_INTR_MAP: u5,

          /// [5:31] 
          res0: u27,

        }), @ptrFromInt(0x60010070));

        /// register description
        pub const CPU_PERI_TIMEOUT_INTR_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:4] Need add description
          CPU_PERI_TIMEOUT_INTR_MAP: u5,

          /// [5:31] 
          res0: u27,

        }), @ptrFromInt(0x60010074));

        /// register description
        pub const GPIO_INTERRUPT_PRO_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:4] Need add description
          GPIO_INTERRUPT_PRO_MAP: u5,

          /// [5:31] 
          res0: u27,

        }), @ptrFromInt(0x60010078));

        /// register description
        pub const GPIO_INTERRUPT_PRO_NMI_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:4] Need add description
          GPIO_INTERRUPT_PRO_NMI_MAP: u5,

          /// [5:31] 
          res0: u27,

        }), @ptrFromInt(0x6001007c));

        /// register description
        pub const PAU_INTR_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:4] Need add description
          PAU_INTR_MAP: u5,

          /// [5:31] 
          res0: u27,

        }), @ptrFromInt(0x60010080));

        /// register description
        pub const HP_PERI_TIMEOUT_INTR_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:4] Need add description
          HP_PERI_TIMEOUT_INTR_MAP: u5,

          /// [5:31] 
          res0: u27,

        }), @ptrFromInt(0x60010084));

        /// register description
        pub const MODEM_PERI_TIMEOUT_INTR_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:4] Need add description
          MODEM_PERI_TIMEOUT_INTR_MAP: u5,

          /// [5:31] 
          res0: u27,

        }), @ptrFromInt(0x60010088));

        /// register description
        pub const HP_APM_M0_INTR_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:4] Need add description
          HP_APM_M0_INTR_MAP: u5,

          /// [5:31] 
          res0: u27,

        }), @ptrFromInt(0x6001008c));

        /// register description
        pub const HP_APM_M1_INTR_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:4] Need add description
          HP_APM_M1_INTR_MAP: u5,

          /// [5:31] 
          res0: u27,

        }), @ptrFromInt(0x60010090));

        /// register description
        pub const HP_APM_M2_INTR_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:4] Need add description
          HP_APM_M2_INTR_MAP: u5,

          /// [5:31] 
          res0: u27,

        }), @ptrFromInt(0x60010094));

        /// register description
        pub const HP_APM_M3_INTR_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:4] Need add description
          HP_APM_M3_INTR_MAP: u5,

          /// [5:31] 
          res0: u27,

        }), @ptrFromInt(0x60010098));

        /// register description
        pub const LP_APM0_INTR_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:4] Need add description
          LP_APM0_INTR_MAP: u5,

          /// [5:31] 
          res0: u27,

        }), @ptrFromInt(0x6001009c));

        /// register description
        pub const MSPI_INTR_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:4] Need add description
          MSPI_INTR_MAP: u5,

          /// [5:31] 
          res0: u27,

        }), @ptrFromInt(0x600100a0));

        /// register description
        pub const I2S1_INTR_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:4] Need add description
          I2S1_INTR_MAP: u5,

          /// [5:31] 
          res0: u27,

        }), @ptrFromInt(0x600100a4));

        /// register description
        pub const UHCI0_INTR_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:4] Need add description
          UHCI0_INTR_MAP: u5,

          /// [5:31] 
          res0: u27,

        }), @ptrFromInt(0x600100a8));

        /// register description
        pub const UART0_INTR_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:4] Need add description
          UART0_INTR_MAP: u5,

          /// [5:31] 
          res0: u27,

        }), @ptrFromInt(0x600100ac));

        /// register description
        pub const UART1_INTR_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:4] Need add description
          UART1_INTR_MAP: u5,

          /// [5:31] 
          res0: u27,

        }), @ptrFromInt(0x600100b0));

        /// register description
        pub const LEDC_INTR_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:4] Need add description
          LEDC_INTR_MAP: u5,

          /// [5:31] 
          res0: u27,

        }), @ptrFromInt(0x600100b4));

        /// register description
        pub const CAN0_INTR_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:4] Need add description
          CAN0_INTR_MAP: u5,

          /// [5:31] 
          res0: u27,

        }), @ptrFromInt(0x600100b8));

        /// register description
        pub const CAN1_INTR_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:4] Need add description
          CAN1_INTR_MAP: u5,

          /// [5:31] 
          res0: u27,

        }), @ptrFromInt(0x600100bc));

        /// register description
        pub const USB_INTR_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:4] Need add description
          USB_INTR_MAP: u5,

          /// [5:31] 
          res0: u27,

        }), @ptrFromInt(0x600100c0));

        /// register description
        pub const RMT_INTR_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:4] Need add description
          RMT_INTR_MAP: u5,

          /// [5:31] 
          res0: u27,

        }), @ptrFromInt(0x600100c4));

        /// register description
        pub const I2C_EXT0_INTR_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:4] Need add description
          I2C_EXT0_INTR_MAP: u5,

          /// [5:31] 
          res0: u27,

        }), @ptrFromInt(0x600100c8));

        /// register description
        pub const TG0_T0_INTR_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:4] Need add description
          TG0_T0_INTR_MAP: u5,

          /// [5:31] 
          res0: u27,

        }), @ptrFromInt(0x600100cc));

        /// register description
        pub const TG0_T1_INTR_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:4] Need add description
          TG0_T1_INTR_MAP: u5,

          /// [5:31] 
          res0: u27,

        }), @ptrFromInt(0x600100d0));

        /// register description
        pub const TG0_WDT_INTR_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:4] Need add description
          TG0_WDT_INTR_MAP: u5,

          /// [5:31] 
          res0: u27,

        }), @ptrFromInt(0x600100d4));

        /// register description
        pub const TG1_T0_INTR_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:4] Need add description
          TG1_T0_INTR_MAP: u5,

          /// [5:31] 
          res0: u27,

        }), @ptrFromInt(0x600100d8));

        /// register description
        pub const TG1_T1_INTR_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:4] Need add description
          TG1_T1_INTR_MAP: u5,

          /// [5:31] 
          res0: u27,

        }), @ptrFromInt(0x600100dc));

        /// register description
        pub const TG1_WDT_INTR_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:4] Need add description
          TG1_WDT_INTR_MAP: u5,

          /// [5:31] 
          res0: u27,

        }), @ptrFromInt(0x600100e0));

        /// register description
        pub const SYSTIMER_TARGET0_INTR_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:4] Need add description
          SYSTIMER_TARGET0_INTR_MAP: u5,

          /// [5:31] 
          res0: u27,

        }), @ptrFromInt(0x600100e4));

        /// register description
        pub const SYSTIMER_TARGET1_INTR_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:4] Need add description
          SYSTIMER_TARGET1_INTR_MAP: u5,

          /// [5:31] 
          res0: u27,

        }), @ptrFromInt(0x600100e8));

        /// register description
        pub const SYSTIMER_TARGET2_INTR_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:4] Need add description
          SYSTIMER_TARGET2_INTR_MAP: u5,

          /// [5:31] 
          res0: u27,

        }), @ptrFromInt(0x600100ec));

        /// register description
        pub const APB_ADC_INTR_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:4] Need add description
          APB_ADC_INTR_MAP: u5,

          /// [5:31] 
          res0: u27,

        }), @ptrFromInt(0x600100f0));

        /// register description
        pub const PWM_INTR_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:4] Need add description
          PWM_INTR_MAP: u5,

          /// [5:31] 
          res0: u27,

        }), @ptrFromInt(0x600100f4));

        /// register description
        pub const PCNT_INTR_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:4] Need add description
          PCNT_INTR_MAP: u5,

          /// [5:31] 
          res0: u27,

        }), @ptrFromInt(0x600100f8));

        /// register description
        pub const PARL_IO_INTR_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:4] Need add description
          PARL_IO_INTR_MAP: u5,

          /// [5:31] 
          res0: u27,

        }), @ptrFromInt(0x600100fc));

        /// register description
        pub const SLC0_INTR_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:4] Need add description
          SLC0_INTR_MAP: u5,

          /// [5:31] 
          res0: u27,

        }), @ptrFromInt(0x60010100));

        /// register description
        pub const SLC1_INTR_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:4] Need add description
          SLC1_INTR_MAP: u5,

          /// [5:31] 
          res0: u27,

        }), @ptrFromInt(0x60010104));

        /// register description
        pub const DMA_IN_CH0_INTR_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:4] Need add description
          DMA_IN_CH0_INTR_MAP: u5,

          /// [5:31] 
          res0: u27,

        }), @ptrFromInt(0x60010108));

        /// register description
        pub const DMA_IN_CH1_INTR_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:4] Need add description
          DMA_IN_CH1_INTR_MAP: u5,

          /// [5:31] 
          res0: u27,

        }), @ptrFromInt(0x6001010c));

        /// register description
        pub const DMA_IN_CH2_INTR_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:4] Need add description
          DMA_IN_CH2_INTR_MAP: u5,

          /// [5:31] 
          res0: u27,

        }), @ptrFromInt(0x60010110));

        /// register description
        pub const DMA_OUT_CH0_INTR_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:4] Need add description
          DMA_OUT_CH0_INTR_MAP: u5,

          /// [5:31] 
          res0: u27,

        }), @ptrFromInt(0x60010114));

        /// register description
        pub const DMA_OUT_CH1_INTR_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:4] Need add description
          DMA_OUT_CH1_INTR_MAP: u5,

          /// [5:31] 
          res0: u27,

        }), @ptrFromInt(0x60010118));

        /// register description
        pub const DMA_OUT_CH2_INTR_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:4] Need add description
          DMA_OUT_CH2_INTR_MAP: u5,

          /// [5:31] 
          res0: u27,

        }), @ptrFromInt(0x6001011c));

        /// register description
        pub const GPSPI2_INTR_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:4] Need add description
          GPSPI2_INTR_MAP: u5,

          /// [5:31] 
          res0: u27,

        }), @ptrFromInt(0x60010120));

        /// register description
        pub const AES_INTR_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:4] Need add description
          AES_INTR_MAP: u5,

          /// [5:31] 
          res0: u27,

        }), @ptrFromInt(0x60010124));

        /// register description
        pub const SHA_INTR_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:4] Need add description
          SHA_INTR_MAP: u5,

          /// [5:31] 
          res0: u27,

        }), @ptrFromInt(0x60010128));

        /// register description
        pub const RSA_INTR_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:4] Need add description
          RSA_INTR_MAP: u5,

          /// [5:31] 
          res0: u27,

        }), @ptrFromInt(0x6001012c));

        /// register description
        pub const ECC_INTR_MAP = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:4] Need add description
          ECC_INTR_MAP: u5,

          /// [5:31] 
          res0: u27,

        }), @ptrFromInt(0x60010130));

        /// register description
        pub const INTR_STATUS_REG_0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Need add description
          INTR_STATUS_0: u32,

        }), @ptrFromInt(0x60010134));

        /// register description
        pub const INTR_STATUS_REG_1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Need add description
          INTR_STATUS_1: u32,

        }), @ptrFromInt(0x60010138));

        /// register description
        pub const INT_STATUS_REG_2 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Need add description
          INT_STATUS_2: u32,

        }), @ptrFromInt(0x6001013c));

        /// register description
        pub const CLOCK_GATE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Need add description
          REG_CLK_EN: u1,

          /// [1:31] 
          res0: u31,

        }), @ptrFromInt(0x60010140));

        /// register description
        pub const INTERRUPT_REG_DATE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:27] Need add description
          INTERRUPT_REG_DATE: u28,

          /// [28:31] 
          res0: u4,

        }), @ptrFromInt(0x600107fc));

      };

      /// INTPRI Peripheral
      pub const INTPRI = struct {

        /// register description
        pub const CPU_INT_ENABLE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Need add description
          CPU_INT_ENABLE: u32,

        }), @ptrFromInt(0x600c5000));

        /// register description
        pub const CPU_INT_TYPE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Need add description
          CPU_INT_TYPE: u32,

        }), @ptrFromInt(0x600c5004));

        /// register description
        pub const CPU_INT_EIP_STATUS = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Need add description
          CPU_INT_EIP_STATUS: u32,

        }), @ptrFromInt(0x600c5008));

        /// register description
        pub const CPU_INT_PRI_0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:3] Need add description
          CPU_PRI_0_MAP: u4,

          /// [4:31] 
          res0: u28,

        }), @ptrFromInt(0x600c500c));

        /// register description
        pub const CPU_INT_PRI_1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:3] Need add description
          CPU_PRI_1_MAP: u4,

          /// [4:31] 
          res0: u28,

        }), @ptrFromInt(0x600c5010));

        /// register description
        pub const CPU_INT_PRI_2 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:3] Need add description
          CPU_PRI_2_MAP: u4,

          /// [4:31] 
          res0: u28,

        }), @ptrFromInt(0x600c5014));

        /// register description
        pub const CPU_INT_PRI_3 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:3] Need add description
          CPU_PRI_3_MAP: u4,

          /// [4:31] 
          res0: u28,

        }), @ptrFromInt(0x600c5018));

        /// register description
        pub const CPU_INT_PRI_4 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:3] Need add description
          CPU_PRI_4_MAP: u4,

          /// [4:31] 
          res0: u28,

        }), @ptrFromInt(0x600c501c));

        /// register description
        pub const CPU_INT_PRI_5 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:3] Need add description
          CPU_PRI_5_MAP: u4,

          /// [4:31] 
          res0: u28,

        }), @ptrFromInt(0x600c5020));

        /// register description
        pub const CPU_INT_PRI_6 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:3] Need add description
          CPU_PRI_6_MAP: u4,

          /// [4:31] 
          res0: u28,

        }), @ptrFromInt(0x600c5024));

        /// register description
        pub const CPU_INT_PRI_7 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:3] Need add description
          CPU_PRI_7_MAP: u4,

          /// [4:31] 
          res0: u28,

        }), @ptrFromInt(0x600c5028));

        /// register description
        pub const CPU_INT_PRI_8 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:3] Need add description
          CPU_PRI_8_MAP: u4,

          /// [4:31] 
          res0: u28,

        }), @ptrFromInt(0x600c502c));

        /// register description
        pub const CPU_INT_PRI_9 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:3] Need add description
          CPU_PRI_9_MAP: u4,

          /// [4:31] 
          res0: u28,

        }), @ptrFromInt(0x600c5030));

        /// register description
        pub const CPU_INT_PRI_10 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:3] Need add description
          CPU_PRI_10_MAP: u4,

          /// [4:31] 
          res0: u28,

        }), @ptrFromInt(0x600c5034));

        /// register description
        pub const CPU_INT_PRI_11 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:3] Need add description
          CPU_PRI_11_MAP: u4,

          /// [4:31] 
          res0: u28,

        }), @ptrFromInt(0x600c5038));

        /// register description
        pub const CPU_INT_PRI_12 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:3] Need add description
          CPU_PRI_12_MAP: u4,

          /// [4:31] 
          res0: u28,

        }), @ptrFromInt(0x600c503c));

        /// register description
        pub const CPU_INT_PRI_13 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:3] Need add description
          CPU_PRI_13_MAP: u4,

          /// [4:31] 
          res0: u28,

        }), @ptrFromInt(0x600c5040));

        /// register description
        pub const CPU_INT_PRI_14 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:3] Need add description
          CPU_PRI_14_MAP: u4,

          /// [4:31] 
          res0: u28,

        }), @ptrFromInt(0x600c5044));

        /// register description
        pub const CPU_INT_PRI_15 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:3] Need add description
          CPU_PRI_15_MAP: u4,

          /// [4:31] 
          res0: u28,

        }), @ptrFromInt(0x600c5048));

        /// register description
        pub const CPU_INT_PRI_16 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:3] Need add description
          CPU_PRI_16_MAP: u4,

          /// [4:31] 
          res0: u28,

        }), @ptrFromInt(0x600c504c));

        /// register description
        pub const CPU_INT_PRI_17 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:3] Need add description
          CPU_PRI_17_MAP: u4,

          /// [4:31] 
          res0: u28,

        }), @ptrFromInt(0x600c5050));

        /// register description
        pub const CPU_INT_PRI_18 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:3] Need add description
          CPU_PRI_18_MAP: u4,

          /// [4:31] 
          res0: u28,

        }), @ptrFromInt(0x600c5054));

        /// register description
        pub const CPU_INT_PRI_19 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:3] Need add description
          CPU_PRI_19_MAP: u4,

          /// [4:31] 
          res0: u28,

        }), @ptrFromInt(0x600c5058));

        /// register description
        pub const CPU_INT_PRI_20 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:3] Need add description
          CPU_PRI_20_MAP: u4,

          /// [4:31] 
          res0: u28,

        }), @ptrFromInt(0x600c505c));

        /// register description
        pub const CPU_INT_PRI_21 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:3] Need add description
          CPU_PRI_21_MAP: u4,

          /// [4:31] 
          res0: u28,

        }), @ptrFromInt(0x600c5060));

        /// register description
        pub const CPU_INT_PRI_22 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:3] Need add description
          CPU_PRI_22_MAP: u4,

          /// [4:31] 
          res0: u28,

        }), @ptrFromInt(0x600c5064));

        /// register description
        pub const CPU_INT_PRI_23 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:3] Need add description
          CPU_PRI_23_MAP: u4,

          /// [4:31] 
          res0: u28,

        }), @ptrFromInt(0x600c5068));

        /// register description
        pub const CPU_INT_PRI_24 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:3] Need add description
          CPU_PRI_24_MAP: u4,

          /// [4:31] 
          res0: u28,

        }), @ptrFromInt(0x600c506c));

        /// register description
        pub const CPU_INT_PRI_25 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:3] Need add description
          CPU_PRI_25_MAP: u4,

          /// [4:31] 
          res0: u28,

        }), @ptrFromInt(0x600c5070));

        /// register description
        pub const CPU_INT_PRI_26 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:3] Need add description
          CPU_PRI_26_MAP: u4,

          /// [4:31] 
          res0: u28,

        }), @ptrFromInt(0x600c5074));

        /// register description
        pub const CPU_INT_PRI_27 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:3] Need add description
          CPU_PRI_27_MAP: u4,

          /// [4:31] 
          res0: u28,

        }), @ptrFromInt(0x600c5078));

        /// register description
        pub const CPU_INT_PRI_28 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:3] Need add description
          CPU_PRI_28_MAP: u4,

          /// [4:31] 
          res0: u28,

        }), @ptrFromInt(0x600c507c));

        /// register description
        pub const CPU_INT_PRI_29 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:3] Need add description
          CPU_PRI_29_MAP: u4,

          /// [4:31] 
          res0: u28,

        }), @ptrFromInt(0x600c5080));

        /// register description
        pub const CPU_INT_PRI_30 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:3] Need add description
          CPU_PRI_30_MAP: u4,

          /// [4:31] 
          res0: u28,

        }), @ptrFromInt(0x600c5084));

        /// register description
        pub const CPU_INT_PRI_31 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:3] Need add description
          CPU_PRI_31_MAP: u4,

          /// [4:31] 
          res0: u28,

        }), @ptrFromInt(0x600c5088));

        /// register description
        pub const CPU_INT_THRESH = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] Need add description
          CPU_INT_THRESH: u8,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x600c508c));

        /// register description
        pub const CPU_INTR_FROM_CPU_0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Need add description
          CPU_INTR_FROM_CPU_0: u1,

          /// [1:31] 
          res0: u31,

        }), @ptrFromInt(0x600c5090));

        /// register description
        pub const CPU_INTR_FROM_CPU_1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Need add description
          CPU_INTR_FROM_CPU_1: u1,

          /// [1:31] 
          res0: u31,

        }), @ptrFromInt(0x600c5094));

        /// register description
        pub const CPU_INTR_FROM_CPU_2 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Need add description
          CPU_INTR_FROM_CPU_2: u1,

          /// [1:31] 
          res0: u31,

        }), @ptrFromInt(0x600c5098));

        /// register description
        pub const CPU_INTR_FROM_CPU_3 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Need add description
          CPU_INTR_FROM_CPU_3: u1,

          /// [1:31] 
          res0: u31,

        }), @ptrFromInt(0x600c509c));

        /// register description
        pub const DATE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:27] Need add description
          DATE: u28,

          /// [28:31] 
          res0: u4,

        }), @ptrFromInt(0x600c50a0));

        /// register description
        pub const CLOCK_GATE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Need add description
          CLK_EN: u1,

          /// [1:31] 
          res0: u31,

        }), @ptrFromInt(0x600c50a4));

        /// register description
        pub const CPU_INT_CLEAR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Need add description
          CPU_INT_CLEAR: u32,

        }), @ptrFromInt(0x600c50a8));

        /// redcy eco register.
        pub const RND_ECO = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Only reserved for ECO.
          REDCY_ENA: u1,

          /// [1:1] Only reserved for ECO.
          REDCY_RESULT: u1,

          /// [2:31] 
          res0: u30,

        }), @ptrFromInt(0x600c50ac));

        /// redcy eco low register.
        pub const RND_ECO_LOW = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Only reserved for ECO.
          REDCY_LOW: u32,

        }), @ptrFromInt(0x600c50b0));

        /// redcy eco high register.
        pub const RND_ECO_HIGH = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Only reserved for ECO.
          REDCY_HIGH: u32,

        }), @ptrFromInt(0x600c53fc));

      };

      /// Input/Output Multiplexer
      pub const IO_MUX = struct {

        /// Clock Output Configuration Register
        pub const PIN_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:4] If you want to output clock for I2S to CLK_OUT_out1, set this register to 0x0. CLK_OUT_out1 can be found in peripheral output signals.
          CLK_OUT1: u5,

          /// [5:9] If you want to output clock for I2S to CLK_OUT_out2, set this register to 0x0. CLK_OUT_out2 can be found in peripheral output signals.
          CLK_OUT2: u5,

          /// [10:14] If you want to output clock for I2S to CLK_OUT_out3, set this register to 0x0. CLK_OUT_out3 can be found in peripheral output signals.
          CLK_OUT3: u5,

          /// [15:31] 
          res0: u17,

        }), @ptrFromInt(0x60090000));

        /// IO MUX Configure Register for pad XTAL_32K_P
        pub const GPIO0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Output enable of the pad in sleep mode. 1: output enabled. 0: output disabled.
          MCU_OE: u1,

          /// [1:1] Sleep mode selection of this pad. Set to 1 to put the pad in pad mode.
          SLP_SEL: u1,

          /// [2:2] Pull-down enable of the pad in sleep mode. 1: internal pull-down enabled. 0: internal pull-down disabled.
          MCU_WPD: u1,

          /// [3:3] Pull-up enable of the pad during sleep mode. 1: internal pull-up enabled. 0: internal pull-up disabled.
          MCU_WPU: u1,

          /// [4:4] Input enable of the pad during sleep mode. 1: input enabled. 0: input disabled.
          MCU_IE: u1,

          /// [5:6] Select the drive strength of the pad during sleep mode. 0: ~5 mA. 1: ~10mA. 2: ~20mA. 3: ~40mA.
          MCU_DRV: u2,

          /// [7:7] Pull-down enable of the pad. 1: internal pull-down enabled. 0: internal pull-down disabled.
          FUN_WPD: u1,

          /// [8:8] Pull-up enable of the pad. 1: internal pull-up enabled. 0: internal pull-up disabled.
          FUN_WPU: u1,

          /// [9:9] Input enable of the pad. 1: input enabled. 0: input disabled.
          FUN_IE: u1,

          /// [10:11] Select the drive strength of the pad. 0: ~5 mA. 1: ~10mA. 2: ~20mA. 3: ~40mA.
          FUN_DRV: u2,

          /// [12:14] Select IO MUX function for this signal. 0: Select Function 1. 1: Select Function 2. etc.
          MCU_SEL: u3,

          /// [15:15] Enable filter for pin input signals. 1: Filter enabled. 0: Filter disabled.
          FILTER_EN: u1,

          /// [16:31] 
          res0: u16,

        }), @ptrFromInt(0x60090004));

        /// IO MUX Configure Register for pad XTAL_32K_P
        pub const GPIO1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Output enable of the pad in sleep mode. 1: output enabled. 0: output disabled.
          MCU_OE: u1,

          /// [1:1] Sleep mode selection of this pad. Set to 1 to put the pad in pad mode.
          SLP_SEL: u1,

          /// [2:2] Pull-down enable of the pad in sleep mode. 1: internal pull-down enabled. 0: internal pull-down disabled.
          MCU_WPD: u1,

          /// [3:3] Pull-up enable of the pad during sleep mode. 1: internal pull-up enabled. 0: internal pull-up disabled.
          MCU_WPU: u1,

          /// [4:4] Input enable of the pad during sleep mode. 1: input enabled. 0: input disabled.
          MCU_IE: u1,

          /// [5:6] Select the drive strength of the pad during sleep mode. 0: ~5 mA. 1: ~10mA. 2: ~20mA. 3: ~40mA.
          MCU_DRV: u2,

          /// [7:7] Pull-down enable of the pad. 1: internal pull-down enabled. 0: internal pull-down disabled.
          FUN_WPD: u1,

          /// [8:8] Pull-up enable of the pad. 1: internal pull-up enabled. 0: internal pull-up disabled.
          FUN_WPU: u1,

          /// [9:9] Input enable of the pad. 1: input enabled. 0: input disabled.
          FUN_IE: u1,

          /// [10:11] Select the drive strength of the pad. 0: ~5 mA. 1: ~10mA. 2: ~20mA. 3: ~40mA.
          FUN_DRV: u2,

          /// [12:14] Select IO MUX function for this signal. 0: Select Function 1. 1: Select Function 2. etc.
          MCU_SEL: u3,

          /// [15:15] Enable filter for pin input signals. 1: Filter enabled. 0: Filter disabled.
          FILTER_EN: u1,

          /// [16:31] 
          res0: u16,

        }), @ptrFromInt(0x60090008));

        /// IO MUX Configure Register for pad XTAL_32K_P
        pub const GPIO2 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Output enable of the pad in sleep mode. 1: output enabled. 0: output disabled.
          MCU_OE: u1,

          /// [1:1] Sleep mode selection of this pad. Set to 1 to put the pad in pad mode.
          SLP_SEL: u1,

          /// [2:2] Pull-down enable of the pad in sleep mode. 1: internal pull-down enabled. 0: internal pull-down disabled.
          MCU_WPD: u1,

          /// [3:3] Pull-up enable of the pad during sleep mode. 1: internal pull-up enabled. 0: internal pull-up disabled.
          MCU_WPU: u1,

          /// [4:4] Input enable of the pad during sleep mode. 1: input enabled. 0: input disabled.
          MCU_IE: u1,

          /// [5:6] Select the drive strength of the pad during sleep mode. 0: ~5 mA. 1: ~10mA. 2: ~20mA. 3: ~40mA.
          MCU_DRV: u2,

          /// [7:7] Pull-down enable of the pad. 1: internal pull-down enabled. 0: internal pull-down disabled.
          FUN_WPD: u1,

          /// [8:8] Pull-up enable of the pad. 1: internal pull-up enabled. 0: internal pull-up disabled.
          FUN_WPU: u1,

          /// [9:9] Input enable of the pad. 1: input enabled. 0: input disabled.
          FUN_IE: u1,

          /// [10:11] Select the drive strength of the pad. 0: ~5 mA. 1: ~10mA. 2: ~20mA. 3: ~40mA.
          FUN_DRV: u2,

          /// [12:14] Select IO MUX function for this signal. 0: Select Function 1. 1: Select Function 2. etc.
          MCU_SEL: u3,

          /// [15:15] Enable filter for pin input signals. 1: Filter enabled. 0: Filter disabled.
          FILTER_EN: u1,

          /// [16:31] 
          res0: u16,

        }), @ptrFromInt(0x6009000c));

        /// IO MUX Configure Register for pad XTAL_32K_P
        pub const GPIO3 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Output enable of the pad in sleep mode. 1: output enabled. 0: output disabled.
          MCU_OE: u1,

          /// [1:1] Sleep mode selection of this pad. Set to 1 to put the pad in pad mode.
          SLP_SEL: u1,

          /// [2:2] Pull-down enable of the pad in sleep mode. 1: internal pull-down enabled. 0: internal pull-down disabled.
          MCU_WPD: u1,

          /// [3:3] Pull-up enable of the pad during sleep mode. 1: internal pull-up enabled. 0: internal pull-up disabled.
          MCU_WPU: u1,

          /// [4:4] Input enable of the pad during sleep mode. 1: input enabled. 0: input disabled.
          MCU_IE: u1,

          /// [5:6] Select the drive strength of the pad during sleep mode. 0: ~5 mA. 1: ~10mA. 2: ~20mA. 3: ~40mA.
          MCU_DRV: u2,

          /// [7:7] Pull-down enable of the pad. 1: internal pull-down enabled. 0: internal pull-down disabled.
          FUN_WPD: u1,

          /// [8:8] Pull-up enable of the pad. 1: internal pull-up enabled. 0: internal pull-up disabled.
          FUN_WPU: u1,

          /// [9:9] Input enable of the pad. 1: input enabled. 0: input disabled.
          FUN_IE: u1,

          /// [10:11] Select the drive strength of the pad. 0: ~5 mA. 1: ~10mA. 2: ~20mA. 3: ~40mA.
          FUN_DRV: u2,

          /// [12:14] Select IO MUX function for this signal. 0: Select Function 1. 1: Select Function 2. etc.
          MCU_SEL: u3,

          /// [15:15] Enable filter for pin input signals. 1: Filter enabled. 0: Filter disabled.
          FILTER_EN: u1,

          /// [16:31] 
          res0: u16,

        }), @ptrFromInt(0x60090010));

        /// IO MUX Configure Register for pad XTAL_32K_P
        pub const GPIO4 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Output enable of the pad in sleep mode. 1: output enabled. 0: output disabled.
          MCU_OE: u1,

          /// [1:1] Sleep mode selection of this pad. Set to 1 to put the pad in pad mode.
          SLP_SEL: u1,

          /// [2:2] Pull-down enable of the pad in sleep mode. 1: internal pull-down enabled. 0: internal pull-down disabled.
          MCU_WPD: u1,

          /// [3:3] Pull-up enable of the pad during sleep mode. 1: internal pull-up enabled. 0: internal pull-up disabled.
          MCU_WPU: u1,

          /// [4:4] Input enable of the pad during sleep mode. 1: input enabled. 0: input disabled.
          MCU_IE: u1,

          /// [5:6] Select the drive strength of the pad during sleep mode. 0: ~5 mA. 1: ~10mA. 2: ~20mA. 3: ~40mA.
          MCU_DRV: u2,

          /// [7:7] Pull-down enable of the pad. 1: internal pull-down enabled. 0: internal pull-down disabled.
          FUN_WPD: u1,

          /// [8:8] Pull-up enable of the pad. 1: internal pull-up enabled. 0: internal pull-up disabled.
          FUN_WPU: u1,

          /// [9:9] Input enable of the pad. 1: input enabled. 0: input disabled.
          FUN_IE: u1,

          /// [10:11] Select the drive strength of the pad. 0: ~5 mA. 1: ~10mA. 2: ~20mA. 3: ~40mA.
          FUN_DRV: u2,

          /// [12:14] Select IO MUX function for this signal. 0: Select Function 1. 1: Select Function 2. etc.
          MCU_SEL: u3,

          /// [15:15] Enable filter for pin input signals. 1: Filter enabled. 0: Filter disabled.
          FILTER_EN: u1,

          /// [16:31] 
          res0: u16,

        }), @ptrFromInt(0x60090014));

        /// IO MUX Configure Register for pad XTAL_32K_P
        pub const GPIO5 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Output enable of the pad in sleep mode. 1: output enabled. 0: output disabled.
          MCU_OE: u1,

          /// [1:1] Sleep mode selection of this pad. Set to 1 to put the pad in pad mode.
          SLP_SEL: u1,

          /// [2:2] Pull-down enable of the pad in sleep mode. 1: internal pull-down enabled. 0: internal pull-down disabled.
          MCU_WPD: u1,

          /// [3:3] Pull-up enable of the pad during sleep mode. 1: internal pull-up enabled. 0: internal pull-up disabled.
          MCU_WPU: u1,

          /// [4:4] Input enable of the pad during sleep mode. 1: input enabled. 0: input disabled.
          MCU_IE: u1,

          /// [5:6] Select the drive strength of the pad during sleep mode. 0: ~5 mA. 1: ~10mA. 2: ~20mA. 3: ~40mA.
          MCU_DRV: u2,

          /// [7:7] Pull-down enable of the pad. 1: internal pull-down enabled. 0: internal pull-down disabled.
          FUN_WPD: u1,

          /// [8:8] Pull-up enable of the pad. 1: internal pull-up enabled. 0: internal pull-up disabled.
          FUN_WPU: u1,

          /// [9:9] Input enable of the pad. 1: input enabled. 0: input disabled.
          FUN_IE: u1,

          /// [10:11] Select the drive strength of the pad. 0: ~5 mA. 1: ~10mA. 2: ~20mA. 3: ~40mA.
          FUN_DRV: u2,

          /// [12:14] Select IO MUX function for this signal. 0: Select Function 1. 1: Select Function 2. etc.
          MCU_SEL: u3,

          /// [15:15] Enable filter for pin input signals. 1: Filter enabled. 0: Filter disabled.
          FILTER_EN: u1,

          /// [16:31] 
          res0: u16,

        }), @ptrFromInt(0x60090018));

        /// IO MUX Configure Register for pad XTAL_32K_P
        pub const GPIO6 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Output enable of the pad in sleep mode. 1: output enabled. 0: output disabled.
          MCU_OE: u1,

          /// [1:1] Sleep mode selection of this pad. Set to 1 to put the pad in pad mode.
          SLP_SEL: u1,

          /// [2:2] Pull-down enable of the pad in sleep mode. 1: internal pull-down enabled. 0: internal pull-down disabled.
          MCU_WPD: u1,

          /// [3:3] Pull-up enable of the pad during sleep mode. 1: internal pull-up enabled. 0: internal pull-up disabled.
          MCU_WPU: u1,

          /// [4:4] Input enable of the pad during sleep mode. 1: input enabled. 0: input disabled.
          MCU_IE: u1,

          /// [5:6] Select the drive strength of the pad during sleep mode. 0: ~5 mA. 1: ~10mA. 2: ~20mA. 3: ~40mA.
          MCU_DRV: u2,

          /// [7:7] Pull-down enable of the pad. 1: internal pull-down enabled. 0: internal pull-down disabled.
          FUN_WPD: u1,

          /// [8:8] Pull-up enable of the pad. 1: internal pull-up enabled. 0: internal pull-up disabled.
          FUN_WPU: u1,

          /// [9:9] Input enable of the pad. 1: input enabled. 0: input disabled.
          FUN_IE: u1,

          /// [10:11] Select the drive strength of the pad. 0: ~5 mA. 1: ~10mA. 2: ~20mA. 3: ~40mA.
          FUN_DRV: u2,

          /// [12:14] Select IO MUX function for this signal. 0: Select Function 1. 1: Select Function 2. etc.
          MCU_SEL: u3,

          /// [15:15] Enable filter for pin input signals. 1: Filter enabled. 0: Filter disabled.
          FILTER_EN: u1,

          /// [16:31] 
          res0: u16,

        }), @ptrFromInt(0x6009001c));

        /// IO MUX Configure Register for pad XTAL_32K_P
        pub const GPIO7 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Output enable of the pad in sleep mode. 1: output enabled. 0: output disabled.
          MCU_OE: u1,

          /// [1:1] Sleep mode selection of this pad. Set to 1 to put the pad in pad mode.
          SLP_SEL: u1,

          /// [2:2] Pull-down enable of the pad in sleep mode. 1: internal pull-down enabled. 0: internal pull-down disabled.
          MCU_WPD: u1,

          /// [3:3] Pull-up enable of the pad during sleep mode. 1: internal pull-up enabled. 0: internal pull-up disabled.
          MCU_WPU: u1,

          /// [4:4] Input enable of the pad during sleep mode. 1: input enabled. 0: input disabled.
          MCU_IE: u1,

          /// [5:6] Select the drive strength of the pad during sleep mode. 0: ~5 mA. 1: ~10mA. 2: ~20mA. 3: ~40mA.
          MCU_DRV: u2,

          /// [7:7] Pull-down enable of the pad. 1: internal pull-down enabled. 0: internal pull-down disabled.
          FUN_WPD: u1,

          /// [8:8] Pull-up enable of the pad. 1: internal pull-up enabled. 0: internal pull-up disabled.
          FUN_WPU: u1,

          /// [9:9] Input enable of the pad. 1: input enabled. 0: input disabled.
          FUN_IE: u1,

          /// [10:11] Select the drive strength of the pad. 0: ~5 mA. 1: ~10mA. 2: ~20mA. 3: ~40mA.
          FUN_DRV: u2,

          /// [12:14] Select IO MUX function for this signal. 0: Select Function 1. 1: Select Function 2. etc.
          MCU_SEL: u3,

          /// [15:15] Enable filter for pin input signals. 1: Filter enabled. 0: Filter disabled.
          FILTER_EN: u1,

          /// [16:31] 
          res0: u16,

        }), @ptrFromInt(0x60090020));

        /// IO MUX Configure Register for pad XTAL_32K_P
        pub const GPIO8 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Output enable of the pad in sleep mode. 1: output enabled. 0: output disabled.
          MCU_OE: u1,

          /// [1:1] Sleep mode selection of this pad. Set to 1 to put the pad in pad mode.
          SLP_SEL: u1,

          /// [2:2] Pull-down enable of the pad in sleep mode. 1: internal pull-down enabled. 0: internal pull-down disabled.
          MCU_WPD: u1,

          /// [3:3] Pull-up enable of the pad during sleep mode. 1: internal pull-up enabled. 0: internal pull-up disabled.
          MCU_WPU: u1,

          /// [4:4] Input enable of the pad during sleep mode. 1: input enabled. 0: input disabled.
          MCU_IE: u1,

          /// [5:6] Select the drive strength of the pad during sleep mode. 0: ~5 mA. 1: ~10mA. 2: ~20mA. 3: ~40mA.
          MCU_DRV: u2,

          /// [7:7] Pull-down enable of the pad. 1: internal pull-down enabled. 0: internal pull-down disabled.
          FUN_WPD: u1,

          /// [8:8] Pull-up enable of the pad. 1: internal pull-up enabled. 0: internal pull-up disabled.
          FUN_WPU: u1,

          /// [9:9] Input enable of the pad. 1: input enabled. 0: input disabled.
          FUN_IE: u1,

          /// [10:11] Select the drive strength of the pad. 0: ~5 mA. 1: ~10mA. 2: ~20mA. 3: ~40mA.
          FUN_DRV: u2,

          /// [12:14] Select IO MUX function for this signal. 0: Select Function 1. 1: Select Function 2. etc.
          MCU_SEL: u3,

          /// [15:15] Enable filter for pin input signals. 1: Filter enabled. 0: Filter disabled.
          FILTER_EN: u1,

          /// [16:31] 
          res0: u16,

        }), @ptrFromInt(0x60090024));

        /// IO MUX Configure Register for pad XTAL_32K_P
        pub const GPIO9 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Output enable of the pad in sleep mode. 1: output enabled. 0: output disabled.
          MCU_OE: u1,

          /// [1:1] Sleep mode selection of this pad. Set to 1 to put the pad in pad mode.
          SLP_SEL: u1,

          /// [2:2] Pull-down enable of the pad in sleep mode. 1: internal pull-down enabled. 0: internal pull-down disabled.
          MCU_WPD: u1,

          /// [3:3] Pull-up enable of the pad during sleep mode. 1: internal pull-up enabled. 0: internal pull-up disabled.
          MCU_WPU: u1,

          /// [4:4] Input enable of the pad during sleep mode. 1: input enabled. 0: input disabled.
          MCU_IE: u1,

          /// [5:6] Select the drive strength of the pad during sleep mode. 0: ~5 mA. 1: ~10mA. 2: ~20mA. 3: ~40mA.
          MCU_DRV: u2,

          /// [7:7] Pull-down enable of the pad. 1: internal pull-down enabled. 0: internal pull-down disabled.
          FUN_WPD: u1,

          /// [8:8] Pull-up enable of the pad. 1: internal pull-up enabled. 0: internal pull-up disabled.
          FUN_WPU: u1,

          /// [9:9] Input enable of the pad. 1: input enabled. 0: input disabled.
          FUN_IE: u1,

          /// [10:11] Select the drive strength of the pad. 0: ~5 mA. 1: ~10mA. 2: ~20mA. 3: ~40mA.
          FUN_DRV: u2,

          /// [12:14] Select IO MUX function for this signal. 0: Select Function 1. 1: Select Function 2. etc.
          MCU_SEL: u3,

          /// [15:15] Enable filter for pin input signals. 1: Filter enabled. 0: Filter disabled.
          FILTER_EN: u1,

          /// [16:31] 
          res0: u16,

        }), @ptrFromInt(0x60090028));

        /// IO MUX Configure Register for pad XTAL_32K_P
        pub const GPIO10 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Output enable of the pad in sleep mode. 1: output enabled. 0: output disabled.
          MCU_OE: u1,

          /// [1:1] Sleep mode selection of this pad. Set to 1 to put the pad in pad mode.
          SLP_SEL: u1,

          /// [2:2] Pull-down enable of the pad in sleep mode. 1: internal pull-down enabled. 0: internal pull-down disabled.
          MCU_WPD: u1,

          /// [3:3] Pull-up enable of the pad during sleep mode. 1: internal pull-up enabled. 0: internal pull-up disabled.
          MCU_WPU: u1,

          /// [4:4] Input enable of the pad during sleep mode. 1: input enabled. 0: input disabled.
          MCU_IE: u1,

          /// [5:6] Select the drive strength of the pad during sleep mode. 0: ~5 mA. 1: ~10mA. 2: ~20mA. 3: ~40mA.
          MCU_DRV: u2,

          /// [7:7] Pull-down enable of the pad. 1: internal pull-down enabled. 0: internal pull-down disabled.
          FUN_WPD: u1,

          /// [8:8] Pull-up enable of the pad. 1: internal pull-up enabled. 0: internal pull-up disabled.
          FUN_WPU: u1,

          /// [9:9] Input enable of the pad. 1: input enabled. 0: input disabled.
          FUN_IE: u1,

          /// [10:11] Select the drive strength of the pad. 0: ~5 mA. 1: ~10mA. 2: ~20mA. 3: ~40mA.
          FUN_DRV: u2,

          /// [12:14] Select IO MUX function for this signal. 0: Select Function 1. 1: Select Function 2. etc.
          MCU_SEL: u3,

          /// [15:15] Enable filter for pin input signals. 1: Filter enabled. 0: Filter disabled.
          FILTER_EN: u1,

          /// [16:31] 
          res0: u16,

        }), @ptrFromInt(0x6009002c));

        /// IO MUX Configure Register for pad XTAL_32K_P
        pub const GPIO11 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Output enable of the pad in sleep mode. 1: output enabled. 0: output disabled.
          MCU_OE: u1,

          /// [1:1] Sleep mode selection of this pad. Set to 1 to put the pad in pad mode.
          SLP_SEL: u1,

          /// [2:2] Pull-down enable of the pad in sleep mode. 1: internal pull-down enabled. 0: internal pull-down disabled.
          MCU_WPD: u1,

          /// [3:3] Pull-up enable of the pad during sleep mode. 1: internal pull-up enabled. 0: internal pull-up disabled.
          MCU_WPU: u1,

          /// [4:4] Input enable of the pad during sleep mode. 1: input enabled. 0: input disabled.
          MCU_IE: u1,

          /// [5:6] Select the drive strength of the pad during sleep mode. 0: ~5 mA. 1: ~10mA. 2: ~20mA. 3: ~40mA.
          MCU_DRV: u2,

          /// [7:7] Pull-down enable of the pad. 1: internal pull-down enabled. 0: internal pull-down disabled.
          FUN_WPD: u1,

          /// [8:8] Pull-up enable of the pad. 1: internal pull-up enabled. 0: internal pull-up disabled.
          FUN_WPU: u1,

          /// [9:9] Input enable of the pad. 1: input enabled. 0: input disabled.
          FUN_IE: u1,

          /// [10:11] Select the drive strength of the pad. 0: ~5 mA. 1: ~10mA. 2: ~20mA. 3: ~40mA.
          FUN_DRV: u2,

          /// [12:14] Select IO MUX function for this signal. 0: Select Function 1. 1: Select Function 2. etc.
          MCU_SEL: u3,

          /// [15:15] Enable filter for pin input signals. 1: Filter enabled. 0: Filter disabled.
          FILTER_EN: u1,

          /// [16:31] 
          res0: u16,

        }), @ptrFromInt(0x60090030));

        /// IO MUX Configure Register for pad XTAL_32K_P
        pub const GPIO12 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Output enable of the pad in sleep mode. 1: output enabled. 0: output disabled.
          MCU_OE: u1,

          /// [1:1] Sleep mode selection of this pad. Set to 1 to put the pad in pad mode.
          SLP_SEL: u1,

          /// [2:2] Pull-down enable of the pad in sleep mode. 1: internal pull-down enabled. 0: internal pull-down disabled.
          MCU_WPD: u1,

          /// [3:3] Pull-up enable of the pad during sleep mode. 1: internal pull-up enabled. 0: internal pull-up disabled.
          MCU_WPU: u1,

          /// [4:4] Input enable of the pad during sleep mode. 1: input enabled. 0: input disabled.
          MCU_IE: u1,

          /// [5:6] Select the drive strength of the pad during sleep mode. 0: ~5 mA. 1: ~10mA. 2: ~20mA. 3: ~40mA.
          MCU_DRV: u2,

          /// [7:7] Pull-down enable of the pad. 1: internal pull-down enabled. 0: internal pull-down disabled.
          FUN_WPD: u1,

          /// [8:8] Pull-up enable of the pad. 1: internal pull-up enabled. 0: internal pull-up disabled.
          FUN_WPU: u1,

          /// [9:9] Input enable of the pad. 1: input enabled. 0: input disabled.
          FUN_IE: u1,

          /// [10:11] Select the drive strength of the pad. 0: ~5 mA. 1: ~10mA. 2: ~20mA. 3: ~40mA.
          FUN_DRV: u2,

          /// [12:14] Select IO MUX function for this signal. 0: Select Function 1. 1: Select Function 2. etc.
          MCU_SEL: u3,

          /// [15:15] Enable filter for pin input signals. 1: Filter enabled. 0: Filter disabled.
          FILTER_EN: u1,

          /// [16:31] 
          res0: u16,

        }), @ptrFromInt(0x60090034));

        /// IO MUX Configure Register for pad XTAL_32K_P
        pub const GPIO13 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Output enable of the pad in sleep mode. 1: output enabled. 0: output disabled.
          MCU_OE: u1,

          /// [1:1] Sleep mode selection of this pad. Set to 1 to put the pad in pad mode.
          SLP_SEL: u1,

          /// [2:2] Pull-down enable of the pad in sleep mode. 1: internal pull-down enabled. 0: internal pull-down disabled.
          MCU_WPD: u1,

          /// [3:3] Pull-up enable of the pad during sleep mode. 1: internal pull-up enabled. 0: internal pull-up disabled.
          MCU_WPU: u1,

          /// [4:4] Input enable of the pad during sleep mode. 1: input enabled. 0: input disabled.
          MCU_IE: u1,

          /// [5:6] Select the drive strength of the pad during sleep mode. 0: ~5 mA. 1: ~10mA. 2: ~20mA. 3: ~40mA.
          MCU_DRV: u2,

          /// [7:7] Pull-down enable of the pad. 1: internal pull-down enabled. 0: internal pull-down disabled.
          FUN_WPD: u1,

          /// [8:8] Pull-up enable of the pad. 1: internal pull-up enabled. 0: internal pull-up disabled.
          FUN_WPU: u1,

          /// [9:9] Input enable of the pad. 1: input enabled. 0: input disabled.
          FUN_IE: u1,

          /// [10:11] Select the drive strength of the pad. 0: ~5 mA. 1: ~10mA. 2: ~20mA. 3: ~40mA.
          FUN_DRV: u2,

          /// [12:14] Select IO MUX function for this signal. 0: Select Function 1. 1: Select Function 2. etc.
          MCU_SEL: u3,

          /// [15:15] Enable filter for pin input signals. 1: Filter enabled. 0: Filter disabled.
          FILTER_EN: u1,

          /// [16:31] 
          res0: u16,

        }), @ptrFromInt(0x60090038));

        /// IO MUX Configure Register for pad XTAL_32K_P
        pub const GPIO14 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Output enable of the pad in sleep mode. 1: output enabled. 0: output disabled.
          MCU_OE: u1,

          /// [1:1] Sleep mode selection of this pad. Set to 1 to put the pad in pad mode.
          SLP_SEL: u1,

          /// [2:2] Pull-down enable of the pad in sleep mode. 1: internal pull-down enabled. 0: internal pull-down disabled.
          MCU_WPD: u1,

          /// [3:3] Pull-up enable of the pad during sleep mode. 1: internal pull-up enabled. 0: internal pull-up disabled.
          MCU_WPU: u1,

          /// [4:4] Input enable of the pad during sleep mode. 1: input enabled. 0: input disabled.
          MCU_IE: u1,

          /// [5:6] Select the drive strength of the pad during sleep mode. 0: ~5 mA. 1: ~10mA. 2: ~20mA. 3: ~40mA.
          MCU_DRV: u2,

          /// [7:7] Pull-down enable of the pad. 1: internal pull-down enabled. 0: internal pull-down disabled.
          FUN_WPD: u1,

          /// [8:8] Pull-up enable of the pad. 1: internal pull-up enabled. 0: internal pull-up disabled.
          FUN_WPU: u1,

          /// [9:9] Input enable of the pad. 1: input enabled. 0: input disabled.
          FUN_IE: u1,

          /// [10:11] Select the drive strength of the pad. 0: ~5 mA. 1: ~10mA. 2: ~20mA. 3: ~40mA.
          FUN_DRV: u2,

          /// [12:14] Select IO MUX function for this signal. 0: Select Function 1. 1: Select Function 2. etc.
          MCU_SEL: u3,

          /// [15:15] Enable filter for pin input signals. 1: Filter enabled. 0: Filter disabled.
          FILTER_EN: u1,

          /// [16:31] 
          res0: u16,

        }), @ptrFromInt(0x6009003c));

        /// IO MUX Configure Register for pad XTAL_32K_P
        pub const GPIO15 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Output enable of the pad in sleep mode. 1: output enabled. 0: output disabled.
          MCU_OE: u1,

          /// [1:1] Sleep mode selection of this pad. Set to 1 to put the pad in pad mode.
          SLP_SEL: u1,

          /// [2:2] Pull-down enable of the pad in sleep mode. 1: internal pull-down enabled. 0: internal pull-down disabled.
          MCU_WPD: u1,

          /// [3:3] Pull-up enable of the pad during sleep mode. 1: internal pull-up enabled. 0: internal pull-up disabled.
          MCU_WPU: u1,

          /// [4:4] Input enable of the pad during sleep mode. 1: input enabled. 0: input disabled.
          MCU_IE: u1,

          /// [5:6] Select the drive strength of the pad during sleep mode. 0: ~5 mA. 1: ~10mA. 2: ~20mA. 3: ~40mA.
          MCU_DRV: u2,

          /// [7:7] Pull-down enable of the pad. 1: internal pull-down enabled. 0: internal pull-down disabled.
          FUN_WPD: u1,

          /// [8:8] Pull-up enable of the pad. 1: internal pull-up enabled. 0: internal pull-up disabled.
          FUN_WPU: u1,

          /// [9:9] Input enable of the pad. 1: input enabled. 0: input disabled.
          FUN_IE: u1,

          /// [10:11] Select the drive strength of the pad. 0: ~5 mA. 1: ~10mA. 2: ~20mA. 3: ~40mA.
          FUN_DRV: u2,

          /// [12:14] Select IO MUX function for this signal. 0: Select Function 1. 1: Select Function 2. etc.
          MCU_SEL: u3,

          /// [15:15] Enable filter for pin input signals. 1: Filter enabled. 0: Filter disabled.
          FILTER_EN: u1,

          /// [16:31] 
          res0: u16,

        }), @ptrFromInt(0x60090040));

        /// IO MUX Configure Register for pad XTAL_32K_P
        pub const GPIO16 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Output enable of the pad in sleep mode. 1: output enabled. 0: output disabled.
          MCU_OE: u1,

          /// [1:1] Sleep mode selection of this pad. Set to 1 to put the pad in pad mode.
          SLP_SEL: u1,

          /// [2:2] Pull-down enable of the pad in sleep mode. 1: internal pull-down enabled. 0: internal pull-down disabled.
          MCU_WPD: u1,

          /// [3:3] Pull-up enable of the pad during sleep mode. 1: internal pull-up enabled. 0: internal pull-up disabled.
          MCU_WPU: u1,

          /// [4:4] Input enable of the pad during sleep mode. 1: input enabled. 0: input disabled.
          MCU_IE: u1,

          /// [5:6] Select the drive strength of the pad during sleep mode. 0: ~5 mA. 1: ~10mA. 2: ~20mA. 3: ~40mA.
          MCU_DRV: u2,

          /// [7:7] Pull-down enable of the pad. 1: internal pull-down enabled. 0: internal pull-down disabled.
          FUN_WPD: u1,

          /// [8:8] Pull-up enable of the pad. 1: internal pull-up enabled. 0: internal pull-up disabled.
          FUN_WPU: u1,

          /// [9:9] Input enable of the pad. 1: input enabled. 0: input disabled.
          FUN_IE: u1,

          /// [10:11] Select the drive strength of the pad. 0: ~5 mA. 1: ~10mA. 2: ~20mA. 3: ~40mA.
          FUN_DRV: u2,

          /// [12:14] Select IO MUX function for this signal. 0: Select Function 1. 1: Select Function 2. etc.
          MCU_SEL: u3,

          /// [15:15] Enable filter for pin input signals. 1: Filter enabled. 0: Filter disabled.
          FILTER_EN: u1,

          /// [16:31] 
          res0: u16,

        }), @ptrFromInt(0x60090044));

        /// IO MUX Configure Register for pad XTAL_32K_P
        pub const GPIO17 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Output enable of the pad in sleep mode. 1: output enabled. 0: output disabled.
          MCU_OE: u1,

          /// [1:1] Sleep mode selection of this pad. Set to 1 to put the pad in pad mode.
          SLP_SEL: u1,

          /// [2:2] Pull-down enable of the pad in sleep mode. 1: internal pull-down enabled. 0: internal pull-down disabled.
          MCU_WPD: u1,

          /// [3:3] Pull-up enable of the pad during sleep mode. 1: internal pull-up enabled. 0: internal pull-up disabled.
          MCU_WPU: u1,

          /// [4:4] Input enable of the pad during sleep mode. 1: input enabled. 0: input disabled.
          MCU_IE: u1,

          /// [5:6] Select the drive strength of the pad during sleep mode. 0: ~5 mA. 1: ~10mA. 2: ~20mA. 3: ~40mA.
          MCU_DRV: u2,

          /// [7:7] Pull-down enable of the pad. 1: internal pull-down enabled. 0: internal pull-down disabled.
          FUN_WPD: u1,

          /// [8:8] Pull-up enable of the pad. 1: internal pull-up enabled. 0: internal pull-up disabled.
          FUN_WPU: u1,

          /// [9:9] Input enable of the pad. 1: input enabled. 0: input disabled.
          FUN_IE: u1,

          /// [10:11] Select the drive strength of the pad. 0: ~5 mA. 1: ~10mA. 2: ~20mA. 3: ~40mA.
          FUN_DRV: u2,

          /// [12:14] Select IO MUX function for this signal. 0: Select Function 1. 1: Select Function 2. etc.
          MCU_SEL: u3,

          /// [15:15] Enable filter for pin input signals. 1: Filter enabled. 0: Filter disabled.
          FILTER_EN: u1,

          /// [16:31] 
          res0: u16,

        }), @ptrFromInt(0x60090048));

        /// IO MUX Configure Register for pad XTAL_32K_P
        pub const GPIO18 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Output enable of the pad in sleep mode. 1: output enabled. 0: output disabled.
          MCU_OE: u1,

          /// [1:1] Sleep mode selection of this pad. Set to 1 to put the pad in pad mode.
          SLP_SEL: u1,

          /// [2:2] Pull-down enable of the pad in sleep mode. 1: internal pull-down enabled. 0: internal pull-down disabled.
          MCU_WPD: u1,

          /// [3:3] Pull-up enable of the pad during sleep mode. 1: internal pull-up enabled. 0: internal pull-up disabled.
          MCU_WPU: u1,

          /// [4:4] Input enable of the pad during sleep mode. 1: input enabled. 0: input disabled.
          MCU_IE: u1,

          /// [5:6] Select the drive strength of the pad during sleep mode. 0: ~5 mA. 1: ~10mA. 2: ~20mA. 3: ~40mA.
          MCU_DRV: u2,

          /// [7:7] Pull-down enable of the pad. 1: internal pull-down enabled. 0: internal pull-down disabled.
          FUN_WPD: u1,

          /// [8:8] Pull-up enable of the pad. 1: internal pull-up enabled. 0: internal pull-up disabled.
          FUN_WPU: u1,

          /// [9:9] Input enable of the pad. 1: input enabled. 0: input disabled.
          FUN_IE: u1,

          /// [10:11] Select the drive strength of the pad. 0: ~5 mA. 1: ~10mA. 2: ~20mA. 3: ~40mA.
          FUN_DRV: u2,

          /// [12:14] Select IO MUX function for this signal. 0: Select Function 1. 1: Select Function 2. etc.
          MCU_SEL: u3,

          /// [15:15] Enable filter for pin input signals. 1: Filter enabled. 0: Filter disabled.
          FILTER_EN: u1,

          /// [16:31] 
          res0: u16,

        }), @ptrFromInt(0x6009004c));

        /// IO MUX Configure Register for pad XTAL_32K_P
        pub const GPIO19 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Output enable of the pad in sleep mode. 1: output enabled. 0: output disabled.
          MCU_OE: u1,

          /// [1:1] Sleep mode selection of this pad. Set to 1 to put the pad in pad mode.
          SLP_SEL: u1,

          /// [2:2] Pull-down enable of the pad in sleep mode. 1: internal pull-down enabled. 0: internal pull-down disabled.
          MCU_WPD: u1,

          /// [3:3] Pull-up enable of the pad during sleep mode. 1: internal pull-up enabled. 0: internal pull-up disabled.
          MCU_WPU: u1,

          /// [4:4] Input enable of the pad during sleep mode. 1: input enabled. 0: input disabled.
          MCU_IE: u1,

          /// [5:6] Select the drive strength of the pad during sleep mode. 0: ~5 mA. 1: ~10mA. 2: ~20mA. 3: ~40mA.
          MCU_DRV: u2,

          /// [7:7] Pull-down enable of the pad. 1: internal pull-down enabled. 0: internal pull-down disabled.
          FUN_WPD: u1,

          /// [8:8] Pull-up enable of the pad. 1: internal pull-up enabled. 0: internal pull-up disabled.
          FUN_WPU: u1,

          /// [9:9] Input enable of the pad. 1: input enabled. 0: input disabled.
          FUN_IE: u1,

          /// [10:11] Select the drive strength of the pad. 0: ~5 mA. 1: ~10mA. 2: ~20mA. 3: ~40mA.
          FUN_DRV: u2,

          /// [12:14] Select IO MUX function for this signal. 0: Select Function 1. 1: Select Function 2. etc.
          MCU_SEL: u3,

          /// [15:15] Enable filter for pin input signals. 1: Filter enabled. 0: Filter disabled.
          FILTER_EN: u1,

          /// [16:31] 
          res0: u16,

        }), @ptrFromInt(0x60090050));

        /// IO MUX Configure Register for pad XTAL_32K_P
        pub const GPIO20 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Output enable of the pad in sleep mode. 1: output enabled. 0: output disabled.
          MCU_OE: u1,

          /// [1:1] Sleep mode selection of this pad. Set to 1 to put the pad in pad mode.
          SLP_SEL: u1,

          /// [2:2] Pull-down enable of the pad in sleep mode. 1: internal pull-down enabled. 0: internal pull-down disabled.
          MCU_WPD: u1,

          /// [3:3] Pull-up enable of the pad during sleep mode. 1: internal pull-up enabled. 0: internal pull-up disabled.
          MCU_WPU: u1,

          /// [4:4] Input enable of the pad during sleep mode. 1: input enabled. 0: input disabled.
          MCU_IE: u1,

          /// [5:6] Select the drive strength of the pad during sleep mode. 0: ~5 mA. 1: ~10mA. 2: ~20mA. 3: ~40mA.
          MCU_DRV: u2,

          /// [7:7] Pull-down enable of the pad. 1: internal pull-down enabled. 0: internal pull-down disabled.
          FUN_WPD: u1,

          /// [8:8] Pull-up enable of the pad. 1: internal pull-up enabled. 0: internal pull-up disabled.
          FUN_WPU: u1,

          /// [9:9] Input enable of the pad. 1: input enabled. 0: input disabled.
          FUN_IE: u1,

          /// [10:11] Select the drive strength of the pad. 0: ~5 mA. 1: ~10mA. 2: ~20mA. 3: ~40mA.
          FUN_DRV: u2,

          /// [12:14] Select IO MUX function for this signal. 0: Select Function 1. 1: Select Function 2. etc.
          MCU_SEL: u3,

          /// [15:15] Enable filter for pin input signals. 1: Filter enabled. 0: Filter disabled.
          FILTER_EN: u1,

          /// [16:31] 
          res0: u16,

        }), @ptrFromInt(0x60090054));

        /// IO MUX Configure Register for pad XTAL_32K_P
        pub const GPIO21 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Output enable of the pad in sleep mode. 1: output enabled. 0: output disabled.
          MCU_OE: u1,

          /// [1:1] Sleep mode selection of this pad. Set to 1 to put the pad in pad mode.
          SLP_SEL: u1,

          /// [2:2] Pull-down enable of the pad in sleep mode. 1: internal pull-down enabled. 0: internal pull-down disabled.
          MCU_WPD: u1,

          /// [3:3] Pull-up enable of the pad during sleep mode. 1: internal pull-up enabled. 0: internal pull-up disabled.
          MCU_WPU: u1,

          /// [4:4] Input enable of the pad during sleep mode. 1: input enabled. 0: input disabled.
          MCU_IE: u1,

          /// [5:6] Select the drive strength of the pad during sleep mode. 0: ~5 mA. 1: ~10mA. 2: ~20mA. 3: ~40mA.
          MCU_DRV: u2,

          /// [7:7] Pull-down enable of the pad. 1: internal pull-down enabled. 0: internal pull-down disabled.
          FUN_WPD: u1,

          /// [8:8] Pull-up enable of the pad. 1: internal pull-up enabled. 0: internal pull-up disabled.
          FUN_WPU: u1,

          /// [9:9] Input enable of the pad. 1: input enabled. 0: input disabled.
          FUN_IE: u1,

          /// [10:11] Select the drive strength of the pad. 0: ~5 mA. 1: ~10mA. 2: ~20mA. 3: ~40mA.
          FUN_DRV: u2,

          /// [12:14] Select IO MUX function for this signal. 0: Select Function 1. 1: Select Function 2. etc.
          MCU_SEL: u3,

          /// [15:15] Enable filter for pin input signals. 1: Filter enabled. 0: Filter disabled.
          FILTER_EN: u1,

          /// [16:31] 
          res0: u16,

        }), @ptrFromInt(0x60090058));

        /// IO MUX Configure Register for pad XTAL_32K_P
        pub const GPIO22 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Output enable of the pad in sleep mode. 1: output enabled. 0: output disabled.
          MCU_OE: u1,

          /// [1:1] Sleep mode selection of this pad. Set to 1 to put the pad in pad mode.
          SLP_SEL: u1,

          /// [2:2] Pull-down enable of the pad in sleep mode. 1: internal pull-down enabled. 0: internal pull-down disabled.
          MCU_WPD: u1,

          /// [3:3] Pull-up enable of the pad during sleep mode. 1: internal pull-up enabled. 0: internal pull-up disabled.
          MCU_WPU: u1,

          /// [4:4] Input enable of the pad during sleep mode. 1: input enabled. 0: input disabled.
          MCU_IE: u1,

          /// [5:6] Select the drive strength of the pad during sleep mode. 0: ~5 mA. 1: ~10mA. 2: ~20mA. 3: ~40mA.
          MCU_DRV: u2,

          /// [7:7] Pull-down enable of the pad. 1: internal pull-down enabled. 0: internal pull-down disabled.
          FUN_WPD: u1,

          /// [8:8] Pull-up enable of the pad. 1: internal pull-up enabled. 0: internal pull-up disabled.
          FUN_WPU: u1,

          /// [9:9] Input enable of the pad. 1: input enabled. 0: input disabled.
          FUN_IE: u1,

          /// [10:11] Select the drive strength of the pad. 0: ~5 mA. 1: ~10mA. 2: ~20mA. 3: ~40mA.
          FUN_DRV: u2,

          /// [12:14] Select IO MUX function for this signal. 0: Select Function 1. 1: Select Function 2. etc.
          MCU_SEL: u3,

          /// [15:15] Enable filter for pin input signals. 1: Filter enabled. 0: Filter disabled.
          FILTER_EN: u1,

          /// [16:31] 
          res0: u16,

        }), @ptrFromInt(0x6009005c));

        /// IO MUX Configure Register for pad XTAL_32K_P
        pub const GPIO23 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Output enable of the pad in sleep mode. 1: output enabled. 0: output disabled.
          MCU_OE: u1,

          /// [1:1] Sleep mode selection of this pad. Set to 1 to put the pad in pad mode.
          SLP_SEL: u1,

          /// [2:2] Pull-down enable of the pad in sleep mode. 1: internal pull-down enabled. 0: internal pull-down disabled.
          MCU_WPD: u1,

          /// [3:3] Pull-up enable of the pad during sleep mode. 1: internal pull-up enabled. 0: internal pull-up disabled.
          MCU_WPU: u1,

          /// [4:4] Input enable of the pad during sleep mode. 1: input enabled. 0: input disabled.
          MCU_IE: u1,

          /// [5:6] Select the drive strength of the pad during sleep mode. 0: ~5 mA. 1: ~10mA. 2: ~20mA. 3: ~40mA.
          MCU_DRV: u2,

          /// [7:7] Pull-down enable of the pad. 1: internal pull-down enabled. 0: internal pull-down disabled.
          FUN_WPD: u1,

          /// [8:8] Pull-up enable of the pad. 1: internal pull-up enabled. 0: internal pull-up disabled.
          FUN_WPU: u1,

          /// [9:9] Input enable of the pad. 1: input enabled. 0: input disabled.
          FUN_IE: u1,

          /// [10:11] Select the drive strength of the pad. 0: ~5 mA. 1: ~10mA. 2: ~20mA. 3: ~40mA.
          FUN_DRV: u2,

          /// [12:14] Select IO MUX function for this signal. 0: Select Function 1. 1: Select Function 2. etc.
          MCU_SEL: u3,

          /// [15:15] Enable filter for pin input signals. 1: Filter enabled. 0: Filter disabled.
          FILTER_EN: u1,

          /// [16:31] 
          res0: u16,

        }), @ptrFromInt(0x60090060));

        /// IO MUX Configure Register for pad XTAL_32K_P
        pub const GPIO24 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Output enable of the pad in sleep mode. 1: output enabled. 0: output disabled.
          MCU_OE: u1,

          /// [1:1] Sleep mode selection of this pad. Set to 1 to put the pad in pad mode.
          SLP_SEL: u1,

          /// [2:2] Pull-down enable of the pad in sleep mode. 1: internal pull-down enabled. 0: internal pull-down disabled.
          MCU_WPD: u1,

          /// [3:3] Pull-up enable of the pad during sleep mode. 1: internal pull-up enabled. 0: internal pull-up disabled.
          MCU_WPU: u1,

          /// [4:4] Input enable of the pad during sleep mode. 1: input enabled. 0: input disabled.
          MCU_IE: u1,

          /// [5:6] Select the drive strength of the pad during sleep mode. 0: ~5 mA. 1: ~10mA. 2: ~20mA. 3: ~40mA.
          MCU_DRV: u2,

          /// [7:7] Pull-down enable of the pad. 1: internal pull-down enabled. 0: internal pull-down disabled.
          FUN_WPD: u1,

          /// [8:8] Pull-up enable of the pad. 1: internal pull-up enabled. 0: internal pull-up disabled.
          FUN_WPU: u1,

          /// [9:9] Input enable of the pad. 1: input enabled. 0: input disabled.
          FUN_IE: u1,

          /// [10:11] Select the drive strength of the pad. 0: ~5 mA. 1: ~10mA. 2: ~20mA. 3: ~40mA.
          FUN_DRV: u2,

          /// [12:14] Select IO MUX function for this signal. 0: Select Function 1. 1: Select Function 2. etc.
          MCU_SEL: u3,

          /// [15:15] Enable filter for pin input signals. 1: Filter enabled. 0: Filter disabled.
          FILTER_EN: u1,

          /// [16:31] 
          res0: u16,

        }), @ptrFromInt(0x60090064));

        /// IO MUX Configure Register for pad XTAL_32K_P
        pub const GPIO25 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Output enable of the pad in sleep mode. 1: output enabled. 0: output disabled.
          MCU_OE: u1,

          /// [1:1] Sleep mode selection of this pad. Set to 1 to put the pad in pad mode.
          SLP_SEL: u1,

          /// [2:2] Pull-down enable of the pad in sleep mode. 1: internal pull-down enabled. 0: internal pull-down disabled.
          MCU_WPD: u1,

          /// [3:3] Pull-up enable of the pad during sleep mode. 1: internal pull-up enabled. 0: internal pull-up disabled.
          MCU_WPU: u1,

          /// [4:4] Input enable of the pad during sleep mode. 1: input enabled. 0: input disabled.
          MCU_IE: u1,

          /// [5:6] Select the drive strength of the pad during sleep mode. 0: ~5 mA. 1: ~10mA. 2: ~20mA. 3: ~40mA.
          MCU_DRV: u2,

          /// [7:7] Pull-down enable of the pad. 1: internal pull-down enabled. 0: internal pull-down disabled.
          FUN_WPD: u1,

          /// [8:8] Pull-up enable of the pad. 1: internal pull-up enabled. 0: internal pull-up disabled.
          FUN_WPU: u1,

          /// [9:9] Input enable of the pad. 1: input enabled. 0: input disabled.
          FUN_IE: u1,

          /// [10:11] Select the drive strength of the pad. 0: ~5 mA. 1: ~10mA. 2: ~20mA. 3: ~40mA.
          FUN_DRV: u2,

          /// [12:14] Select IO MUX function for this signal. 0: Select Function 1. 1: Select Function 2. etc.
          MCU_SEL: u3,

          /// [15:15] Enable filter for pin input signals. 1: Filter enabled. 0: Filter disabled.
          FILTER_EN: u1,

          /// [16:31] 
          res0: u16,

        }), @ptrFromInt(0x60090068));

        /// IO MUX Configure Register for pad XTAL_32K_P
        pub const GPIO26 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Output enable of the pad in sleep mode. 1: output enabled. 0: output disabled.
          MCU_OE: u1,

          /// [1:1] Sleep mode selection of this pad. Set to 1 to put the pad in pad mode.
          SLP_SEL: u1,

          /// [2:2] Pull-down enable of the pad in sleep mode. 1: internal pull-down enabled. 0: internal pull-down disabled.
          MCU_WPD: u1,

          /// [3:3] Pull-up enable of the pad during sleep mode. 1: internal pull-up enabled. 0: internal pull-up disabled.
          MCU_WPU: u1,

          /// [4:4] Input enable of the pad during sleep mode. 1: input enabled. 0: input disabled.
          MCU_IE: u1,

          /// [5:6] Select the drive strength of the pad during sleep mode. 0: ~5 mA. 1: ~10mA. 2: ~20mA. 3: ~40mA.
          MCU_DRV: u2,

          /// [7:7] Pull-down enable of the pad. 1: internal pull-down enabled. 0: internal pull-down disabled.
          FUN_WPD: u1,

          /// [8:8] Pull-up enable of the pad. 1: internal pull-up enabled. 0: internal pull-up disabled.
          FUN_WPU: u1,

          /// [9:9] Input enable of the pad. 1: input enabled. 0: input disabled.
          FUN_IE: u1,

          /// [10:11] Select the drive strength of the pad. 0: ~5 mA. 1: ~10mA. 2: ~20mA. 3: ~40mA.
          FUN_DRV: u2,

          /// [12:14] Select IO MUX function for this signal. 0: Select Function 1. 1: Select Function 2. etc.
          MCU_SEL: u3,

          /// [15:15] Enable filter for pin input signals. 1: Filter enabled. 0: Filter disabled.
          FILTER_EN: u1,

          /// [16:31] 
          res0: u16,

        }), @ptrFromInt(0x6009006c));

        /// IO MUX Configure Register for pad XTAL_32K_P
        pub const GPIO27 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Output enable of the pad in sleep mode. 1: output enabled. 0: output disabled.
          MCU_OE: u1,

          /// [1:1] Sleep mode selection of this pad. Set to 1 to put the pad in pad mode.
          SLP_SEL: u1,

          /// [2:2] Pull-down enable of the pad in sleep mode. 1: internal pull-down enabled. 0: internal pull-down disabled.
          MCU_WPD: u1,

          /// [3:3] Pull-up enable of the pad during sleep mode. 1: internal pull-up enabled. 0: internal pull-up disabled.
          MCU_WPU: u1,

          /// [4:4] Input enable of the pad during sleep mode. 1: input enabled. 0: input disabled.
          MCU_IE: u1,

          /// [5:6] Select the drive strength of the pad during sleep mode. 0: ~5 mA. 1: ~10mA. 2: ~20mA. 3: ~40mA.
          MCU_DRV: u2,

          /// [7:7] Pull-down enable of the pad. 1: internal pull-down enabled. 0: internal pull-down disabled.
          FUN_WPD: u1,

          /// [8:8] Pull-up enable of the pad. 1: internal pull-up enabled. 0: internal pull-up disabled.
          FUN_WPU: u1,

          /// [9:9] Input enable of the pad. 1: input enabled. 0: input disabled.
          FUN_IE: u1,

          /// [10:11] Select the drive strength of the pad. 0: ~5 mA. 1: ~10mA. 2: ~20mA. 3: ~40mA.
          FUN_DRV: u2,

          /// [12:14] Select IO MUX function for this signal. 0: Select Function 1. 1: Select Function 2. etc.
          MCU_SEL: u3,

          /// [15:15] Enable filter for pin input signals. 1: Filter enabled. 0: Filter disabled.
          FILTER_EN: u1,

          /// [16:31] 
          res0: u16,

        }), @ptrFromInt(0x60090070));

        /// IO MUX Configure Register for pad XTAL_32K_P
        pub const GPIO28 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Output enable of the pad in sleep mode. 1: output enabled. 0: output disabled.
          MCU_OE: u1,

          /// [1:1] Sleep mode selection of this pad. Set to 1 to put the pad in pad mode.
          SLP_SEL: u1,

          /// [2:2] Pull-down enable of the pad in sleep mode. 1: internal pull-down enabled. 0: internal pull-down disabled.
          MCU_WPD: u1,

          /// [3:3] Pull-up enable of the pad during sleep mode. 1: internal pull-up enabled. 0: internal pull-up disabled.
          MCU_WPU: u1,

          /// [4:4] Input enable of the pad during sleep mode. 1: input enabled. 0: input disabled.
          MCU_IE: u1,

          /// [5:6] Select the drive strength of the pad during sleep mode. 0: ~5 mA. 1: ~10mA. 2: ~20mA. 3: ~40mA.
          MCU_DRV: u2,

          /// [7:7] Pull-down enable of the pad. 1: internal pull-down enabled. 0: internal pull-down disabled.
          FUN_WPD: u1,

          /// [8:8] Pull-up enable of the pad. 1: internal pull-up enabled. 0: internal pull-up disabled.
          FUN_WPU: u1,

          /// [9:9] Input enable of the pad. 1: input enabled. 0: input disabled.
          FUN_IE: u1,

          /// [10:11] Select the drive strength of the pad. 0: ~5 mA. 1: ~10mA. 2: ~20mA. 3: ~40mA.
          FUN_DRV: u2,

          /// [12:14] Select IO MUX function for this signal. 0: Select Function 1. 1: Select Function 2. etc.
          MCU_SEL: u3,

          /// [15:15] Enable filter for pin input signals. 1: Filter enabled. 0: Filter disabled.
          FILTER_EN: u1,

          /// [16:31] 
          res0: u16,

        }), @ptrFromInt(0x60090074));

        /// IO MUX Configure Register for pad XTAL_32K_P
        pub const GPIO29 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Output enable of the pad in sleep mode. 1: output enabled. 0: output disabled.
          MCU_OE: u1,

          /// [1:1] Sleep mode selection of this pad. Set to 1 to put the pad in pad mode.
          SLP_SEL: u1,

          /// [2:2] Pull-down enable of the pad in sleep mode. 1: internal pull-down enabled. 0: internal pull-down disabled.
          MCU_WPD: u1,

          /// [3:3] Pull-up enable of the pad during sleep mode. 1: internal pull-up enabled. 0: internal pull-up disabled.
          MCU_WPU: u1,

          /// [4:4] Input enable of the pad during sleep mode. 1: input enabled. 0: input disabled.
          MCU_IE: u1,

          /// [5:6] Select the drive strength of the pad during sleep mode. 0: ~5 mA. 1: ~10mA. 2: ~20mA. 3: ~40mA.
          MCU_DRV: u2,

          /// [7:7] Pull-down enable of the pad. 1: internal pull-down enabled. 0: internal pull-down disabled.
          FUN_WPD: u1,

          /// [8:8] Pull-up enable of the pad. 1: internal pull-up enabled. 0: internal pull-up disabled.
          FUN_WPU: u1,

          /// [9:9] Input enable of the pad. 1: input enabled. 0: input disabled.
          FUN_IE: u1,

          /// [10:11] Select the drive strength of the pad. 0: ~5 mA. 1: ~10mA. 2: ~20mA. 3: ~40mA.
          FUN_DRV: u2,

          /// [12:14] Select IO MUX function for this signal. 0: Select Function 1. 1: Select Function 2. etc.
          MCU_SEL: u3,

          /// [15:15] Enable filter for pin input signals. 1: Filter enabled. 0: Filter disabled.
          FILTER_EN: u1,

          /// [16:31] 
          res0: u16,

        }), @ptrFromInt(0x60090078));

        /// IO MUX Configure Register for pad XTAL_32K_P
        pub const GPIO30 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Output enable of the pad in sleep mode. 1: output enabled. 0: output disabled.
          MCU_OE: u1,

          /// [1:1] Sleep mode selection of this pad. Set to 1 to put the pad in pad mode.
          SLP_SEL: u1,

          /// [2:2] Pull-down enable of the pad in sleep mode. 1: internal pull-down enabled. 0: internal pull-down disabled.
          MCU_WPD: u1,

          /// [3:3] Pull-up enable of the pad during sleep mode. 1: internal pull-up enabled. 0: internal pull-up disabled.
          MCU_WPU: u1,

          /// [4:4] Input enable of the pad during sleep mode. 1: input enabled. 0: input disabled.
          MCU_IE: u1,

          /// [5:6] Select the drive strength of the pad during sleep mode. 0: ~5 mA. 1: ~10mA. 2: ~20mA. 3: ~40mA.
          MCU_DRV: u2,

          /// [7:7] Pull-down enable of the pad. 1: internal pull-down enabled. 0: internal pull-down disabled.
          FUN_WPD: u1,

          /// [8:8] Pull-up enable of the pad. 1: internal pull-up enabled. 0: internal pull-up disabled.
          FUN_WPU: u1,

          /// [9:9] Input enable of the pad. 1: input enabled. 0: input disabled.
          FUN_IE: u1,

          /// [10:11] Select the drive strength of the pad. 0: ~5 mA. 1: ~10mA. 2: ~20mA. 3: ~40mA.
          FUN_DRV: u2,

          /// [12:14] Select IO MUX function for this signal. 0: Select Function 1. 1: Select Function 2. etc.
          MCU_SEL: u3,

          /// [15:15] Enable filter for pin input signals. 1: Filter enabled. 0: Filter disabled.
          FILTER_EN: u1,

          /// [16:31] 
          res0: u16,

        }), @ptrFromInt(0x6009007c));

        /// GPIO MATRIX Configure Register for modem diag
        pub const MODEM_DIAG_EN = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] bit i to enable modem_diag[i] into gpio matrix. 1:enable modem_diag[i] into gpio matrix. 0:enable other signals into gpio matrix
          MODEM_DIAG_EN: u32,

        }), @ptrFromInt(0x600900bc));

        /// IO MUX Version Control Register
        pub const DATE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:27] Version control register
          REG_DATE: u28,

          /// [28:31] 
          res0: u4,

        }), @ptrFromInt(0x600900fc));

      };

      /// LED Control PWM (Pulse Width Modulation)
      pub const LEDC = struct {

        /// Configuration register 0 for channel %s
        pub const CH0_CONF0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:1] This field is used to select one of timers for channel %s.0: select timer0, 1: select timer1, 2: select timer2, 3: select timer3
          TIMER_SEL: u2,

          /// [2:2] Set this bit to enable signal output on channel %s.
          SIG_OUT_EN: u1,

          /// [3:3] This bit is used to control the output value when channel %s is inactive (when LEDC_SIG_OUT_EN_CH%s is 0).
          IDLE_LV: u1,

          /// [4:4] This bit is used to update LEDC_HPOINT_CH%s, LEDC_DUTY_START_CH%s, LEDC_SIG_OUT_EN_CH%s, LEDC_TIMER_SEL_CH%s, LEDC_DUTY_NUM_CH%s, LEDC_DUTY_CYCLE_CH%s, LEDC_DUTY_SCALE_CH%s, LEDC_DUTY_INC_CH%s, and LEDC_OVF_CNT_EN_CH%s fields for channel %s, and will be automatically cleared by hardware.
          PARA_UP: u1,

          /// [5:14] This register is used to configure the maximum times of overflow minus 1.The LEDC_OVF_CNT_CH%s_INT interrupt will be triggered when channel %s overflows for (LEDC_OVF_NUM_CH%s + 1) times.
          OVF_NUM: u10,

          /// [15:15] This bit is used to enable the ovf_cnt of channel %s.
          OVF_CNT_EN: u1,

          /// [16:16] Set this bit to reset the ovf_cnt of channel %s.
          OVF_CNT_RESET: u1,

          /// [17:31] 
          res0: u15,

        }), @ptrFromInt(0x60007000));

        /// Configuration register 0 for channel %s
        pub const CH1_CONF0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:1] This field is used to select one of timers for channel %s.0: select timer0, 1: select timer1, 2: select timer2, 3: select timer3
          TIMER_SEL: u2,

          /// [2:2] Set this bit to enable signal output on channel %s.
          SIG_OUT_EN: u1,

          /// [3:3] This bit is used to control the output value when channel %s is inactive (when LEDC_SIG_OUT_EN_CH%s is 0).
          IDLE_LV: u1,

          /// [4:4] This bit is used to update LEDC_HPOINT_CH%s, LEDC_DUTY_START_CH%s, LEDC_SIG_OUT_EN_CH%s, LEDC_TIMER_SEL_CH%s, LEDC_DUTY_NUM_CH%s, LEDC_DUTY_CYCLE_CH%s, LEDC_DUTY_SCALE_CH%s, LEDC_DUTY_INC_CH%s, and LEDC_OVF_CNT_EN_CH%s fields for channel %s, and will be automatically cleared by hardware.
          PARA_UP: u1,

          /// [5:14] This register is used to configure the maximum times of overflow minus 1.The LEDC_OVF_CNT_CH%s_INT interrupt will be triggered when channel %s overflows for (LEDC_OVF_NUM_CH%s + 1) times.
          OVF_NUM: u10,

          /// [15:15] This bit is used to enable the ovf_cnt of channel %s.
          OVF_CNT_EN: u1,

          /// [16:16] Set this bit to reset the ovf_cnt of channel %s.
          OVF_CNT_RESET: u1,

          /// [17:31] 
          res0: u15,

        }), @ptrFromInt(0x60007004));

        /// Configuration register 0 for channel %s
        pub const CH2_CONF0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:1] This field is used to select one of timers for channel %s.0: select timer0, 1: select timer1, 2: select timer2, 3: select timer3
          TIMER_SEL: u2,

          /// [2:2] Set this bit to enable signal output on channel %s.
          SIG_OUT_EN: u1,

          /// [3:3] This bit is used to control the output value when channel %s is inactive (when LEDC_SIG_OUT_EN_CH%s is 0).
          IDLE_LV: u1,

          /// [4:4] This bit is used to update LEDC_HPOINT_CH%s, LEDC_DUTY_START_CH%s, LEDC_SIG_OUT_EN_CH%s, LEDC_TIMER_SEL_CH%s, LEDC_DUTY_NUM_CH%s, LEDC_DUTY_CYCLE_CH%s, LEDC_DUTY_SCALE_CH%s, LEDC_DUTY_INC_CH%s, and LEDC_OVF_CNT_EN_CH%s fields for channel %s, and will be automatically cleared by hardware.
          PARA_UP: u1,

          /// [5:14] This register is used to configure the maximum times of overflow minus 1.The LEDC_OVF_CNT_CH%s_INT interrupt will be triggered when channel %s overflows for (LEDC_OVF_NUM_CH%s + 1) times.
          OVF_NUM: u10,

          /// [15:15] This bit is used to enable the ovf_cnt of channel %s.
          OVF_CNT_EN: u1,

          /// [16:16] Set this bit to reset the ovf_cnt of channel %s.
          OVF_CNT_RESET: u1,

          /// [17:31] 
          res0: u15,

        }), @ptrFromInt(0x60007008));

        /// Configuration register 0 for channel %s
        pub const CH3_CONF0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:1] This field is used to select one of timers for channel %s.0: select timer0, 1: select timer1, 2: select timer2, 3: select timer3
          TIMER_SEL: u2,

          /// [2:2] Set this bit to enable signal output on channel %s.
          SIG_OUT_EN: u1,

          /// [3:3] This bit is used to control the output value when channel %s is inactive (when LEDC_SIG_OUT_EN_CH%s is 0).
          IDLE_LV: u1,

          /// [4:4] This bit is used to update LEDC_HPOINT_CH%s, LEDC_DUTY_START_CH%s, LEDC_SIG_OUT_EN_CH%s, LEDC_TIMER_SEL_CH%s, LEDC_DUTY_NUM_CH%s, LEDC_DUTY_CYCLE_CH%s, LEDC_DUTY_SCALE_CH%s, LEDC_DUTY_INC_CH%s, and LEDC_OVF_CNT_EN_CH%s fields for channel %s, and will be automatically cleared by hardware.
          PARA_UP: u1,

          /// [5:14] This register is used to configure the maximum times of overflow minus 1.The LEDC_OVF_CNT_CH%s_INT interrupt will be triggered when channel %s overflows for (LEDC_OVF_NUM_CH%s + 1) times.
          OVF_NUM: u10,

          /// [15:15] This bit is used to enable the ovf_cnt of channel %s.
          OVF_CNT_EN: u1,

          /// [16:16] Set this bit to reset the ovf_cnt of channel %s.
          OVF_CNT_RESET: u1,

          /// [17:31] 
          res0: u15,

        }), @ptrFromInt(0x6000700c));

        /// Configuration register 0 for channel %s
        pub const CH4_CONF0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:1] This field is used to select one of timers for channel %s.0: select timer0, 1: select timer1, 2: select timer2, 3: select timer3
          TIMER_SEL: u2,

          /// [2:2] Set this bit to enable signal output on channel %s.
          SIG_OUT_EN: u1,

          /// [3:3] This bit is used to control the output value when channel %s is inactive (when LEDC_SIG_OUT_EN_CH%s is 0).
          IDLE_LV: u1,

          /// [4:4] This bit is used to update LEDC_HPOINT_CH%s, LEDC_DUTY_START_CH%s, LEDC_SIG_OUT_EN_CH%s, LEDC_TIMER_SEL_CH%s, LEDC_DUTY_NUM_CH%s, LEDC_DUTY_CYCLE_CH%s, LEDC_DUTY_SCALE_CH%s, LEDC_DUTY_INC_CH%s, and LEDC_OVF_CNT_EN_CH%s fields for channel %s, and will be automatically cleared by hardware.
          PARA_UP: u1,

          /// [5:14] This register is used to configure the maximum times of overflow minus 1.The LEDC_OVF_CNT_CH%s_INT interrupt will be triggered when channel %s overflows for (LEDC_OVF_NUM_CH%s + 1) times.
          OVF_NUM: u10,

          /// [15:15] This bit is used to enable the ovf_cnt of channel %s.
          OVF_CNT_EN: u1,

          /// [16:16] Set this bit to reset the ovf_cnt of channel %s.
          OVF_CNT_RESET: u1,

          /// [17:31] 
          res0: u15,

        }), @ptrFromInt(0x60007010));

        /// Configuration register 0 for channel %s
        pub const CH5_CONF0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:1] This field is used to select one of timers for channel %s.0: select timer0, 1: select timer1, 2: select timer2, 3: select timer3
          TIMER_SEL: u2,

          /// [2:2] Set this bit to enable signal output on channel %s.
          SIG_OUT_EN: u1,

          /// [3:3] This bit is used to control the output value when channel %s is inactive (when LEDC_SIG_OUT_EN_CH%s is 0).
          IDLE_LV: u1,

          /// [4:4] This bit is used to update LEDC_HPOINT_CH%s, LEDC_DUTY_START_CH%s, LEDC_SIG_OUT_EN_CH%s, LEDC_TIMER_SEL_CH%s, LEDC_DUTY_NUM_CH%s, LEDC_DUTY_CYCLE_CH%s, LEDC_DUTY_SCALE_CH%s, LEDC_DUTY_INC_CH%s, and LEDC_OVF_CNT_EN_CH%s fields for channel %s, and will be automatically cleared by hardware.
          PARA_UP: u1,

          /// [5:14] This register is used to configure the maximum times of overflow minus 1.The LEDC_OVF_CNT_CH%s_INT interrupt will be triggered when channel %s overflows for (LEDC_OVF_NUM_CH%s + 1) times.
          OVF_NUM: u10,

          /// [15:15] This bit is used to enable the ovf_cnt of channel %s.
          OVF_CNT_EN: u1,

          /// [16:16] Set this bit to reset the ovf_cnt of channel %s.
          OVF_CNT_RESET: u1,

          /// [17:31] 
          res0: u15,

        }), @ptrFromInt(0x60007014));

        /// High point register for channel %s
        pub const CH0_HPOINT = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:19] The output value changes to high when the selected timers has reached the value specified by this register.
          HPOINT: u20,

          /// [20:31] 
          res0: u12,

        }), @ptrFromInt(0x60007004));

        /// High point register for channel %s
        pub const CH1_HPOINT = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:19] The output value changes to high when the selected timers has reached the value specified by this register.
          HPOINT: u20,

          /// [20:31] 
          res0: u12,

        }), @ptrFromInt(0x60007008));

        /// High point register for channel %s
        pub const CH2_HPOINT = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:19] The output value changes to high when the selected timers has reached the value specified by this register.
          HPOINT: u20,

          /// [20:31] 
          res0: u12,

        }), @ptrFromInt(0x6000700c));

        /// High point register for channel %s
        pub const CH3_HPOINT = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:19] The output value changes to high when the selected timers has reached the value specified by this register.
          HPOINT: u20,

          /// [20:31] 
          res0: u12,

        }), @ptrFromInt(0x60007010));

        /// High point register for channel %s
        pub const CH4_HPOINT = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:19] The output value changes to high when the selected timers has reached the value specified by this register.
          HPOINT: u20,

          /// [20:31] 
          res0: u12,

        }), @ptrFromInt(0x60007014));

        /// High point register for channel %s
        pub const CH5_HPOINT = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:19] The output value changes to high when the selected timers has reached the value specified by this register.
          HPOINT: u20,

          /// [20:31] 
          res0: u12,

        }), @ptrFromInt(0x60007018));

        /// Initial duty cycle for channel %s
        pub const CH0_DUTY = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:24] This register is used to change the output duty by controlling the Lpoint.The output value turns to low when the selected timers has reached the Lpoint.
          DUTY: u25,

          /// [25:31] 
          res0: u7,

        }), @ptrFromInt(0x60007008));

        /// Initial duty cycle for channel %s
        pub const CH1_DUTY = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:24] This register is used to change the output duty by controlling the Lpoint.The output value turns to low when the selected timers has reached the Lpoint.
          DUTY: u25,

          /// [25:31] 
          res0: u7,

        }), @ptrFromInt(0x6000700c));

        /// Initial duty cycle for channel %s
        pub const CH2_DUTY = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:24] This register is used to change the output duty by controlling the Lpoint.The output value turns to low when the selected timers has reached the Lpoint.
          DUTY: u25,

          /// [25:31] 
          res0: u7,

        }), @ptrFromInt(0x60007010));

        /// Initial duty cycle for channel %s
        pub const CH3_DUTY = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:24] This register is used to change the output duty by controlling the Lpoint.The output value turns to low when the selected timers has reached the Lpoint.
          DUTY: u25,

          /// [25:31] 
          res0: u7,

        }), @ptrFromInt(0x60007014));

        /// Initial duty cycle for channel %s
        pub const CH4_DUTY = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:24] This register is used to change the output duty by controlling the Lpoint.The output value turns to low when the selected timers has reached the Lpoint.
          DUTY: u25,

          /// [25:31] 
          res0: u7,

        }), @ptrFromInt(0x60007018));

        /// Initial duty cycle for channel %s
        pub const CH5_DUTY = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:24] This register is used to change the output duty by controlling the Lpoint.The output value turns to low when the selected timers has reached the Lpoint.
          DUTY: u25,

          /// [25:31] 
          res0: u7,

        }), @ptrFromInt(0x6000701c));

        /// Configuration register 1 for channel %s
        pub const CH0_CONF1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:30] 
          res0: u31,

          /// [31:31] Other configured fields in LEDC_CH%s_CONF1_REG will start to take effect when this bit is set to 1.
          DUTY_START: u1,

        }), @ptrFromInt(0x6000700c));

        /// Configuration register 1 for channel %s
        pub const CH1_CONF1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:30] 
          res0: u31,

          /// [31:31] Other configured fields in LEDC_CH%s_CONF1_REG will start to take effect when this bit is set to 1.
          DUTY_START: u1,

        }), @ptrFromInt(0x60007010));

        /// Configuration register 1 for channel %s
        pub const CH2_CONF1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:30] 
          res0: u31,

          /// [31:31] Other configured fields in LEDC_CH%s_CONF1_REG will start to take effect when this bit is set to 1.
          DUTY_START: u1,

        }), @ptrFromInt(0x60007014));

        /// Configuration register 1 for channel %s
        pub const CH3_CONF1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:30] 
          res0: u31,

          /// [31:31] Other configured fields in LEDC_CH%s_CONF1_REG will start to take effect when this bit is set to 1.
          DUTY_START: u1,

        }), @ptrFromInt(0x60007018));

        /// Configuration register 1 for channel %s
        pub const CH4_CONF1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:30] 
          res0: u31,

          /// [31:31] Other configured fields in LEDC_CH%s_CONF1_REG will start to take effect when this bit is set to 1.
          DUTY_START: u1,

        }), @ptrFromInt(0x6000701c));

        /// Configuration register 1 for channel %s
        pub const CH5_CONF1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:30] 
          res0: u31,

          /// [31:31] Other configured fields in LEDC_CH%s_CONF1_REG will start to take effect when this bit is set to 1.
          DUTY_START: u1,

        }), @ptrFromInt(0x60007020));

        /// Current duty cycle for channel %s
        pub const CH0_DUTY_R = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:24] This register stores the current duty of output signal on channel %s.
          DUTY_CH_R: u25,

          /// [25:31] 
          res0: u7,

        }), @ptrFromInt(0x60007010));

        /// Current duty cycle for channel %s
        pub const CH1_DUTY_R = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:24] This register stores the current duty of output signal on channel %s.
          DUTY_CH_R: u25,

          /// [25:31] 
          res0: u7,

        }), @ptrFromInt(0x60007014));

        /// Current duty cycle for channel %s
        pub const CH2_DUTY_R = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:24] This register stores the current duty of output signal on channel %s.
          DUTY_CH_R: u25,

          /// [25:31] 
          res0: u7,

        }), @ptrFromInt(0x60007018));

        /// Current duty cycle for channel %s
        pub const CH3_DUTY_R = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:24] This register stores the current duty of output signal on channel %s.
          DUTY_CH_R: u25,

          /// [25:31] 
          res0: u7,

        }), @ptrFromInt(0x6000701c));

        /// Current duty cycle for channel %s
        pub const CH4_DUTY_R = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:24] This register stores the current duty of output signal on channel %s.
          DUTY_CH_R: u25,

          /// [25:31] 
          res0: u7,

        }), @ptrFromInt(0x60007020));

        /// Current duty cycle for channel %s
        pub const CH5_DUTY_R = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:24] This register stores the current duty of output signal on channel %s.
          DUTY_CH_R: u25,

          /// [25:31] 
          res0: u7,

        }), @ptrFromInt(0x60007024));

        /// Timer %s configuration
        pub const TIMER0_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:4] This register is used to control the range of the counter in timer %s.
          DUTY_RES: u5,

          /// [5:22] This register is used to configure the divisor for the divider in timer %s.The least significant eight bits represent the fractional part.
          CLK_DIV: u18,

          /// [23:23] This bit is used to suspend the counter in timer %s.
          PAUSE: u1,

          /// [24:24] This bit is used to reset timer %s. The counter will show 0 after reset.
          RST: u1,

          /// [25:25] This bit is used to select clock for timer %s. When this bit is set to 1 LEDC_APB_CLK_SEL[1:0] should be 1, otherwise the timer clock may be not accurate.1'h0: SLOW_CLK 1'h1: REF_TICK
          TICK_SEL: u1,

          /// [26:26] Set this bit to update LEDC_CLK_DIV_TIMER%s and LEDC_TIMER%s_DUTY_RES.
          PARA_UP: u1,

          /// [27:31] 
          res0: u5,

        }), @ptrFromInt(0x600070a0));

        /// Timer %s configuration
        pub const TIMER1_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:4] This register is used to control the range of the counter in timer %s.
          DUTY_RES: u5,

          /// [5:22] This register is used to configure the divisor for the divider in timer %s.The least significant eight bits represent the fractional part.
          CLK_DIV: u18,

          /// [23:23] This bit is used to suspend the counter in timer %s.
          PAUSE: u1,

          /// [24:24] This bit is used to reset timer %s. The counter will show 0 after reset.
          RST: u1,

          /// [25:25] This bit is used to select clock for timer %s. When this bit is set to 1 LEDC_APB_CLK_SEL[1:0] should be 1, otherwise the timer clock may be not accurate.1'h0: SLOW_CLK 1'h1: REF_TICK
          TICK_SEL: u1,

          /// [26:26] Set this bit to update LEDC_CLK_DIV_TIMER%s and LEDC_TIMER%s_DUTY_RES.
          PARA_UP: u1,

          /// [27:31] 
          res0: u5,

        }), @ptrFromInt(0x600070a4));

        /// Timer %s configuration
        pub const TIMER2_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:4] This register is used to control the range of the counter in timer %s.
          DUTY_RES: u5,

          /// [5:22] This register is used to configure the divisor for the divider in timer %s.The least significant eight bits represent the fractional part.
          CLK_DIV: u18,

          /// [23:23] This bit is used to suspend the counter in timer %s.
          PAUSE: u1,

          /// [24:24] This bit is used to reset timer %s. The counter will show 0 after reset.
          RST: u1,

          /// [25:25] This bit is used to select clock for timer %s. When this bit is set to 1 LEDC_APB_CLK_SEL[1:0] should be 1, otherwise the timer clock may be not accurate.1'h0: SLOW_CLK 1'h1: REF_TICK
          TICK_SEL: u1,

          /// [26:26] Set this bit to update LEDC_CLK_DIV_TIMER%s and LEDC_TIMER%s_DUTY_RES.
          PARA_UP: u1,

          /// [27:31] 
          res0: u5,

        }), @ptrFromInt(0x600070a8));

        /// Timer %s configuration
        pub const TIMER3_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:4] This register is used to control the range of the counter in timer %s.
          DUTY_RES: u5,

          /// [5:22] This register is used to configure the divisor for the divider in timer %s.The least significant eight bits represent the fractional part.
          CLK_DIV: u18,

          /// [23:23] This bit is used to suspend the counter in timer %s.
          PAUSE: u1,

          /// [24:24] This bit is used to reset timer %s. The counter will show 0 after reset.
          RST: u1,

          /// [25:25] This bit is used to select clock for timer %s. When this bit is set to 1 LEDC_APB_CLK_SEL[1:0] should be 1, otherwise the timer clock may be not accurate.1'h0: SLOW_CLK 1'h1: REF_TICK
          TICK_SEL: u1,

          /// [26:26] Set this bit to update LEDC_CLK_DIV_TIMER%s and LEDC_TIMER%s_DUTY_RES.
          PARA_UP: u1,

          /// [27:31] 
          res0: u5,

        }), @ptrFromInt(0x600070ac));

        /// Timer %s current counter value
        pub const TIMER0_VALUE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:19] This register stores the current counter value of timer %s.
          TIMER_CNT: u20,

          /// [20:31] 
          res0: u12,

        }), @ptrFromInt(0x600070a4));

        /// Timer %s current counter value
        pub const TIMER1_VALUE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:19] This register stores the current counter value of timer %s.
          TIMER_CNT: u20,

          /// [20:31] 
          res0: u12,

        }), @ptrFromInt(0x600070a8));

        /// Timer %s current counter value
        pub const TIMER2_VALUE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:19] This register stores the current counter value of timer %s.
          TIMER_CNT: u20,

          /// [20:31] 
          res0: u12,

        }), @ptrFromInt(0x600070ac));

        /// Timer %s current counter value
        pub const TIMER3_VALUE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:19] This register stores the current counter value of timer %s.
          TIMER_CNT: u20,

          /// [20:31] 
          res0: u12,

        }), @ptrFromInt(0x600070b0));

        /// Raw interrupt status
        pub const INT_RAW = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Triggered when the timer0 has reached its maximum counter value.
          TIMER0_OVF_INT_RAW: u1,

          /// [1:1] Triggered when the timer1 has reached its maximum counter value.
          TIMER1_OVF_INT_RAW: u1,

          /// [2:2] Triggered when the timer2 has reached its maximum counter value.
          TIMER2_OVF_INT_RAW: u1,

          /// [3:3] Triggered when the timer3 has reached its maximum counter value.
          TIMER3_OVF_INT_RAW: u1,

          /// [4:4] Interrupt raw bit for channel 0. Triggered when the gradual change of duty has finished.
          DUTY_CHNG_END_CH0_INT_RAW: u1,

          /// [5:5] Interrupt raw bit for channel 1. Triggered when the gradual change of duty has finished.
          DUTY_CHNG_END_CH1_INT_RAW: u1,

          /// [6:6] Interrupt raw bit for channel 2. Triggered when the gradual change of duty has finished.
          DUTY_CHNG_END_CH2_INT_RAW: u1,

          /// [7:7] Interrupt raw bit for channel 3. Triggered when the gradual change of duty has finished.
          DUTY_CHNG_END_CH3_INT_RAW: u1,

          /// [8:8] Interrupt raw bit for channel 4. Triggered when the gradual change of duty has finished.
          DUTY_CHNG_END_CH4_INT_RAW: u1,

          /// [9:9] Interrupt raw bit for channel 5. Triggered when the gradual change of duty has finished.
          DUTY_CHNG_END_CH5_INT_RAW: u1,

          /// [10:11] 
          res0: u2,

          /// [12:12] Interrupt raw bit for channel 0. Triggered when the ovf_cnt has reached the value specified by LEDC_OVF_NUM_CH0.
          OVF_CNT_CH0_INT_RAW: u1,

          /// [13:13] Interrupt raw bit for channel 1. Triggered when the ovf_cnt has reached the value specified by LEDC_OVF_NUM_CH1.
          OVF_CNT_CH1_INT_RAW: u1,

          /// [14:14] Interrupt raw bit for channel 2. Triggered when the ovf_cnt has reached the value specified by LEDC_OVF_NUM_CH2.
          OVF_CNT_CH2_INT_RAW: u1,

          /// [15:15] Interrupt raw bit for channel 3. Triggered when the ovf_cnt has reached the value specified by LEDC_OVF_NUM_CH3.
          OVF_CNT_CH3_INT_RAW: u1,

          /// [16:16] Interrupt raw bit for channel 4. Triggered when the ovf_cnt has reached the value specified by LEDC_OVF_NUM_CH4.
          OVF_CNT_CH4_INT_RAW: u1,

          /// [17:17] Interrupt raw bit for channel 5. Triggered when the ovf_cnt has reached the value specified by LEDC_OVF_NUM_CH5.
          OVF_CNT_CH5_INT_RAW: u1,

          /// [18:31] 
          res1: u14,

        }), @ptrFromInt(0x600070c0));

        /// Masked interrupt status
        pub const INT_ST = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] This is the masked interrupt status bit for the LEDC_TIMER0_OVF_INT interrupt when LEDC_TIMER0_OVF_INT_ENA is set to 1.
          TIMER0_OVF_INT_ST: u1,

          /// [1:1] This is the masked interrupt status bit for the LEDC_TIMER1_OVF_INT interrupt when LEDC_TIMER1_OVF_INT_ENA is set to 1.
          TIMER1_OVF_INT_ST: u1,

          /// [2:2] This is the masked interrupt status bit for the LEDC_TIMER2_OVF_INT interrupt when LEDC_TIMER2_OVF_INT_ENA is set to 1.
          TIMER2_OVF_INT_ST: u1,

          /// [3:3] This is the masked interrupt status bit for the LEDC_TIMER3_OVF_INT interrupt when LEDC_TIMER3_OVF_INT_ENA is set to 1.
          TIMER3_OVF_INT_ST: u1,

          /// [4:4] This is the masked interrupt status bit for the LEDC_DUTY_CHNG_END_CH0_INT interrupt when LEDC_DUTY_CHNG_END_CH0_INT_ENA is set to 1.
          DUTY_CHNG_END_CH0_INT_ST: u1,

          /// [5:5] This is the masked interrupt status bit for the LEDC_DUTY_CHNG_END_CH1_INT interrupt when LEDC_DUTY_CHNG_END_CH1_INT_ENA is set to 1.
          DUTY_CHNG_END_CH1_INT_ST: u1,

          /// [6:6] This is the masked interrupt status bit for the LEDC_DUTY_CHNG_END_CH2_INT interrupt when LEDC_DUTY_CHNG_END_CH2_INT_ENA is set to 1.
          DUTY_CHNG_END_CH2_INT_ST: u1,

          /// [7:7] This is the masked interrupt status bit for the LEDC_DUTY_CHNG_END_CH3_INT interrupt when LEDC_DUTY_CHNG_END_CH3_INT_ENA is set to 1.
          DUTY_CHNG_END_CH3_INT_ST: u1,

          /// [8:8] This is the masked interrupt status bit for the LEDC_DUTY_CHNG_END_CH4_INT interrupt when LEDC_DUTY_CHNG_END_CH4_INT_ENA is set to 1.
          DUTY_CHNG_END_CH4_INT_ST: u1,

          /// [9:9] This is the masked interrupt status bit for the LEDC_DUTY_CHNG_END_CH5_INT interrupt when LEDC_DUTY_CHNG_END_CH5_INT_ENA is set to 1.
          DUTY_CHNG_END_CH5_INT_ST: u1,

          /// [10:11] 
          res0: u2,

          /// [12:12] This is the masked interrupt status bit for the LEDC_OVF_CNT_CH0_INT interrupt when LEDC_OVF_CNT_CH0_INT_ENA is set to 1.
          OVF_CNT_CH0_INT_ST: u1,

          /// [13:13] This is the masked interrupt status bit for the LEDC_OVF_CNT_CH1_INT interrupt when LEDC_OVF_CNT_CH1_INT_ENA is set to 1.
          OVF_CNT_CH1_INT_ST: u1,

          /// [14:14] This is the masked interrupt status bit for the LEDC_OVF_CNT_CH2_INT interrupt when LEDC_OVF_CNT_CH2_INT_ENA is set to 1.
          OVF_CNT_CH2_INT_ST: u1,

          /// [15:15] This is the masked interrupt status bit for the LEDC_OVF_CNT_CH3_INT interrupt when LEDC_OVF_CNT_CH3_INT_ENA is set to 1.
          OVF_CNT_CH3_INT_ST: u1,

          /// [16:16] This is the masked interrupt status bit for the LEDC_OVF_CNT_CH4_INT interrupt when LEDC_OVF_CNT_CH4_INT_ENA is set to 1.
          OVF_CNT_CH4_INT_ST: u1,

          /// [17:17] This is the masked interrupt status bit for the LEDC_OVF_CNT_CH5_INT interrupt when LEDC_OVF_CNT_CH5_INT_ENA is set to 1.
          OVF_CNT_CH5_INT_ST: u1,

          /// [18:31] 
          res1: u14,

        }), @ptrFromInt(0x600070c4));

        /// Interrupt enable bits
        pub const INT_ENA = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] The interrupt enable bit for the LEDC_TIMER0_OVF_INT interrupt.
          TIMER0_OVF_INT_ENA: u1,

          /// [1:1] The interrupt enable bit for the LEDC_TIMER1_OVF_INT interrupt.
          TIMER1_OVF_INT_ENA: u1,

          /// [2:2] The interrupt enable bit for the LEDC_TIMER2_OVF_INT interrupt.
          TIMER2_OVF_INT_ENA: u1,

          /// [3:3] The interrupt enable bit for the LEDC_TIMER3_OVF_INT interrupt.
          TIMER3_OVF_INT_ENA: u1,

          /// [4:4] The interrupt enable bit for the LEDC_DUTY_CHNG_END_CH0_INT interrupt.
          DUTY_CHNG_END_CH0_INT_ENA: u1,

          /// [5:5] The interrupt enable bit for the LEDC_DUTY_CHNG_END_CH1_INT interrupt.
          DUTY_CHNG_END_CH1_INT_ENA: u1,

          /// [6:6] The interrupt enable bit for the LEDC_DUTY_CHNG_END_CH2_INT interrupt.
          DUTY_CHNG_END_CH2_INT_ENA: u1,

          /// [7:7] The interrupt enable bit for the LEDC_DUTY_CHNG_END_CH3_INT interrupt.
          DUTY_CHNG_END_CH3_INT_ENA: u1,

          /// [8:8] The interrupt enable bit for the LEDC_DUTY_CHNG_END_CH4_INT interrupt.
          DUTY_CHNG_END_CH4_INT_ENA: u1,

          /// [9:9] The interrupt enable bit for the LEDC_DUTY_CHNG_END_CH5_INT interrupt.
          DUTY_CHNG_END_CH5_INT_ENA: u1,

          /// [10:11] 
          res0: u2,

          /// [12:12] The interrupt enable bit for the LEDC_OVF_CNT_CH0_INT interrupt.
          OVF_CNT_CH0_INT_ENA: u1,

          /// [13:13] The interrupt enable bit for the LEDC_OVF_CNT_CH1_INT interrupt.
          OVF_CNT_CH1_INT_ENA: u1,

          /// [14:14] The interrupt enable bit for the LEDC_OVF_CNT_CH2_INT interrupt.
          OVF_CNT_CH2_INT_ENA: u1,

          /// [15:15] The interrupt enable bit for the LEDC_OVF_CNT_CH3_INT interrupt.
          OVF_CNT_CH3_INT_ENA: u1,

          /// [16:16] The interrupt enable bit for the LEDC_OVF_CNT_CH4_INT interrupt.
          OVF_CNT_CH4_INT_ENA: u1,

          /// [17:17] The interrupt enable bit for the LEDC_OVF_CNT_CH5_INT interrupt.
          OVF_CNT_CH5_INT_ENA: u1,

          /// [18:31] 
          res1: u14,

        }), @ptrFromInt(0x600070c8));

        /// Interrupt clear bits
        pub const INT_CLR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Set this bit to clear the LEDC_TIMER0_OVF_INT interrupt.
          TIMER0_OVF_INT_CLR: u1,

          /// [1:1] Set this bit to clear the LEDC_TIMER1_OVF_INT interrupt.
          TIMER1_OVF_INT_CLR: u1,

          /// [2:2] Set this bit to clear the LEDC_TIMER2_OVF_INT interrupt.
          TIMER2_OVF_INT_CLR: u1,

          /// [3:3] Set this bit to clear the LEDC_TIMER3_OVF_INT interrupt.
          TIMER3_OVF_INT_CLR: u1,

          /// [4:4] Set this bit to clear the LEDC_DUTY_CHNG_END_CH0_INT interrupt.
          DUTY_CHNG_END_CH0_INT_CLR: u1,

          /// [5:5] Set this bit to clear the LEDC_DUTY_CHNG_END_CH1_INT interrupt.
          DUTY_CHNG_END_CH1_INT_CLR: u1,

          /// [6:6] Set this bit to clear the LEDC_DUTY_CHNG_END_CH2_INT interrupt.
          DUTY_CHNG_END_CH2_INT_CLR: u1,

          /// [7:7] Set this bit to clear the LEDC_DUTY_CHNG_END_CH3_INT interrupt.
          DUTY_CHNG_END_CH3_INT_CLR: u1,

          /// [8:8] Set this bit to clear the LEDC_DUTY_CHNG_END_CH4_INT interrupt.
          DUTY_CHNG_END_CH4_INT_CLR: u1,

          /// [9:9] Set this bit to clear the LEDC_DUTY_CHNG_END_CH5_INT interrupt.
          DUTY_CHNG_END_CH5_INT_CLR: u1,

          /// [10:11] 
          res0: u2,

          /// [12:12] Set this bit to clear the LEDC_OVF_CNT_CH0_INT interrupt.
          OVF_CNT_CH0_INT_CLR: u1,

          /// [13:13] Set this bit to clear the LEDC_OVF_CNT_CH1_INT interrupt.
          OVF_CNT_CH1_INT_CLR: u1,

          /// [14:14] Set this bit to clear the LEDC_OVF_CNT_CH2_INT interrupt.
          OVF_CNT_CH2_INT_CLR: u1,

          /// [15:15] Set this bit to clear the LEDC_OVF_CNT_CH3_INT interrupt.
          OVF_CNT_CH3_INT_CLR: u1,

          /// [16:16] Set this bit to clear the LEDC_OVF_CNT_CH4_INT interrupt.
          OVF_CNT_CH4_INT_CLR: u1,

          /// [17:17] Set this bit to clear the LEDC_OVF_CNT_CH5_INT interrupt.
          OVF_CNT_CH5_INT_CLR: u1,

          /// [18:31] 
          res1: u14,

        }), @ptrFromInt(0x600070cc));

        /// Ledc ch%s gamma ram write register.
        pub const CH0_GAMMA_WR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Ledc ch%s gamma duty inc of current ram write address.This register is used to increase or decrease the duty of output signal on channel %s. 1: Increase0: Decrease.
          CH_GAMMA_DUTY_INC: u1,

          /// [1:10] Ledc ch%s gamma duty cycle of current ram write address.The duty will change every LEDC_CH%s_GAMMA_DUTY_CYCLE on channel %s.
          CH_GAMMA_DUTY_CYCLE: u10,

          /// [11:20] Ledc ch%s gamma scale of current ram write address.This register is used to configure the changing step scale of duty on channel %s.
          CH_GAMMA_SCALE: u10,

          /// [21:30] Ledc ch%s gamma duty num of current ram write address.This register is used to control the number of times the duty cycle will be changed.
          CH_GAMMA_DUTY_NUM: u10,

          /// [31:31] 
          res0: u1,

        }), @ptrFromInt(0x60007100));

        /// Ledc ch%s gamma ram write register.
        pub const CH1_GAMMA_WR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Ledc ch%s gamma duty inc of current ram write address.This register is used to increase or decrease the duty of output signal on channel %s. 1: Increase0: Decrease.
          CH_GAMMA_DUTY_INC: u1,

          /// [1:10] Ledc ch%s gamma duty cycle of current ram write address.The duty will change every LEDC_CH%s_GAMMA_DUTY_CYCLE on channel %s.
          CH_GAMMA_DUTY_CYCLE: u10,

          /// [11:20] Ledc ch%s gamma scale of current ram write address.This register is used to configure the changing step scale of duty on channel %s.
          CH_GAMMA_SCALE: u10,

          /// [21:30] Ledc ch%s gamma duty num of current ram write address.This register is used to control the number of times the duty cycle will be changed.
          CH_GAMMA_DUTY_NUM: u10,

          /// [31:31] 
          res0: u1,

        }), @ptrFromInt(0x60007104));

        /// Ledc ch%s gamma ram write register.
        pub const CH2_GAMMA_WR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Ledc ch%s gamma duty inc of current ram write address.This register is used to increase or decrease the duty of output signal on channel %s. 1: Increase0: Decrease.
          CH_GAMMA_DUTY_INC: u1,

          /// [1:10] Ledc ch%s gamma duty cycle of current ram write address.The duty will change every LEDC_CH%s_GAMMA_DUTY_CYCLE on channel %s.
          CH_GAMMA_DUTY_CYCLE: u10,

          /// [11:20] Ledc ch%s gamma scale of current ram write address.This register is used to configure the changing step scale of duty on channel %s.
          CH_GAMMA_SCALE: u10,

          /// [21:30] Ledc ch%s gamma duty num of current ram write address.This register is used to control the number of times the duty cycle will be changed.
          CH_GAMMA_DUTY_NUM: u10,

          /// [31:31] 
          res0: u1,

        }), @ptrFromInt(0x60007108));

        /// Ledc ch%s gamma ram write register.
        pub const CH3_GAMMA_WR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Ledc ch%s gamma duty inc of current ram write address.This register is used to increase or decrease the duty of output signal on channel %s. 1: Increase0: Decrease.
          CH_GAMMA_DUTY_INC: u1,

          /// [1:10] Ledc ch%s gamma duty cycle of current ram write address.The duty will change every LEDC_CH%s_GAMMA_DUTY_CYCLE on channel %s.
          CH_GAMMA_DUTY_CYCLE: u10,

          /// [11:20] Ledc ch%s gamma scale of current ram write address.This register is used to configure the changing step scale of duty on channel %s.
          CH_GAMMA_SCALE: u10,

          /// [21:30] Ledc ch%s gamma duty num of current ram write address.This register is used to control the number of times the duty cycle will be changed.
          CH_GAMMA_DUTY_NUM: u10,

          /// [31:31] 
          res0: u1,

        }), @ptrFromInt(0x6000710c));

        /// Ledc ch%s gamma ram write register.
        pub const CH4_GAMMA_WR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Ledc ch%s gamma duty inc of current ram write address.This register is used to increase or decrease the duty of output signal on channel %s. 1: Increase0: Decrease.
          CH_GAMMA_DUTY_INC: u1,

          /// [1:10] Ledc ch%s gamma duty cycle of current ram write address.The duty will change every LEDC_CH%s_GAMMA_DUTY_CYCLE on channel %s.
          CH_GAMMA_DUTY_CYCLE: u10,

          /// [11:20] Ledc ch%s gamma scale of current ram write address.This register is used to configure the changing step scale of duty on channel %s.
          CH_GAMMA_SCALE: u10,

          /// [21:30] Ledc ch%s gamma duty num of current ram write address.This register is used to control the number of times the duty cycle will be changed.
          CH_GAMMA_DUTY_NUM: u10,

          /// [31:31] 
          res0: u1,

        }), @ptrFromInt(0x60007110));

        /// Ledc ch%s gamma ram write register.
        pub const CH5_GAMMA_WR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Ledc ch%s gamma duty inc of current ram write address.This register is used to increase or decrease the duty of output signal on channel %s. 1: Increase0: Decrease.
          CH_GAMMA_DUTY_INC: u1,

          /// [1:10] Ledc ch%s gamma duty cycle of current ram write address.The duty will change every LEDC_CH%s_GAMMA_DUTY_CYCLE on channel %s.
          CH_GAMMA_DUTY_CYCLE: u10,

          /// [11:20] Ledc ch%s gamma scale of current ram write address.This register is used to configure the changing step scale of duty on channel %s.
          CH_GAMMA_SCALE: u10,

          /// [21:30] Ledc ch%s gamma duty num of current ram write address.This register is used to control the number of times the duty cycle will be changed.
          CH_GAMMA_DUTY_NUM: u10,

          /// [31:31] 
          res0: u1,

        }), @ptrFromInt(0x60007114));

        /// Ledc ch%s gamma ram write address register.
        pub const CH0_GAMMA_WR_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:3] Ledc ch%s gamma ram write address.
          CH_GAMMA_WR_ADDR: u4,

          /// [4:31] 
          res0: u28,

        }), @ptrFromInt(0x60007104));

        /// Ledc ch%s gamma ram write address register.
        pub const CH1_GAMMA_WR_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:3] Ledc ch%s gamma ram write address.
          CH_GAMMA_WR_ADDR: u4,

          /// [4:31] 
          res0: u28,

        }), @ptrFromInt(0x60007108));

        /// Ledc ch%s gamma ram write address register.
        pub const CH2_GAMMA_WR_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:3] Ledc ch%s gamma ram write address.
          CH_GAMMA_WR_ADDR: u4,

          /// [4:31] 
          res0: u28,

        }), @ptrFromInt(0x6000710c));

        /// Ledc ch%s gamma ram write address register.
        pub const CH3_GAMMA_WR_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:3] Ledc ch%s gamma ram write address.
          CH_GAMMA_WR_ADDR: u4,

          /// [4:31] 
          res0: u28,

        }), @ptrFromInt(0x60007110));

        /// Ledc ch%s gamma ram write address register.
        pub const CH4_GAMMA_WR_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:3] Ledc ch%s gamma ram write address.
          CH_GAMMA_WR_ADDR: u4,

          /// [4:31] 
          res0: u28,

        }), @ptrFromInt(0x60007114));

        /// Ledc ch%s gamma ram write address register.
        pub const CH5_GAMMA_WR_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:3] Ledc ch%s gamma ram write address.
          CH_GAMMA_WR_ADDR: u4,

          /// [4:31] 
          res0: u28,

        }), @ptrFromInt(0x60007118));

        /// Ledc ch%s gamma ram read address register.
        pub const CH0_GAMMA_RD_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:3] Ledc ch%s gamma ram read address.
          CH_GAMMA_RD_ADDR: u4,

          /// [4:31] 
          res0: u28,

        }), @ptrFromInt(0x60007108));

        /// Ledc ch%s gamma ram read address register.
        pub const CH1_GAMMA_RD_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:3] Ledc ch%s gamma ram read address.
          CH_GAMMA_RD_ADDR: u4,

          /// [4:31] 
          res0: u28,

        }), @ptrFromInt(0x6000710c));

        /// Ledc ch%s gamma ram read address register.
        pub const CH2_GAMMA_RD_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:3] Ledc ch%s gamma ram read address.
          CH_GAMMA_RD_ADDR: u4,

          /// [4:31] 
          res0: u28,

        }), @ptrFromInt(0x60007110));

        /// Ledc ch%s gamma ram read address register.
        pub const CH3_GAMMA_RD_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:3] Ledc ch%s gamma ram read address.
          CH_GAMMA_RD_ADDR: u4,

          /// [4:31] 
          res0: u28,

        }), @ptrFromInt(0x60007114));

        /// Ledc ch%s gamma ram read address register.
        pub const CH4_GAMMA_RD_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:3] Ledc ch%s gamma ram read address.
          CH_GAMMA_RD_ADDR: u4,

          /// [4:31] 
          res0: u28,

        }), @ptrFromInt(0x60007118));

        /// Ledc ch%s gamma ram read address register.
        pub const CH5_GAMMA_RD_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:3] Ledc ch%s gamma ram read address.
          CH_GAMMA_RD_ADDR: u4,

          /// [4:31] 
          res0: u28,

        }), @ptrFromInt(0x6000711c));

        /// Ledc ch%s gamma ram read data register.
        pub const CH0_GAMMA_RD_DATA = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:30] Ledc ch%s gamma ram read data.
          CH_GAMMA_RD_DATA: u31,

          /// [31:31] 
          res0: u1,

        }), @ptrFromInt(0x6000710c));

        /// Ledc ch%s gamma ram read data register.
        pub const CH1_GAMMA_RD_DATA = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:30] Ledc ch%s gamma ram read data.
          CH_GAMMA_RD_DATA: u31,

          /// [31:31] 
          res0: u1,

        }), @ptrFromInt(0x60007110));

        /// Ledc ch%s gamma ram read data register.
        pub const CH2_GAMMA_RD_DATA = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:30] Ledc ch%s gamma ram read data.
          CH_GAMMA_RD_DATA: u31,

          /// [31:31] 
          res0: u1,

        }), @ptrFromInt(0x60007114));

        /// Ledc ch%s gamma ram read data register.
        pub const CH3_GAMMA_RD_DATA = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:30] Ledc ch%s gamma ram read data.
          CH_GAMMA_RD_DATA: u31,

          /// [31:31] 
          res0: u1,

        }), @ptrFromInt(0x60007118));

        /// Ledc ch%s gamma ram read data register.
        pub const CH4_GAMMA_RD_DATA = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:30] Ledc ch%s gamma ram read data.
          CH_GAMMA_RD_DATA: u31,

          /// [31:31] 
          res0: u1,

        }), @ptrFromInt(0x6000711c));

        /// Ledc ch%s gamma ram read data register.
        pub const CH5_GAMMA_RD_DATA = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:30] Ledc ch%s gamma ram read data.
          CH_GAMMA_RD_DATA: u31,

          /// [31:31] 
          res0: u1,

        }), @ptrFromInt(0x60007120));

        /// Ledc ch%s gamma config register.
        pub const CH0_GAMMA_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:4] Ledc ch%s gamma entry num.
          CH_GAMMA_ENTRY_NUM: u5,

          /// [5:5] Ledc ch%s gamma pause, write 1 to pause.
          CH_GAMMA_PAUSE: u1,

          /// [6:6] Ledc ch%s gamma resume, write 1 to resume.
          CH_GAMMA_RESUME: u1,

          /// [7:31] 
          res0: u25,

        }), @ptrFromInt(0x60007180));

        /// Ledc ch%s gamma config register.
        pub const CH1_GAMMA_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:4] Ledc ch%s gamma entry num.
          CH_GAMMA_ENTRY_NUM: u5,

          /// [5:5] Ledc ch%s gamma pause, write 1 to pause.
          CH_GAMMA_PAUSE: u1,

          /// [6:6] Ledc ch%s gamma resume, write 1 to resume.
          CH_GAMMA_RESUME: u1,

          /// [7:31] 
          res0: u25,

        }), @ptrFromInt(0x60007184));

        /// Ledc ch%s gamma config register.
        pub const CH2_GAMMA_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:4] Ledc ch%s gamma entry num.
          CH_GAMMA_ENTRY_NUM: u5,

          /// [5:5] Ledc ch%s gamma pause, write 1 to pause.
          CH_GAMMA_PAUSE: u1,

          /// [6:6] Ledc ch%s gamma resume, write 1 to resume.
          CH_GAMMA_RESUME: u1,

          /// [7:31] 
          res0: u25,

        }), @ptrFromInt(0x60007188));

        /// Ledc ch%s gamma config register.
        pub const CH3_GAMMA_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:4] Ledc ch%s gamma entry num.
          CH_GAMMA_ENTRY_NUM: u5,

          /// [5:5] Ledc ch%s gamma pause, write 1 to pause.
          CH_GAMMA_PAUSE: u1,

          /// [6:6] Ledc ch%s gamma resume, write 1 to resume.
          CH_GAMMA_RESUME: u1,

          /// [7:31] 
          res0: u25,

        }), @ptrFromInt(0x6000718c));

        /// Ledc ch%s gamma config register.
        pub const CH4_GAMMA_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:4] Ledc ch%s gamma entry num.
          CH_GAMMA_ENTRY_NUM: u5,

          /// [5:5] Ledc ch%s gamma pause, write 1 to pause.
          CH_GAMMA_PAUSE: u1,

          /// [6:6] Ledc ch%s gamma resume, write 1 to resume.
          CH_GAMMA_RESUME: u1,

          /// [7:31] 
          res0: u25,

        }), @ptrFromInt(0x60007190));

        /// Ledc ch%s gamma config register.
        pub const CH5_GAMMA_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:4] Ledc ch%s gamma entry num.
          CH_GAMMA_ENTRY_NUM: u5,

          /// [5:5] Ledc ch%s gamma pause, write 1 to pause.
          CH_GAMMA_PAUSE: u1,

          /// [6:6] Ledc ch%s gamma resume, write 1 to resume.
          CH_GAMMA_RESUME: u1,

          /// [7:31] 
          res0: u25,

        }), @ptrFromInt(0x60007194));

        /// Ledc event task enable bit register0.
        pub const EVT_TASK_EN0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Ledc ch0 duty change end event enable register, write 1 to enable this event.
          EVT_DUTY_CHNG_END_CH0_EN: u1,

          /// [1:1] Ledc ch1 duty change end event enable register, write 1 to enable this event.
          EVT_DUTY_CHNG_END_CH1_EN: u1,

          /// [2:2] Ledc ch2 duty change end event enable register, write 1 to enable this event.
          EVT_DUTY_CHNG_END_CH2_EN: u1,

          /// [3:3] Ledc ch3 duty change end event enable register, write 1 to enable this event.
          EVT_DUTY_CHNG_END_CH3_EN: u1,

          /// [4:4] Ledc ch4 duty change end event enable register, write 1 to enable this event.
          EVT_DUTY_CHNG_END_CH4_EN: u1,

          /// [5:5] Ledc ch5 duty change end event enable register, write 1 to enable this event.
          EVT_DUTY_CHNG_END_CH5_EN: u1,

          /// [6:7] 
          res0: u2,

          /// [8:8] Ledc ch0 overflow count pulse event enable register, write 1 to enable this event.
          EVT_OVF_CNT_PLS_CH0_EN: u1,

          /// [9:9] Ledc ch1 overflow count pulse event enable register, write 1 to enable this event.
          EVT_OVF_CNT_PLS_CH1_EN: u1,

          /// [10:10] Ledc ch2 overflow count pulse event enable register, write 1 to enable this event.
          EVT_OVF_CNT_PLS_CH2_EN: u1,

          /// [11:11] Ledc ch3 overflow count pulse event enable register, write 1 to enable this event.
          EVT_OVF_CNT_PLS_CH3_EN: u1,

          /// [12:12] Ledc ch4 overflow count pulse event enable register, write 1 to enable this event.
          EVT_OVF_CNT_PLS_CH4_EN: u1,

          /// [13:13] Ledc ch5 overflow count pulse event enable register, write 1 to enable this event.
          EVT_OVF_CNT_PLS_CH5_EN: u1,

          /// [14:15] 
          res1: u2,

          /// [16:16] Ledc timer0 overflow event enable register, write 1 to enable this event.
          EVT_TIME_OVF_TIMER0_EN: u1,

          /// [17:17] Ledc timer1 overflow event enable register, write 1 to enable this event.
          EVT_TIME_OVF_TIMER1_EN: u1,

          /// [18:18] Ledc timer2 overflow event enable register, write 1 to enable this event.
          EVT_TIME_OVF_TIMER2_EN: u1,

          /// [19:19] Ledc timer3 overflow event enable register, write 1 to enable this event.
          EVT_TIME_OVF_TIMER3_EN: u1,

          /// [20:20] Ledc timer0 compare event enable register, write 1 to enable this event.
          EVT_TIME0_CMP_EN: u1,

          /// [21:21] Ledc timer1 compare event enable register, write 1 to enable this event.
          EVT_TIME1_CMP_EN: u1,

          /// [22:22] Ledc timer2 compare event enable register, write 1 to enable this event.
          EVT_TIME2_CMP_EN: u1,

          /// [23:23] Ledc timer3 compare event enable register, write 1 to enable this event.
          EVT_TIME3_CMP_EN: u1,

          /// [24:24] Ledc ch0 duty scale update task enable register, write 1 to enable this task.
          TASK_DUTY_SCALE_UPDATE_CH0_EN: u1,

          /// [25:25] Ledc ch1 duty scale update task enable register, write 1 to enable this task.
          TASK_DUTY_SCALE_UPDATE_CH1_EN: u1,

          /// [26:26] Ledc ch2 duty scale update task enable register, write 1 to enable this task.
          TASK_DUTY_SCALE_UPDATE_CH2_EN: u1,

          /// [27:27] Ledc ch3 duty scale update task enable register, write 1 to enable this task.
          TASK_DUTY_SCALE_UPDATE_CH3_EN: u1,

          /// [28:28] Ledc ch4 duty scale update task enable register, write 1 to enable this task.
          TASK_DUTY_SCALE_UPDATE_CH4_EN: u1,

          /// [29:29] Ledc ch5 duty scale update task enable register, write 1 to enable this task.
          TASK_DUTY_SCALE_UPDATE_CH5_EN: u1,

          /// [30:31] 
          res2: u2,

        }), @ptrFromInt(0x600071a0));

        /// Ledc event task enable bit register1.
        pub const EVT_TASK_EN1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Ledc timer0 res update task enable register, write 1 to enable this task.
          TASK_TIMER0_RES_UPDATE_EN: u1,

          /// [1:1] Ledc timer1 res update task enable register, write 1 to enable this task.
          TASK_TIMER1_RES_UPDATE_EN: u1,

          /// [2:2] Ledc timer2 res update task enable register, write 1 to enable this task.
          TASK_TIMER2_RES_UPDATE_EN: u1,

          /// [3:3] Ledc timer3 res update task enable register, write 1 to enable this task.
          TASK_TIMER3_RES_UPDATE_EN: u1,

          /// [4:4] Ledc timer0 capture task enable register, write 1 to enable this task.
          TASK_TIMER0_CAP_EN: u1,

          /// [5:5] Ledc timer1 capture task enable register, write 1 to enable this task.
          TASK_TIMER1_CAP_EN: u1,

          /// [6:6] Ledc timer2 capture task enable register, write 1 to enable this task.
          TASK_TIMER2_CAP_EN: u1,

          /// [7:7] Ledc timer3 capture task enable register, write 1 to enable this task.
          TASK_TIMER3_CAP_EN: u1,

          /// [8:8] Ledc ch0 signal out disable task enable register, write 1 to enable this task.
          TASK_SIG_OUT_DIS_CH0_EN: u1,

          /// [9:9] Ledc ch1 signal out disable task enable register, write 1 to enable this task.
          TASK_SIG_OUT_DIS_CH1_EN: u1,

          /// [10:10] Ledc ch2 signal out disable task enable register, write 1 to enable this task.
          TASK_SIG_OUT_DIS_CH2_EN: u1,

          /// [11:11] Ledc ch3 signal out disable task enable register, write 1 to enable this task.
          TASK_SIG_OUT_DIS_CH3_EN: u1,

          /// [12:12] Ledc ch4 signal out disable task enable register, write 1 to enable this task.
          TASK_SIG_OUT_DIS_CH4_EN: u1,

          /// [13:13] Ledc ch5 signal out disable task enable register, write 1 to enable this task.
          TASK_SIG_OUT_DIS_CH5_EN: u1,

          /// [14:15] 
          res0: u2,

          /// [16:16] Ledc ch0 overflow count reset task enable register, write 1 to enable this task.
          TASK_OVF_CNT_RST_CH0_EN: u1,

          /// [17:17] Ledc ch1 overflow count reset task enable register, write 1 to enable this task.
          TASK_OVF_CNT_RST_CH1_EN: u1,

          /// [18:18] Ledc ch2 overflow count reset task enable register, write 1 to enable this task.
          TASK_OVF_CNT_RST_CH2_EN: u1,

          /// [19:19] Ledc ch3 overflow count reset task enable register, write 1 to enable this task.
          TASK_OVF_CNT_RST_CH3_EN: u1,

          /// [20:20] Ledc ch4 overflow count reset task enable register, write 1 to enable this task.
          TASK_OVF_CNT_RST_CH4_EN: u1,

          /// [21:21] Ledc ch5 overflow count reset task enable register, write 1 to enable this task.
          TASK_OVF_CNT_RST_CH5_EN: u1,

          /// [22:23] 
          res1: u2,

          /// [24:24] Ledc timer0 reset task enable register, write 1 to enable this task.
          TASK_TIMER0_RST_EN: u1,

          /// [25:25] Ledc timer1 reset task enable register, write 1 to enable this task.
          TASK_TIMER1_RST_EN: u1,

          /// [26:26] Ledc timer2 reset task enable register, write 1 to enable this task.
          TASK_TIMER2_RST_EN: u1,

          /// [27:27] Ledc timer3 reset task enable register, write 1 to enable this task.
          TASK_TIMER3_RST_EN: u1,

          /// [28:28] Ledc timer0 pause resume task enable register, write 1 to enable this task.
          TASK_TIMER0_PAUSE_RESUME_EN: u1,

          /// [29:29] Ledc timer1 pause resume task enable register, write 1 to enable this task.
          TASK_TIMER1_PAUSE_RESUME_EN: u1,

          /// [30:30] Ledc timer2 pause resume task enable register, write 1 to enable this task.
          TASK_TIMER2_PAUSE_RESUME_EN: u1,

          /// [31:31] Ledc timer3 pause resume task enable register, write 1 to enable this task.
          TASK_TIMER3_PAUSE_RESUME_EN: u1,

        }), @ptrFromInt(0x600071a4));

        /// Ledc event task enable bit register2.
        pub const EVT_TASK_EN2 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Ledc ch0 gamma restart task enable register, write 1 to enable this task.
          TASK_GAMMA_RESTART_CH0_EN: u1,

          /// [1:1] Ledc ch1 gamma restart task enable register, write 1 to enable this task.
          TASK_GAMMA_RESTART_CH1_EN: u1,

          /// [2:2] Ledc ch2 gamma restart task enable register, write 1 to enable this task.
          TASK_GAMMA_RESTART_CH2_EN: u1,

          /// [3:3] Ledc ch3 gamma restart task enable register, write 1 to enable this task.
          TASK_GAMMA_RESTART_CH3_EN: u1,

          /// [4:4] Ledc ch4 gamma restart task enable register, write 1 to enable this task.
          TASK_GAMMA_RESTART_CH4_EN: u1,

          /// [5:5] Ledc ch5 gamma restart task enable register, write 1 to enable this task.
          TASK_GAMMA_RESTART_CH5_EN: u1,

          /// [6:7] 
          res0: u2,

          /// [8:8] Ledc ch0 gamma pause task enable register, write 1 to enable this task.
          TASK_GAMMA_PAUSE_CH0_EN: u1,

          /// [9:9] Ledc ch1 gamma pause task enable register, write 1 to enable this task.
          TASK_GAMMA_PAUSE_CH1_EN: u1,

          /// [10:10] Ledc ch2 gamma pause task enable register, write 1 to enable this task.
          TASK_GAMMA_PAUSE_CH2_EN: u1,

          /// [11:11] Ledc ch3 gamma pause task enable register, write 1 to enable this task.
          TASK_GAMMA_PAUSE_CH3_EN: u1,

          /// [12:12] Ledc ch4 gamma pause task enable register, write 1 to enable this task.
          TASK_GAMMA_PAUSE_CH4_EN: u1,

          /// [13:13] Ledc ch5 gamma pause task enable register, write 1 to enable this task.
          TASK_GAMMA_PAUSE_CH5_EN: u1,

          /// [14:15] 
          res1: u2,

          /// [16:16] Ledc ch0 gamma resume task enable register, write 1 to enable this task.
          TASK_GAMMA_RESUME_CH0_EN: u1,

          /// [17:17] Ledc ch1 gamma resume task enable register, write 1 to enable this task.
          TASK_GAMMA_RESUME_CH1_EN: u1,

          /// [18:18] Ledc ch2 gamma resume task enable register, write 1 to enable this task.
          TASK_GAMMA_RESUME_CH2_EN: u1,

          /// [19:19] Ledc ch3 gamma resume task enable register, write 1 to enable this task.
          TASK_GAMMA_RESUME_CH3_EN: u1,

          /// [20:20] Ledc ch4 gamma resume task enable register, write 1 to enable this task.
          TASK_GAMMA_RESUME_CH4_EN: u1,

          /// [21:21] Ledc ch5 gamma resume task enable register, write 1 to enable this task.
          TASK_GAMMA_RESUME_CH5_EN: u1,

          /// [22:31] 
          res2: u10,

        }), @ptrFromInt(0x600071a8));

        /// Ledc timer%s compare value register.
        pub const TIMER0_CMP = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:19] This register stores ledc timer%s compare value.
          TIMER_CMP: u20,

          /// [20:31] 
          res0: u12,

        }), @ptrFromInt(0x600071b0));

        /// Ledc timer%s compare value register.
        pub const TIMER1_CMP = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:19] This register stores ledc timer%s compare value.
          TIMER_CMP: u20,

          /// [20:31] 
          res0: u12,

        }), @ptrFromInt(0x600071b4));

        /// Ledc timer%s compare value register.
        pub const TIMER2_CMP = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:19] This register stores ledc timer%s compare value.
          TIMER_CMP: u20,

          /// [20:31] 
          res0: u12,

        }), @ptrFromInt(0x600071b8));

        /// Ledc timer%s compare value register.
        pub const TIMER3_CMP = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:19] This register stores ledc timer%s compare value.
          TIMER_CMP: u20,

          /// [20:31] 
          res0: u12,

        }), @ptrFromInt(0x600071bc));

        /// Ledc timer%s count value capture register.
        pub const TIMER0_CNT_CAP = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:19] This register stores ledc timer%s count value.
          TIMER_CNT_CAP: u20,

          /// [20:31] 
          res0: u12,

        }), @ptrFromInt(0x600071c0));

        /// Ledc timer%s count value capture register.
        pub const TIMER1_CNT_CAP = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:19] This register stores ledc timer%s count value.
          TIMER_CNT_CAP: u20,

          /// [20:31] 
          res0: u12,

        }), @ptrFromInt(0x600071c4));

        /// Ledc timer%s count value capture register.
        pub const TIMER2_CNT_CAP = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:19] This register stores ledc timer%s count value.
          TIMER_CNT_CAP: u20,

          /// [20:31] 
          res0: u12,

        }), @ptrFromInt(0x600071c8));

        /// Ledc timer%s count value capture register.
        pub const TIMER3_CNT_CAP = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:19] This register stores ledc timer%s count value.
          TIMER_CNT_CAP: u20,

          /// [20:31] 
          res0: u12,

        }), @ptrFromInt(0x600071cc));

        /// Global ledc configuration register
        pub const CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:1] This bit is used to select clock source for the 4 timers .2'd1: APB_CLK 2'd2: RTC8M_CLK 2'd3: XTAL_CLK
          APB_CLK_SEL: u2,

          /// [2:2] This bit is used to control clock.1'b1: Force clock on for gamma ram. 1'h0: Support clock only when application writes or read gamma ram.
          GAMMA_RAM_CLK_EN_CH0: u1,

          /// [3:3] This bit is used to control clock.1'b1: Force clock on for gamma ram. 1'h0: Support clock only when application writes or read gamma ram.
          GAMMA_RAM_CLK_EN_CH1: u1,

          /// [4:4] This bit is used to control clock.1'b1: Force clock on for gamma ram. 1'h0: Support clock only when application writes or read gamma ram.
          GAMMA_RAM_CLK_EN_CH2: u1,

          /// [5:5] This bit is used to control clock.1'b1: Force clock on for gamma ram. 1'h0: Support clock only when application writes or read gamma ram.
          GAMMA_RAM_CLK_EN_CH3: u1,

          /// [6:6] This bit is used to control clock.1'b1: Force clock on for gamma ram. 1'h0: Support clock only when application writes or read gamma ram.
          GAMMA_RAM_CLK_EN_CH4: u1,

          /// [7:7] This bit is used to control clock.1'b1: Force clock on for gamma ram. 1'h0: Support clock only when application writes or read gamma ram.
          GAMMA_RAM_CLK_EN_CH5: u1,

          /// [8:30] 
          res0: u23,

          /// [31:31] This bit is used to control clock.1'b1: Force clock on for register. 1'h0: Support clock only when application writes registers.
          CLK_EN: u1,

        }), @ptrFromInt(0x600071f0));

        /// Version control register
        pub const DATE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:27] This is the version control register.
          LEDC_DATE: u28,

          /// [28:31] 
          res0: u4,

        }), @ptrFromInt(0x600071fc));

      };

      /// LP_PERI Peripheral
      pub const LP_PERI = struct {

        /// need_des
        pub const CLK_EN = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:22] 
          res0: u23,

          /// [23:23] need_des
          LP_TOUCH_CK_EN: u1,

          /// [24:24] need_des
          RNG_CK_EN: u1,

          /// [25:25] need_des
          OTP_DBG_CK_EN: u1,

          /// [26:26] need_des
          LP_UART_CK_EN: u1,

          /// [27:27] need_des
          LP_IO_CK_EN: u1,

          /// [28:28] need_des
          LP_EXT_I2C_CK_EN: u1,

          /// [29:29] need_des
          LP_ANA_I2C_CK_EN: u1,

          /// [30:30] need_des
          EFUSE_CK_EN: u1,

          /// [31:31] need_des
          LP_CPU_CK_EN: u1,

        }), @ptrFromInt(0x600b2800));

        /// need_des
        pub const RESET_EN = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:22] 
          res0: u23,

          /// [23:23] need_des
          BUS_RESET_EN: u1,

          /// [24:24] need_des
          LP_TOUCH_RESET_EN: u1,

          /// [25:25] need_des
          OTP_DBG_RESET_EN: u1,

          /// [26:26] need_des
          LP_UART_RESET_EN: u1,

          /// [27:27] need_des
          LP_IO_RESET_EN: u1,

          /// [28:28] need_des
          LP_EXT_I2C_RESET_EN: u1,

          /// [29:29] need_des
          LP_ANA_I2C_RESET_EN: u1,

          /// [30:30] need_des
          EFUSE_RESET_EN: u1,

          /// [31:31] need_des
          LP_CPU_RESET_EN: u1,

        }), @ptrFromInt(0x600b2804));

        /// need_des
        pub const RNG_DATA = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] need_des
          RND_DATA: u32,

        }), @ptrFromInt(0x600b2808));

        /// need_des
        pub const CPU = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:30] 
          res0: u31,

          /// [31:31] need_des
          LPCORE_DBGM_UNAVALIABLE: u1,

        }), @ptrFromInt(0x600b280c));

        /// need_des
        pub const BUS_TIMEOUT = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:13] 
          res0: u14,

          /// [14:29] need_des
          LP_PERI_TIMEOUT_THRES: u16,

          /// [30:30] need_des
          LP_PERI_TIMEOUT_INT_CLEAR: u1,

          /// [31:31] need_des
          LP_PERI_TIMEOUT_PROTECT_EN: u1,

        }), @ptrFromInt(0x600b2810));

        /// need_des
        pub const BUS_TIMEOUT_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] need_des
          LP_PERI_TIMEOUT_ADDR: u32,

        }), @ptrFromInt(0x600b2814));

        /// need_des
        pub const BUS_TIMEOUT_UID = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:6] need_des
          LP_PERI_TIMEOUT_UID: u7,

          /// [7:31] 
          res0: u25,

        }), @ptrFromInt(0x600b2818));

        /// need_des
        pub const MEM_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] need_des
          UART_WAKEUP_FLAG_CLR: u1,

          /// [1:1] need_des
          UART_WAKEUP_FLAG: u1,

          /// [2:28] 
          res0: u27,

          /// [29:29] need_des
          UART_WAKEUP_EN: u1,

          /// [30:30] need_des
          UART_MEM_FORCE_PD: u1,

          /// [31:31] need_des
          UART_MEM_FORCE_PU: u1,

        }), @ptrFromInt(0x600b281c));

        /// need_des
        pub const INTERRUPT_SOURCE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] BIT5~BIT0: pmu_lp_int, modem_lp_int, lp_timer_lp_int, lp_uart_int, lp_i2c_int, lp_io_int
          LP_INTERRUPT_SOURCE: u6,

          /// [6:31] 
          res0: u26,

        }), @ptrFromInt(0x600b2820));

        /// need_des
        pub const DATE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:30] need_des
          LPPERI_DATE: u31,

          /// [31:31] need_des
          CLK_EN: u1,

        }), @ptrFromInt(0x600b2bfc));

      };

      /// LP_ANA Peripheral
      pub const LP_ANA = struct {

        /// need_des
        pub const BOD_MODE0_CNTL = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] 
          res0: u6,

          /// [6:6] need_des
          BOD_MODE0_CLOSE_FLASH_ENA: u1,

          /// [7:7] need_des
          BOD_MODE0_PD_RF_ENA: u1,

          /// [8:17] need_des
          BOD_MODE0_INTR_WAIT: u10,

          /// [18:27] need_des
          BOD_MODE0_RESET_WAIT: u10,

          /// [28:28] need_des
          BOD_MODE0_CNT_CLR: u1,

          /// [29:29] need_des
          BOD_MODE0_INTR_ENA: u1,

          /// [30:30] need_des
          BOD_MODE0_RESET_SEL: u1,

          /// [31:31] need_des
          BOD_MODE0_RESET_ENA: u1,

        }), @ptrFromInt(0x600b2c00));

        /// need_des
        pub const BOD_MODE1_CNTL = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:30] 
          res0: u31,

          /// [31:31] need_des
          BOD_MODE1_RESET_ENA: u1,

        }), @ptrFromInt(0x600b2c04));

        /// need_des
        pub const CK_GLITCH_CNTL = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:30] 
          res0: u31,

          /// [31:31] need_des
          CK_GLITCH_RESET_ENA: u1,

        }), @ptrFromInt(0x600b2c08));

        /// need_des
        pub const FIB_ENABLE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] need_des
          ANA_FIB_ENA: u32,

        }), @ptrFromInt(0x600b2c0c));

        /// need_des
        pub const INT_RAW = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:30] 
          res0: u31,

          /// [31:31] need_des
          BOD_MODE0_INT_RAW: u1,

        }), @ptrFromInt(0x600b2c10));

        /// need_des
        pub const INT_ST = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:30] 
          res0: u31,

          /// [31:31] need_des
          BOD_MODE0_INT_ST: u1,

        }), @ptrFromInt(0x600b2c14));

        /// need_des
        pub const INT_ENA = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:30] 
          res0: u31,

          /// [31:31] need_des
          BOD_MODE0_INT_ENA: u1,

        }), @ptrFromInt(0x600b2c18));

        /// need_des
        pub const INT_CLR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:30] 
          res0: u31,

          /// [31:31] need_des
          BOD_MODE0_INT_CLR: u1,

        }), @ptrFromInt(0x600b2c1c));

        /// need_des
        pub const LP_INT_RAW = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:30] 
          res0: u31,

          /// [31:31] need_des
          BOD_MODE0_LP_INT_RAW: u1,

        }), @ptrFromInt(0x600b2c20));

        /// need_des
        pub const LP_INT_ST = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:30] 
          res0: u31,

          /// [31:31] need_des
          BOD_MODE0_LP_INT_ST: u1,

        }), @ptrFromInt(0x600b2c24));

        /// need_des
        pub const LP_INT_ENA = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:30] 
          res0: u31,

          /// [31:31] need_des
          BOD_MODE0_LP_INT_ENA: u1,

        }), @ptrFromInt(0x600b2c28));

        /// need_des
        pub const LP_INT_CLR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:30] 
          res0: u31,

          /// [31:31] need_des
          BOD_MODE0_LP_INT_CLR: u1,

        }), @ptrFromInt(0x600b2c2c));

        /// need_des
        pub const DATE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:30] need_des
          LP_ANA_DATE: u31,

          /// [31:31] need_des
          CLK_EN: u1,

        }), @ptrFromInt(0x600b2ffc));

      };

      /// LP_AON Peripheral
      pub const LP_AON = struct {

        /// need_des
        pub const STORE0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] need_des
          LP_AON_STORE0: u32,

        }), @ptrFromInt(0x600b1000));

        /// need_des
        pub const STORE1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] need_des
          LP_AON_STORE1: u32,

        }), @ptrFromInt(0x600b1004));

        /// need_des
        pub const STORE2 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] need_des
          LP_AON_STORE2: u32,

        }), @ptrFromInt(0x600b1008));

        /// need_des
        pub const STORE3 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] need_des
          LP_AON_STORE3: u32,

        }), @ptrFromInt(0x600b100c));

        /// need_des
        pub const STORE4 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] need_des
          LP_AON_STORE4: u32,

        }), @ptrFromInt(0x600b1010));

        /// need_des
        pub const STORE5 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] need_des
          LP_AON_STORE5: u32,

        }), @ptrFromInt(0x600b1014));

        /// need_des
        pub const STORE6 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] need_des
          LP_AON_STORE6: u32,

        }), @ptrFromInt(0x600b1018));

        /// need_des
        pub const STORE7 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] need_des
          LP_AON_STORE7: u32,

        }), @ptrFromInt(0x600b101c));

        /// need_des
        pub const STORE8 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] need_des
          LP_AON_STORE8: u32,

        }), @ptrFromInt(0x600b1020));

        /// need_des
        pub const STORE9 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] need_des
          LP_AON_STORE9: u32,

        }), @ptrFromInt(0x600b1024));

        /// need_des
        pub const GPIO_MUX = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] need_des
          SEL: u8,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x600b1028));

        /// need_des
        pub const GPIO_HOLD0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] need_des
          GPIO_HOLD0: u32,

        }), @ptrFromInt(0x600b102c));

        /// need_des
        pub const GPIO_HOLD1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] need_des
          GPIO_HOLD1: u32,

        }), @ptrFromInt(0x600b1030));

        /// need_des
        pub const SYS_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:29] 
          res0: u30,

          /// [30:30] need_des
          FORCE_DOWNLOAD_BOOT: u1,

          /// [31:31] need_des
          HPSYS_SW_RESET: u1,

        }), @ptrFromInt(0x600b1034));

        /// need_des
        pub const CPUCORE0_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] need_des
          CPU_CORE0_SW_STALL: u8,

          /// [8:27] 
          res0: u20,

          /// [28:28] need_des
          CPU_CORE0_SW_RESET: u1,

          /// [29:29] need_des
          CPU_CORE0_OCD_HALT_ON_RESET: u1,

          /// [30:30] need_des
          CPU_CORE0_STAT_VECTOR_SEL: u1,

          /// [31:31] need_des
          CPU_CORE0_DRESET_MASK: u1,

        }), @ptrFromInt(0x600b1038));

        /// need_des
        pub const IO_MUX = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:30] 
          res0: u31,

          /// [31:31] need_des
          RESET_DISABLE: u1,

        }), @ptrFromInt(0x600b103c));

        /// need_des
        pub const EXT_WAKEUP_CNTL = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] need_des
          EXT_WAKEUP_STATUS: u8,

          /// [8:13] 
          res0: u6,

          /// [14:14] need_des
          EXT_WAKEUP_STATUS_CLR: u1,

          /// [15:22] need_des
          EXT_WAKEUP_SEL: u8,

          /// [23:30] need_des
          EXT_WAKEUP_LV: u8,

          /// [31:31] need_des
          EXT_WAKEUP_FILTER: u1,

        }), @ptrFromInt(0x600b1040));

        /// need_des
        pub const USB = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:30] 
          res0: u31,

          /// [31:31] need_des
          RESET_DISABLE: u1,

        }), @ptrFromInt(0x600b1044));

        /// need_des
        pub const LPBUS = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:15] 
          res0: u16,

          /// [16:18] This field controls fast memory WPULSE parameter.
          FAST_MEM_WPULSE: u3,

          /// [19:21] This field controls fast memory WA parameter.
          FAST_MEM_WA: u3,

          /// [22:23] This field controls fast memory RA parameter.
          FAST_MEM_RA: u2,

          /// [24:27] 
          res1: u4,

          /// [28:28] need_des
          FAST_MEM_MUX_FSM_IDLE: u1,

          /// [29:29] need_des
          FAST_MEM_MUX_SEL_STATUS: u1,

          /// [30:30] need_des
          FAST_MEM_MUX_SEL_UPDATE: u1,

          /// [31:31] need_des
          FAST_MEM_MUX_SEL: u1,

        }), @ptrFromInt(0x600b1048));

        /// need_des
        pub const SDIO_ACTIVE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:21] 
          res0: u22,

          /// [22:31] need_des
          SDIO_ACT_DNUM: u10,

        }), @ptrFromInt(0x600b104c));

        /// need_des
        pub const LPCORE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] need_des
          ETM_WAKEUP_FLAG_CLR: u1,

          /// [1:1] need_des
          ETM_WAKEUP_FLAG: u1,

          /// [2:30] 
          res0: u29,

          /// [31:31] need_des
          DISABLE: u1,

        }), @ptrFromInt(0x600b1050));

        /// need_des
        pub const SAR_CCT = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:28] 
          res0: u29,

          /// [29:31] need_des
          SAR2_PWDET_CCT: u3,

        }), @ptrFromInt(0x600b1054));

        /// need_des
        pub const DATE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:30] need_des
          DATE: u31,

          /// [31:31] need_des
          CLK_EN: u1,

        }), @ptrFromInt(0x600b13fc));

      };

      /// Low-power Access Permission Management Controller
      pub const LP_APM = struct {

        /// Region filter enable register
        pub const REGION_FILTER_EN = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:3] Region filter enable
          REGION_FILTER_EN: u4,

          /// [4:31] 
          res0: u28,

        }), @ptrFromInt(0x600b3800));

        /// Region address register
        pub const REGION0_ADDR_START = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Start address of region0
          REGION0_ADDR_START: u32,

        }), @ptrFromInt(0x600b3804));

        /// Region address register
        pub const REGION0_ADDR_END = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] End address of region0
          REGION0_ADDR_END: u32,

        }), @ptrFromInt(0x600b3808));

        /// Region access authority attribute register
        pub const REGION0_PMS_ATTR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Region execute authority in REE_MODE0
          REGION0_R0_PMS_X: u1,

          /// [1:1] Region write authority in REE_MODE0
          REGION0_R0_PMS_W: u1,

          /// [2:2] Region read authority in REE_MODE0
          REGION0_R0_PMS_R: u1,

          /// [3:3] 
          res0: u1,

          /// [4:4] Region execute authority in REE_MODE1
          REGION0_R1_PMS_X: u1,

          /// [5:5] Region write authority in REE_MODE1
          REGION0_R1_PMS_W: u1,

          /// [6:6] Region read authority in REE_MODE1
          REGION0_R1_PMS_R: u1,

          /// [7:7] 
          res1: u1,

          /// [8:8] Region execute authority in REE_MODE2
          REGION0_R2_PMS_X: u1,

          /// [9:9] Region write authority in REE_MODE2
          REGION0_R2_PMS_W: u1,

          /// [10:10] Region read authority in REE_MODE2
          REGION0_R2_PMS_R: u1,

          /// [11:31] 
          res2: u21,

        }), @ptrFromInt(0x600b380c));

        /// Region address register
        pub const REGION1_ADDR_START = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Start address of region1
          REGION1_ADDR_START: u32,

        }), @ptrFromInt(0x600b3810));

        /// Region address register
        pub const REGION1_ADDR_END = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] End address of region1
          REGION1_ADDR_END: u32,

        }), @ptrFromInt(0x600b3814));

        /// Region access authority attribute register
        pub const REGION1_PMS_ATTR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Region execute authority in REE_MODE0
          REGION1_R0_PMS_X: u1,

          /// [1:1] Region write authority in REE_MODE0
          REGION1_R0_PMS_W: u1,

          /// [2:2] Region read authority in REE_MODE0
          REGION1_R0_PMS_R: u1,

          /// [3:3] 
          res0: u1,

          /// [4:4] Region execute authority in REE_MODE1
          REGION1_R1_PMS_X: u1,

          /// [5:5] Region write authority in REE_MODE1
          REGION1_R1_PMS_W: u1,

          /// [6:6] Region read authority in REE_MODE1
          REGION1_R1_PMS_R: u1,

          /// [7:7] 
          res1: u1,

          /// [8:8] Region execute authority in REE_MODE2
          REGION1_R2_PMS_X: u1,

          /// [9:9] Region write authority in REE_MODE2
          REGION1_R2_PMS_W: u1,

          /// [10:10] Region read authority in REE_MODE2
          REGION1_R2_PMS_R: u1,

          /// [11:31] 
          res2: u21,

        }), @ptrFromInt(0x600b3818));

        /// Region address register
        pub const REGION2_ADDR_START = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Start address of region2
          REGION2_ADDR_START: u32,

        }), @ptrFromInt(0x600b381c));

        /// Region address register
        pub const REGION2_ADDR_END = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] End address of region2
          REGION2_ADDR_END: u32,

        }), @ptrFromInt(0x600b3820));

        /// Region access authority attribute register
        pub const REGION2_PMS_ATTR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Region execute authority in REE_MODE0
          REGION2_R0_PMS_X: u1,

          /// [1:1] Region write authority in REE_MODE0
          REGION2_R0_PMS_W: u1,

          /// [2:2] Region read authority in REE_MODE0
          REGION2_R0_PMS_R: u1,

          /// [3:3] 
          res0: u1,

          /// [4:4] Region execute authority in REE_MODE1
          REGION2_R1_PMS_X: u1,

          /// [5:5] Region write authority in REE_MODE1
          REGION2_R1_PMS_W: u1,

          /// [6:6] Region read authority in REE_MODE1
          REGION2_R1_PMS_R: u1,

          /// [7:7] 
          res1: u1,

          /// [8:8] Region execute authority in REE_MODE2
          REGION2_R2_PMS_X: u1,

          /// [9:9] Region write authority in REE_MODE2
          REGION2_R2_PMS_W: u1,

          /// [10:10] Region read authority in REE_MODE2
          REGION2_R2_PMS_R: u1,

          /// [11:31] 
          res2: u21,

        }), @ptrFromInt(0x600b3824));

        /// Region address register
        pub const REGION3_ADDR_START = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Start address of region3
          REGION3_ADDR_START: u32,

        }), @ptrFromInt(0x600b3828));

        /// Region address register
        pub const REGION3_ADDR_END = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] End address of region3
          REGION3_ADDR_END: u32,

        }), @ptrFromInt(0x600b382c));

        /// Region access authority attribute register
        pub const REGION3_PMS_ATTR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Region execute authority in REE_MODE0
          REGION3_R0_PMS_X: u1,

          /// [1:1] Region write authority in REE_MODE0
          REGION3_R0_PMS_W: u1,

          /// [2:2] Region read authority in REE_MODE0
          REGION3_R0_PMS_R: u1,

          /// [3:3] 
          res0: u1,

          /// [4:4] Region execute authority in REE_MODE1
          REGION3_R1_PMS_X: u1,

          /// [5:5] Region write authority in REE_MODE1
          REGION3_R1_PMS_W: u1,

          /// [6:6] Region read authority in REE_MODE1
          REGION3_R1_PMS_R: u1,

          /// [7:7] 
          res1: u1,

          /// [8:8] Region execute authority in REE_MODE2
          REGION3_R2_PMS_X: u1,

          /// [9:9] Region write authority in REE_MODE2
          REGION3_R2_PMS_W: u1,

          /// [10:10] Region read authority in REE_MODE2
          REGION3_R2_PMS_R: u1,

          /// [11:31] 
          res2: u21,

        }), @ptrFromInt(0x600b3830));

        /// PMS function control register
        pub const FUNC_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] PMS M0 function enable
          M0_PMS_FUNC_EN: u1,

          /// [1:1] PMS M1 function enable
          M1_PMS_FUNC_EN: u1,

          /// [2:31] 
          res0: u30,

        }), @ptrFromInt(0x600b38c4));

        /// M0 status register
        pub const M0_STATUS = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:1] Exception status
          M0_EXCEPTION_STATUS: u2,

          /// [2:31] 
          res0: u30,

        }), @ptrFromInt(0x600b38c8));

        /// M0 status clear register
        pub const M0_STATUS_CLR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Clear exception status
          M0_REGION_STATUS_CLR: u1,

          /// [1:31] 
          res0: u31,

        }), @ptrFromInt(0x600b38cc));

        /// M0 exception_info0 register
        pub const M0_EXCEPTION_INFO0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:3] Exception region
          M0_EXCEPTION_REGION: u4,

          /// [4:15] 
          res0: u12,

          /// [16:17] Exception mode
          M0_EXCEPTION_MODE: u2,

          /// [18:22] Exception id information
          M0_EXCEPTION_ID: u5,

          /// [23:31] 
          res1: u9,

        }), @ptrFromInt(0x600b38d0));

        /// M0 exception_info1 register
        pub const M0_EXCEPTION_INFO1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Exception addr
          M0_EXCEPTION_ADDR: u32,

        }), @ptrFromInt(0x600b38d4));

        /// M1 status register
        pub const M1_STATUS = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:1] Exception status
          M1_EXCEPTION_STATUS: u2,

          /// [2:31] 
          res0: u30,

        }), @ptrFromInt(0x600b38d8));

        /// M1 status clear register
        pub const M1_STATUS_CLR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Clear exception status
          M1_REGION_STATUS_CLR: u1,

          /// [1:31] 
          res0: u31,

        }), @ptrFromInt(0x600b38dc));

        /// M1 exception_info0 register
        pub const M1_EXCEPTION_INFO0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:3] Exception region
          M1_EXCEPTION_REGION: u4,

          /// [4:15] 
          res0: u12,

          /// [16:17] Exception mode
          M1_EXCEPTION_MODE: u2,

          /// [18:22] Exception id information
          M1_EXCEPTION_ID: u5,

          /// [23:31] 
          res1: u9,

        }), @ptrFromInt(0x600b38e0));

        /// M1 exception_info1 register
        pub const M1_EXCEPTION_INFO1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Exception addr
          M1_EXCEPTION_ADDR: u32,

        }), @ptrFromInt(0x600b38e4));

        /// APM interrupt enable register
        pub const INT_EN = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] APM M0 interrupt enable
          M0_APM_INT_EN: u1,

          /// [1:1] APM M1 interrupt enable
          M1_APM_INT_EN: u1,

          /// [2:31] 
          res0: u30,

        }), @ptrFromInt(0x600b38e8));

        /// clock gating register
        pub const CLOCK_GATE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] reg_clk_en
          CLK_EN: u1,

          /// [1:31] 
          res0: u31,

        }), @ptrFromInt(0x600b38ec));

        /// Version register
        pub const DATE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:27] reg_date
          DATE: u28,

          /// [28:31] 
          res0: u4,

        }), @ptrFromInt(0x600b38fc));

      };

      /// LP_APM0 Peripheral
      pub const LP_APM0 = struct {

        /// Region filter enable register
        pub const REGION_FILTER_EN = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:3] Region filter enable
          REGION_FILTER_EN: u4,

          /// [4:31] 
          res0: u28,

        }), @ptrFromInt(0x60099800));

        /// Region address register
        pub const REGION0_ADDR_START = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Start address of region0
          REGION0_ADDR_START: u32,

        }), @ptrFromInt(0x60099804));

        /// Region address register
        pub const REGION0_ADDR_END = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] End address of region0
          REGION0_ADDR_END: u32,

        }), @ptrFromInt(0x60099808));

        /// Region access authority attribute register
        pub const REGION0_PMS_ATTR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Region execute authority in REE_MODE0
          REGION0_R0_PMS_X: u1,

          /// [1:1] Region write authority in REE_MODE0
          REGION0_R0_PMS_W: u1,

          /// [2:2] Region read authority in REE_MODE0
          REGION0_R0_PMS_R: u1,

          /// [3:3] 
          res0: u1,

          /// [4:4] Region execute authority in REE_MODE1
          REGION0_R1_PMS_X: u1,

          /// [5:5] Region write authority in REE_MODE1
          REGION0_R1_PMS_W: u1,

          /// [6:6] Region read authority in REE_MODE1
          REGION0_R1_PMS_R: u1,

          /// [7:7] 
          res1: u1,

          /// [8:8] Region execute authority in REE_MODE2
          REGION0_R2_PMS_X: u1,

          /// [9:9] Region write authority in REE_MODE2
          REGION0_R2_PMS_W: u1,

          /// [10:10] Region read authority in REE_MODE2
          REGION0_R2_PMS_R: u1,

          /// [11:31] 
          res2: u21,

        }), @ptrFromInt(0x6009980c));

        /// Region address register
        pub const REGION1_ADDR_START = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Start address of region1
          REGION1_ADDR_START: u32,

        }), @ptrFromInt(0x60099810));

        /// Region address register
        pub const REGION1_ADDR_END = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] End address of region1
          REGION1_ADDR_END: u32,

        }), @ptrFromInt(0x60099814));

        /// Region access authority attribute register
        pub const REGION1_PMS_ATTR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Region execute authority in REE_MODE0
          REGION1_R0_PMS_X: u1,

          /// [1:1] Region write authority in REE_MODE0
          REGION1_R0_PMS_W: u1,

          /// [2:2] Region read authority in REE_MODE0
          REGION1_R0_PMS_R: u1,

          /// [3:3] 
          res0: u1,

          /// [4:4] Region execute authority in REE_MODE1
          REGION1_R1_PMS_X: u1,

          /// [5:5] Region write authority in REE_MODE1
          REGION1_R1_PMS_W: u1,

          /// [6:6] Region read authority in REE_MODE1
          REGION1_R1_PMS_R: u1,

          /// [7:7] 
          res1: u1,

          /// [8:8] Region execute authority in REE_MODE2
          REGION1_R2_PMS_X: u1,

          /// [9:9] Region write authority in REE_MODE2
          REGION1_R2_PMS_W: u1,

          /// [10:10] Region read authority in REE_MODE2
          REGION1_R2_PMS_R: u1,

          /// [11:31] 
          res2: u21,

        }), @ptrFromInt(0x60099818));

        /// Region address register
        pub const REGION2_ADDR_START = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Start address of region2
          REGION2_ADDR_START: u32,

        }), @ptrFromInt(0x6009981c));

        /// Region address register
        pub const REGION2_ADDR_END = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] End address of region2
          REGION2_ADDR_END: u32,

        }), @ptrFromInt(0x60099820));

        /// Region access authority attribute register
        pub const REGION2_PMS_ATTR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Region execute authority in REE_MODE0
          REGION2_R0_PMS_X: u1,

          /// [1:1] Region write authority in REE_MODE0
          REGION2_R0_PMS_W: u1,

          /// [2:2] Region read authority in REE_MODE0
          REGION2_R0_PMS_R: u1,

          /// [3:3] 
          res0: u1,

          /// [4:4] Region execute authority in REE_MODE1
          REGION2_R1_PMS_X: u1,

          /// [5:5] Region write authority in REE_MODE1
          REGION2_R1_PMS_W: u1,

          /// [6:6] Region read authority in REE_MODE1
          REGION2_R1_PMS_R: u1,

          /// [7:7] 
          res1: u1,

          /// [8:8] Region execute authority in REE_MODE2
          REGION2_R2_PMS_X: u1,

          /// [9:9] Region write authority in REE_MODE2
          REGION2_R2_PMS_W: u1,

          /// [10:10] Region read authority in REE_MODE2
          REGION2_R2_PMS_R: u1,

          /// [11:31] 
          res2: u21,

        }), @ptrFromInt(0x60099824));

        /// Region address register
        pub const REGION3_ADDR_START = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Start address of region3
          REGION3_ADDR_START: u32,

        }), @ptrFromInt(0x60099828));

        /// Region address register
        pub const REGION3_ADDR_END = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] End address of region3
          REGION3_ADDR_END: u32,

        }), @ptrFromInt(0x6009982c));

        /// Region access authority attribute register
        pub const REGION3_PMS_ATTR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Region execute authority in REE_MODE0
          REGION3_R0_PMS_X: u1,

          /// [1:1] Region write authority in REE_MODE0
          REGION3_R0_PMS_W: u1,

          /// [2:2] Region read authority in REE_MODE0
          REGION3_R0_PMS_R: u1,

          /// [3:3] 
          res0: u1,

          /// [4:4] Region execute authority in REE_MODE1
          REGION3_R1_PMS_X: u1,

          /// [5:5] Region write authority in REE_MODE1
          REGION3_R1_PMS_W: u1,

          /// [6:6] Region read authority in REE_MODE1
          REGION3_R1_PMS_R: u1,

          /// [7:7] 
          res1: u1,

          /// [8:8] Region execute authority in REE_MODE2
          REGION3_R2_PMS_X: u1,

          /// [9:9] Region write authority in REE_MODE2
          REGION3_R2_PMS_W: u1,

          /// [10:10] Region read authority in REE_MODE2
          REGION3_R2_PMS_R: u1,

          /// [11:31] 
          res2: u21,

        }), @ptrFromInt(0x60099830));

        /// PMS function control register
        pub const FUNC_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] PMS M0 function enable
          M0_PMS_FUNC_EN: u1,

          /// [1:31] 
          res0: u31,

        }), @ptrFromInt(0x600998c4));

        /// M0 status register
        pub const M0_STATUS = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:1] Exception status
          M0_EXCEPTION_STATUS: u2,

          /// [2:31] 
          res0: u30,

        }), @ptrFromInt(0x600998c8));

        /// M0 status clear register
        pub const M0_STATUS_CLR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Clear exception status
          M0_REGION_STATUS_CLR: u1,

          /// [1:31] 
          res0: u31,

        }), @ptrFromInt(0x600998cc));

        /// M0 exception_info0 register
        pub const M0_EXCEPTION_INFO0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:3] Exception region
          M0_EXCEPTION_REGION: u4,

          /// [4:15] 
          res0: u12,

          /// [16:17] Exception mode
          M0_EXCEPTION_MODE: u2,

          /// [18:22] Exception id information
          M0_EXCEPTION_ID: u5,

          /// [23:31] 
          res1: u9,

        }), @ptrFromInt(0x600998d0));

        /// M0 exception_info1 register
        pub const M0_EXCEPTION_INFO1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Exception addr
          M0_EXCEPTION_ADDR: u32,

        }), @ptrFromInt(0x600998d4));

        /// APM interrupt enable register
        pub const INT_EN = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] APM M0 interrupt enable
          M0_APM_INT_EN: u1,

          /// [1:31] 
          res0: u31,

        }), @ptrFromInt(0x600998d8));

        /// clock gating register
        pub const CLOCK_GATE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] reg_clk_en
          CLK_EN: u1,

          /// [1:31] 
          res0: u31,

        }), @ptrFromInt(0x600998dc));

        /// Version register
        pub const DATE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:27] reg_date
          DATE: u28,

          /// [28:31] 
          res0: u4,

        }), @ptrFromInt(0x60099ffc));

      };

      /// LP_CLKRST Peripheral
      pub const LP_CLKRST = struct {

        /// need_des
        pub const LP_CLK_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:1] need_des
          SLOW_CLK_SEL: u2,

          /// [2:2] need_des
          FAST_CLK_SEL: u1,

          /// [3:10] need_des
          LP_PERI_DIV_NUM: u8,

          /// [11:31] 
          res0: u21,

        }), @ptrFromInt(0x600b0400));

        /// need_des
        pub const LP_CLK_PO_EN = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] need_des
          AON_SLOW_OEN: u1,

          /// [1:1] need_des
          AON_FAST_OEN: u1,

          /// [2:2] need_des
          SOSC_OEN: u1,

          /// [3:3] need_des
          FOSC_OEN: u1,

          /// [4:4] need_des
          OSC32K_OEN: u1,

          /// [5:5] need_des
          XTAL32K_OEN: u1,

          /// [6:6] need_des
          CORE_EFUSE_OEN: u1,

          /// [7:7] need_des
          SLOW_OEN: u1,

          /// [8:8] need_des
          FAST_OEN: u1,

          /// [9:9] need_des
          RNG_OEN: u1,

          /// [10:10] need_des
          LPBUS_OEN: u1,

          /// [11:31] 
          res0: u21,

        }), @ptrFromInt(0x600b0404));

        /// need_des
        pub const LP_CLK_EN = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:30] 
          res0: u31,

          /// [31:31] need_des
          FAST_ORI_GATE: u1,

        }), @ptrFromInt(0x600b0408));

        /// need_des
        pub const LP_RST_EN = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:27] 
          res0: u28,

          /// [28:28] need_des
          AON_EFUSE_CORE_RESET_EN: u1,

          /// [29:29] need_des
          LP_TIMER_RESET_EN: u1,

          /// [30:30] need_des
          WDT_RESET_EN: u1,

          /// [31:31] need_des
          ANA_PERI_RESET_EN: u1,

        }), @ptrFromInt(0x600b040c));

        /// need_des
        pub const RESET_CAUSE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:4] need_des
          RESET_CAUSE: u5,

          /// [5:5] need_des
          CORE0_RESET_FLAG: u1,

          /// [6:28] 
          res0: u23,

          /// [29:29] need_des
          CORE0_RESET_CAUSE_CLR: u1,

          /// [30:30] need_des
          CORE0_RESET_FLAG_SET: u1,

          /// [31:31] need_des
          CORE0_RESET_FLAG_CLR: u1,

        }), @ptrFromInt(0x600b0410));

        /// need_des
        pub const CPU_RESET = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:21] 
          res0: u22,

          /// [22:24] need_des
          RTC_WDT_CPU_RESET_LENGTH: u3,

          /// [25:25] need_des
          RTC_WDT_CPU_RESET_EN: u1,

          /// [26:30] need_des
          CPU_STALL_WAIT: u5,

          /// [31:31] need_des
          CPU_STALL_EN: u1,

        }), @ptrFromInt(0x600b0414));

        /// need_des
        pub const FOSC_CNTL = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:21] 
          res0: u22,

          /// [22:31] need_des
          FOSC_DFREQ: u10,

        }), @ptrFromInt(0x600b0418));

        /// need_des
        pub const RC32K_CNTL = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:21] 
          res0: u22,

          /// [22:31] need_des
          RC32K_DFREQ: u10,

        }), @ptrFromInt(0x600b041c));

        /// need_des
        pub const CLK_TO_HP = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:27] 
          res0: u28,

          /// [28:28] need_des
          ICG_HP_XTAL32K: u1,

          /// [29:29] need_des
          ICG_HP_SOSC: u1,

          /// [30:30] need_des
          ICG_HP_OSC32K: u1,

          /// [31:31] need_des
          ICG_HP_FOSC: u1,

        }), @ptrFromInt(0x600b0420));

        /// need_des
        pub const LPMEM_FORCE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:30] 
          res0: u31,

          /// [31:31] need_des
          LPMEM_CLK_FORCE_ON: u1,

        }), @ptrFromInt(0x600b0424));

        /// need_des
        pub const LPPERI = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:29] 
          res0: u30,

          /// [30:30] need_des
          LP_I2C_CLK_SEL: u1,

          /// [31:31] need_des
          LP_UART_CLK_SEL: u1,

        }), @ptrFromInt(0x600b0428));

        /// need_des
        pub const XTAL32K = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:21] 
          res0: u22,

          /// [22:24] need_des
          DRES_XTAL32K: u3,

          /// [25:27] need_des
          DGM_XTAL32K: u3,

          /// [28:28] need_des
          DBUF_XTAL32K: u1,

          /// [29:31] need_des
          DAC_XTAL32K: u3,

        }), @ptrFromInt(0x600b042c));

        /// need_des
        pub const DATE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:30] need_des
          CLKRST_DATE: u31,

          /// [31:31] need_des
          CLK_EN: u1,

        }), @ptrFromInt(0x600b07fc));

      };

      /// Low-power I2C (Inter-Integrated Circuit) Controller 0
      pub const LP_I2C0 = struct {

        /// Configures the low level width of the SCLClock
        pub const I2C_SCL_LOW_PERIOD = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:8] This register is used to configure for how long SCL remains low in master mode, in I2C module clock cycles.
          I2C_SCL_LOW_PERIOD: u9,

          /// [9:31] 
          res0: u23,

        }), @ptrFromInt(0x600b1800));

        /// Transmission setting
        pub const I2C_CTR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] 1: direct output, 0: open drain output.
          I2C_SDA_FORCE_OUT: u1,

          /// [1:1] 1: direct output, 0: open drain output.
          I2C_SCL_FORCE_OUT: u1,

          /// [2:2] This register is used to select the sample mode.1: sample SDA data on the SCL low level.0: sample SDA data on the SCL high level.
          I2C_SAMPLE_SCL_LEVEL: u1,

          /// [3:3] This register is used to configure the ACK value that need to sent by master when the rx_fifo_cnt has reached the threshold.
          I2C_RX_FULL_ACK_LEVEL: u1,

          /// [4:4] 
          res0: u1,

          /// [5:5] Set this bit to start sending the data in txfifo.
          I2C_TRANS_START: u1,

          /// [6:6] This bit is used to control the sending mode for data needing to be sent. 1: send data from the least significant bit,0: send data from the most significant bit.
          I2C_TX_LSB_FIRST: u1,

          /// [7:7] This bit is used to control the storage mode for received data.1: receive data from the least significant bit,0: receive data from the most significant bit.
          I2C_RX_LSB_FIRST: u1,

          /// [8:8] Reserved
          I2C_CLK_EN: u1,

          /// [9:9] This is the enable bit for arbitration_lost.
          I2C_ARBITRATION_EN: u1,

          /// [10:10] This register is used to reset the scl FMS.
          I2C_FSM_RST: u1,

          /// [11:11] synchronization bit
          I2C_CONF_UPGATE: u1,

          /// [12:31] 
          res1: u20,

        }), @ptrFromInt(0x600b1804));

        /// Describe I2C work status.
        pub const I2C_SR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] The received ACK value in master mode or slave mode. 0: ACK, 1: NACK.
          I2C_RESP_REC: u1,

          /// [1:2] 
          res0: u2,

          /// [3:3] When the I2C controller loses control of SCL line, this register changes to 1.
          I2C_ARB_LOST: u1,

          /// [4:4] 1: the I2C bus is busy transferring data, 0: the I2C bus is in idle state.
          I2C_BUS_BUSY: u1,

          /// [5:7] 
          res1: u3,

          /// [8:12] This field represents the amount of data needed to be sent.
          I2C_RXFIFO_CNT: u5,

          /// [13:17] 
          res2: u5,

          /// [18:22] This field stores the amount of received data in RAM.
          I2C_TXFIFO_CNT: u5,

          /// [23:23] 
          res3: u1,

          /// [24:26] This field indicates the states of the I2C module state machine. 0: Idle, 1: Address shift, 2: ACK address, 3: Rx data, 4: Tx data, 5: Send ACK, 6: Wait ACK
          I2C_SCL_MAIN_STATE_LAST: u3,

          /// [27:27] 
          res4: u1,

          /// [28:30] This field indicates the states of the state machine used to produce SCL.0: Idle, 1: Start, 2: Negative edge, 3: Low, 4: Positive edge, 5: High, 6: Stop
          I2C_SCL_STATE_LAST: u3,

          /// [31:31] 
          res5: u1,

        }), @ptrFromInt(0x600b1808));

        /// Setting time out control for receiving data.
        pub const I2C_TO = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:4] This register is used to configure the timeout for receiving a data bit in APBclock cycles.
          I2C_TIME_OUT_VALUE: u5,

          /// [5:5] This is the enable bit for time out control.
          I2C_TIME_OUT_EN: u1,

          /// [6:31] 
          res0: u26,

        }), @ptrFromInt(0x600b180c));

        /// FIFO status register.
        pub const I2C_FIFO_ST = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:3] This is the offset address of the APB reading from rxfifo
          I2C_RXFIFO_RADDR: u4,

          /// [4:4] 
          res0: u1,

          /// [5:8] This is the offset address of i2c module receiving data and writing to rxfifo.
          I2C_RXFIFO_WADDR: u4,

          /// [9:9] 
          res1: u1,

          /// [10:13] This is the offset address of i2c module reading from txfifo.
          I2C_TXFIFO_RADDR: u4,

          /// [14:14] 
          res2: u1,

          /// [15:18] This is the offset address of APB bus writing to txfifo.
          I2C_TXFIFO_WADDR: u4,

          /// [19:31] 
          res3: u13,

        }), @ptrFromInt(0x600b1814));

        /// FIFO configuration register.
        pub const FIFO_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:3] The water mark threshold of rx FIFO in nonfifo access mode. When reg_reg_fifo_prt_en is 1 and rx FIFO counter is bigger than reg_rxfifo_wm_thrhd[3:0], reg_rxfifo_wm_int_raw bit will be valid.
          RXFIFO_WM_THRHD: u4,

          /// [4:4] 
          res0: u1,

          /// [5:8] The water mark threshold of tx FIFO in nonfifo access mode. When reg_reg_fifo_prt_en is 1 and tx FIFO counter is smaller than reg_txfifo_wm_thrhd[3:0], reg_txfifo_wm_int_raw bit will be valid.
          TXFIFO_WM_THRHD: u4,

          /// [9:9] 
          res1: u1,

          /// [10:10] Set this bit to enable APB nonfifo access.
          NONFIFO_EN: u1,

          /// [11:11] 
          res2: u1,

          /// [12:12] Set this bit to reset rx-fifo.
          RX_FIFO_RST: u1,

          /// [13:13] Set this bit to reset tx-fifo.
          TX_FIFO_RST: u1,

          /// [14:14] The control enable bit of FIFO pointer in non-fifo access mode. This bit controls the valid bits and the interrupts of tx/rx_fifo overflow, underflow, full and empty.
          FIFO_PRT_EN: u1,

          /// [15:31] 
          res3: u17,

        }), @ptrFromInt(0x600b1818));

        /// Rx FIFO read data.
        pub const I2C_DATA = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] The value of rx FIFO read data.
          I2C_FIFO_RDATA: u8,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x600b181c));

        /// Raw interrupt status
        pub const I2C_INT_RAW = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] The raw interrupt bit for I2C_RXFIFO_WM_INT interrupt.
          I2C_RXFIFO_WM_INT_RAW: u1,

          /// [1:1] The raw interrupt bit for I2C_TXFIFO_WM_INT interrupt.
          I2C_TXFIFO_WM_INT_RAW: u1,

          /// [2:2] The raw interrupt bit for I2C_RXFIFO_OVF_INT interrupt.
          I2C_RXFIFO_OVF_INT_RAW: u1,

          /// [3:3] The raw interrupt bit for the I2C_END_DETECT_INT interrupt.
          I2C_END_DETECT_INT_RAW: u1,

          /// [4:4] The raw interrupt bit for the I2C_END_DETECT_INT interrupt.
          I2C_BYTE_TRANS_DONE_INT_RAW: u1,

          /// [5:5] The raw interrupt bit for the I2C_ARBITRATION_LOST_INT interrupt.
          I2C_ARBITRATION_LOST_INT_RAW: u1,

          /// [6:6] The raw interrupt bit for I2C_TRANS_COMPLETE_INT interrupt.
          I2C_MST_TXFIFO_UDF_INT_RAW: u1,

          /// [7:7] The raw interrupt bit for the I2C_TRANS_COMPLETE_INT interrupt.
          I2C_TRANS_COMPLETE_INT_RAW: u1,

          /// [8:8] The raw interrupt bit for the I2C_TIME_OUT_INT interrupt.
          I2C_TIME_OUT_INT_RAW: u1,

          /// [9:9] The raw interrupt bit for the I2C_TRANS_START_INT interrupt.
          I2C_TRANS_START_INT_RAW: u1,

          /// [10:10] The raw interrupt bit for I2C_SLAVE_STRETCH_INT interrupt.
          I2C_NACK_INT_RAW: u1,

          /// [11:11] The raw interrupt bit for I2C_TXFIFO_OVF_INT interrupt.
          I2C_TXFIFO_OVF_INT_RAW: u1,

          /// [12:12] The raw interrupt bit for I2C_RXFIFO_UDF_INTinterrupt.
          I2C_RXFIFO_UDF_INT_RAW: u1,

          /// [13:13] The raw interrupt bit for I2C_SCL_ST_TO_INT interrupt.
          I2C_SCL_ST_TO_INT_RAW: u1,

          /// [14:14] The raw interrupt bit for I2C_SCL_MAIN_ST_TO_INT interrupt.
          I2C_SCL_MAIN_ST_TO_INT_RAW: u1,

          /// [15:15] The raw interrupt bit for I2C_DET_START_INT interrupt.
          I2C_DET_START_INT_RAW: u1,

          /// [16:31] 
          res0: u16,

        }), @ptrFromInt(0x600b1820));

        /// Interrupt clear bits
        pub const I2C_INT_CLR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Set this bit to clear I2C_RXFIFO_WM_INT interrupt.
          I2C_RXFIFO_WM_INT_CLR: u1,

          /// [1:1] Set this bit to clear I2C_TXFIFO_WM_INT interrupt.
          I2C_TXFIFO_WM_INT_CLR: u1,

          /// [2:2] Set this bit to clear I2C_RXFIFO_OVF_INT interrupt.
          I2C_RXFIFO_OVF_INT_CLR: u1,

          /// [3:3] Set this bit to clear the I2C_END_DETECT_INT interrupt.
          I2C_END_DETECT_INT_CLR: u1,

          /// [4:4] Set this bit to clear the I2C_END_DETECT_INT interrupt.
          I2C_BYTE_TRANS_DONE_INT_CLR: u1,

          /// [5:5] Set this bit to clear the I2C_ARBITRATION_LOST_INT interrupt.
          I2C_ARBITRATION_LOST_INT_CLR: u1,

          /// [6:6] Set this bit to clear I2C_TRANS_COMPLETE_INT interrupt.
          I2C_MST_TXFIFO_UDF_INT_CLR: u1,

          /// [7:7] Set this bit to clear the I2C_TRANS_COMPLETE_INT interrupt.
          I2C_TRANS_COMPLETE_INT_CLR: u1,

          /// [8:8] Set this bit to clear the I2C_TIME_OUT_INT interrupt.
          I2C_TIME_OUT_INT_CLR: u1,

          /// [9:9] Set this bit to clear the I2C_TRANS_START_INT interrupt.
          I2C_TRANS_START_INT_CLR: u1,

          /// [10:10] Set this bit to clear I2C_SLAVE_STRETCH_INT interrupt.
          I2C_NACK_INT_CLR: u1,

          /// [11:11] Set this bit to clear I2C_TXFIFO_OVF_INT interrupt.
          I2C_TXFIFO_OVF_INT_CLR: u1,

          /// [12:12] Set this bit to clear I2C_RXFIFO_UDF_INTinterrupt.
          I2C_RXFIFO_UDF_INT_CLR: u1,

          /// [13:13] Set this bit to clear I2C_SCL_ST_TO_INT interrupt.
          I2C_SCL_ST_TO_INT_CLR: u1,

          /// [14:14] Set this bit to clear I2C_SCL_MAIN_ST_TO_INT interrupt.
          I2C_SCL_MAIN_ST_TO_INT_CLR: u1,

          /// [15:15] Set this bit to clear I2C_DET_START_INT interrupt.
          I2C_DET_START_INT_CLR: u1,

          /// [16:31] 
          res0: u16,

        }), @ptrFromInt(0x600b1824));

        /// Interrupt enable bits
        pub const I2C_INT_ENA = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] The interrupt enable bit for I2C_RXFIFO_WM_INT interrupt.
          I2C_RXFIFO_WM_INT_ENA: u1,

          /// [1:1] The interrupt enable bit for I2C_TXFIFO_WM_INT interrupt.
          I2C_TXFIFO_WM_INT_ENA: u1,

          /// [2:2] The interrupt enable bit for I2C_RXFIFO_OVF_INT interrupt.
          I2C_RXFIFO_OVF_INT_ENA: u1,

          /// [3:3] The interrupt enable bit for the I2C_END_DETECT_INT interrupt.
          I2C_END_DETECT_INT_ENA: u1,

          /// [4:4] The interrupt enable bit for the I2C_END_DETECT_INT interrupt.
          I2C_BYTE_TRANS_DONE_INT_ENA: u1,

          /// [5:5] The interrupt enable bit for the I2C_ARBITRATION_LOST_INT interrupt.
          I2C_ARBITRATION_LOST_INT_ENA: u1,

          /// [6:6] The interrupt enable bit for I2C_TRANS_COMPLETE_INT interrupt.
          I2C_MST_TXFIFO_UDF_INT_ENA: u1,

          /// [7:7] The interrupt enable bit for the I2C_TRANS_COMPLETE_INT interrupt.
          I2C_TRANS_COMPLETE_INT_ENA: u1,

          /// [8:8] The interrupt enable bit for the I2C_TIME_OUT_INT interrupt.
          I2C_TIME_OUT_INT_ENA: u1,

          /// [9:9] The interrupt enable bit for the I2C_TRANS_START_INT interrupt.
          I2C_TRANS_START_INT_ENA: u1,

          /// [10:10] The interrupt enable bit for I2C_SLAVE_STRETCH_INT interrupt.
          I2C_NACK_INT_ENA: u1,

          /// [11:11] The interrupt enable bit for I2C_TXFIFO_OVF_INT interrupt.
          I2C_TXFIFO_OVF_INT_ENA: u1,

          /// [12:12] The interrupt enable bit for I2C_RXFIFO_UDF_INTinterrupt.
          I2C_RXFIFO_UDF_INT_ENA: u1,

          /// [13:13] The interrupt enable bit for I2C_SCL_ST_TO_INT interrupt.
          I2C_SCL_ST_TO_INT_ENA: u1,

          /// [14:14] The interrupt enable bit for I2C_SCL_MAIN_ST_TO_INT interrupt.
          I2C_SCL_MAIN_ST_TO_INT_ENA: u1,

          /// [15:15] The interrupt enable bit for I2C_DET_START_INT interrupt.
          I2C_DET_START_INT_ENA: u1,

          /// [16:31] 
          res0: u16,

        }), @ptrFromInt(0x600b1828));

        /// Status of captured I2C communication events
        pub const I2C_INT_STATUS = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] The masked interrupt status bit for I2C_RXFIFO_WM_INT interrupt.
          I2C_RXFIFO_WM_INT_ST: u1,

          /// [1:1] The masked interrupt status bit for I2C_TXFIFO_WM_INT interrupt.
          I2C_TXFIFO_WM_INT_ST: u1,

          /// [2:2] The masked interrupt status bit for I2C_RXFIFO_OVF_INT interrupt.
          I2C_RXFIFO_OVF_INT_ST: u1,

          /// [3:3] The masked interrupt status bit for the I2C_END_DETECT_INT interrupt.
          I2C_END_DETECT_INT_ST: u1,

          /// [4:4] The masked interrupt status bit for the I2C_END_DETECT_INT interrupt.
          I2C_BYTE_TRANS_DONE_INT_ST: u1,

          /// [5:5] The masked interrupt status bit for the I2C_ARBITRATION_LOST_INT interrupt.
          I2C_ARBITRATION_LOST_INT_ST: u1,

          /// [6:6] The masked interrupt status bit for I2C_TRANS_COMPLETE_INT interrupt.
          I2C_MST_TXFIFO_UDF_INT_ST: u1,

          /// [7:7] The masked interrupt status bit for the I2C_TRANS_COMPLETE_INT interrupt.
          I2C_TRANS_COMPLETE_INT_ST: u1,

          /// [8:8] The masked interrupt status bit for the I2C_TIME_OUT_INT interrupt.
          I2C_TIME_OUT_INT_ST: u1,

          /// [9:9] The masked interrupt status bit for the I2C_TRANS_START_INT interrupt.
          I2C_TRANS_START_INT_ST: u1,

          /// [10:10] The masked interrupt status bit for I2C_SLAVE_STRETCH_INT interrupt.
          I2C_NACK_INT_ST: u1,

          /// [11:11] The masked interrupt status bit for I2C_TXFIFO_OVF_INT interrupt.
          I2C_TXFIFO_OVF_INT_ST: u1,

          /// [12:12] The masked interrupt status bit for I2C_RXFIFO_UDF_INTinterrupt.
          I2C_RXFIFO_UDF_INT_ST: u1,

          /// [13:13] The masked interrupt status bit for I2C_SCL_ST_TO_INT interrupt.
          I2C_SCL_ST_TO_INT_ST: u1,

          /// [14:14] The masked interrupt status bit for I2C_SCL_MAIN_ST_TO_INT interrupt.
          I2C_SCL_MAIN_ST_TO_INT_ST: u1,

          /// [15:15] The masked interrupt status bit for I2C_DET_START_INT interrupt.
          I2C_DET_START_INT_ST: u1,

          /// [16:31] 
          res0: u16,

        }), @ptrFromInt(0x600b182c));

        /// Configures the hold time after a negative SCL edge.
        pub const I2C_SDA_HOLD = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:8] This register is used to configure the time to hold the data after the negativeedge of SCL, in I2C module clock cycles.
          TIME: u9,

          /// [9:31] 
          res0: u23,

        }), @ptrFromInt(0x600b1830));

        /// Configures the sample time after a positive SCL edge.
        pub const I2C_SDA_SAMPLE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:8] This register is used to configure for how long SDA is sampled, in I2C module clock cycles.
          TIME: u9,

          /// [9:31] 
          res0: u23,

        }), @ptrFromInt(0x600b1834));

        /// Configures the high level width of SCL
        pub const I2C_SCL_HIGH_PERIOD = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:8] This register is used to configure for how long SCL setup to high level and remains high in master mode, in I2C module clock cycles.
          I2C_SCL_HIGH_PERIOD: u9,

          /// [9:15] This register is used to configure for the SCL_FSM's waiting period for SCL high level in master mode, in I2C module clock cycles.
          I2C_SCL_WAIT_HIGH_PERIOD: u7,

          /// [16:31] 
          res0: u16,

        }), @ptrFromInt(0x600b1838));

        /// Configures the delay between the SDA and SCL negative edge for a start condition
        pub const I2C_SCL_START_HOLD = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:8] This register is used to configure the time between the negative edgeof SDA and the negative edge of SCL for a START condition, in I2C module clock cycles.
          TIME: u9,

          /// [9:31] 
          res0: u23,

        }), @ptrFromInt(0x600b1840));

        /// Configures the delay between the positiveedge of SCL and the negative edge of SDA
        pub const I2C_SCL_RSTART_SETUP = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:8] This register is used to configure the time between the positiveedge of SCL and the negative edge of SDA for a RESTART condition, in I2C module clock cycles.
          TIME: u9,

          /// [9:31] 
          res0: u23,

        }), @ptrFromInt(0x600b1844));

        /// Configures the delay after the SCL clockedge for a stop condition
        pub const I2C_SCL_STOP_HOLD = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:8] This register is used to configure the delay after the STOP condition,in I2C module clock cycles.
          TIME: u9,

          /// [9:31] 
          res0: u23,

        }), @ptrFromInt(0x600b1848));

        /// Configures the delay between the SDA andSCL positive edge for a stop condition
        pub const I2C_SCL_STOP_SETUP = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:8] This register is used to configure the time between the positive edgeof SCL and the positive edge of SDA, in I2C module clock cycles.
          TIME: u9,

          /// [9:31] 
          res0: u23,

        }), @ptrFromInt(0x600b184c));

        /// SCL and SDA filter configuration register
        pub const I2C_FILTER_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:3] When a pulse on the SCL input has smaller width than this register valuein I2C module clock cycles, the I2C controller will ignore that pulse.
          I2C_SCL_FILTER_THRES: u4,

          /// [4:7] When a pulse on the SDA input has smaller width than this register valuein I2C module clock cycles, the I2C controller will ignore that pulse.
          I2C_SDA_FILTER_THRES: u4,

          /// [8:8] This is the filter enable bit for SCL.
          I2C_SCL_FILTER_EN: u1,

          /// [9:9] This is the filter enable bit for SDA.
          I2C_SDA_FILTER_EN: u1,

          /// [10:31] 
          res0: u22,

        }), @ptrFromInt(0x600b1850));

        /// I2C CLK configuration register
        pub const I2C_CLK_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] the integral part of the fractional divisor for i2c module
          I2C_SCLK_DIV_NUM: u8,

          /// [8:13] the numerator of the fractional part of the fractional divisor for i2c module
          I2C_SCLK_DIV_A: u6,

          /// [14:19] the denominator of the fractional part of the fractional divisor for i2c module
          I2C_SCLK_DIV_B: u6,

          /// [20:20] The clock selection for i2c module:0-XTAL,1-CLK_8MHz.
          I2C_SCLK_SEL: u1,

          /// [21:21] The clock switch for i2c module
          I2C_SCLK_ACTIVE: u1,

          /// [22:31] 
          res0: u10,

        }), @ptrFromInt(0x600b1854));

        /// I2C command register 0
        pub const I2C_COMD0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:13] This is the content of command 0. It consists of three parts: op_code is the command, 0: RSTART, 1: WRITE, 2: READ, 3: STOP, 4: END.Byte_num represents the number of bytes that need to be sent or received.ack_check_en, ack_exp and ack are used to control the ACK bit. See I2C cmd structure for moreInformation.
          I2C_COMMAND0: u14,

          /// [14:30] 
          res0: u17,

          /// [31:31] When command 0 is done in I2C Master mode, this bit changes to highlevel.
          I2C_COMMAND0_DONE: u1,

        }), @ptrFromInt(0x600b1858));

        /// I2C command register 1
        pub const I2C_COMD1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:13] This is the content of command 1. It consists of three parts: op_code is the command, 0: RSTART, 1: WRITE, 2: READ, 3: STOP, 4: END.Byte_num represents the number of bytes that need to be sent or received.ack_check_en, ack_exp and ack are used to control the ACK bit. See I2C cmd structure for moreInformation.
          I2C_COMMAND1: u14,

          /// [14:30] 
          res0: u17,

          /// [31:31] When command 1 is done in I2C Master mode, this bit changes to highlevel.
          I2C_COMMAND1_DONE: u1,

        }), @ptrFromInt(0x600b185c));

        /// I2C command register 2
        pub const I2C_COMD2 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:13] This is the content of command 2. It consists of three parts: op_code is the command, 0: RSTART, 1: WRITE, 2: READ, 3: STOP, 4: END.Byte_num represents the number of bytes that need to be sent or received.ack_check_en, ack_exp and ack are used to control the ACK bit. See I2C cmd structure for moreInformation.
          I2C_COMMAND2: u14,

          /// [14:30] 
          res0: u17,

          /// [31:31] When command 2 is done in I2C Master mode, this bit changes to highLevel.
          I2C_COMMAND2_DONE: u1,

        }), @ptrFromInt(0x600b1860));

        /// I2C command register 3
        pub const I2C_COMD3 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:13] This is the content of command 3. It consists of three parts: op_code is the command, 0: RSTART, 1: WRITE, 2: READ, 3: STOP, 4: END.Byte_num represents the number of bytes that need to be sent or received.ack_check_en, ack_exp and ack are used to control the ACK bit. See I2C cmd structure for moreInformation.
          I2C_COMMAND3: u14,

          /// [14:30] 
          res0: u17,

          /// [31:31] When command 3 is done in I2C Master mode, this bit changes to highlevel.
          I2C_COMMAND3_DONE: u1,

        }), @ptrFromInt(0x600b1864));

        /// I2C command register 4
        pub const I2C_COMD4 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:13] This is the content of command 4. It consists of three parts: op_code is the command, 0: RSTART, 1: WRITE, 2: READ, 3: STOP, 4: END.Byte_num represents the number of bytes that need to be sent or received.ack_check_en, ack_exp and ack are used to control the ACK bit. See I2C cmd structure for moreInformation.
          I2C_COMMAND4: u14,

          /// [14:30] 
          res0: u17,

          /// [31:31] When command 4 is done in I2C Master mode, this bit changes to highlevel.
          I2C_COMMAND4_DONE: u1,

        }), @ptrFromInt(0x600b1868));

        /// I2C command register 5
        pub const I2C_COMD5 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:13] This is the content of command 5. It consists of three parts:op_code is the command, 0: RSTART, 1: WRITE, 2: READ, 3: STOP, 4: END.Byte_num represents the number of bytes that need to be sent or received.ack_check_en, ack_exp and ack are used to control the ACK bit. See I2C cmd structure for moreInformation.
          I2C_COMMAND5: u14,

          /// [14:30] 
          res0: u17,

          /// [31:31] When command 5 is done in I2C Master mode, this bit changes to high level.
          I2C_COMMAND5_DONE: u1,

        }), @ptrFromInt(0x600b186c));

        /// I2C command register 6
        pub const I2C_COMD6 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:13] This is the content of command 6. It consists of three parts: op_code is the command, 0: RSTART, 1: WRITE, 2: READ, 3: STOP, 4: END.Byte_num represents the number of bytes that need to be sent or received.ack_check_en, ack_exp and ack are used to control the ACK bit. See I2C cmd structure for moreInformation.
          I2C_COMMAND6: u14,

          /// [14:30] 
          res0: u17,

          /// [31:31] When command 6 is done in I2C Master mode, this bit changes to high level.
          I2C_COMMAND6_DONE: u1,

        }), @ptrFromInt(0x600b1870));

        /// I2C command register 7
        pub const I2C_COMD7 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:13] This is the content of command 7. It consists of three parts: op_code is the command, 0: RSTART, 1: WRITE, 2: READ, 3: STOP, 4: END.Byte_num represents the number of bytes that need to be sent or received.ack_check_en, ack_exp and ack are used to control the ACK bit. See I2C cmd structure for moreInformation.
          I2C_COMMAND7: u14,

          /// [14:30] 
          res0: u17,

          /// [31:31] When command 7 is done in I2C Master mode, this bit changes to high level.
          I2C_COMMAND7_DONE: u1,

        }), @ptrFromInt(0x600b1874));

        /// SCL status time out register
        pub const I2C_SCL_ST_TIME_OUT = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:4] The threshold value of SCL_FSM state unchanged period. It should be o more than 23
          I2C_SCL_ST_TO_I2C: u5,

          /// [5:31] 
          res0: u27,

        }), @ptrFromInt(0x600b1878));

        /// SCL main status time out register
        pub const I2C_SCL_MAIN_ST_TIME_OUT = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:4] The threshold value of SCL_MAIN_FSM state unchanged period.nIt should be o more than 23
          I2C_SCL_MAIN_ST_TO_I2C: u5,

          /// [5:31] 
          res0: u27,

        }), @ptrFromInt(0x600b187c));

        /// Power configuration register
        pub const I2C_SCL_SP_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] When I2C master is IDLE, set this bit to send out SCL pulses. The number of pulses equals to reg_scl_rst_slv_num[4:0].
          I2C_SCL_RST_SLV_EN: u1,

          /// [1:5] Configure the pulses of SCL generated in I2C master mode. Valid when reg_scl_rst_slv_en is 1.
          I2C_SCL_RST_SLV_NUM: u5,

          /// [6:6] The power down enable bit for the I2C output SCL line. 1: Power down. 0: Not power down. Set reg_scl_force_out and reg_scl_pd_en to 1 to stretch SCL low.
          I2C_SCL_PD_EN: u1,

          /// [7:7] The power down enable bit for the I2C output SDA line. 1: Power down. 0: Not power down. Set reg_sda_force_out and reg_sda_pd_en to 1 to stretch SDA low.
          I2C_SDA_PD_EN: u1,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x600b1880));

        /// Version register
        pub const I2C_DATE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] This is the the version register.
          I2C_DATE: u32,

        }), @ptrFromInt(0x600b18f8));

        /// I2C TXFIFO base address register
        pub const I2C_TXFIFO_START_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] This is the I2C txfifo first address.
          I2C_TXFIFO_START_ADDR: u32,

        }), @ptrFromInt(0x600b1900));

        /// I2C RXFIFO base address register
        pub const I2C_RXFIFO_START_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] This is the I2C rxfifo first address.
          I2C_RXFIFO_START_ADDR: u32,

        }), @ptrFromInt(0x600b1980));

      };

      /// LP_I2C_ANA_MST Peripheral
      pub const LP_I2C_ANA_MST = struct {

        /// need_des
        pub const I2C0_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:24] need_des
          LP_I2C_ANA_MAST_I2C0_CTRL: u25,

          /// [25:25] need_des
          LP_I2C_ANA_MAST_I2C0_BUSY: u1,

          /// [26:31] 
          res0: u6,

        }), @ptrFromInt(0x600b2400));

        /// need_des
        pub const I2C0_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:23] need_des
          LP_I2C_ANA_MAST_I2C0_CONF: u24,

          /// [24:31] reserved
          LP_I2C_ANA_MAST_I2C0_STATUS: u8,

        }), @ptrFromInt(0x600b2404));

        /// need_des
        pub const I2C0_DATA = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] need_des
          LP_I2C_ANA_MAST_I2C0_RDATA: u8,

          /// [8:10] need_des
          LP_I2C_ANA_MAST_I2C0_CLK_SEL: u3,

          /// [11:11] needdes
          LP_I2C_ANA_MAST_I2C_MST_SEL: u1,

          /// [12:31] 
          res0: u20,

        }), @ptrFromInt(0x600b2408));

        /// need_des
        pub const ANA_CONF1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:23] need_des
          LP_I2C_ANA_MAST_ANA_CONF1: u24,

          /// [24:31] 
          res0: u8,

        }), @ptrFromInt(0x600b240c));

        /// need_des
        pub const NOUSE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] need_des
          LP_I2C_ANA_MAST_I2C_MST_NOUSE: u32,

        }), @ptrFromInt(0x600b2410));

        /// need_des
        pub const DEVICE_EN = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:11] need_des
          LP_I2C_ANA_MAST_I2C_DEVICE_EN: u12,

          /// [12:31] 
          res0: u20,

        }), @ptrFromInt(0x600b2414));

        /// need_des
        pub const DATE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:27] need_des
          LP_I2C_ANA_MAST_I2C_MAT_DATE: u28,

          /// [28:28] need_des
          LP_I2C_ANA_MAST_I2C_MAT_CLK_EN: u1,

          /// [29:31] 
          res0: u3,

        }), @ptrFromInt(0x600b27fc));

      };

      /// LP_IO Peripheral
      pub const LP_IO = struct {

        /// need des
        pub const OUT_DATA = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] set lp gpio output data
          LP_GPIO_OUT_DATA: u8,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x600b2000));

        /// need des
        pub const OUT_DATA_W1TS = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] set one time output data
          LP_GPIO_OUT_DATA_W1TS: u8,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x600b2004));

        /// need des
        pub const OUT_DATA_W1TC = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] clear one time output data
          LP_GPIO_OUT_DATA_W1TC: u8,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x600b2008));

        /// need des
        pub const OUT_ENABLE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] set lp gpio output data
          LP_GPIO_ENABLE: u8,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x600b200c));

        /// need des
        pub const OUT_ENABLE_W1TS = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] set one time output data
          LP_GPIO_ENABLE_W1TS: u8,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x600b2010));

        /// need des
        pub const OUT_ENABLE_W1TC = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] clear one time output data
          LP_GPIO_ENABLE_W1TC: u8,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x600b2014));

        /// need des
        pub const STATUS = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] set lp gpio output data
          LP_GPIO_STATUS_INTERRUPT: u8,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x600b2018));

        /// need des
        pub const STATUS_W1TS = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] set one time output data
          LP_GPIO_STATUS_W1TS: u8,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x600b201c));

        /// need des
        pub const STATUS_W1TC = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] clear one time output data
          LP_GPIO_STATUS_W1TC: u8,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x600b2020));

        /// need des
        pub const IN = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] need des
          LP_GPIO_IN_DATA_NEXT: u8,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x600b2024));

        /// need des
        pub const PIN0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:1] need des
          LP_GPIO0_SYNC_BYPASS: u2,

          /// [2:2] need des
          LP_GPIO0_PAD_DRIVER: u1,

          /// [3:3] need des
          LP_GPIO0_EDGE_WAKEUP_CLR: u1,

          /// [4:6] 
          res0: u3,

          /// [7:9] need des
          LP_GPIO0_INT_TYPE: u3,

          /// [10:10] need des
          LP_GPIO0_WAKEUP_ENABLE: u1,

          /// [11:11] need des
          LP_GPIO0_FILTER_EN: u1,

          /// [12:31] 
          res1: u20,

        }), @ptrFromInt(0x600b2028));

        /// need des
        pub const PIN1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:1] need des
          LP_GPIO1_SYNC_BYPASS: u2,

          /// [2:2] need des
          LP_GPIO1_PAD_DRIVER: u1,

          /// [3:3] need des
          LP_GPIO1_EDGE_WAKEUP_CLR: u1,

          /// [4:6] 
          res0: u3,

          /// [7:9] need des
          LP_GPIO1_INT_TYPE: u3,

          /// [10:10] need des
          LP_GPIO1_WAKEUP_ENABLE: u1,

          /// [11:11] need des
          LP_GPIO1_FILTER_EN: u1,

          /// [12:31] 
          res1: u20,

        }), @ptrFromInt(0x600b202c));

        /// need des
        pub const PIN2 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:1] need des
          LP_GPIO2_SYNC_BYPASS: u2,

          /// [2:2] need des
          LP_GPIO2_PAD_DRIVER: u1,

          /// [3:3] need des
          LP_GPIO2_EDGE_WAKEUP_CLR: u1,

          /// [4:6] 
          res0: u3,

          /// [7:9] need des
          LP_GPIO2_INT_TYPE: u3,

          /// [10:10] need des
          LP_GPIO2_WAKEUP_ENABLE: u1,

          /// [11:11] need des
          LP_GPIO2_FILTER_EN: u1,

          /// [12:31] 
          res1: u20,

        }), @ptrFromInt(0x600b2030));

        /// need des
        pub const PIN3 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:1] need des
          LP_GPIO3_SYNC_BYPASS: u2,

          /// [2:2] need des
          LP_GPIO3_PAD_DRIVER: u1,

          /// [3:3] need des
          LP_GPIO3_EDGE_WAKEUP_CLR: u1,

          /// [4:6] 
          res0: u3,

          /// [7:9] need des
          LP_GPIO3_INT_TYPE: u3,

          /// [10:10] need des
          LP_GPIO3_WAKEUP_ENABLE: u1,

          /// [11:11] need des
          LP_GPIO3_FILTER_EN: u1,

          /// [12:31] 
          res1: u20,

        }), @ptrFromInt(0x600b2034));

        /// need des
        pub const PIN4 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:1] need des
          LP_GPIO4_SYNC_BYPASS: u2,

          /// [2:2] need des
          LP_GPIO4_PAD_DRIVER: u1,

          /// [3:3] need des
          LP_GPIO4_EDGE_WAKEUP_CLR: u1,

          /// [4:6] 
          res0: u3,

          /// [7:9] need des
          LP_GPIO4_INT_TYPE: u3,

          /// [10:10] need des
          LP_GPIO4_WAKEUP_ENABLE: u1,

          /// [11:11] need des
          LP_GPIO4_FILTER_EN: u1,

          /// [12:31] 
          res1: u20,

        }), @ptrFromInt(0x600b2038));

        /// need des
        pub const PIN5 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:1] need des
          LP_GPIO5_SYNC_BYPASS: u2,

          /// [2:2] need des
          LP_GPIO5_PAD_DRIVER: u1,

          /// [3:3] need des
          LP_GPIO5_EDGE_WAKEUP_CLR: u1,

          /// [4:6] 
          res0: u3,

          /// [7:9] need des
          LP_GPIO5_INT_TYPE: u3,

          /// [10:10] need des
          LP_GPIO5_WAKEUP_ENABLE: u1,

          /// [11:11] need des
          LP_GPIO5_FILTER_EN: u1,

          /// [12:31] 
          res1: u20,

        }), @ptrFromInt(0x600b203c));

        /// need des
        pub const PIN6 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:1] need des
          LP_GPIO6_SYNC_BYPASS: u2,

          /// [2:2] need des
          LP_GPIO6_PAD_DRIVER: u1,

          /// [3:3] need des
          LP_GPIO6_EDGE_WAKEUP_CLR: u1,

          /// [4:6] 
          res0: u3,

          /// [7:9] need des
          LP_GPIO6_INT_TYPE: u3,

          /// [10:10] need des
          LP_GPIO6_WAKEUP_ENABLE: u1,

          /// [11:11] need des
          LP_GPIO6_FILTER_EN: u1,

          /// [12:31] 
          res1: u20,

        }), @ptrFromInt(0x600b2040));

        /// need des
        pub const PIN7 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:1] need des
          LP_GPIO7_SYNC_BYPASS: u2,

          /// [2:2] need des
          LP_GPIO7_PAD_DRIVER: u1,

          /// [3:3] need des
          LP_GPIO7_EDGE_WAKEUP_CLR: u1,

          /// [4:6] 
          res0: u3,

          /// [7:9] need des
          LP_GPIO7_INT_TYPE: u3,

          /// [10:10] need des
          LP_GPIO7_WAKEUP_ENABLE: u1,

          /// [11:11] need des
          LP_GPIO7_FILTER_EN: u1,

          /// [12:31] 
          res1: u20,

        }), @ptrFromInt(0x600b2044));

        /// need des
        pub const GPIO0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] need des
          LP_GPIO0_MCU_OE: u1,

          /// [1:1] need des
          LP_GPIO0_SLP_SEL: u1,

          /// [2:2] need des
          LP_GPIO0_MCU_WPD: u1,

          /// [3:3] need des
          LP_GPIO0_MCU_WPU: u1,

          /// [4:4] need des
          LP_GPIO0_MCU_IE: u1,

          /// [5:6] need des
          LP_GPIO0_MCU_DRV: u2,

          /// [7:7] need des
          LP_GPIO0_FUN_WPD: u1,

          /// [8:8] need des
          LP_GPIO0_FUN_WPU: u1,

          /// [9:9] need des
          LP_GPIO0_FUN_IE: u1,

          /// [10:11] need des
          LP_GPIO0_FUN_DRV: u2,

          /// [12:14] need des
          LP_GPIO0_MCU_SEL: u3,

          /// [15:31] 
          res0: u17,

        }), @ptrFromInt(0x600b2048));

        /// need des
        pub const GPIO1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] need des
          LP_GPIO1_MCU_OE: u1,

          /// [1:1] need des
          LP_GPIO1_SLP_SEL: u1,

          /// [2:2] need des
          LP_GPIO1_MCU_WPD: u1,

          /// [3:3] need des
          LP_GPIO1_MCU_WPU: u1,

          /// [4:4] need des
          LP_GPIO1_MCU_IE: u1,

          /// [5:6] need des
          LP_GPIO1_MCU_DRV: u2,

          /// [7:7] need des
          LP_GPIO1_FUN_WPD: u1,

          /// [8:8] need des
          LP_GPIO1_FUN_WPU: u1,

          /// [9:9] need des
          LP_GPIO1_FUN_IE: u1,

          /// [10:11] need des
          LP_GPIO1_FUN_DRV: u2,

          /// [12:14] need des
          LP_GPIO1_MCU_SEL: u3,

          /// [15:31] 
          res0: u17,

        }), @ptrFromInt(0x600b204c));

        /// need des
        pub const GPIO2 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] need des
          LP_GPIO2_MCU_OE: u1,

          /// [1:1] need des
          LP_GPIO2_SLP_SEL: u1,

          /// [2:2] need des
          LP_GPIO2_MCU_WPD: u1,

          /// [3:3] need des
          LP_GPIO2_MCU_WPU: u1,

          /// [4:4] need des
          LP_GPIO2_MCU_IE: u1,

          /// [5:6] need des
          LP_GPIO2_MCU_DRV: u2,

          /// [7:7] need des
          LP_GPIO2_FUN_WPD: u1,

          /// [8:8] need des
          LP_GPIO2_FUN_WPU: u1,

          /// [9:9] need des
          LP_GPIO2_FUN_IE: u1,

          /// [10:11] need des
          LP_GPIO2_FUN_DRV: u2,

          /// [12:14] need des
          LP_GPIO2_MCU_SEL: u3,

          /// [15:31] 
          res0: u17,

        }), @ptrFromInt(0x600b2050));

        /// need des
        pub const GPIO3 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] need des
          LP_GPIO3_MCU_OE: u1,

          /// [1:1] need des
          LP_GPIO3_SLP_SEL: u1,

          /// [2:2] need des
          LP_GPIO3_MCU_WPD: u1,

          /// [3:3] need des
          LP_GPIO3_MCU_WPU: u1,

          /// [4:4] need des
          LP_GPIO3_MCU_IE: u1,

          /// [5:6] need des
          LP_GPIO3_MCU_DRV: u2,

          /// [7:7] need des
          LP_GPIO3_FUN_WPD: u1,

          /// [8:8] need des
          LP_GPIO3_FUN_WPU: u1,

          /// [9:9] need des
          LP_GPIO3_FUN_IE: u1,

          /// [10:11] need des
          LP_GPIO3_FUN_DRV: u2,

          /// [12:14] need des
          LP_GPIO3_MCU_SEL: u3,

          /// [15:31] 
          res0: u17,

        }), @ptrFromInt(0x600b2054));

        /// need des
        pub const GPIO4 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] need des
          LP_GPIO4_MCU_OE: u1,

          /// [1:1] need des
          LP_GPIO4_SLP_SEL: u1,

          /// [2:2] need des
          LP_GPIO4_MCU_WPD: u1,

          /// [3:3] need des
          LP_GPIO4_MCU_WPU: u1,

          /// [4:4] need des
          LP_GPIO4_MCU_IE: u1,

          /// [5:6] need des
          LP_GPIO4_MCU_DRV: u2,

          /// [7:7] need des
          LP_GPIO4_FUN_WPD: u1,

          /// [8:8] need des
          LP_GPIO4_FUN_WPU: u1,

          /// [9:9] need des
          LP_GPIO4_FUN_IE: u1,

          /// [10:11] need des
          LP_GPIO4_FUN_DRV: u2,

          /// [12:14] need des
          LP_GPIO4_MCU_SEL: u3,

          /// [15:31] 
          res0: u17,

        }), @ptrFromInt(0x600b2058));

        /// need des
        pub const GPIO5 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] need des
          LP_GPIO5_MCU_OE: u1,

          /// [1:1] need des
          LP_GPIO5_SLP_SEL: u1,

          /// [2:2] need des
          LP_GPIO5_MCU_WPD: u1,

          /// [3:3] need des
          LP_GPIO5_MCU_WPU: u1,

          /// [4:4] need des
          LP_GPIO5_MCU_IE: u1,

          /// [5:6] need des
          LP_GPIO5_MCU_DRV: u2,

          /// [7:7] need des
          LP_GPIO5_FUN_WPD: u1,

          /// [8:8] need des
          LP_GPIO5_FUN_WPU: u1,

          /// [9:9] need des
          LP_GPIO5_FUN_IE: u1,

          /// [10:11] need des
          LP_GPIO5_FUN_DRV: u2,

          /// [12:14] need des
          LP_GPIO5_MCU_SEL: u3,

          /// [15:31] 
          res0: u17,

        }), @ptrFromInt(0x600b205c));

        /// need des
        pub const GPIO6 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] need des
          LP_GPIO6_MCU_OE: u1,

          /// [1:1] need des
          LP_GPIO6_SLP_SEL: u1,

          /// [2:2] need des
          LP_GPIO6_MCU_WPD: u1,

          /// [3:3] need des
          LP_GPIO6_MCU_WPU: u1,

          /// [4:4] need des
          LP_GPIO6_MCU_IE: u1,

          /// [5:6] need des
          LP_GPIO6_MCU_DRV: u2,

          /// [7:7] need des
          LP_GPIO6_FUN_WPD: u1,

          /// [8:8] need des
          LP_GPIO6_FUN_WPU: u1,

          /// [9:9] need des
          LP_GPIO6_FUN_IE: u1,

          /// [10:11] need des
          LP_GPIO6_FUN_DRV: u2,

          /// [12:14] need des
          LP_GPIO6_MCU_SEL: u3,

          /// [15:31] 
          res0: u17,

        }), @ptrFromInt(0x600b2060));

        /// need des
        pub const GPIO7 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] need des
          LP_GPIO7_MCU_OE: u1,

          /// [1:1] need des
          LP_GPIO7_SLP_SEL: u1,

          /// [2:2] need des
          LP_GPIO7_MCU_WPD: u1,

          /// [3:3] need des
          LP_GPIO7_MCU_WPU: u1,

          /// [4:4] need des
          LP_GPIO7_MCU_IE: u1,

          /// [5:6] need des
          LP_GPIO7_MCU_DRV: u2,

          /// [7:7] need des
          LP_GPIO7_FUN_WPD: u1,

          /// [8:8] need des
          LP_GPIO7_FUN_WPU: u1,

          /// [9:9] need des
          LP_GPIO7_FUN_IE: u1,

          /// [10:11] need des
          LP_GPIO7_FUN_DRV: u2,

          /// [12:14] need des
          LP_GPIO7_MCU_SEL: u3,

          /// [15:31] 
          res0: u17,

        }), @ptrFromInt(0x600b2064));

        /// need des
        pub const STATUS_INTERRUPT = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] need des
          LP_GPIO_STATUS_INTERRUPT_NEXT: u8,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x600b2068));

        /// need des
        pub const DEBUG_SEL0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:6] need des
          LP_DEBUG_SEL0: u7,

          /// [7:13] need des
          LP_DEBUG_SEL1: u7,

          /// [14:20] need des
          LP_DEBUG_SEL2: u7,

          /// [21:27] need des
          LP_DEBUG_SEL3: u7,

          /// [28:31] 
          res0: u4,

        }), @ptrFromInt(0x600b206c));

        /// need des
        pub const DEBUG_SEL1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:6] need des
          LP_DEBUG_SEL4: u7,

          /// [7:31] 
          res0: u25,

        }), @ptrFromInt(0x600b2070));

        /// need des
        pub const LPI2C = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:29] 
          res0: u30,

          /// [30:30] need des
          LP_I2C_SDA_IE: u1,

          /// [31:31] need des
          LP_I2C_SCL_IE: u1,

        }), @ptrFromInt(0x600b2074));

        /// need des
        pub const DATE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:30] need des
          LP_IO_DATE: u31,

          /// [31:31] need des
          CLK_EN: u1,

        }), @ptrFromInt(0x600b23fc));

      };

      /// Low-power Trusted Execution Environment
      pub const LP_TEE = struct {

        /// Tee mode control register
        pub const M0_MODE_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:1] M0 security level mode: 2'd3: ree_mode2. 2'd2: ree_mode1. 2'd1: ree_mode0. 2'd0: tee_mode
          M0_MODE: u2,

          /// [2:31] 
          res0: u30,

        }), @ptrFromInt(0x600b3400));

        /// Clock gating register
        pub const CLOCK_GATE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] reg_clk_en
          CLK_EN: u1,

          /// [1:31] 
          res0: u31,

        }), @ptrFromInt(0x600b3404));

        /// need_des
        pub const FORCE_ACC_HP = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] need_des
          LP_AON_FORCE_ACC_HPMEM_EN: u1,

          /// [1:31] 
          res0: u31,

        }), @ptrFromInt(0x600b3490));

        /// Version register
        pub const DATE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:27] reg_tee_date
          DATE: u28,

          /// [28:31] 
          res0: u4,

        }), @ptrFromInt(0x600b34fc));

      };

      /// Low-power Timer
      pub const LP_TIMER = struct {

        /// need_des
        pub const TAR0_LOW = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] need_des
          MAIN_TIMER_TAR_LOW0: u32,

        }), @ptrFromInt(0x600b0c00));

        /// need_des
        pub const TAR0_HIGH = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:15] need_des
          MAIN_TIMER_TAR_HIGH0: u16,

          /// [16:30] 
          res0: u15,

          /// [31:31] need_des
          MAIN_TIMER_TAR_EN0: u1,

        }), @ptrFromInt(0x600b0c04));

        /// need_des
        pub const TAR1_LOW = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] need_des
          MAIN_TIMER_TAR_LOW1: u32,

        }), @ptrFromInt(0x600b0c08));

        /// need_des
        pub const TAR1_HIGH = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:15] need_des
          MAIN_TIMER_TAR_HIGH1: u16,

          /// [16:30] 
          res0: u15,

          /// [31:31] need_des
          MAIN_TIMER_TAR_EN1: u1,

        }), @ptrFromInt(0x600b0c0c));

        /// need_des
        pub const UPDATE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:27] 
          res0: u28,

          /// [28:28] need_des
          MAIN_TIMER_UPDATE: u1,

          /// [29:29] need_des
          MAIN_TIMER_XTAL_OFF: u1,

          /// [30:30] need_des
          MAIN_TIMER_SYS_STALL: u1,

          /// [31:31] need_des
          MAIN_TIMER_SYS_RST: u1,

        }), @ptrFromInt(0x600b0c10));

        /// need_des
        pub const MAIN_BUF0_LOW = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] need_des
          MAIN_TIMER_BUF0_LOW: u32,

        }), @ptrFromInt(0x600b0c14));

        /// need_des
        pub const MAIN_BUF0_HIGH = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:15] need_des
          MAIN_TIMER_BUF0_HIGH: u16,

          /// [16:31] 
          res0: u16,

        }), @ptrFromInt(0x600b0c18));

        /// need_des
        pub const MAIN_BUF1_LOW = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] need_des
          MAIN_TIMER_BUF1_LOW: u32,

        }), @ptrFromInt(0x600b0c1c));

        /// need_des
        pub const MAIN_BUF1_HIGH = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:15] need_des
          MAIN_TIMER_BUF1_HIGH: u16,

          /// [16:31] 
          res0: u16,

        }), @ptrFromInt(0x600b0c20));

        /// need_des
        pub const MAIN_OVERFLOW = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:30] 
          res0: u31,

          /// [31:31] need_des
          MAIN_TIMER_ALARM_LOAD: u1,

        }), @ptrFromInt(0x600b0c24));

        /// need_des
        pub const INT_RAW = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:29] 
          res0: u30,

          /// [30:30] need_des
          OVERFLOW_RAW: u1,

          /// [31:31] need_des
          SOC_WAKEUP_INT_RAW: u1,

        }), @ptrFromInt(0x600b0c28));

        /// need_des
        pub const INT_ST = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:29] 
          res0: u30,

          /// [30:30] need_des
          OVERFLOW_ST: u1,

          /// [31:31] need_des
          SOC_WAKEUP_INT_ST: u1,

        }), @ptrFromInt(0x600b0c2c));

        /// need_des
        pub const INT_ENA = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:29] 
          res0: u30,

          /// [30:30] need_des
          OVERFLOW_ENA: u1,

          /// [31:31] need_des
          SOC_WAKEUP_INT_ENA: u1,

        }), @ptrFromInt(0x600b0c30));

        /// need_des
        pub const INT_CLR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:29] 
          res0: u30,

          /// [30:30] need_des
          OVERFLOW_CLR: u1,

          /// [31:31] need_des
          SOC_WAKEUP_INT_CLR: u1,

        }), @ptrFromInt(0x600b0c34));

        /// need_des
        pub const LP_INT_RAW = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:29] 
          res0: u30,

          /// [30:30] need_des
          MAIN_TIMER_OVERFLOW_LP_INT_RAW: u1,

          /// [31:31] need_des
          MAIN_TIMER_LP_INT_RAW: u1,

        }), @ptrFromInt(0x600b0c38));

        /// need_des
        pub const LP_INT_ST = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:29] 
          res0: u30,

          /// [30:30] need_des
          MAIN_TIMER_OVERFLOW_LP_INT_ST: u1,

          /// [31:31] need_des
          MAIN_TIMER_LP_INT_ST: u1,

        }), @ptrFromInt(0x600b0c3c));

        /// need_des
        pub const LP_INT_ENA = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:29] 
          res0: u30,

          /// [30:30] need_des
          MAIN_TIMER_OVERFLOW_LP_INT_ENA: u1,

          /// [31:31] need_des
          MAIN_TIMER_LP_INT_ENA: u1,

        }), @ptrFromInt(0x600b0c40));

        /// need_des
        pub const LP_INT_CLR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:29] 
          res0: u30,

          /// [30:30] need_des
          MAIN_TIMER_OVERFLOW_LP_INT_CLR: u1,

          /// [31:31] need_des
          MAIN_TIMER_LP_INT_CLR: u1,

        }), @ptrFromInt(0x600b0c44));

        /// need_des
        pub const DATE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:30] need_des
          DATE: u31,

          /// [31:31] need_des
          CLK_EN: u1,

        }), @ptrFromInt(0x600b0ffc));

      };

      /// Low-power UART (Universal Asynchronous Receiver-Transmitter) Controller
      pub const LP_UART = struct {

        /// FIFO data register
        pub const FIFO = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] UART 0 accesses FIFO via this register.
          RXFIFO_RD_BYTE: u8,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x600b1400));

        /// Raw interrupt status
        pub const INT_RAW = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] This interrupt raw bit turns to high level when receiver receives more data than what rxfifo_full_thrhd specifies.
          RXFIFO_FULL_INT_RAW: u1,

          /// [1:1] This interrupt raw bit turns to high level when the amount of data in Tx-FIFO is less than what txfifo_empty_thrhd specifies .
          TXFIFO_EMPTY_INT_RAW: u1,

          /// [2:2] This interrupt raw bit turns to high level when receiver detects a parity error in the data.
          PARITY_ERR_INT_RAW: u1,

          /// [3:3] This interrupt raw bit turns to high level when receiver detects a data frame error .
          FRM_ERR_INT_RAW: u1,

          /// [4:4] This interrupt raw bit turns to high level when receiver receives more data than the FIFO can store.
          RXFIFO_OVF_INT_RAW: u1,

          /// [5:5] This interrupt raw bit turns to high level when receiver detects the edge change of DSRn signal.
          DSR_CHG_INT_RAW: u1,

          /// [6:6] This interrupt raw bit turns to high level when receiver detects the edge change of CTSn signal.
          CTS_CHG_INT_RAW: u1,

          /// [7:7] This interrupt raw bit turns to high level when receiver detects a 0 after the stop bit.
          BRK_DET_INT_RAW: u1,

          /// [8:8] This interrupt raw bit turns to high level when receiver takes more time than rx_tout_thrhd to receive a byte.
          RXFIFO_TOUT_INT_RAW: u1,

          /// [9:9] This interrupt raw bit turns to high level when receiver recevies Xon char when uart_sw_flow_con_en is set to 1.
          SW_XON_INT_RAW: u1,

          /// [10:10] This interrupt raw bit turns to high level when receiver receives Xoff char when uart_sw_flow_con_en is set to 1.
          SW_XOFF_INT_RAW: u1,

          /// [11:11] This interrupt raw bit turns to high level when receiver detects a glitch in the middle of a start bit.
          GLITCH_DET_INT_RAW: u1,

          /// [12:12] This interrupt raw bit turns to high level when transmitter completessendingNULL characters after all data in Tx-FIFO are sent.
          TX_BRK_DONE_INT_RAW: u1,

          /// [13:13] This interrupt raw bit turns to high level when transmitter has kept the shortest duration after sending thelast data.
          TX_BRK_IDLE_DONE_INT_RAW: u1,

          /// [14:14] This interrupt raw bit turns to high level when transmitter has send out all data in FIFO.
          TX_DONE_INT_RAW: u1,

          /// [15:17] 
          res0: u3,

          /// [18:18] This interrupt raw bit turns to high level when receiver detects the configured at_cmd char.
          AT_CMD_CHAR_DET_INT_RAW: u1,

          /// [19:19] This interrupt raw bit turns to high level when input rxd edge changes more times than what reg_active_threshold specifies in light sleeping mode.
          WAKEUP_INT_RAW: u1,

          /// [20:31] 
          res1: u12,

        }), @ptrFromInt(0x600b1404));

        /// Masked interrupt status
        pub const INT_ST = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] This is the status bit for rxfifo_full_int_raw when rxfifo_full_int_ena is set to 1.
          RXFIFO_FULL_INT_ST: u1,

          /// [1:1] This is the status bit fortxfifo_empty_int_rawwhen txfifo_empty_int_ena is set to 1.
          TXFIFO_EMPTY_INT_ST: u1,

          /// [2:2] This is the status bit for parity_err_int_raw when parity_err_int_ena is set to 1.
          PARITY_ERR_INT_ST: u1,

          /// [3:3] This is the status bit for frm_err_int_raw when frm_err_int_ena is set to 1.
          FRM_ERR_INT_ST: u1,

          /// [4:4] This is the status bit for rxfifo_ovf_int_raw when rxfifo_ovf_int_ena is set to 1.
          RXFIFO_OVF_INT_ST: u1,

          /// [5:5] This is the status bit for dsr_chg_int_raw when dsr_chg_int_ena is set to 1.
          DSR_CHG_INT_ST: u1,

          /// [6:6] This is the status bit for cts_chg_int_raw when cts_chg_int_ena is set to 1.
          CTS_CHG_INT_ST: u1,

          /// [7:7] This is the status bit for brk_det_int_raw when brk_det_int_ena is set to 1.
          BRK_DET_INT_ST: u1,

          /// [8:8] This is the status bit for rxfifo_tout_int_raw when rxfifo_tout_int_ena is set to 1.
          RXFIFO_TOUT_INT_ST: u1,

          /// [9:9] This is the status bit for sw_xon_int_raw when sw_xon_int_ena is set to 1.
          SW_XON_INT_ST: u1,

          /// [10:10] This is the status bit for sw_xoff_int_raw when sw_xoff_int_ena is set to 1.
          SW_XOFF_INT_ST: u1,

          /// [11:11] This is the status bit for glitch_det_int_raw when glitch_det_int_ena is set to 1.
          GLITCH_DET_INT_ST: u1,

          /// [12:12] This is the status bit for tx_brk_done_int_raw when tx_brk_done_int_ena is set to 1.
          TX_BRK_DONE_INT_ST: u1,

          /// [13:13] This is the stauts bit for tx_brk_idle_done_int_raw when tx_brk_idle_done_int_ena is set to 1.
          TX_BRK_IDLE_DONE_INT_ST: u1,

          /// [14:14] This is the status bit for tx_done_int_raw when tx_done_int_ena is set to 1.
          TX_DONE_INT_ST: u1,

          /// [15:17] 
          res0: u3,

          /// [18:18] This is the status bit for at_cmd_det_int_raw when at_cmd_char_det_int_ena is set to 1.
          AT_CMD_CHAR_DET_INT_ST: u1,

          /// [19:19] This is the status bit for uart_wakeup_int_raw when uart_wakeup_int_ena is set to 1.
          WAKEUP_INT_ST: u1,

          /// [20:31] 
          res1: u12,

        }), @ptrFromInt(0x600b1408));

        /// Interrupt enable bits
        pub const INT_ENA = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] This is the enable bit for rxfifo_full_int_st register.
          RXFIFO_FULL_INT_ENA: u1,

          /// [1:1] This is the enable bit for txfifo_empty_int_st register.
          TXFIFO_EMPTY_INT_ENA: u1,

          /// [2:2] This is the enable bit for parity_err_int_st register.
          PARITY_ERR_INT_ENA: u1,

          /// [3:3] This is the enable bit for frm_err_int_st register.
          FRM_ERR_INT_ENA: u1,

          /// [4:4] This is the enable bit for rxfifo_ovf_int_st register.
          RXFIFO_OVF_INT_ENA: u1,

          /// [5:5] This is the enable bit for dsr_chg_int_st register.
          DSR_CHG_INT_ENA: u1,

          /// [6:6] This is the enable bit for cts_chg_int_st register.
          CTS_CHG_INT_ENA: u1,

          /// [7:7] This is the enable bit for brk_det_int_st register.
          BRK_DET_INT_ENA: u1,

          /// [8:8] This is the enable bit for rxfifo_tout_int_st register.
          RXFIFO_TOUT_INT_ENA: u1,

          /// [9:9] This is the enable bit for sw_xon_int_st register.
          SW_XON_INT_ENA: u1,

          /// [10:10] This is the enable bit for sw_xoff_int_st register.
          SW_XOFF_INT_ENA: u1,

          /// [11:11] This is the enable bit for glitch_det_int_st register.
          GLITCH_DET_INT_ENA: u1,

          /// [12:12] This is the enable bit for tx_brk_done_int_st register.
          TX_BRK_DONE_INT_ENA: u1,

          /// [13:13] This is the enable bit for tx_brk_idle_done_int_st register.
          TX_BRK_IDLE_DONE_INT_ENA: u1,

          /// [14:14] This is the enable bit for tx_done_int_st register.
          TX_DONE_INT_ENA: u1,

          /// [15:17] 
          res0: u3,

          /// [18:18] This is the enable bit for at_cmd_char_det_int_st register.
          AT_CMD_CHAR_DET_INT_ENA: u1,

          /// [19:19] This is the enable bit for uart_wakeup_int_st register.
          WAKEUP_INT_ENA: u1,

          /// [20:31] 
          res1: u12,

        }), @ptrFromInt(0x600b140c));

        /// Interrupt clear bits
        pub const INT_CLR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Set this bit to clear the rxfifo_full_int_raw interrupt.
          RXFIFO_FULL_INT_CLR: u1,

          /// [1:1] Set this bit to clear txfifo_empty_int_raw interrupt.
          TXFIFO_EMPTY_INT_CLR: u1,

          /// [2:2] Set this bit to clear parity_err_int_raw interrupt.
          PARITY_ERR_INT_CLR: u1,

          /// [3:3] Set this bit to clear frm_err_int_raw interrupt.
          FRM_ERR_INT_CLR: u1,

          /// [4:4] Set this bit to clear rxfifo_ovf_int_raw interrupt.
          RXFIFO_OVF_INT_CLR: u1,

          /// [5:5] Set this bit to clear the dsr_chg_int_raw interrupt.
          DSR_CHG_INT_CLR: u1,

          /// [6:6] Set this bit to clear the cts_chg_int_raw interrupt.
          CTS_CHG_INT_CLR: u1,

          /// [7:7] Set this bit to clear the brk_det_int_raw interrupt.
          BRK_DET_INT_CLR: u1,

          /// [8:8] Set this bit to clear the rxfifo_tout_int_raw interrupt.
          RXFIFO_TOUT_INT_CLR: u1,

          /// [9:9] Set this bit to clear the sw_xon_int_raw interrupt.
          SW_XON_INT_CLR: u1,

          /// [10:10] Set this bit to clear the sw_xoff_int_raw interrupt.
          SW_XOFF_INT_CLR: u1,

          /// [11:11] Set this bit to clear the glitch_det_int_raw interrupt.
          GLITCH_DET_INT_CLR: u1,

          /// [12:12] Set this bit to clear the tx_brk_done_int_raw interrupt..
          TX_BRK_DONE_INT_CLR: u1,

          /// [13:13] Set this bit to clear the tx_brk_idle_done_int_raw interrupt.
          TX_BRK_IDLE_DONE_INT_CLR: u1,

          /// [14:14] Set this bit to clear the tx_done_int_raw interrupt.
          TX_DONE_INT_CLR: u1,

          /// [15:17] 
          res0: u3,

          /// [18:18] Set this bit to clear the at_cmd_char_det_int_raw interrupt.
          AT_CMD_CHAR_DET_INT_CLR: u1,

          /// [19:19] Set this bit to clear the uart_wakeup_int_raw interrupt.
          WAKEUP_INT_CLR: u1,

          /// [20:31] 
          res1: u12,

        }), @ptrFromInt(0x600b1410));

        /// Clock divider configuration
        pub const CLKDIV = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:11] The integral part of the frequency divider factor.
          CLKDIV: u12,

          /// [12:19] 
          res0: u8,

          /// [20:23] The decimal part of the frequency divider factor.
          FRAG: u4,

          /// [24:31] 
          res1: u8,

        }), @ptrFromInt(0x600b1414));

        /// Rx Filter configuration
        pub const RX_FILT = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] when input pulse width is lower than this value the pulse is ignored.
          GLITCH_FILT: u8,

          /// [8:8] Set this bit to enable Rx signal filter.
          GLITCH_FILT_EN: u1,

          /// [9:31] 
          res0: u23,

        }), @ptrFromInt(0x600b1418));

        /// UART status register
        pub const STATUS = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:2] 
          res0: u3,

          /// [3:7] Stores the byte number of valid data in Rx-FIFO.
          RXFIFO_CNT: u5,

          /// [8:12] 
          res1: u5,

          /// [13:13] The register represent the level value of the internal uart dsr signal.
          DSRN: u1,

          /// [14:14] This register represent the level value of the internal uart cts signal.
          CTSN: u1,

          /// [15:15] This register represent thelevel value of the internal uart rxd signal.
          RXD: u1,

          /// [16:18] 
          res2: u3,

          /// [19:23] Stores the byte number of data in Tx-FIFO.
          TXFIFO_CNT: u5,

          /// [24:28] 
          res3: u5,

          /// [29:29] This bit represents the level of the internal uart dtr signal.
          DTRN: u1,

          /// [30:30] This bit represents the level of the internal uart rts signal.
          RTSN: u1,

          /// [31:31] This bit represents thelevel of the internal uart txd signal.
          TXD: u1,

        }), @ptrFromInt(0x600b141c));

        /// Configuration register 0
        pub const CONF0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] This register is used to configure the parity check mode.
          PARITY: u1,

          /// [1:1] Set this bit to enable uart parity check.
          PARITY_EN: u1,

          /// [2:3] This register is used to set the length of data.
          BIT_NUM: u2,

          /// [4:5] This register is used to set the length ofstop bit.
          STOP_BIT_NUM: u2,

          /// [6:6] Set this bit to enbale transmitter tosend NULL when the process of sending data is done.
          TXD_BRK: u1,

          /// [7:11] 
          res0: u5,

          /// [12:12] Set this bit to enable uart loopback test mode.
          LOOPBACK: u1,

          /// [13:13] Set this bit to enable flow control function for transmitter.
          TX_FLOW_EN: u1,

          /// [14:14] 
          res1: u1,

          /// [15:15] Set this bit to inverse the level value of uart rxd signal.
          RXD_INV: u1,

          /// [16:16] Set this bit to inverse the level value of uart txd signal.
          TXD_INV: u1,

          /// [17:17] Disable UART Rx data overflow detect.
          DIS_RX_DAT_OVF: u1,

          /// [18:18] 1'h1: Receiver stops storing data into FIFO when data is wrong. 1'h0: Receiver stores the data even if thereceived data is wrong.
          ERR_WR_MASK: u1,

          /// [19:19] 
          res2: u1,

          /// [20:20] UART memory clock gate enable signal.
          MEM_CLK_EN: u1,

          /// [21:21] This register is used to configure the software rts signal which is used in software flow control.
          SW_RTS: u1,

          /// [22:22] Set this bit to reset the uart receive-FIFO.
          RXFIFO_RST: u1,

          /// [23:23] Set this bit to reset the uart transmit-FIFO.
          TXFIFO_RST: u1,

          /// [24:31] 
          res3: u8,

        }), @ptrFromInt(0x600b1420));

        /// Configuration register 1
        pub const CONF1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:2] 
          res0: u3,

          /// [3:7] It will produce rxfifo_full_int interrupt when receiver receives more data than this register value.
          RXFIFO_FULL_THRHD: u5,

          /// [8:10] 
          res1: u3,

          /// [11:15] It will produce txfifo_empty_int interrupt when the data amount in Tx-FIFO is less than this register value.
          TXFIFO_EMPTY_THRHD: u5,

          /// [16:16] Set this bit to inverse the level value of uart cts signal.
          CTS_INV: u1,

          /// [17:17] Set this bit to inverse the level value of uart dsr signal.
          DSR_INV: u1,

          /// [18:18] Set this bit to inverse the level value of uart rts signal.
          RTS_INV: u1,

          /// [19:19] Set this bit to inverse the level value of uart dtr signal.
          DTR_INV: u1,

          /// [20:20] This register is used to configure the software dtr signal which is used in software flow control.
          SW_DTR: u1,

          /// [21:21] 1'h1: Force clock on for register. 1'h0: Support clock only when application writes registers.
          CLK_EN: u1,

          /// [22:31] 
          res2: u10,

        }), @ptrFromInt(0x600b1424));

        /// Hardware flow-control configuration
        pub const HWFC_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:2] 
          res0: u3,

          /// [3:7] This register is used to configure the maximum amount of data that can be receivedwhen hardware flow control works.
          RX_FLOW_THRHD: u5,

          /// [8:8] This is the flow enable bit for UART receiver.
          RX_FLOW_EN: u1,

          /// [9:31] 
          res1: u23,

        }), @ptrFromInt(0x600b142c));

        /// UART sleep configure register 0
        pub const SLEEP_CONF0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] This register restores the specified wake up char1 to wake up
          WK_CHAR1: u8,

          /// [8:15] This register restores the specified wake up char2 to wake up
          WK_CHAR2: u8,

          /// [16:23] This register restores the specified wake up char3 to wake up
          WK_CHAR3: u8,

          /// [24:31] This register restores the specified wake up char4 to wake up
          WK_CHAR4: u8,

        }), @ptrFromInt(0x600b1430));

        /// UART sleep configure register 1
        pub const SLEEP_CONF1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] This register restores the specified char0 to wake up
          WK_CHAR0: u8,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x600b1434));

        /// UART sleep configure register 2
        pub const SLEEP_CONF2 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:9] The uart is activated from light sleeping mode when the input rxd edge changes more times than this register value.
          ACTIVE_THRESHOLD: u10,

          /// [10:12] 
          res0: u3,

          /// [13:17] In wake up mode 1 this field is used to set the received data number threshold to wake up chip.
          RX_WAKE_UP_THRHD: u5,

          /// [18:20] This register is used to select number of wake up char.
          WK_CHAR_NUM: u3,

          /// [21:25] This register is used to maskwake up char.
          WK_CHAR_MASK: u5,

          /// [26:27] This register is used to select wake up mode. 0: RXD toggling to wake up. 1: received data number larger than
          WK_MODE_SEL: u2,

          /// [28:31] 
          res1: u4,

        }), @ptrFromInt(0x600b1438));

        /// Software flow-control character configuration
        pub const SWFC_CONF0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] This register stores the Xon flow control char.
          XON_CHAR: u8,

          /// [8:15] This register stores the Xoff flow control char.
          XOFF_CHAR: u8,

          /// [16:16] In software flow control mode, UART Tx is disabled once UART Rx receives XOFF. In this status, UART Tx can not transmit XOFF even the received data number is larger than UART_XOFF_THRESHOLD. Set this bit to enable UART Tx can transmit XON/XOFF when UART Tx is disabled.
          XON_XOFF_STILL_SEND: u1,

          /// [17:17] Set this bit to enable software flow control. It is used with register sw_xon or sw_xoff.
          SW_FLOW_CON_EN: u1,

          /// [18:18] Set this bit to remove flow control char from the received data.
          XONOFF_DEL: u1,

          /// [19:19] Set this bit to enable the transmitter to go on sending data.
          FORCE_XON: u1,

          /// [20:20] Set this bit to stop thetransmitter from sending data.
          FORCE_XOFF: u1,

          /// [21:21] Set this bit to send Xon char. It is cleared by hardware automatically.
          SEND_XON: u1,

          /// [22:22] Set this bit to send Xoff char. It is cleared by hardware automatically.
          SEND_XOFF: u1,

          /// [23:31] 
          res0: u9,

        }), @ptrFromInt(0x600b143c));

        /// Software flow-control character configuration
        pub const SWFC_CONF1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:2] 
          res0: u3,

          /// [3:7] When the data amount in Rx-FIFO is less than this register value with uart_sw_flow_con_en set to 1it will send a Xon char.
          XON_THRESHOLD: u5,

          /// [8:10] 
          res1: u3,

          /// [11:15] When the data amount in Rx-FIFO is more than this register value with uart_sw_flow_con_en set to 1it will send a Xoff char.
          XOFF_THRESHOLD: u5,

          /// [16:31] 
          res2: u16,

        }), @ptrFromInt(0x600b1440));

        /// Tx Break character configuration
        pub const TXBRK_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] This register is used to configure the number of 0 to be sent after the process of sending data is done. It is active when txd_brk is set to 1.
          TX_BRK_NUM: u8,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x600b1444));

        /// Frame-end idle configuration
        pub const IDLE_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:9] It will produce frame end signal when receiver takes more time to receive one byte data than this register value.
          RX_IDLE_THRHD: u10,

          /// [10:19] This register is used to configure the duration time between transfers.
          TX_IDLE_NUM: u10,

          /// [20:31] 
          res0: u12,

        }), @ptrFromInt(0x600b1448));

        /// RS485 mode configuration
        pub const RS485_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] 
          res0: u1,

          /// [1:1] Set this bit to delay the stop bit by 1 bit.
          DL0_EN: u1,

          /// [2:2] Set this bit to delay the stop bit by 1 bit.
          DL1_EN: u1,

          /// [3:31] 
          res1: u29,

        }), @ptrFromInt(0x600b144c));

        /// Pre-sequence timing configuration
        pub const AT_CMD_PRECNT = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:15] This register is used to configure the idle duration time before the first at_cmd is received by receiver.
          PRE_IDLE_NUM: u16,

          /// [16:31] 
          res0: u16,

        }), @ptrFromInt(0x600b1450));

        /// Post-sequence timing configuration
        pub const AT_CMD_POSTCNT = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:15] This register is used to configure the duration time between the last at_cmd and the next data.
          POST_IDLE_NUM: u16,

          /// [16:31] 
          res0: u16,

        }), @ptrFromInt(0x600b1454));

        /// Timeout configuration
        pub const AT_CMD_GAPTOUT = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:15] This register is used to configure the duration time between the at_cmd chars.
          RX_GAP_TOUT: u16,

          /// [16:31] 
          res0: u16,

        }), @ptrFromInt(0x600b1458));

        /// AT escape sequence detection configuration
        pub const AT_CMD_CHAR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] This register is used to configure the content of at_cmd char.
          AT_CMD_CHAR: u8,

          /// [8:15] This register is used to configure the num of continuous at_cmd chars received by receiver.
          CHAR_NUM: u8,

          /// [16:31] 
          res0: u16,

        }), @ptrFromInt(0x600b145c));

        /// UART memory power configuration
        pub const MEM_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:24] 
          res0: u25,

          /// [25:25] Set this bit to force power down UART memory.
          MEM_FORCE_PD: u1,

          /// [26:26] Set this bit to force power up UART memory.
          MEM_FORCE_PU: u1,

          /// [27:31] 
          res1: u5,

        }), @ptrFromInt(0x600b1460));

        /// UART threshold and allocation configuration
        pub const TOUT_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] This is the enble bit for uart receiver's timeout function.
          RX_TOUT_EN: u1,

          /// [1:1] Set this bit to stop accumulating idle_cnt when hardware flow control works.
          RX_TOUT_FLOW_DIS: u1,

          /// [2:11] This register is used to configure the threshold time that receiver takes to receive one byte. The rxfifo_tout_int interrupt will be trigger when the receiver takes more time to receive one byte with rx_tout_en set to 1.
          RX_TOUT_THRHD: u10,

          /// [12:31] 
          res0: u20,

        }), @ptrFromInt(0x600b1464));

        /// Tx-SRAM write and read offset address.
        pub const MEM_TX_STATUS = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:2] 
          res0: u3,

          /// [3:7] This register stores the offset write address in Tx-SRAM.
          TX_SRAM_WADDR: u5,

          /// [8:11] 
          res1: u4,

          /// [12:16] This register stores the offset read address in Tx-SRAM.
          TX_SRAM_RADDR: u5,

          /// [17:31] 
          res2: u15,

        }), @ptrFromInt(0x600b1468));

        /// Rx-SRAM write and read offset address.
        pub const MEM_RX_STATUS = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:2] 
          res0: u3,

          /// [3:7] This register stores the offset read address in RX-SRAM.
          RX_SRAM_RADDR: u5,

          /// [8:11] 
          res1: u4,

          /// [12:16] This register stores the offset write address in Rx-SRAM.
          RX_SRAM_WADDR: u5,

          /// [17:31] 
          res2: u15,

        }), @ptrFromInt(0x600b146c));

        /// UART transmit and receive status.
        pub const FSM_STATUS = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:3] This is the status register of receiver.
          ST_URX_OUT: u4,

          /// [4:7] This is the status register of transmitter.
          ST_UTX_OUT: u4,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x600b1470));

        /// UART core clock configuration
        pub const CLK_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] Thedenominator of the frequency divider factor.
          SCLK_DIV_B: u6,

          /// [6:11] The numerator of the frequency divider factor.
          SCLK_DIV_A: u6,

          /// [12:19] The integral part of the frequency divider factor.
          SCLK_DIV_NUM: u8,

          /// [20:21] UART clock source select. 1: 80Mhz.2: 8Mhz.3: XTAL.
          SCLK_SEL: u2,

          /// [22:22] Set this bit to enable UART Tx/Rx clock.
          SCLK_EN: u1,

          /// [23:23] Write 1 then write 0 to this bit to reset UART Tx/Rx.
          RST_CORE: u1,

          /// [24:24] Set this bit to enable UART Tx clock.
          TX_SCLK_EN: u1,

          /// [25:25] Set this bit to enable UART Rx clock.
          RX_SCLK_EN: u1,

          /// [26:26] Write 1 then write 0 to this bit to reset UART Tx.
          TX_RST_CORE: u1,

          /// [27:27] Write 1 then write 0 to this bit to reset UART Rx.
          RX_RST_CORE: u1,

          /// [28:31] 
          res0: u4,

        }), @ptrFromInt(0x600b1488));

        /// UART Version register
        pub const DATE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] This is the version register.
          DATE: u32,

        }), @ptrFromInt(0x600b148c));

        /// UART AFIFO Status
        pub const AFIFO_STATUS = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Full signal of APB TX AFIFO.
          TX_AFIFO_FULL: u1,

          /// [1:1] Empty signal of APB TX AFIFO.
          TX_AFIFO_EMPTY: u1,

          /// [2:2] Full signal of APB RX AFIFO.
          RX_AFIFO_FULL: u1,

          /// [3:3] Empty signal of APB RX AFIFO.
          RX_AFIFO_EMPTY: u1,

          /// [4:31] 
          res0: u28,

        }), @ptrFromInt(0x600b1490));

        /// UART Registers Configuration Update register
        pub const REG_UPDATE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Software write 1 would synchronize registers into UART Core clock domain and would be cleared by hardware after synchronization is done.
          REG_UPDATE: u1,

          /// [1:31] 
          res0: u31,

        }), @ptrFromInt(0x600b1498));

        /// UART ID register
        pub const ID = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] This register is used to configure the uart_id.
          ID: u32,

        }), @ptrFromInt(0x600b149c));

      };

      /// Low-power Watchdog Timer
      pub const LP_WDT = struct {

        /// need_des
        pub const WDTCONFIG0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] need_des
          WDT_CHIP_RESET_WIDTH: u8,

          /// [8:8] need_des
          WDT_CHIP_RESET_EN: u1,

          /// [9:9] need_des
          WDT_PAUSE_IN_SLP: u1,

          /// [10:10] need_des
          WDT_APPCPU_RESET_EN: u1,

          /// [11:11] need_des
          WDT_PROCPU_RESET_EN: u1,

          /// [12:12] need_des
          WDT_FLASHBOOT_MOD_EN: u1,

          /// [13:15] need_des
          WDT_SYS_RESET_LENGTH: u3,

          /// [16:18] need_des
          WDT_CPU_RESET_LENGTH: u3,

          /// [19:21] need_des
          WDT_STG3: u3,

          /// [22:24] need_des
          WDT_STG2: u3,

          /// [25:27] need_des
          WDT_STG1: u3,

          /// [28:30] need_des
          WDT_STG0: u3,

          /// [31:31] need_des
          WDT_EN: u1,

        }), @ptrFromInt(0x600b1c00));

        /// need_des
        pub const CONFIG1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] need_des
          WDT_STG0_HOLD: u32,

        }), @ptrFromInt(0x600b1c04));

        /// need_des
        pub const CONFIG2 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] need_des
          WDT_STG1_HOLD: u32,

        }), @ptrFromInt(0x600b1c08));

        /// need_des
        pub const CONFIG3 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] need_des
          WDT_STG2_HOLD: u32,

        }), @ptrFromInt(0x600b1c0c));

        /// need_des
        pub const CONFIG4 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] need_des
          WDT_STG3_HOLD: u32,

        }), @ptrFromInt(0x600b1c10));

        /// need_des
        pub const WDTFEED = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:30] 
          res0: u31,

          /// [31:31] need_des
          RTC_WDT_FEED: u1,

        }), @ptrFromInt(0x600b1c14));

        /// need_des
        pub const WDTWPROTECT = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] need_des
          WDT_WKEY: u32,

        }), @ptrFromInt(0x600b1c18));

        /// need_des
        pub const SWD_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] need_des
          SWD_RESET_FLAG: u1,

          /// [1:17] 
          res0: u17,

          /// [18:18] need_des
          SWD_AUTO_FEED_EN: u1,

          /// [19:19] need_des
          SWD_RST_FLAG_CLR: u1,

          /// [20:29] need_des
          SWD_SIGNAL_WIDTH: u10,

          /// [30:30] need_des
          SWD_DISABLE: u1,

          /// [31:31] need_des
          SWD_FEED: u1,

        }), @ptrFromInt(0x600b1c1c));

        /// need_des
        pub const SWD_WPROTECT = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] need_des
          SWD_WKEY: u32,

        }), @ptrFromInt(0x600b1c20));

        /// need_des
        pub const INT_RAW = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:29] 
          res0: u30,

          /// [30:30] need_des
          SUPER_WDT_INT_RAW: u1,

          /// [31:31] need_des
          LP_WDT_INT_RAW: u1,

        }), @ptrFromInt(0x600b1c24));

        /// need_des
        pub const INT_ST_RTC = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:29] 
          res0: u30,

          /// [30:30] need_des
          SUPER_WDT_INT_ST: u1,

          /// [31:31] need_des
          WDT_INT_ST: u1,

        }), @ptrFromInt(0x600b1c28));

        /// need_des
        pub const INT_ENA_RTC = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:29] 
          res0: u30,

          /// [30:30] need_des
          SUPER_WDT_INT_ENA: u1,

          /// [31:31] need_des
          WDT_INT_ENA: u1,

        }), @ptrFromInt(0x600b1c2c));

        /// need_des
        pub const INT_CLR_RTC = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:29] 
          res0: u30,

          /// [30:30] need_des
          SUPER_WDT_INT_CLR: u1,

          /// [31:31] need_des
          WDT_INT_CLR: u1,

        }), @ptrFromInt(0x600b1c30));

        /// need_des
        pub const DATE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:30] need_des
          LP_WDT_DATE: u31,

          /// [31:31] need_des
          CLK_EN: u1,

        }), @ptrFromInt(0x600b1ffc));

      };

      /// Motor Control Pulse-Width Modulation 0
      pub const MCPWM0 = struct {

        /// PWM clock prescaler register.
        pub const CLK_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] Period of PWM_clk = 6.25ns * (PWM_CLK_PRESCALE + 1)
          CLK_PRESCALE: u8,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x60014000));

        /// PWM timer0 period and update method configuration register.
        pub const TIMER0_CFG0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] period of PT0_clk = Period of PWM_clk * (PWM_TIMER0_PRESCALE + 1)
          TIMER0_PRESCALE: u8,

          /// [8:23] period shadow register of PWM timer0
          TIMER0_PERIOD: u16,

          /// [24:25] Update method for active register of PWM timer0 period, 0: immediate, 1: TEZ, 2: sync, 3: TEZ | sync. TEZ here and below means timer equal zero event
          TIMER0_PERIOD_UPMETHOD: u2,

          /// [26:31] 
          res0: u6,

        }), @ptrFromInt(0x60014004));

        /// PWM timer0 working mode and start/stop control configuration register.
        pub const TIMER0_CFG1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:2] PWM timer0 start and stop control. 0: if PWM timer0 starts, then stops at TEZ, 1: if timer0 starts, then stops at TEP, 2: PWM timer0 starts and runs on, 3: timer0 starts and stops at the next TEZ, 4: timer0 starts and stops at the next TEP. TEP here and below means the event that happens when the timer equals to period
          TIMER0_START: u3,

          /// [3:4] PWM timer0 working mode, 0: freeze, 1: increase mode, 2: decrease mode, 3: up-down mode
          TIMER0_MOD: u2,

          /// [5:31] 
          res0: u27,

        }), @ptrFromInt(0x60014008));

        /// PWM timer0 sync function configuration register.
        pub const TIMER0_SYNC = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] When set, timer reloading with phase on sync input event is enabled.
          TIMER0_SYNCI_EN: u1,

          /// [1:1] Toggling this bit will trigger a software sync.
          SW: u1,

          /// [2:3] PWM timer0 sync_out selection, 0: sync_in, 1: TEZ, 2: TEP, and sync out will always generate when toggling the reg_timer0_sync_sw bit
          TIMER0_SYNCO_SEL: u2,

          /// [4:19] phase for timer reload on sync event
          TIMER0_PHASE: u16,

          /// [20:20] Configure the PWM timer0's direction when timer0 mode is up-down mode: 0-increase,1-decrease
          TIMER0_PHASE_DIRECTION: u1,

          /// [21:31] 
          res0: u11,

        }), @ptrFromInt(0x6001400c));

        /// PWM timer0 status register.
        pub const TIMER0_STATUS = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:15] current PWM timer0 counter value
          TIMER0_VALUE: u16,

          /// [16:16] current PWM timer0 counter direction, 0: increment 1: decrement
          TIMER0_DIRECTION: u1,

          /// [17:31] 
          res0: u15,

        }), @ptrFromInt(0x60014010));

        /// PWM timer1 period and update method configuration register.
        pub const TIMER1_CFG0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] period of PT0_clk = Period of PWM_clk * (PWM_timer1_PRESCALE + 1)
          TIMER1_PRESCALE: u8,

          /// [8:23] period shadow register of PWM timer1
          TIMER1_PERIOD: u16,

          /// [24:25] Update method for active register of PWM timer1 period, 0: immediate, 1: TEZ, 2: sync, 3: TEZ | sync. TEZ here and below means timer equal zero event
          TIMER1_PERIOD_UPMETHOD: u2,

          /// [26:31] 
          res0: u6,

        }), @ptrFromInt(0x60014014));

        /// PWM timer1 working mode and start/stop control configuration register.
        pub const TIMER1_CFG1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:2] PWM timer1 start and stop control. 0: if PWM timer1 starts, then stops at TEZ, 1: if timer1 starts, then stops at TEP, 2: PWM timer1 starts and runs on, 3: timer1 starts and stops at the next TEZ, 4: timer1 starts and stops at the next TEP. TEP here and below means the event that happens when the timer equals to period
          TIMER1_START: u3,

          /// [3:4] PWM timer1 working mode, 0: freeze, 1: increase mode, 2: decrease mode, 3: up-down mode
          TIMER1_MOD: u2,

          /// [5:31] 
          res0: u27,

        }), @ptrFromInt(0x60014018));

        /// PWM timer1 sync function configuration register.
        pub const TIMER1_SYNC = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] When set, timer reloading with phase on sync input event is enabled.
          TIMER1_SYNCI_EN: u1,

          /// [1:1] Toggling this bit will trigger a software sync.
          SW: u1,

          /// [2:3] PWM timer1 sync_out selection, 0: sync_in, 1: TEZ, 2: TEP, and sync out will always generate when toggling the reg_timer1_sync_sw bit
          TIMER1_SYNCO_SEL: u2,

          /// [4:19] phase for timer reload on sync event
          TIMER1_PHASE: u16,

          /// [20:20] Configure the PWM timer1's direction when timer1 mode is up-down mode: 0-increase,1-decrease
          TIMER1_PHASE_DIRECTION: u1,

          /// [21:31] 
          res0: u11,

        }), @ptrFromInt(0x6001401c));

        /// PWM timer1 status register.
        pub const TIMER1_STATUS = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:15] current PWM timer1 counter value
          TIMER1_VALUE: u16,

          /// [16:16] current PWM timer1 counter direction, 0: increment 1: decrement
          TIMER1_DIRECTION: u1,

          /// [17:31] 
          res0: u15,

        }), @ptrFromInt(0x60014020));

        /// PWM timer2 period and update method configuration register.
        pub const TIMER2_CFG0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] period of PT0_clk = Period of PWM_clk * (PWM_timer2_PRESCALE + 1)
          TIMER2_PRESCALE: u8,

          /// [8:23] period shadow register of PWM timer2
          TIMER2_PERIOD: u16,

          /// [24:25] Update method for active register of PWM timer2 period, 0: immediate, 1: TEZ, 2: sync, 3: TEZ | sync. TEZ here and below means timer equal zero event
          TIMER2_PERIOD_UPMETHOD: u2,

          /// [26:31] 
          res0: u6,

        }), @ptrFromInt(0x60014024));

        /// PWM timer2 working mode and start/stop control configuration register.
        pub const TIMER2_CFG1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:2] PWM timer2 start and stop control. 0: if PWM timer2 starts, then stops at TEZ, 1: if timer2 starts, then stops at TEP, 2: PWM timer2 starts and runs on, 3: timer2 starts and stops at the next TEZ, 4: timer2 starts and stops at the next TEP. TEP here and below means the event that happens when the timer equals to period
          TIMER2_START: u3,

          /// [3:4] PWM timer2 working mode, 0: freeze, 1: increase mode, 2: decrease mode, 3: up-down mode
          TIMER2_MOD: u2,

          /// [5:31] 
          res0: u27,

        }), @ptrFromInt(0x60014028));

        /// PWM timer2 sync function configuration register.
        pub const TIMER2_SYNC = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] When set, timer reloading with phase on sync input event is enabled.
          TIMER2_SYNCI_EN: u1,

          /// [1:1] Toggling this bit will trigger a software sync.
          SW: u1,

          /// [2:3] PWM timer2 sync_out selection, 0: sync_in, 1: TEZ, 2: TEP, and sync out will always generate when toggling the reg_timer0_sync_sw bit
          TIMER2_SYNCO_SEL: u2,

          /// [4:19] phase for timer reload on sync event
          TIMER2_PHASE: u16,

          /// [20:20] Configure the PWM timer2's direction when timer2 mode is up-down mode: 0-increase,1-decrease
          TIMER2_PHASE_DIRECTION: u1,

          /// [21:31] 
          res0: u11,

        }), @ptrFromInt(0x6001402c));

        /// PWM timer2 status register.
        pub const TIMER2_STATUS = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:15] current PWM timer2 counter value
          TIMER2_VALUE: u16,

          /// [16:16] current PWM timer2 counter direction, 0: increment 1: decrement
          TIMER2_DIRECTION: u1,

          /// [17:31] 
          res0: u15,

        }), @ptrFromInt(0x60014030));

        /// Synchronization input selection for three PWM timers.
        pub const TIMER_SYNCI_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:2] select sync input for PWM timer0, 1: PWM timer0 sync_out, 2: PWM timer1 sync_out, 3: PWM timer2 sync_out, 4: SYNC0 from GPIO matrix, 5: SYNC1 from GPIO matrix, 6: SYNC2 from GPIO matrix, other values: no sync input selected
          TIMER0_SYNCISEL: u3,

          /// [3:5] select sync input for PWM timer1, 1: PWM timer0 sync_out, 2: PWM timer1 sync_out, 3: PWM timer2 sync_out, 4: SYNC0 from GPIO matrix, 5: SYNC1 from GPIO matrix, 6: SYNC2 from GPIO matrix, other values: no sync input selected
          TIMER1_SYNCISEL: u3,

          /// [6:8] select sync input for PWM timer2, 1: PWM timer0 sync_out, 2: PWM timer1 sync_out, 3: PWM timer2 sync_out, 4: SYNC0 from GPIO matrix, 5: SYNC1 from GPIO matrix, 6: SYNC2 from GPIO matrix, other values: no sync input selected
          TIMER2_SYNCISEL: u3,

          /// [9:9] invert SYNC0 from GPIO matrix
          EXTERNAL_SYNCI0_INVERT: u1,

          /// [10:10] invert SYNC1 from GPIO matrix
          EXTERNAL_SYNCI1_INVERT: u1,

          /// [11:11] invert SYNC2 from GPIO matrix
          EXTERNAL_SYNCI2_INVERT: u1,

          /// [12:31] 
          res0: u20,

        }), @ptrFromInt(0x60014034));

        /// Select specific timer for PWM operators.
        pub const OPERATOR_TIMERSEL = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:1] Select which PWM timer's is the timing reference for PWM operator0, 0: timer0, 1: timer1, 2: timer2
          OPERATOR0_TIMERSEL: u2,

          /// [2:3] Select which PWM timer's is the timing reference for PWM operator1, 0: timer0, 1: timer1, 2: timer2
          OPERATOR1_TIMERSEL: u2,

          /// [4:5] Select which PWM timer's is the timing reference for PWM operator2, 0: timer0, 1: timer1, 2: timer2
          OPERATOR2_TIMERSEL: u2,

          /// [6:31] 
          res0: u26,

        }), @ptrFromInt(0x60014038));

        /// Transfer status and update method for time stamp registers A and B
        pub const GEN0_STMP_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:3] Update method for PWM generator 0 time stamp A's active register. When all bits are set to 0: immediately, when bit0 is set to 1: TEZ, when bit1 is set to 1: TEP,when bit2 is set to 1: sync, when bit3 is set to 1: disable the update.
          CMPR0_A_UPMETHOD: u4,

          /// [4:7] Update method for PWM generator 0 time stamp B's active register. When all bits are set to 0: immediately, when bit0 is set to 1: TEZ, when bit1 is set to 1: TEP,when bit2 is set to 1: sync, when bit3 is set to 1: disable the update.
          CMPR0_B_UPMETHOD: u4,

          /// [8:8] Set and reset by hardware. If set, PWM generator 0 time stamp A's shadow reg is filled and waiting to be transferred to A's active reg. If cleared, A's active reg has been updated with shadow register latest value
          CMPR0_A_SHDW_FULL: u1,

          /// [9:9] Set and reset by hardware. If set, PWM generator 0 time stamp B's shadow reg is filled and waiting to be transferred to B's active reg. If cleared, B's active reg has been updated with shadow register latest value
          CMPR0_B_SHDW_FULL: u1,

          /// [10:31] 
          res0: u22,

        }), @ptrFromInt(0x6001403c));

        /// Shadow register for register A.
        pub const GEN0_TSTMP_A = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:15] PWM generator 0 time stamp A's shadow register
          CMPR0_A: u16,

          /// [16:31] 
          res0: u16,

        }), @ptrFromInt(0x60014040));

        /// Shadow register for register B.
        pub const GEN0_TSTMP_B = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:15] PWM generator 0 time stamp B's shadow register
          CMPR0_B: u16,

          /// [16:31] 
          res0: u16,

        }), @ptrFromInt(0x60014044));

        /// Fault event T0 and T1 handling
        pub const GEN0_CFG0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:3] Update method for PWM generator 0's active register of configuration. When all bits are set to 0: immediately, when bit0 is set to 1: TEZ, when bit1 is set to 1:TEP,when bit2 is set to 1:sync,when bit3 is set to 1:disable the update
          GEN0_CFG_UPMETHOD: u4,

          /// [4:6] Source selection for PWM generator 0 event_t0, take effect immediately, 0: fault_event0, 1: fault_event1, 2: fault_event2, 3: sync_taken, 4: none
          GEN0_T0_SEL: u3,

          /// [7:9] Source selection for PWM generator 0 event_t1, take effect immediately, 0: fault_event0, 1: fault_event1, 2: fault_event2, 3: sync_taken, 4: none
          GEN0_T1_SEL: u3,

          /// [10:31] 
          res0: u22,

        }), @ptrFromInt(0x60014048));

        /// Permissives to force PWM0A and PWM0B outputs by software
        pub const GEN0_FORCE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] Updating method for continuous software force of PWM generator0. When all bits are set to 0: immediately, when bit0 is set to 1: TEZ,,when bit1 is set to 1: TEP, when bit2 is set to 1: TEA, when bit3 is set to 1: TEB, when bit4 is set to 1: sync, when bit5 is set to 1: disable update. (TEA/B here and below means an event generated when the timer's value equals to that of register A/B.)
          GEN0_CNTUFORCE_UPMETHOD: u6,

          /// [6:7] Continuous software force mode for PWM0A. 0: disabled, 1: low, 2: high, 3: disabled
          GEN0_A_CNTUFORCE_MODE: u2,

          /// [8:9] Continuous software force mode for PWM0B. 0: disabled, 1: low, 2: high, 3: disabled
          GEN0_B_CNTUFORCE_MODE: u2,

          /// [10:10] Trigger of non-continuous immediate software-force event for PWM0A, a toggle will trigger a force event.
          GEN0_A_NCIFORCE: u1,

          /// [11:12] non-continuous immediate software force mode for PWM0A, 0: disabled, 1: low, 2: high, 3: disabled
          GEN0_A_NCIFORCE_MODE: u2,

          /// [13:13] Trigger of non-continuous immediate software-force event for PWM0B, a toggle will trigger a force event.
          GEN0_B_NCIFORCE: u1,

          /// [14:15] non-continuous immediate software force mode for PWM0B, 0: disabled, 1: low, 2: high, 3: disabled
          GEN0_B_NCIFORCE_MODE: u2,

          /// [16:31] 
          res0: u16,

        }), @ptrFromInt(0x6001404c));

        /// Actions triggered by events on PWM0A
        pub const GEN0_A = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:1] Action on PWM0A triggered by event TEZ when timer increasing
          UTEZ: u2,

          /// [2:3] Action on PWM0A triggered by event TEP when timer increasing
          UTEP: u2,

          /// [4:5] Action on PWM0A triggered by event TEA when timer increasing
          UTEA: u2,

          /// [6:7] Action on PWM0A triggered by event TEB when timer increasing
          UTEB: u2,

          /// [8:9] Action on PWM0A triggered by event_t0 when timer increasing
          UT0: u2,

          /// [10:11] Action on PWM0A triggered by event_t1 when timer increasing
          UT1: u2,

          /// [12:13] Action on PWM0A triggered by event TEZ when timer decreasing
          DTEZ: u2,

          /// [14:15] Action on PWM0A triggered by event TEP when timer decreasing
          DTEP: u2,

          /// [16:17] Action on PWM0A triggered by event TEA when timer decreasing
          DTEA: u2,

          /// [18:19] Action on PWM0A triggered by event TEB when timer decreasing
          DTEB: u2,

          /// [20:21] Action on PWM0A triggered by event_t0 when timer decreasing
          DT0: u2,

          /// [22:23] Action on PWM0A triggered by event_t1 when timer decreasing. 0: no change, 1: low, 2: high, 3: toggle
          DT1: u2,

          /// [24:31] 
          res0: u8,

        }), @ptrFromInt(0x60014050));

        /// Actions triggered by events on PWM0B
        pub const GEN0_B = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:1] Action on PWM0B triggered by event TEZ when timer increasing
          UTEZ: u2,

          /// [2:3] Action on PWM0B triggered by event TEP when timer increasing
          UTEP: u2,

          /// [4:5] Action on PWM0B triggered by event TEA when timer increasing
          UTEA: u2,

          /// [6:7] Action on PWM0B triggered by event TEB when timer increasing
          UTEB: u2,

          /// [8:9] Action on PWM0B triggered by event_t0 when timer increasing
          UT0: u2,

          /// [10:11] Action on PWM0B triggered by event_t1 when timer increasing
          UT1: u2,

          /// [12:13] Action on PWM0B triggered by event TEZ when timer decreasing
          DTEZ: u2,

          /// [14:15] Action on PWM0B triggered by event TEP when timer decreasing
          DTEP: u2,

          /// [16:17] Action on PWM0B triggered by event TEA when timer decreasing
          DTEA: u2,

          /// [18:19] Action on PWM0B triggered by event TEB when timer decreasing
          DTEB: u2,

          /// [20:21] Action on PWM0B triggered by event_t0 when timer decreasing
          DT0: u2,

          /// [22:23] Action on PWM0B triggered by event_t1 when timer decreasing. 0: no change, 1: low, 2: high, 3: toggle
          DT1: u2,

          /// [24:31] 
          res0: u8,

        }), @ptrFromInt(0x60014054));

        /// dead time type selection and configuration
        pub const DT0_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:3] Update method for FED (rising edge delay) active register. 0: immediate, when bit0 is set to 1: tez, when bit1 is set to 1:tep,when bit2 is set to 1: sync, when bit3 is set to 1: disable the update
          DB0_FED_UPMETHOD: u4,

          /// [4:7] Update method for RED (rising edge delay) active register. 0: immediate, when bit0 is set to 1: tez, when bit1 is set to 1:tep,when bit2 is set to 1: sync, when bit3 is set to 1: disable the update
          DB0_RED_UPMETHOD: u4,

          /// [8:8] S8 in table, dual-edge B mode, 0: fed/red take effect on different path separately, 1: fed/red take effect on B path, A out is in bypass or dulpB mode
          DB0_DEB_MODE: u1,

          /// [9:9] S6 in table
          DB0_A_OUTSWAP: u1,

          /// [10:10] S7 in table
          DB0_B_OUTSWAP: u1,

          /// [11:11] S4 in table
          DB0_RED_INSEL: u1,

          /// [12:12] S5 in table
          DB0_FED_INSEL: u1,

          /// [13:13] S2 in table
          DB0_RED_OUTINVERT: u1,

          /// [14:14] S3 in table
          DB0_FED_OUTINVERT: u1,

          /// [15:15] S1 in table
          DB0_A_OUTBYPASS: u1,

          /// [16:16] S0 in table
          DB0_B_OUTBYPASS: u1,

          /// [17:17] Dead time generator 0 clock selection. 0: PWM_clk, 1: PT_clk
          DB0_CLK_SEL: u1,

          /// [18:31] 
          res0: u14,

        }), @ptrFromInt(0x60014058));

        /// Shadow register for falling edge delay (FED).
        pub const DT0_FED_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:15] Shadow register for FED
          DB0_FED: u16,

          /// [16:31] 
          res0: u16,

        }), @ptrFromInt(0x6001405c));

        /// Shadow register for rising edge delay (RED).
        pub const DT0_RED_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:15] Shadow register for RED
          DB0_RED: u16,

          /// [16:31] 
          res0: u16,

        }), @ptrFromInt(0x60014060));

        /// Carrier enable and configuratoin
        pub const CARRIER0_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] When set, carrier0 function is enabled. When cleared, carrier0 is bypassed
          CHOPPER0_EN: u1,

          /// [1:4] PWM carrier0 clock (PC_clk) prescale value. Period of PC_clk = period of PWM_clk * (PWM_CARRIER0_PRESCALE + 1)
          CHOPPER0_PRESCALE: u4,

          /// [5:7] carrier duty selection. Duty = PWM_CARRIER0_DUTY / 8
          CHOPPER0_DUTY: u3,

          /// [8:11] width of the first pulse in number of periods of the carrier
          CHOPPER0_OSHTWTH: u4,

          /// [12:12] when set, invert the output of PWM0A and PWM0B for this submodule
          CHOPPER0_OUT_INVERT: u1,

          /// [13:13] when set, invert the input of PWM0A and PWM0B for this submodule
          CHOPPER0_IN_INVERT: u1,

          /// [14:31] 
          res0: u18,

        }), @ptrFromInt(0x60014064));

        /// Actions on PWM0A and PWM0B trip events
        pub const FH0_CFG0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Enable register for software force cycle-by-cycle mode action. 0: disable, 1: enable
          TZ0_SW_CBC: u1,

          /// [1:1] event_f2 will trigger cycle-by-cycle mode action. 0: disable, 1: enable
          TZ0_F2_CBC: u1,

          /// [2:2] event_f1 will trigger cycle-by-cycle mode action. 0: disable, 1: enable
          TZ0_F1_CBC: u1,

          /// [3:3] event_f0 will trigger cycle-by-cycle mode action. 0: disable, 1: enable
          TZ0_F0_CBC: u1,

          /// [4:4] Enable register for software force one-shot mode action. 0: disable, 1: enable
          TZ0_SW_OST: u1,

          /// [5:5] event_f2 will trigger one-shot mode action. 0: disable, 1: enable
          TZ0_F2_OST: u1,

          /// [6:6] event_f1 will trigger one-shot mode action. 0: disable, 1: enable
          TZ0_F1_OST: u1,

          /// [7:7] event_f0 will trigger one-shot mode action. 0: disable, 1: enable
          TZ0_F0_OST: u1,

          /// [8:9] Cycle-by-cycle mode action on PWM0A when fault event occurs and timer is decreasing. 0: do nothing, 1: force low, 2: force high, 3: toggle
          TZ0_A_CBC_D: u2,

          /// [10:11] Cycle-by-cycle mode action on PWM0A when fault event occurs and timer is increasing. 0: do nothing, 1: force low, 2: force high, 3: toggle
          TZ0_A_CBC_U: u2,

          /// [12:13] One-shot mode action on PWM0A when fault event occurs and timer is decreasing. 0: do nothing, 1: force low, 2: force high, 3: toggle
          TZ0_A_OST_D: u2,

          /// [14:15] One-shot mode action on PWM0A when fault event occurs and timer is increasing. 0: do nothing, 1: force low, 2: force high, 3: toggle
          TZ0_A_OST_U: u2,

          /// [16:17] Cycle-by-cycle mode action on PWM0B when fault event occurs and timer is decreasing. 0: do nothing, 1: force low, 2: force high, 3: toggle
          TZ0_B_CBC_D: u2,

          /// [18:19] Cycle-by-cycle mode action on PWM0B when fault event occurs and timer is increasing. 0: do nothing,1: force low, 2: force high, 3: toggle
          TZ0_B_CBC_U: u2,

          /// [20:21] One-shot mode action on PWM0B when fault event occurs and timer is decreasing. 0: do nothing, 1: force low, 2: force high, 3: toggle
          TZ0_B_OST_D: u2,

          /// [22:23] One-shot mode action on PWM0B when fault event occurs and timer is increasing. 0: do nothing, 1: force low, 2: force high, 3: toggle
          TZ0_B_OST_U: u2,

          /// [24:31] 
          res0: u8,

        }), @ptrFromInt(0x60014068));

        /// Software triggers for fault handler actions
        pub const FH0_CFG1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] a rising edge will clear on going one-shot mode action
          TZ0_CLR_OST: u1,

          /// [1:2] cycle-by-cycle mode action refresh moment selection. When bit0 is set to 1: TEZ, when bit1 is set to 1:TEP
          TZ0_CBCPULSE: u2,

          /// [3:3] a toggle trigger a cycle-by-cycle mode action
          TZ0_FORCE_CBC: u1,

          /// [4:4] a toggle (software negate its value) triggers a one-shot mode action
          TZ0_FORCE_OST: u1,

          /// [5:31] 
          res0: u27,

        }), @ptrFromInt(0x6001406c));

        /// Status of fault events.
        pub const FH0_STATUS = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Set and reset by hardware. If set, a cycle-by-cycle mode action is on going
          TZ0_CBC_ON: u1,

          /// [1:1] Set and reset by hardware. If set, an one-shot mode action is on going
          TZ0_OST_ON: u1,

          /// [2:31] 
          res0: u30,

        }), @ptrFromInt(0x60014070));

        /// Transfer status and update method for time stamp registers A and B
        pub const GEN1_STMP_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:3] Update method for PWM generator 1 time stamp A's active register. When all bits are set to 0: immediately, when bit0 is set to 1: TEZ, when bit1 is set to 1: TEP,when bit2 is set to 1: sync, when bit3 is set to 1: disable the update.
          CMPR1_A_UPMETHOD: u4,

          /// [4:7] Update method for PWM generator 1 time stamp B's active register. When all bits are set to 0: immediately, when bit0 is set to 1: TEZ, when bit1 is set to 1: TEP,when bit2 is set to 1: sync, when bit3 is set to 1: disable the update.
          CMPR1_B_UPMETHOD: u4,

          /// [8:8] Set and reset by hardware. If set, PWM generator 1 time stamp A's shadow reg is filled and waiting to be transferred to A's active reg. If cleared, A's active reg has been updated with shadow register latest value
          CMPR1_A_SHDW_FULL: u1,

          /// [9:9] Set and reset by hardware. If set, PWM generator 1 time stamp B's shadow reg is filled and waiting to be transferred to B's active reg. If cleared, B's active reg has been updated with shadow register latest value
          CMPR1_B_SHDW_FULL: u1,

          /// [10:31] 
          res0: u22,

        }), @ptrFromInt(0x60014074));

        /// Shadow register for register A.
        pub const GEN1_TSTMP_A = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:15] PWM generator 1 time stamp A's shadow register
          CMPR1_A: u16,

          /// [16:31] 
          res0: u16,

        }), @ptrFromInt(0x60014078));

        /// Shadow register for register B.
        pub const GEN1_TSTMP_B = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:15] PWM generator 1 time stamp B's shadow register
          CMPR1_B: u16,

          /// [16:31] 
          res0: u16,

        }), @ptrFromInt(0x6001407c));

        /// Fault event T0 and T1 handling
        pub const GEN1_CFG0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:3] Update method for PWM generator 1's active register of configuration. When all bits are set to 0: immediately, when bit0 is set to 1: TEZ, when bit1 is set to 1:sync;when bit3 is set to 1:disable the update.
          GEN1_CFG_UPMETHOD: u4,

          /// [4:6] Source selection for PWM generator 1 event_t0, take effect immediately, 0: fault_event0, 1: fault_event1, 2: fault_event2, 3: sync_taken, 4: none
          GEN1_T0_SEL: u3,

          /// [7:9] Source selection for PWM generator 1 event_t1, take effect immediately, 0: fault_event0, 1: fault_event1, 2: fault_event2, 3: sync_taken, 4: none
          GEN1_T1_SEL: u3,

          /// [10:31] 
          res0: u22,

        }), @ptrFromInt(0x60014080));

        /// Permissives to force PWM1A and PWM1B outputs by software
        pub const GEN1_FORCE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] Updating method for continuous software force of PWM generator 1. When all bits are set to 0: immediately, when bit0 is set to 1: TEZ,,when bit1 is set to 1: TEP, when bit2 is set to 1: TEA, when bit3 is set to 1: TEB, when bit4 is set to 1: sync, when bit5 is set to 1: disable update. (TEA/B here and below means an event generated when the timer's value equals to that of register A/B.)
          GEN1_CNTUFORCE_UPMETHOD: u6,

          /// [6:7] Continuous software force mode for PWM1A. 0: disabled, 1: low, 2: high, 3: disabled
          GEN1_A_CNTUFORCE_MODE: u2,

          /// [8:9] Continuous software force mode for PWM1B. 0: disabled, 1: low, 2: high, 3: disabled
          GEN1_B_CNTUFORCE_MODE: u2,

          /// [10:10] Trigger of non-continuous immediate software-force event for PWM1A, a toggle will trigger a force event.
          GEN1_A_NCIFORCE: u1,

          /// [11:12] non-continuous immediate software force mode for PWM1A, 0: disabled, 1: low, 2: high, 3: disabled
          GEN1_A_NCIFORCE_MODE: u2,

          /// [13:13] Trigger of non-continuous immediate software-force event for PWM1B, a toggle will trigger a force event.
          GEN1_B_NCIFORCE: u1,

          /// [14:15] non-continuous immediate software force mode for PWM1B, 0: disabled, 1: low, 2: high, 3: disabled
          GEN1_B_NCIFORCE_MODE: u2,

          /// [16:31] 
          res0: u16,

        }), @ptrFromInt(0x60014084));

        /// Actions triggered by events on PWM1A
        pub const GEN1_A = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:1] Action on PWM1A triggered by event TEZ when timer increasing
          UTEZ: u2,

          /// [2:3] Action on PWM1A triggered by event TEP when timer increasing
          UTEP: u2,

          /// [4:5] Action on PWM1A triggered by event TEA when timer increasing
          UTEA: u2,

          /// [6:7] Action on PWM1A triggered by event TEB when timer increasing
          UTEB: u2,

          /// [8:9] Action on PWM1A triggered by event_t0 when timer increasing
          UT0: u2,

          /// [10:11] Action on PWM1A triggered by event_t1 when timer increasing
          UT1: u2,

          /// [12:13] Action on PWM1A triggered by event TEZ when timer decreasing
          DTEZ: u2,

          /// [14:15] Action on PWM1A triggered by event TEP when timer decreasing
          DTEP: u2,

          /// [16:17] Action on PWM1A triggered by event TEA when timer decreasing
          DTEA: u2,

          /// [18:19] Action on PWM1A triggered by event TEB when timer decreasing
          DTEB: u2,

          /// [20:21] Action on PWM1A triggered by event_t0 when timer decreasing
          DT0: u2,

          /// [22:23] Action on PWM1A triggered by event_t1 when timer decreasing. 0: no change, 1: low, 2: high, 3: toggle
          DT1: u2,

          /// [24:31] 
          res0: u8,

        }), @ptrFromInt(0x60014088));

        /// Actions triggered by events on PWM1B
        pub const GEN1_B = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:1] Action on PWM1B triggered by event TEZ when timer increasing
          UTEZ: u2,

          /// [2:3] Action on PWM1B triggered by event TEP when timer increasing
          UTEP: u2,

          /// [4:5] Action on PWM1B triggered by event TEA when timer increasing
          UTEA: u2,

          /// [6:7] Action on PWM1B triggered by event TEB when timer increasing
          UTEB: u2,

          /// [8:9] Action on PWM1B triggered by event_t0 when timer increasing
          UT0: u2,

          /// [10:11] Action on PWM1B triggered by event_t1 when timer increasing
          UT1: u2,

          /// [12:13] Action on PWM1B triggered by event TEZ when timer decreasing
          DTEZ: u2,

          /// [14:15] Action on PWM1B triggered by event TEP when timer decreasing
          DTEP: u2,

          /// [16:17] Action on PWM1B triggered by event TEA when timer decreasing
          DTEA: u2,

          /// [18:19] Action on PWM1B triggered by event TEB when timer decreasing
          DTEB: u2,

          /// [20:21] Action on PWM1B triggered by event_t0 when timer decreasing
          DT0: u2,

          /// [22:23] Action on PWM1B triggered by event_t1 when timer decreasing. 0: no change, 1: low, 2: high, 3: toggle
          DT1: u2,

          /// [24:31] 
          res0: u8,

        }), @ptrFromInt(0x6001408c));

        /// dead time type selection and configuration
        pub const DT1_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:3] Update method for FED (falling edge delay) active register. 0: immediate, when bit0 is set to 1: tez, when bit1 is set to 1:tep,when bit2 is set to 1: sync, when bit3 is set to 1: disable the update
          DB1_FED_UPMETHOD: u4,

          /// [4:7] Update method for RED (rising edge delay) active register. 0: immediate,when bit0 is set to 1: tez, when bit1 is set to 1:tep,when bit2 is set to 1: sync, when bit3 is set to 1: disable the update
          DB1_RED_UPMETHOD: u4,

          /// [8:8] S8 in table, dual-edge B mode, 0: fed/red take effect on different path separately, 1: fed/red take effect on B path, A out is in bypass or dulpB mode
          DB1_DEB_MODE: u1,

          /// [9:9] S6 in table
          DB1_A_OUTSWAP: u1,

          /// [10:10] S7 in table
          DB1_B_OUTSWAP: u1,

          /// [11:11] S4 in table
          DB1_RED_INSEL: u1,

          /// [12:12] S5 in table
          DB1_FED_INSEL: u1,

          /// [13:13] S2 in table
          DB1_RED_OUTINVERT: u1,

          /// [14:14] S3 in table
          DB1_FED_OUTINVERT: u1,

          /// [15:15] S1 in table
          DB1_A_OUTBYPASS: u1,

          /// [16:16] S0 in table
          DB1_B_OUTBYPASS: u1,

          /// [17:17] Dead time generator 1 clock selection. 0: PWM_clk, 1: PT_clk
          DB1_CLK_SEL: u1,

          /// [18:31] 
          res0: u14,

        }), @ptrFromInt(0x60014090));

        /// Shadow register for falling edge delay (FED).
        pub const DT1_FED_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:15] Shadow register for FED
          DB1_FED: u16,

          /// [16:31] 
          res0: u16,

        }), @ptrFromInt(0x60014094));

        /// Shadow register for rising edge delay (RED).
        pub const DT1_RED_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:15] Shadow register for RED
          DB1_RED: u16,

          /// [16:31] 
          res0: u16,

        }), @ptrFromInt(0x60014098));

        /// Carrier enable and configuratoin
        pub const CARRIER1_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] When set, carrier1 function is enabled. When cleared, carrier1 is bypassed
          CHOPPER1_EN: u1,

          /// [1:4] PWM carrier1 clock (PC_clk) prescale value. Period of PC_clk = period of PWM_clk * (PWM_CARRIER0_PRESCALE + 1)
          CHOPPER1_PRESCALE: u4,

          /// [5:7] carrier duty selection. Duty = PWM_CARRIER0_DUTY / 8
          CHOPPER1_DUTY: u3,

          /// [8:11] width of the first pulse in number of periods of the carrier
          CHOPPER1_OSHTWTH: u4,

          /// [12:12] when set, invert the output of PWM1A and PWM1B for this submodule
          CHOPPER1_OUT_INVERT: u1,

          /// [13:13] when set, invert the input of PWM1A and PWM1B for this submodule
          CHOPPER1_IN_INVERT: u1,

          /// [14:31] 
          res0: u18,

        }), @ptrFromInt(0x6001409c));

        /// Actions on PWM1A and PWM1B trip events
        pub const FH1_CFG0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Enable register for software force cycle-by-cycle mode action. 0: disable, 1: enable
          TZ1_SW_CBC: u1,

          /// [1:1] event_f2 will trigger cycle-by-cycle mode action. 0: disable, 1: enable
          TZ1_F2_CBC: u1,

          /// [2:2] event_f1 will trigger cycle-by-cycle mode action. 0: disable, 1: enable
          TZ1_F1_CBC: u1,

          /// [3:3] event_f0 will trigger cycle-by-cycle mode action. 0: disable, 1: enable
          TZ1_F0_CBC: u1,

          /// [4:4] Enable register for software force one-shot mode action. 0: disable, 1: enable
          TZ1_SW_OST: u1,

          /// [5:5] event_f2 will trigger one-shot mode action. 0: disable, 1: enable
          TZ1_F2_OST: u1,

          /// [6:6] event_f1 will trigger one-shot mode action. 0: disable, 1: enable
          TZ1_F1_OST: u1,

          /// [7:7] event_f0 will trigger one-shot mode action. 0: disable, 1: enable
          TZ1_F0_OST: u1,

          /// [8:9] Cycle-by-cycle mode action on PWM1A when fault event occurs and timer is decreasing. 0: do nothing, 1: force low, 2: force high, 3: toggle
          TZ1_A_CBC_D: u2,

          /// [10:11] Cycle-by-cycle mode action on PWM1A when fault event occurs and timer is increasing. 0: do nothing, 1: force low, 2: force high, 3: toggle
          TZ1_A_CBC_U: u2,

          /// [12:13] One-shot mode action on PWM1A when fault event occurs and timer is decreasing. 0: do nothing,1: force low, 2: force high, 3: toggle
          TZ1_A_OST_D: u2,

          /// [14:15] One-shot mode action on PWM1A when fault event occurs and timer is increasing. 0: do nothing, 1: force low, 2: force high, 3: toggle
          TZ1_A_OST_U: u2,

          /// [16:17] Cycle-by-cycle mode action on PWM1B when fault event occurs and timer is decreasing. 0: do nothing, 1: force low, 2: force high, 3: toggle
          TZ1_B_CBC_D: u2,

          /// [18:19] Cycle-by-cycle mode action on PWM1B when fault event occurs and timer is increasing. 0: do nothing, 1: force low, 2: force high, 3: toggle
          TZ1_B_CBC_U: u2,

          /// [20:21] One-shot mode action on PWM1B when fault event occurs and timer is decreasing. 0: do nothing, 1: force low, 2: force high, 3: toggle
          TZ1_B_OST_D: u2,

          /// [22:23] One-shot mode action on PWM1B when fault event occurs and timer is increasing. 0: do nothing, 1: force low, 2: force high, 3: toggle
          TZ1_B_OST_U: u2,

          /// [24:31] 
          res0: u8,

        }), @ptrFromInt(0x600140a0));

        /// Software triggers for fault handler actions
        pub const FH1_CFG1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] a rising edge will clear on going one-shot mode action
          TZ1_CLR_OST: u1,

          /// [1:2] cycle-by-cycle mode action refresh moment selection. When bit0 is set to 1: TEZ, when bit1 is set to 1:TEP
          TZ1_CBCPULSE: u2,

          /// [3:3] a toggle trigger a cycle-by-cycle mode action
          TZ1_FORCE_CBC: u1,

          /// [4:4] a toggle (software negate its value) triggers a one-shot mode action
          TZ1_FORCE_OST: u1,

          /// [5:31] 
          res0: u27,

        }), @ptrFromInt(0x600140a4));

        /// Status of fault events.
        pub const FH1_STATUS = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Set and reset by hardware. If set, a cycle-by-cycle mode action is on going
          TZ1_CBC_ON: u1,

          /// [1:1] Set and reset by hardware. If set, an one-shot mode action is on going
          TZ1_OST_ON: u1,

          /// [2:31] 
          res0: u30,

        }), @ptrFromInt(0x600140a8));

        /// Transfer status and update method for time stamp registers A and B
        pub const GEN2_STMP_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:3] Update method for PWM generator 2 time stamp A's active register. When all bits are set to 0: immediately, when bit0 is set to 1: TEZ, when bit1 is set to 1: TEP,when bit2 is set to 1: sync, when bit3 is set to 1: disable the update.
          CMPR2_A_UPMETHOD: u4,

          /// [4:7] Update method for PWM generator 2 time stamp B's active register. When all bits are set to 0: immediately, when bit0 is set to 1: TEZ, when bit1 is set to 1: TEP,when bit2 is set to 1: sync, when bit3 is set to 1: disable the update.
          CMPR2_B_UPMETHOD: u4,

          /// [8:8] Set and reset by hardware. If set, PWM generator 2 time stamp A's shadow reg is filled and waiting to be transferred to A's active reg. If cleared, A's active reg has been updated with shadow register latest value
          CMPR2_A_SHDW_FULL: u1,

          /// [9:9] Set and reset by hardware. If set, PWM generator 2 time stamp B's shadow reg is filled and waiting to be transferred to B's active reg. If cleared, B's active reg has been updated with shadow register latest value
          CMPR2_B_SHDW_FULL: u1,

          /// [10:31] 
          res0: u22,

        }), @ptrFromInt(0x600140ac));

        /// Shadow register for register A.
        pub const GEN2_TSTMP_A = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:15] PWM generator 2 time stamp A's shadow register
          CMPR2_A: u16,

          /// [16:31] 
          res0: u16,

        }), @ptrFromInt(0x600140b0));

        /// Shadow register for register B.
        pub const GEN2_TSTMP_B = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:15] PWM generator 2 time stamp B's shadow register
          CMPR2_B: u16,

          /// [16:31] 
          res0: u16,

        }), @ptrFromInt(0x600140b4));

        /// Fault event T0 and T1 handling
        pub const GEN2_CFG0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:3] Update method for PWM generator 2's active register of configuration. 0: immediately, when bit0 is set to 1: TEZ, when bit1 is set to 1:sync;when bit3 is set to 1:disable the update.
          GEN2_CFG_UPMETHOD: u4,

          /// [4:6] Source selection for PWM generator 2 event_t0, take effect immediately, 0: fault_event0, 1: fault_event1, 2: fault_event2, 3: sync_taken, 4: none
          GEN2_T0_SEL: u3,

          /// [7:9] Source selection for PWM generator 2 event_t1, take effect immediately, 0: fault_event0, 1: fault_event1, 2: fault_event2, 3: sync_taken, 4: none
          GEN2_T1_SEL: u3,

          /// [10:31] 
          res0: u22,

        }), @ptrFromInt(0x600140b8));

        /// Permissives to force PWM2A and PWM2B outputs by software
        pub const GEN2_FORCE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] Updating method for continuous software force of PWM generator 2. When all bits are set to 0: immediately, when bit0 is set to 1: TEZ,when bit1 is set to 1: TEP, when bit2 is set to 1: TEA, when bit3 is set to 1: TEB, when bit4 is set to 1: sync, when bit5 is set to 1: disable update. (TEA/B here and below means an event generated when the timer's value equals to that of register A/B.)
          GEN2_CNTUFORCE_UPMETHOD: u6,

          /// [6:7] Continuous software force mode for PWM2A. 0: disabled, 1: low, 2: high, 3: disabled
          GEN2_A_CNTUFORCE_MODE: u2,

          /// [8:9] Continuous software force mode for PWM2B. 0: disabled, 1: low, 2: high, 3: disabled
          GEN2_B_CNTUFORCE_MODE: u2,

          /// [10:10] Trigger of non-continuous immediate software-force event for PWM2A, a toggle will trigger a force event.
          GEN2_A_NCIFORCE: u1,

          /// [11:12] non-continuous immediate software force mode for PWM2A, 0: disabled, 1: low, 2: high, 3: disabled
          GEN2_A_NCIFORCE_MODE: u2,

          /// [13:13] Trigger of non-continuous immediate software-force event for PWM2B, a toggle will trigger a force event.
          GEN2_B_NCIFORCE: u1,

          /// [14:15] non-continuous immediate software force mode for PWM2B, 0: disabled, 1: low, 2: high, 3: disabled
          GEN2_B_NCIFORCE_MODE: u2,

          /// [16:31] 
          res0: u16,

        }), @ptrFromInt(0x600140bc));

        /// Actions triggered by events on PWM2A
        pub const GEN2_A = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:1] Action on PWM2A triggered by event TEZ when timer increasing
          UTEZ: u2,

          /// [2:3] Action on PWM2A triggered by event TEP when timer increasing
          UTEP: u2,

          /// [4:5] Action on PWM2A triggered by event TEA when timer increasing
          UTEA: u2,

          /// [6:7] Action on PWM2A triggered by event TEB when timer increasing
          UTEB: u2,

          /// [8:9] Action on PWM2A triggered by event_t0 when timer increasing
          UT0: u2,

          /// [10:11] Action on PWM2A triggered by event_t1 when timer increasing
          UT1: u2,

          /// [12:13] Action on PWM2A triggered by event TEZ when timer decreasing
          DTEZ: u2,

          /// [14:15] Action on PWM2A triggered by event TEP when timer decreasing
          DTEP: u2,

          /// [16:17] Action on PWM2A triggered by event TEA when timer decreasing
          DTEA: u2,

          /// [18:19] Action on PWM2A triggered by event TEB when timer decreasing
          DTEB: u2,

          /// [20:21] Action on PWM2A triggered by event_t0 when timer decreasing
          DT0: u2,

          /// [22:23] Action on PWM2A triggered by event_t1 when timer decreasing. 0: no change, 1: low, 2: high, 3: toggle
          DT1: u2,

          /// [24:31] 
          res0: u8,

        }), @ptrFromInt(0x600140c0));

        /// Actions triggered by events on PWM2B
        pub const GEN2_B = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:1] Action on PWM2B triggered by event TEZ when timer increasing
          UTEZ: u2,

          /// [2:3] Action on PWM2B triggered by event TEP when timer increasing
          UTEP: u2,

          /// [4:5] Action on PWM2B triggered by event TEA when timer increasing
          UTEA: u2,

          /// [6:7] Action on PWM2B triggered by event TEB when timer increasing
          UTEB: u2,

          /// [8:9] Action on PWM2B triggered by event_t0 when timer increasing
          UT0: u2,

          /// [10:11] Action on PWM2B triggered by event_t1 when timer increasing
          UT1: u2,

          /// [12:13] Action on PWM2B triggered by event TEZ when timer decreasing
          DTEZ: u2,

          /// [14:15] Action on PWM2B triggered by event TEP when timer decreasing
          DTEP: u2,

          /// [16:17] Action on PWM2B triggered by event TEA when timer decreasing
          DTEA: u2,

          /// [18:19] Action on PWM2B triggered by event TEB when timer decreasing
          DTEB: u2,

          /// [20:21] Action on PWM2B triggered by event_t0 when timer decreasing
          DT0: u2,

          /// [22:23] Action on PWM2B triggered by event_t1 when timer decreasing. 0: no change, 1: low, 2: high, 3: toggle
          DT1: u2,

          /// [24:31] 
          res0: u8,

        }), @ptrFromInt(0x600140c4));

        /// dead time type selection and configuration
        pub const DT2_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:3] Update method for FED (falling edge delay) active register.0: immediate,when bit0 is set to 1: tez, when bit1 is set to 1:tep,when bit2 is set to 1: sync, when bit3 is set to 1: disable the update
          DB2_FED_UPMETHOD: u4,

          /// [4:7] Update method for RED (rising edge delay) active register.0: immediate,when bit0 is set to 1: tez, when bit1 is set to 1:tep,when bit2 is set to 1: sync, when bit3 is set to 1: disable the update
          DB2_RED_UPMETHOD: u4,

          /// [8:8] S8 in table, dual-edge B mode, 0: fed/red take effect on different path separately, 1: fed/red take effect on B path, A out is in bypass or dulpB mode
          DB2_DEB_MODE: u1,

          /// [9:9] S6 in table
          DB2_A_OUTSWAP: u1,

          /// [10:10] S7 in table
          DB2_B_OUTSWAP: u1,

          /// [11:11] S4 in table
          DB2_RED_INSEL: u1,

          /// [12:12] S5 in table
          DB2_FED_INSEL: u1,

          /// [13:13] S2 in table
          DB2_RED_OUTINVERT: u1,

          /// [14:14] S3 in table
          DB2_FED_OUTINVERT: u1,

          /// [15:15] S1 in table
          DB2_A_OUTBYPASS: u1,

          /// [16:16] S0 in table
          DB2_B_OUTBYPASS: u1,

          /// [17:17] Dead time generator 2 clock selection. 0: PWM_clk, 1: PT_clk
          DB2_CLK_SEL: u1,

          /// [18:31] 
          res0: u14,

        }), @ptrFromInt(0x600140c8));

        /// Shadow register for falling edge delay (FED).
        pub const DT2_FED_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:15] Shadow register for FED
          DB2_FED: u16,

          /// [16:31] 
          res0: u16,

        }), @ptrFromInt(0x600140cc));

        /// Shadow register for rising edge delay (RED).
        pub const DT2_RED_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:15] Shadow register for RED
          DB2_RED: u16,

          /// [16:31] 
          res0: u16,

        }), @ptrFromInt(0x600140d0));

        /// Carrier enable and configuratoin
        pub const CARRIER2_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] When set, carrier2 function is enabled. When cleared, carrier2 is bypassed
          CHOPPER2_EN: u1,

          /// [1:4] PWM carrier2 clock (PC_clk) prescale value. Period of PC_clk = period of PWM_clk * (PWM_CARRIER0_PRESCALE + 1)
          CHOPPER2_PRESCALE: u4,

          /// [5:7] carrier duty selection. Duty = PWM_CARRIER0_DUTY / 8
          CHOPPER2_DUTY: u3,

          /// [8:11] width of the first pulse in number of periods of the carrier
          CHOPPER2_OSHTWTH: u4,

          /// [12:12] when set, invert the output of PWM2A and PWM2B for this submodule
          CHOPPER2_OUT_INVERT: u1,

          /// [13:13] when set, invert the input of PWM2A and PWM2B for this submodule
          CHOPPER2_IN_INVERT: u1,

          /// [14:31] 
          res0: u18,

        }), @ptrFromInt(0x600140d4));

        /// Actions on PWM2A and PWM2B trip events
        pub const FH2_CFG0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Enable register for software force cycle-by-cycle mode action. 0: disable, 1: enable
          TZ2_SW_CBC: u1,

          /// [1:1] event_f2 will trigger cycle-by-cycle mode action. 0: disable, 1: enable
          TZ2_F2_CBC: u1,

          /// [2:2] event_f1 will trigger cycle-by-cycle mode action. 0: disable, 1: enable
          TZ2_F1_CBC: u1,

          /// [3:3] event_f0 will trigger cycle-by-cycle mode action. 0: disable, 1: enable
          TZ2_F0_CBC: u1,

          /// [4:4] Enable register for software force one-shot mode action. 0: disable, 1: enable
          TZ2_SW_OST: u1,

          /// [5:5] event_f2 will trigger one-shot mode action. 0: disable, 1: enable
          TZ2_F2_OST: u1,

          /// [6:6] event_f1 will trigger one-shot mode action. 0: disable, 1: enable
          TZ2_F1_OST: u1,

          /// [7:7] event_f0 will trigger one-shot mode action. 0: disable, 1: enable
          TZ2_F0_OST: u1,

          /// [8:9] Cycle-by-cycle mode action on PWM2A when fault event occurs and timer is decreasing. 0: do nothing, 1: force low, 2: force high, 3: toggle
          TZ2_A_CBC_D: u2,

          /// [10:11] Cycle-by-cycle mode action on PWM2A when fault event occurs and timer is increasing. 0: do nothing, 1: force low, 2: force high, 3: toggle
          TZ2_A_CBC_U: u2,

          /// [12:13] One-shot mode action on PWM2A when fault event occurs and timer is decreasing. 0: do nothing, 1: force low, 2: force high, 3: toggle
          TZ2_A_OST_D: u2,

          /// [14:15] One-shot mode action on PWM2A when fault event occurs and timer is increasing. 0: do nothing, 1: force low, 2: force high, 3: toggle
          TZ2_A_OST_U: u2,

          /// [16:17] Cycle-by-cycle mode action on PWM2B when fault event occurs and timer is decreasing. 0: do nothing, 1: force low, 2: force high, 3: toggle
          TZ2_B_CBC_D: u2,

          /// [18:19] Cycle-by-cycle mode action on PWM2B when fault event occurs and timer is increasing. 0: do nothing, 1: force low, 2: force high, 3: toggle
          TZ2_B_CBC_U: u2,

          /// [20:21] One-shot mode action on PWM2B when fault event occurs and timer is decreasing. 0: do nothing, 1: force low, 2: force high, 3: toggle
          TZ2_B_OST_D: u2,

          /// [22:23] One-shot mode action on PWM2B when fault event occurs and timer is increasing. 0: do nothing, 1: force low, 2: force high, 3: toggle
          TZ2_B_OST_U: u2,

          /// [24:31] 
          res0: u8,

        }), @ptrFromInt(0x600140d8));

        /// Software triggers for fault handler actions
        pub const FH2_CFG1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] a rising edge will clear on going one-shot mode action
          TZ2_CLR_OST: u1,

          /// [1:2] cycle-by-cycle mode action refresh moment selection. When bit0 is set to 1: TEZ, when bit1 is set to 1:TEP
          TZ2_CBCPULSE: u2,

          /// [3:3] a toggle trigger a cycle-by-cycle mode action
          TZ2_FORCE_CBC: u1,

          /// [4:4] a toggle (software negate its value) triggers a one-shot mode action
          TZ2_FORCE_OST: u1,

          /// [5:31] 
          res0: u27,

        }), @ptrFromInt(0x600140dc));

        /// Status of fault events.
        pub const FH2_STATUS = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Set and reset by hardware. If set, a cycle-by-cycle mode action is on going
          TZ2_CBC_ON: u1,

          /// [1:1] Set and reset by hardware. If set, an one-shot mode action is on going
          TZ2_OST_ON: u1,

          /// [2:31] 
          res0: u30,

        }), @ptrFromInt(0x600140e0));

        /// Fault detection configuration and status
        pub const FAULT_DETECT = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] When set, event_f0 generation is enabled
          F0_EN: u1,

          /// [1:1] When set, event_f1 generation is enabled
          F1_EN: u1,

          /// [2:2] When set, event_f2 generation is enabled
          F2_EN: u1,

          /// [3:3] Set event_f0 trigger polarity on FAULT2 source from GPIO matrix. 0: level low, 1: level high
          F0_POLE: u1,

          /// [4:4] Set event_f1 trigger polarity on FAULT2 source from GPIO matrix. 0: level low, 1: level high
          F1_POLE: u1,

          /// [5:5] Set event_f2 trigger polarity on FAULT2 source from GPIO matrix. 0: level low, 1: level high
          F2_POLE: u1,

          /// [6:6] Set and reset by hardware. If set, event_f0 is on going
          EVENT_F0: u1,

          /// [7:7] Set and reset by hardware. If set, event_f1 is on going
          EVENT_F1: u1,

          /// [8:8] Set and reset by hardware. If set, event_f2 is on going
          EVENT_F2: u1,

          /// [9:31] 
          res0: u23,

        }), @ptrFromInt(0x600140e4));

        /// Configure capture timer
        pub const CAP_TIMER_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] When set, capture timer incrementing under APB_clk is enabled.
          CAP_TIMER_EN: u1,

          /// [1:1] When set, capture timer sync is enabled.
          CAP_SYNCI_EN: u1,

          /// [2:4] capture module sync input selection. 0: none, 1: timer0 sync_out, 2: timer1 sync_out, 3: timer2 sync_out, 4: SYNC0 from GPIO matrix, 5: SYNC1 from GPIO matrix, 6: SYNC2 from GPIO matrix
          CAP_SYNCI_SEL: u3,

          /// [5:5] When reg_cap_synci_en is 1,write 1 will trigger a capture timer sync, capture timer is loaded with value in phase register.
          CAP_SYNC_SW: u1,

          /// [6:31] 
          res0: u26,

        }), @ptrFromInt(0x600140e8));

        /// Phase for capture timer sync
        pub const CAP_TIMER_PHASE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Phase value for capture timer sync operation.
          CAP_PHASE: u32,

        }), @ptrFromInt(0x600140ec));

        /// Capture channel 0 configuration and enable
        pub const CAP_CH0_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] When set, capture on channel 0 is enabled
          CAP0_EN: u1,

          /// [1:2] Edge of capture on channel 0 after prescaling. When bit0 is set to 1: enable capture on the negative edge, When bit1 is set to 1: enable capture on the positive edge.
          CAP0_MODE: u2,

          /// [3:10] Value of prescaling on possitive edge of CAP0. Prescale value = PWM_CAP0_PRESCALE + 1
          CAP0_PRESCALE: u8,

          /// [11:11] when set, CAP0 form GPIO matrix is inverted before prescale
          CAP0_IN_INVERT: u1,

          /// [12:12] Write 1 will trigger a software forced capture on channel 0
          CAP0_SW: u1,

          /// [13:31] 
          res0: u19,

        }), @ptrFromInt(0x600140f0));

        /// Capture channel 1 configuration and enable
        pub const CAP_CH1_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] When set, capture on channel 2 is enabled
          CAP1_EN: u1,

          /// [1:2] Edge of capture on channel 1 after prescaling. When bit0 is set to 1: enable capture on the negative edge, When bit1 is set to 1: enable capture on the positive edge.
          CAP1_MODE: u2,

          /// [3:10] Value of prescaling on possitive edge of CAP1. Prescale value = PWM_CAP1_PRESCALE + 1
          CAP1_PRESCALE: u8,

          /// [11:11] when set, CAP1 form GPIO matrix is inverted before prescale
          CAP1_IN_INVERT: u1,

          /// [12:12] Write 1 will trigger a software forced capture on channel 1
          CAP1_SW: u1,

          /// [13:31] 
          res0: u19,

        }), @ptrFromInt(0x600140f4));

        /// Capture channel 2 configuration and enable
        pub const CAP_CH2_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] When set, capture on channel 2 is enabled
          CAP2_EN: u1,

          /// [1:2] Edge of capture on channel 2 after prescaling. When bit0 is set to 1: enable capture on the negative edge, When bit1 is set to 1: enable capture on the positive edge.
          CAP2_MODE: u2,

          /// [3:10] Value of prescaling on possitive edge of CAP2. Prescale value = PWM_CAP2_PRESCALE + 1
          CAP2_PRESCALE: u8,

          /// [11:11] when set, CAP2 form GPIO matrix is inverted before prescale
          CAP2_IN_INVERT: u1,

          /// [12:12] Write 1 will trigger a software forced capture on channel 2
          CAP2_SW: u1,

          /// [13:31] 
          res0: u19,

        }), @ptrFromInt(0x600140f8));

        /// ch0 capture value status register
        pub const CAP_CH0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Value of last capture on channel 0
          CAP0_VALUE: u32,

        }), @ptrFromInt(0x600140fc));

        /// ch1 capture value status register
        pub const CAP_CH1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Value of last capture on channel 1
          CAP1_VALUE: u32,

        }), @ptrFromInt(0x60014100));

        /// ch2 capture value status register
        pub const CAP_CH2 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Value of last capture on channel 2
          CAP2_VALUE: u32,

        }), @ptrFromInt(0x60014104));

        /// Edge of last capture trigger
        pub const CAP_STATUS = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Edge of last capture trigger on channel 0, 0: posedge, 1: negedge
          CAP0_EDGE: u1,

          /// [1:1] Edge of last capture trigger on channel 1, 0: posedge, 1: negedge
          CAP1_EDGE: u1,

          /// [2:2] Edge of last capture trigger on channel 2, 0: posedge, 1: negedge
          CAP2_EDGE: u1,

          /// [3:31] 
          res0: u29,

        }), @ptrFromInt(0x60014108));

        /// Enable update.
        pub const UPDATE_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] The global enable of update of all active registers in MCPWM module
          GLOBAL_UP_EN: u1,

          /// [1:1] a toggle (software invert its value) will trigger a forced update of all active registers in MCPWM module
          GLOBAL_FORCE_UP: u1,

          /// [2:2] When set and PWM_GLOBAL_UP_EN is set, update of active registers in PWM operator 0 are enabled
          OP0_UP_EN: u1,

          /// [3:3] a toggle (software invert its value) will trigger a forced update of active registers in PWM operator 0
          OP0_FORCE_UP: u1,

          /// [4:4] When set and PWM_GLOBAL_UP_EN is set, update of active registers in PWM operator 1 are enabled
          OP1_UP_EN: u1,

          /// [5:5] a toggle (software invert its value) will trigger a forced update of active registers in PWM operator 1
          OP1_FORCE_UP: u1,

          /// [6:6] When set and PWM_GLOBAL_UP_EN is set, update of active registers in PWM operator 2 are enabled
          OP2_UP_EN: u1,

          /// [7:7] a toggle (software invert its value) will trigger a forced update of active registers in PWM operator 2
          OP2_FORCE_UP: u1,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x6001410c));

        /// Interrupt enable bits
        pub const INT_ENA = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] The enable bit for the interrupt triggered when the timer 0 stops.
          TIMER0_STOP_INT_ENA: u1,

          /// [1:1] The enable bit for the interrupt triggered when the timer 1 stops.
          TIMER1_STOP_INT_ENA: u1,

          /// [2:2] The enable bit for the interrupt triggered when the timer 2 stops.
          TIMER2_STOP_INT_ENA: u1,

          /// [3:3] The enable bit for the interrupt triggered by a PWM timer 0 TEZ event.
          TIMER0_TEZ_INT_ENA: u1,

          /// [4:4] The enable bit for the interrupt triggered by a PWM timer 1 TEZ event.
          TIMER1_TEZ_INT_ENA: u1,

          /// [5:5] The enable bit for the interrupt triggered by a PWM timer 2 TEZ event.
          TIMER2_TEZ_INT_ENA: u1,

          /// [6:6] The enable bit for the interrupt triggered by a PWM timer 0 TEP event.
          TIMER0_TEP_INT_ENA: u1,

          /// [7:7] The enable bit for the interrupt triggered by a PWM timer 1 TEP event.
          TIMER1_TEP_INT_ENA: u1,

          /// [8:8] The enable bit for the interrupt triggered by a PWM timer 2 TEP event.
          TIMER2_TEP_INT_ENA: u1,

          /// [9:9] The enable bit for the interrupt triggered when event_f0 starts.
          FAULT0_INT_ENA: u1,

          /// [10:10] The enable bit for the interrupt triggered when event_f1 starts.
          FAULT1_INT_ENA: u1,

          /// [11:11] The enable bit for the interrupt triggered when event_f2 starts.
          FAULT2_INT_ENA: u1,

          /// [12:12] The enable bit for the interrupt triggered when event_f0 ends.
          FAULT0_CLR_INT_ENA: u1,

          /// [13:13] The enable bit for the interrupt triggered when event_f1 ends.
          FAULT1_CLR_INT_ENA: u1,

          /// [14:14] The enable bit for the interrupt triggered when event_f2 ends.
          FAULT2_CLR_INT_ENA: u1,

          /// [15:15] The enable bit for the interrupt triggered by a PWM operator 0 TEA event
          CMPR0_TEA_INT_ENA: u1,

          /// [16:16] The enable bit for the interrupt triggered by a PWM operator 1 TEA event
          CMPR1_TEA_INT_ENA: u1,

          /// [17:17] The enable bit for the interrupt triggered by a PWM operator 2 TEA event
          CMPR2_TEA_INT_ENA: u1,

          /// [18:18] The enable bit for the interrupt triggered by a PWM operator 0 TEB event
          CMPR0_TEB_INT_ENA: u1,

          /// [19:19] The enable bit for the interrupt triggered by a PWM operator 1 TEB event
          CMPR1_TEB_INT_ENA: u1,

          /// [20:20] The enable bit for the interrupt triggered by a PWM operator 2 TEB event
          CMPR2_TEB_INT_ENA: u1,

          /// [21:21] The enable bit for the interrupt triggered by a cycle-by-cycle mode action on PWM0.
          TZ0_CBC_INT_ENA: u1,

          /// [22:22] The enable bit for the interrupt triggered by a cycle-by-cycle mode action on PWM1.
          TZ1_CBC_INT_ENA: u1,

          /// [23:23] The enable bit for the interrupt triggered by a cycle-by-cycle mode action on PWM2.
          TZ2_CBC_INT_ENA: u1,

          /// [24:24] The enable bit for the interrupt triggered by a one-shot mode action on PWM0.
          TZ0_OST_INT_ENA: u1,

          /// [25:25] The enable bit for the interrupt triggered by a one-shot mode action on PWM1.
          TZ1_OST_INT_ENA: u1,

          /// [26:26] The enable bit for the interrupt triggered by a one-shot mode action on PWM2.
          TZ2_OST_INT_ENA: u1,

          /// [27:27] The enable bit for the interrupt triggered by capture on channel 0.
          CAP0_INT_ENA: u1,

          /// [28:28] The enable bit for the interrupt triggered by capture on channel 1.
          CAP1_INT_ENA: u1,

          /// [29:29] The enable bit for the interrupt triggered by capture on channel 2.
          CAP2_INT_ENA: u1,

          /// [30:31] 
          res0: u2,

        }), @ptrFromInt(0x60014110));

        /// Raw interrupt status
        pub const INT_RAW = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] The raw status bit for the interrupt triggered when the timer 0 stops.
          TIMER0_STOP_INT_RAW: u1,

          /// [1:1] The raw status bit for the interrupt triggered when the timer 1 stops.
          TIMER1_STOP_INT_RAW: u1,

          /// [2:2] The raw status bit for the interrupt triggered when the timer 2 stops.
          TIMER2_STOP_INT_RAW: u1,

          /// [3:3] The raw status bit for the interrupt triggered by a PWM timer 0 TEZ event.
          TIMER0_TEZ_INT_RAW: u1,

          /// [4:4] The raw status bit for the interrupt triggered by a PWM timer 1 TEZ event.
          TIMER1_TEZ_INT_RAW: u1,

          /// [5:5] The raw status bit for the interrupt triggered by a PWM timer 2 TEZ event.
          TIMER2_TEZ_INT_RAW: u1,

          /// [6:6] The raw status bit for the interrupt triggered by a PWM timer 0 TEP event.
          TIMER0_TEP_INT_RAW: u1,

          /// [7:7] The raw status bit for the interrupt triggered by a PWM timer 1 TEP event.
          TIMER1_TEP_INT_RAW: u1,

          /// [8:8] The raw status bit for the interrupt triggered by a PWM timer 2 TEP event.
          TIMER2_TEP_INT_RAW: u1,

          /// [9:9] The raw status bit for the interrupt triggered when event_f0 starts.
          FAULT0_INT_RAW: u1,

          /// [10:10] The raw status bit for the interrupt triggered when event_f1 starts.
          FAULT1_INT_RAW: u1,

          /// [11:11] The raw status bit for the interrupt triggered when event_f2 starts.
          FAULT2_INT_RAW: u1,

          /// [12:12] The raw status bit for the interrupt triggered when event_f0 ends.
          FAULT0_CLR_INT_RAW: u1,

          /// [13:13] The raw status bit for the interrupt triggered when event_f1 ends.
          FAULT1_CLR_INT_RAW: u1,

          /// [14:14] The raw status bit for the interrupt triggered when event_f2 ends.
          FAULT2_CLR_INT_RAW: u1,

          /// [15:15] The raw status bit for the interrupt triggered by a PWM operator 0 TEA event
          CMPR0_TEA_INT_RAW: u1,

          /// [16:16] The raw status bit for the interrupt triggered by a PWM operator 1 TEA event
          CMPR1_TEA_INT_RAW: u1,

          /// [17:17] The raw status bit for the interrupt triggered by a PWM operator 2 TEA event
          CMPR2_TEA_INT_RAW: u1,

          /// [18:18] The raw status bit for the interrupt triggered by a PWM operator 0 TEB event
          CMPR0_TEB_INT_RAW: u1,

          /// [19:19] The raw status bit for the interrupt triggered by a PWM operator 1 TEB event
          CMPR1_TEB_INT_RAW: u1,

          /// [20:20] The raw status bit for the interrupt triggered by a PWM operator 2 TEB event
          CMPR2_TEB_INT_RAW: u1,

          /// [21:21] The raw status bit for the interrupt triggered by a cycle-by-cycle mode action on PWM0.
          TZ0_CBC_INT_RAW: u1,

          /// [22:22] The raw status bit for the interrupt triggered by a cycle-by-cycle mode action on PWM1.
          TZ1_CBC_INT_RAW: u1,

          /// [23:23] The raw status bit for the interrupt triggered by a cycle-by-cycle mode action on PWM2.
          TZ2_CBC_INT_RAW: u1,

          /// [24:24] The raw status bit for the interrupt triggered by a one-shot mode action on PWM0.
          TZ0_OST_INT_RAW: u1,

          /// [25:25] The raw status bit for the interrupt triggered by a one-shot mode action on PWM1.
          TZ1_OST_INT_RAW: u1,

          /// [26:26] The raw status bit for the interrupt triggered by a one-shot mode action on PWM2.
          TZ2_OST_INT_RAW: u1,

          /// [27:27] The raw status bit for the interrupt triggered by capture on channel 0.
          CAP0_INT_RAW: u1,

          /// [28:28] The raw status bit for the interrupt triggered by capture on channel 1.
          CAP1_INT_RAW: u1,

          /// [29:29] The raw status bit for the interrupt triggered by capture on channel 2.
          CAP2_INT_RAW: u1,

          /// [30:31] 
          res0: u2,

        }), @ptrFromInt(0x60014114));

        /// Masked interrupt status
        pub const INT_ST = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] The masked status bit for the interrupt triggered when the timer 0 stops.
          TIMER0_STOP_INT_ST: u1,

          /// [1:1] The masked status bit for the interrupt triggered when the timer 1 stops.
          TIMER1_STOP_INT_ST: u1,

          /// [2:2] The masked status bit for the interrupt triggered when the timer 2 stops.
          TIMER2_STOP_INT_ST: u1,

          /// [3:3] The masked status bit for the interrupt triggered by a PWM timer 0 TEZ event.
          TIMER0_TEZ_INT_ST: u1,

          /// [4:4] The masked status bit for the interrupt triggered by a PWM timer 1 TEZ event.
          TIMER1_TEZ_INT_ST: u1,

          /// [5:5] The masked status bit for the interrupt triggered by a PWM timer 2 TEZ event.
          TIMER2_TEZ_INT_ST: u1,

          /// [6:6] The masked status bit for the interrupt triggered by a PWM timer 0 TEP event.
          TIMER0_TEP_INT_ST: u1,

          /// [7:7] The masked status bit for the interrupt triggered by a PWM timer 1 TEP event.
          TIMER1_TEP_INT_ST: u1,

          /// [8:8] The masked status bit for the interrupt triggered by a PWM timer 2 TEP event.
          TIMER2_TEP_INT_ST: u1,

          /// [9:9] The masked status bit for the interrupt triggered when event_f0 starts.
          FAULT0_INT_ST: u1,

          /// [10:10] The masked status bit for the interrupt triggered when event_f1 starts.
          FAULT1_INT_ST: u1,

          /// [11:11] The masked status bit for the interrupt triggered when event_f2 starts.
          FAULT2_INT_ST: u1,

          /// [12:12] The masked status bit for the interrupt triggered when event_f0 ends.
          FAULT0_CLR_INT_ST: u1,

          /// [13:13] The masked status bit for the interrupt triggered when event_f1 ends.
          FAULT1_CLR_INT_ST: u1,

          /// [14:14] The masked status bit for the interrupt triggered when event_f2 ends.
          FAULT2_CLR_INT_ST: u1,

          /// [15:15] The masked status bit for the interrupt triggered by a PWM operator 0 TEA event
          CMPR0_TEA_INT_ST: u1,

          /// [16:16] The masked status bit for the interrupt triggered by a PWM operator 1 TEA event
          CMPR1_TEA_INT_ST: u1,

          /// [17:17] The masked status bit for the interrupt triggered by a PWM operator 2 TEA event
          CMPR2_TEA_INT_ST: u1,

          /// [18:18] The masked status bit for the interrupt triggered by a PWM operator 0 TEB event
          CMPR0_TEB_INT_ST: u1,

          /// [19:19] The masked status bit for the interrupt triggered by a PWM operator 1 TEB event
          CMPR1_TEB_INT_ST: u1,

          /// [20:20] The masked status bit for the interrupt triggered by a PWM operator 2 TEB event
          CMPR2_TEB_INT_ST: u1,

          /// [21:21] The masked status bit for the interrupt triggered by a cycle-by-cycle mode action on PWM0.
          TZ0_CBC_INT_ST: u1,

          /// [22:22] The masked status bit for the interrupt triggered by a cycle-by-cycle mode action on PWM1.
          TZ1_CBC_INT_ST: u1,

          /// [23:23] The masked status bit for the interrupt triggered by a cycle-by-cycle mode action on PWM2.
          TZ2_CBC_INT_ST: u1,

          /// [24:24] The masked status bit for the interrupt triggered by a one-shot mode action on PWM0.
          TZ0_OST_INT_ST: u1,

          /// [25:25] The masked status bit for the interrupt triggered by a one-shot mode action on PWM1.
          TZ1_OST_INT_ST: u1,

          /// [26:26] The masked status bit for the interrupt triggered by a one-shot mode action on PWM2.
          TZ2_OST_INT_ST: u1,

          /// [27:27] The masked status bit for the interrupt triggered by capture on channel 0.
          CAP0_INT_ST: u1,

          /// [28:28] The masked status bit for the interrupt triggered by capture on channel 1.
          CAP1_INT_ST: u1,

          /// [29:29] The masked status bit for the interrupt triggered by capture on channel 2.
          CAP2_INT_ST: u1,

          /// [30:31] 
          res0: u2,

        }), @ptrFromInt(0x60014118));

        /// Interrupt clear bits
        pub const INT_CLR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Set this bit to clear the interrupt triggered when the timer 0 stops.
          TIMER0_STOP_INT_CLR: u1,

          /// [1:1] Set this bit to clear the interrupt triggered when the timer 1 stops.
          TIMER1_STOP_INT_CLR: u1,

          /// [2:2] Set this bit to clear the interrupt triggered when the timer 2 stops.
          TIMER2_STOP_INT_CLR: u1,

          /// [3:3] Set this bit to clear the interrupt triggered by a PWM timer 0 TEZ event.
          TIMER0_TEZ_INT_CLR: u1,

          /// [4:4] Set this bit to clear the interrupt triggered by a PWM timer 1 TEZ event.
          TIMER1_TEZ_INT_CLR: u1,

          /// [5:5] Set this bit to clear the interrupt triggered by a PWM timer 2 TEZ event.
          TIMER2_TEZ_INT_CLR: u1,

          /// [6:6] Set this bit to clear the interrupt triggered by a PWM timer 0 TEP event.
          TIMER0_TEP_INT_CLR: u1,

          /// [7:7] Set this bit to clear the interrupt triggered by a PWM timer 1 TEP event.
          TIMER1_TEP_INT_CLR: u1,

          /// [8:8] Set this bit to clear the interrupt triggered by a PWM timer 2 TEP event.
          TIMER2_TEP_INT_CLR: u1,

          /// [9:9] Set this bit to clear the interrupt triggered when event_f0 starts.
          FAULT0_INT_CLR: u1,

          /// [10:10] Set this bit to clear the interrupt triggered when event_f1 starts.
          FAULT1_INT_CLR: u1,

          /// [11:11] Set this bit to clear the interrupt triggered when event_f2 starts.
          FAULT2_INT_CLR: u1,

          /// [12:12] Set this bit to clear the interrupt triggered when event_f0 ends.
          FAULT0_CLR_INT_CLR: u1,

          /// [13:13] Set this bit to clear the interrupt triggered when event_f1 ends.
          FAULT1_CLR_INT_CLR: u1,

          /// [14:14] Set this bit to clear the interrupt triggered when event_f2 ends.
          FAULT2_CLR_INT_CLR: u1,

          /// [15:15] Set this bit to clear the interrupt triggered by a PWM operator 0 TEA event
          CMPR0_TEA_INT_CLR: u1,

          /// [16:16] Set this bit to clear the interrupt triggered by a PWM operator 1 TEA event
          CMPR1_TEA_INT_CLR: u1,

          /// [17:17] Set this bit to clear the interrupt triggered by a PWM operator 2 TEA event
          CMPR2_TEA_INT_CLR: u1,

          /// [18:18] Set this bit to clear the interrupt triggered by a PWM operator 0 TEB event
          CMPR0_TEB_INT_CLR: u1,

          /// [19:19] Set this bit to clear the interrupt triggered by a PWM operator 1 TEB event
          CMPR1_TEB_INT_CLR: u1,

          /// [20:20] Set this bit to clear the interrupt triggered by a PWM operator 2 TEB event
          CMPR2_TEB_INT_CLR: u1,

          /// [21:21] Set this bit to clear the interrupt triggered by a cycle-by-cycle mode action on PWM0.
          TZ0_CBC_INT_CLR: u1,

          /// [22:22] Set this bit to clear the interrupt triggered by a cycle-by-cycle mode action on PWM1.
          TZ1_CBC_INT_CLR: u1,

          /// [23:23] Set this bit to clear the interrupt triggered by a cycle-by-cycle mode action on PWM2.
          TZ2_CBC_INT_CLR: u1,

          /// [24:24] Set this bit to clear the interrupt triggered by a one-shot mode action on PWM0.
          TZ0_OST_INT_CLR: u1,

          /// [25:25] Set this bit to clear the interrupt triggered by a one-shot mode action on PWM1.
          TZ1_OST_INT_CLR: u1,

          /// [26:26] Set this bit to clear the interrupt triggered by a one-shot mode action on PWM2.
          TZ2_OST_INT_CLR: u1,

          /// [27:27] Set this bit to clear the interrupt triggered by capture on channel 0.
          CAP0_INT_CLR: u1,

          /// [28:28] Set this bit to clear the interrupt triggered by capture on channel 1.
          CAP1_INT_CLR: u1,

          /// [29:29] Set this bit to clear the interrupt triggered by capture on channel 2.
          CAP2_INT_CLR: u1,

          /// [30:31] 
          res0: u2,

        }), @ptrFromInt(0x6001411c));

        /// MCPWM event enable register
        pub const EVT_EN = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] set this bit high to enable timer0 stop event generate
          EVT_TIMER0_STOP_EN: u1,

          /// [1:1] set this bit high to enable timer1 stop event generate
          EVT_TIMER1_STOP_EN: u1,

          /// [2:2] set this bit high to enable timer2 stop event generate
          EVT_TIMER2_STOP_EN: u1,

          /// [3:3] set this bit high to enable timer0 equal zero event generate
          EVT_TIMER0_TEZ_EN: u1,

          /// [4:4] set this bit high to enable timer1 equal zero event generate
          EVT_TIMER1_TEZ_EN: u1,

          /// [5:5] set this bit high to enable timer2 equal zero event generate
          EVT_TIMER2_TEZ_EN: u1,

          /// [6:6] set this bit high to enable timer0 equal period event generate
          EVT_TIMER0_TEP_EN: u1,

          /// [7:7] set this bit high to enable timer1 equal period event generate
          EVT_TIMER1_TEP_EN: u1,

          /// [8:8] set this bit high to enable timer2 equal period event generate
          EVT_TIMER2_TEP_EN: u1,

          /// [9:9] set this bit high to enable PWM generator0 timer equal a event generate
          EVT_OP0_TEA_EN: u1,

          /// [10:10] set this bit high to enable PWM generator1 timer equal a event generate
          EVT_OP1_TEA_EN: u1,

          /// [11:11] set this bit high to enable PWM generator2 timer equal a event generate
          EVT_OP2_TEA_EN: u1,

          /// [12:12] set this bit high to enable PWM generator0 timer equal b event generate
          EVT_OP0_TEB_EN: u1,

          /// [13:13] set this bit high to enable PWM generator1 timer equal b event generate
          EVT_OP1_TEB_EN: u1,

          /// [14:14] set this bit high to enable PWM generator2 timer equal b event generate
          EVT_OP2_TEB_EN: u1,

          /// [15:15] set this bit high to enable fault0 event generate
          EVT_F0_EN: u1,

          /// [16:16] set this bit high to enable fault1 event generate
          EVT_F1_EN: u1,

          /// [17:17] set this bit high to enable fault2 event generate
          EVT_F2_EN: u1,

          /// [18:18] set this bit high to enable fault0 clear event generate
          EVT_F0_CLR_EN: u1,

          /// [19:19] set this bit high to enable fault1 clear event generate
          EVT_F1_CLR_EN: u1,

          /// [20:20] set this bit high to enable fault2 clear event generate
          EVT_F2_CLR_EN: u1,

          /// [21:21] set this bit high to enable cycle by cycle trip0 event generate
          EVT_TZ0_CBC_EN: u1,

          /// [22:22] set this bit high to enable cycle by cycle trip1 event generate
          EVT_TZ1_CBC_EN: u1,

          /// [23:23] set this bit high to enable cycle by cycle trip2 event generate
          EVT_TZ2_CBC_EN: u1,

          /// [24:24] set this bit high to enable one shot trip0 event generate
          EVT_TZ0_OST_EN: u1,

          /// [25:25] set this bit high to enable one shot trip1 event generate
          EVT_TZ1_OST_EN: u1,

          /// [26:26] set this bit high to enable one shot trip2 event generate
          EVT_TZ2_OST_EN: u1,

          /// [27:27] set this bit high to enable capture0 event generate
          EVT_CAP0_EN: u1,

          /// [28:28] set this bit high to enable capture1 event generate
          EVT_CAP1_EN: u1,

          /// [29:29] set this bit high to enable capture2 event generate
          EVT_CAP2_EN: u1,

          /// [30:31] 
          res0: u2,

        }), @ptrFromInt(0x60014120));

        /// MCPWM task enable register
        pub const TASK_EN = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] set this bit high to enable PWM generator0 timer stamp A's shadow register update task receive
          TASK_CMPR0_A_UP_EN: u1,

          /// [1:1] set this bit high to enable PWM generator1 timer stamp A's shadow register update task receive
          TASK_CMPR1_A_UP_EN: u1,

          /// [2:2] set this bit high to enable PWM generator2 timer stamp A's shadow register update task receive
          TASK_CMPR2_A_UP_EN: u1,

          /// [3:3] set this bit high to enable PWM generator0 timer stamp B's shadow register update task receive
          TASK_CMPR0_B_UP_EN: u1,

          /// [4:4] set this bit high to enable PWM generator1 timer stamp B's shadow register update task receive
          TASK_CMPR1_B_UP_EN: u1,

          /// [5:5] set this bit high to enable PWM generator2 timer stamp B's shadow register update task receive
          TASK_CMPR2_B_UP_EN: u1,

          /// [6:6] set this bit high to enable all PWM generate stop task receive
          TASK_GEN_STOP_EN: u1,

          /// [7:7] set this bit high to enable timer0 sync task receive
          TASK_TIMER0_SYNC_EN: u1,

          /// [8:8] set this bit high to enable timer1 sync task receive
          TASK_TIMER1_SYNC_EN: u1,

          /// [9:9] set this bit high to enable timer2 sync task receive
          TASK_TIMER2_SYNC_EN: u1,

          /// [10:10] set this bit high to enable timer0 period update task receive
          TASK_TIMER0_PERIOD_UP_EN: u1,

          /// [11:11] set this bit high to enable timer1 period update task receive
          TASK_TIMER1_PERIOD_UP_EN: u1,

          /// [12:12] set this bit high to enable timer2 period update task receive
          TASK_TIMER2_PERIOD_UP_EN: u1,

          /// [13:13] set this bit high to enable one shot trip0 task receive
          TASK_TZ0_OST_EN: u1,

          /// [14:14] set this bit high to enable one shot trip1 task receive
          TASK_TZ1_OST_EN: u1,

          /// [15:15] set this bit high to enable one shot trip2 task receive
          TASK_TZ2_OST_EN: u1,

          /// [16:16] set this bit high to enable one shot trip0 clear task receive
          TASK_CLR0_OST_EN: u1,

          /// [17:17] set this bit high to enable one shot trip1 clear task receive
          TASK_CLR1_OST_EN: u1,

          /// [18:18] set this bit high to enable one shot trip2 clear task receive
          TASK_CLR2_OST_EN: u1,

          /// [19:19] set this bit high to enable capture0 task receive
          TASK_CAP0_EN: u1,

          /// [20:20] set this bit high to enable capture1 task receive
          TASK_CAP1_EN: u1,

          /// [21:21] set this bit high to enable capture2 task receive
          TASK_CAP2_EN: u1,

          /// [22:31] 
          res0: u10,

        }), @ptrFromInt(0x60014124));

        /// MCPWM APB configuration register
        pub const CLK = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Force clock on for this register file
          EN: u1,

          /// [1:31] 
          res0: u31,

        }), @ptrFromInt(0x60014128));

        /// Version register.
        pub const VERSION = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:27] Version of this register file
          DATE: u28,

          /// [28:31] 
          res0: u4,

        }), @ptrFromInt(0x6001412c));

      };

      /// MEM_MONITOR Peripheral
      pub const MEM_MONITOR = struct {

        /// log config regsiter
        pub const LOG_SETTING = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:2] enable bus log. BIT0: hp-cpu, BIT1: lp-cpu, BIT2: DMA.
          LOG_ENA: u3,

          /// [3:6] This field must be onehot. 4'b0001 : WR monitor, 4'b0010: WORD monitor, 4'b0100: HALFWORD monitor, 4'b1000: BYTE monitor.
          LOG_MODE: u4,

          /// [7:7] Set 1 enable mem_loop, it will loop write at the range of MEM_START and MEM_END
          LOG_MEM_LOOP_ENABLE: u1,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x60092000));

        /// check data regsiter
        pub const LOG_CHECK_DATA = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] The special check data, when write this special data, it will trigger logging.
          LOG_CHECK_DATA: u32,

        }), @ptrFromInt(0x60092004));

        /// check data mask register
        pub const LOG_DATA_MASK = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:3] byte mask enable, BIT0 mask the first byte of MEM_MONITOR_LOG_CHECK_DATA, and BIT1 mask second byte, and so on.
          LOG_DATA_MASK: u4,

          /// [4:31] 
          res0: u28,

        }), @ptrFromInt(0x60092008));

        /// log boundary regsiter
        pub const LOG_MIN = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] the min address of log range
          LOG_MIN: u32,

        }), @ptrFromInt(0x6009200c));

        /// log boundary regsiter
        pub const LOG_MAX = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] the max address of log range
          LOG_MAX: u32,

        }), @ptrFromInt(0x60092010));

        /// log message store range register
        pub const LOG_MEM_START = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] the start address of writing logging message
          LOG_MEM_START: u32,

        }), @ptrFromInt(0x60092014));

        /// log message store range register
        pub const LOG_MEM_END = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] the end address of writing logging message
          LOG_MEM_END: u32,

        }), @ptrFromInt(0x60092018));

        /// current writing address.
        pub const LOG_MEM_CURRENT_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] means next writing address
          LOG_MEM_CURRENT_ADDR: u32,

        }), @ptrFromInt(0x6009201c));

        /// writing address update
        pub const LOG_MEM_ADDR_UPDATE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Set 1 to updata MEM_MONITOR_LOG_MEM_CURRENT_ADDR, when set 1, MEM_MONITOR_LOG_MEM_CURRENT_ADDR will update to MEM_MONITOR_LOG_MEM_START
          LOG_MEM_ADDR_UPDATE: u1,

          /// [1:31] 
          res0: u31,

        }), @ptrFromInt(0x60092020));

        /// full flag status register
        pub const LOG_MEM_FULL_FLAG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] 1 means memory write loop at least one time at the range of MEM_START and MEM_END
          LOG_MEM_FULL_FLAG: u1,

          /// [1:1] Set 1 to clr MEM_MONITOR_LOG_MEM_FULL_FLAG
          CLR_LOG_MEM_FULL_FLAG: u1,

          /// [2:31] 
          res0: u30,

        }), @ptrFromInt(0x60092024));

        /// clock gate force on register
        pub const CLOCK_GATE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Set 1 to force on the clk of mem_monitor register
          CLK_EN: u1,

          /// [1:31] 
          res0: u31,

        }), @ptrFromInt(0x60092028));

        /// version register
        pub const DATE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:27] version register
          DATE: u28,

          /// [28:31] 
          res0: u4,

        }), @ptrFromInt(0x600923fc));

      };

      /// MODEM_LPCON Peripheral
      pub const MODEM_LPCON = struct {

        
        pub const TEST_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] 
          CLK_EN: u1,

          /// [1:1] 
          CLK_DEBUG_ENA: u1,

          /// [2:31] 
          res0: u30,

        }), @ptrFromInt(0x600af000));

        
        pub const LP_TIMER_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] 
          CLK_LP_TIMER_SEL_OSC_SLOW: u1,

          /// [1:1] 
          CLK_LP_TIMER_SEL_OSC_FAST: u1,

          /// [2:2] 
          CLK_LP_TIMER_SEL_XTAL: u1,

          /// [3:3] 
          CLK_LP_TIMER_SEL_XTAL32K: u1,

          /// [4:15] 
          CLK_LP_TIMER_DIV_NUM: u12,

          /// [16:31] 
          res0: u16,

        }), @ptrFromInt(0x600af004));

        
        pub const COEX_LP_CLK_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] 
          CLK_COEX_LP_SEL_OSC_SLOW: u1,

          /// [1:1] 
          CLK_COEX_LP_SEL_OSC_FAST: u1,

          /// [2:2] 
          CLK_COEX_LP_SEL_XTAL: u1,

          /// [3:3] 
          CLK_COEX_LP_SEL_XTAL32K: u1,

          /// [4:15] 
          CLK_COEX_LP_DIV_NUM: u12,

          /// [16:31] 
          res0: u16,

        }), @ptrFromInt(0x600af008));

        
        pub const WIFI_LP_CLK_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] 
          CLK_WIFIPWR_LP_SEL_OSC_SLOW: u1,

          /// [1:1] 
          CLK_WIFIPWR_LP_SEL_OSC_FAST: u1,

          /// [2:2] 
          CLK_WIFIPWR_LP_SEL_XTAL: u1,

          /// [3:3] 
          CLK_WIFIPWR_LP_SEL_XTAL32K: u1,

          /// [4:15] 
          CLK_WIFIPWR_LP_DIV_NUM: u12,

          /// [16:31] 
          res0: u16,

        }), @ptrFromInt(0x600af00c));

        
        pub const I2C_MST_CLK_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] 
          CLK_I2C_MST_SEL_160M: u1,

          /// [1:31] 
          res0: u31,

        }), @ptrFromInt(0x600af010));

        
        pub const MODEM_32K_CLK_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:1] 
          CLK_MODEM_32K_SEL: u2,

          /// [2:31] 
          res0: u30,

        }), @ptrFromInt(0x600af014));

        
        pub const CLK_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] 
          CLK_WIFIPWR_EN: u1,

          /// [1:1] 
          CLK_COEX_EN: u1,

          /// [2:2] 
          CLK_I2C_MST_EN: u1,

          /// [3:3] 
          CLK_LP_TIMER_EN: u1,

          /// [4:31] 
          res0: u28,

        }), @ptrFromInt(0x600af018));

        
        pub const CLK_CONF_FORCE_ON = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] 
          CLK_WIFIPWR_FO: u1,

          /// [1:1] 
          CLK_COEX_FO: u1,

          /// [2:2] 
          CLK_I2C_MST_FO: u1,

          /// [3:3] 
          CLK_LP_TIMER_FO: u1,

          /// [4:4] 
          CLK_BCMEM_FO: u1,

          /// [5:5] 
          CLK_I2C_MST_MEM_FO: u1,

          /// [6:6] 
          CLK_CHAN_FREQ_MEM_FO: u1,

          /// [7:7] 
          CLK_PBUS_MEM_FO: u1,

          /// [8:8] 
          CLK_AGC_MEM_FO: u1,

          /// [9:9] 
          CLK_DC_MEM_FO: u1,

          /// [10:31] 
          res0: u22,

        }), @ptrFromInt(0x600af01c));

        
        pub const CLK_CONF_POWER_ST = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:15] 
          res0: u16,

          /// [16:19] 
          CLK_WIFIPWR_ST_MAP: u4,

          /// [20:23] 
          CLK_COEX_ST_MAP: u4,

          /// [24:27] 
          CLK_I2C_MST_ST_MAP: u4,

          /// [28:31] 
          CLK_LP_APB_ST_MAP: u4,

        }), @ptrFromInt(0x600af020));

        
        pub const RST_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] 
          RST_WIFIPWR: u1,

          /// [1:1] 
          RST_COEX: u1,

          /// [2:2] 
          RST_I2C_MST: u1,

          /// [3:3] 
          RST_LP_TIMER: u1,

          /// [4:31] 
          res0: u28,

        }), @ptrFromInt(0x600af024));

        
        pub const MEM_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] 
          DC_MEM_FORCE_PU: u1,

          /// [1:1] 
          DC_MEM_FORCE_PD: u1,

          /// [2:2] 
          AGC_MEM_FORCE_PU: u1,

          /// [3:3] 
          AGC_MEM_FORCE_PD: u1,

          /// [4:4] 
          PBUS_MEM_FORCE_PU: u1,

          /// [5:5] 
          PBUS_MEM_FORCE_PD: u1,

          /// [6:6] 
          BC_MEM_FORCE_PU: u1,

          /// [7:7] 
          BC_MEM_FORCE_PD: u1,

          /// [8:8] 
          I2C_MST_MEM_FORCE_PU: u1,

          /// [9:9] 
          I2C_MST_MEM_FORCE_PD: u1,

          /// [10:10] 
          CHAN_FREQ_MEM_FORCE_PU: u1,

          /// [11:11] 
          CHAN_FREQ_MEM_FORCE_PD: u1,

          /// [12:14] 
          MODEM_PWR_MEM_WP: u3,

          /// [15:17] 
          MODEM_PWR_MEM_WA: u3,

          /// [18:19] 
          MODEM_PWR_MEM_RA: u2,

          /// [20:31] 
          res0: u12,

        }), @ptrFromInt(0x600af028));

        
        pub const DATE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:27] 
          DATE: u28,

          /// [28:31] 
          res0: u4,

        }), @ptrFromInt(0x600af02c));

      };

      /// MODEM_SYSCON Peripheral
      pub const MODEM_SYSCON = struct {

        
        pub const TEST_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] 
          CLK_EN: u1,

          /// [1:31] 
          res0: u31,

        }), @ptrFromInt(0x600a9800));

        
        pub const CLK_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:20] 
          res0: u21,

          /// [21:21] 
          CLK_DATA_DUMP_MUX: u1,

          /// [22:22] 
          CLK_ETM_EN: u1,

          /// [23:23] 
          CLK_ZB_APB_EN: u1,

          /// [24:24] 
          CLK_ZB_MAC_EN: u1,

          /// [25:25] 
          CLK_MODEM_SEC_ECB_EN: u1,

          /// [26:26] 
          CLK_MODEM_SEC_CCM_EN: u1,

          /// [27:27] 
          CLK_MODEM_SEC_BAH_EN: u1,

          /// [28:28] 
          CLK_MODEM_SEC_APB_EN: u1,

          /// [29:29] 
          CLK_MODEM_SEC_EN: u1,

          /// [30:30] 
          CLK_BLE_TIMER_EN: u1,

          /// [31:31] 
          CLK_DATA_DUMP_EN: u1,

        }), @ptrFromInt(0x600a9804));

        
        pub const CLK_CONF_FORCE_ON = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:21] 
          res0: u22,

          /// [22:22] 
          CLK_ETM_FO: u1,

          /// [23:23] 
          CLK_ZB_APB_FO: u1,

          /// [24:24] 
          CLK_ZB_MAC_FO: u1,

          /// [25:25] 
          CLK_MODEM_SEC_ECB_FO: u1,

          /// [26:26] 
          CLK_MODEM_SEC_CCM_FO: u1,

          /// [27:27] 
          CLK_MODEM_SEC_BAH_FO: u1,

          /// [28:28] 
          CLK_MODEM_SEC_APB_FO: u1,

          /// [29:29] 
          CLK_MODEM_SEC_FO: u1,

          /// [30:30] 
          CLK_BLE_TIMER_FO: u1,

          /// [31:31] 
          CLK_DATA_DUMP_FO: u1,

        }), @ptrFromInt(0x600a9808));

        
        pub const CLK_CONF_POWER_ST = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] 
          res0: u8,

          /// [8:11] 
          CLK_ZB_ST_MAP: u4,

          /// [12:15] 
          CLK_FE_ST_MAP: u4,

          /// [16:19] 
          CLK_BT_ST_MAP: u4,

          /// [20:23] 
          CLK_WIFI_ST_MAP: u4,

          /// [24:27] 
          CLK_MODEM_PERI_ST_MAP: u4,

          /// [28:31] 
          CLK_MODEM_APB_ST_MAP: u4,

        }), @ptrFromInt(0x600a980c));

        
        pub const MODEM_RST_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] 
          res0: u8,

          /// [8:8] 
          RST_WIFIBB: u1,

          /// [9:9] 
          res1: u1,

          /// [10:10] 
          RST_WIFIMAC: u1,

          /// [11:13] 
          res2: u3,

          /// [14:14] 
          RST_FE: u1,

          /// [15:15] 
          RST_BTMAC_APB: u1,

          /// [16:16] 
          RST_BTMAC: u1,

          /// [17:17] 
          RST_BTBB_APB: u1,

          /// [18:18] 
          RST_BTBB: u1,

          /// [19:21] 
          res3: u3,

          /// [22:22] 
          RST_ETM: u1,

          /// [23:23] 
          res4: u1,

          /// [24:24] 
          RST_ZBMAC: u1,

          /// [25:25] 
          RST_MODEM_ECB: u1,

          /// [26:26] 
          RST_MODEM_CCM: u1,

          /// [27:27] 
          RST_MODEM_BAH: u1,

          /// [28:28] 
          res5: u1,

          /// [29:29] 
          RST_MODEM_SEC: u1,

          /// [30:30] 
          RST_BLE_TIMER: u1,

          /// [31:31] 
          RST_DATA_DUMP: u1,

        }), @ptrFromInt(0x600a9810));

        
        pub const CLK_CONF1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] 
          CLK_WIFIBB_22M_EN: u1,

          /// [1:1] 
          CLK_WIFIBB_40M_EN: u1,

          /// [2:2] 
          CLK_WIFIBB_44M_EN: u1,

          /// [3:3] 
          CLK_WIFIBB_80M_EN: u1,

          /// [4:4] 
          CLK_WIFIBB_40X_EN: u1,

          /// [5:5] 
          CLK_WIFIBB_80X_EN: u1,

          /// [6:6] 
          CLK_WIFIBB_40X1_EN: u1,

          /// [7:7] 
          CLK_WIFIBB_80X1_EN: u1,

          /// [8:8] 
          CLK_WIFIBB_160X1_EN: u1,

          /// [9:9] 
          CLK_WIFIMAC_EN: u1,

          /// [10:10] 
          CLK_WIFI_APB_EN: u1,

          /// [11:11] 
          CLK_FE_20M_EN: u1,

          /// [12:12] 
          CLK_FE_40M_EN: u1,

          /// [13:13] 
          CLK_FE_80M_EN: u1,

          /// [14:14] 
          CLK_FE_160M_EN: u1,

          /// [15:15] 
          CLK_FE_CAL_160M_EN: u1,

          /// [16:16] 
          CLK_FE_APB_EN: u1,

          /// [17:17] 
          CLK_BT_APB_EN: u1,

          /// [18:18] 
          CLK_BT_EN: u1,

          /// [19:19] 
          CLK_WIFIBB_480M_EN: u1,

          /// [20:20] 
          CLK_FE_480M_EN: u1,

          /// [21:21] 
          CLK_FE_ANAMODE_40M_EN: u1,

          /// [22:22] 
          CLK_FE_ANAMODE_80M_EN: u1,

          /// [23:23] 
          CLK_FE_ANAMODE_160M_EN: u1,

          /// [24:31] 
          res0: u8,

        }), @ptrFromInt(0x600a9814));

        
        pub const CLK_CONF1_FORCE_ON = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] 
          CLK_WIFIBB_22M_FO: u1,

          /// [1:1] 
          CLK_WIFIBB_40M_FO: u1,

          /// [2:2] 
          CLK_WIFIBB_44M_FO: u1,

          /// [3:3] 
          CLK_WIFIBB_80M_FO: u1,

          /// [4:4] 
          CLK_WIFIBB_40X_FO: u1,

          /// [5:5] 
          CLK_WIFIBB_80X_FO: u1,

          /// [6:6] 
          CLK_WIFIBB_40X1_FO: u1,

          /// [7:7] 
          CLK_WIFIBB_80X1_FO: u1,

          /// [8:8] 
          CLK_WIFIBB_160X1_FO: u1,

          /// [9:9] 
          CLK_WIFIMAC_FO: u1,

          /// [10:10] 
          CLK_WIFI_APB_FO: u1,

          /// [11:11] 
          CLK_FE_20M_FO: u1,

          /// [12:12] 
          CLK_FE_40M_FO: u1,

          /// [13:13] 
          CLK_FE_80M_FO: u1,

          /// [14:14] 
          CLK_FE_160M_FO: u1,

          /// [15:15] 
          CLK_FE_CAL_160M_FO: u1,

          /// [16:16] 
          CLK_FE_APB_FO: u1,

          /// [17:17] 
          CLK_BT_APB_FO: u1,

          /// [18:18] 
          CLK_BT_FO: u1,

          /// [19:19] 
          CLK_WIFIBB_480M_FO: u1,

          /// [20:20] 
          CLK_FE_480M_FO: u1,

          /// [21:21] 
          CLK_FE_ANAMODE_40M_FO: u1,

          /// [22:22] 
          CLK_FE_ANAMODE_80M_FO: u1,

          /// [23:23] 
          CLK_FE_ANAMODE_160M_FO: u1,

          /// [24:31] 
          res0: u8,

        }), @ptrFromInt(0x600a9818));

        
        pub const WIFI_BB_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] 
          WIFI_BB_CFG: u32,

        }), @ptrFromInt(0x600a981c));

        
        pub const MEM_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:2] 
          MODEM_MEM_WP: u3,

          /// [3:5] 
          MODEM_MEM_WA: u3,

          /// [6:7] 
          MODEM_MEM_RA: u2,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x600a9820));

        
        pub const DATE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:27] 
          DATE: u28,

          /// [28:31] 
          res0: u4,

        }), @ptrFromInt(0x600a9824));

      };

      /// OTP_DEBUG Peripheral
      pub const OTP_DEBUG = struct {

        /// Otp debuger block0 data register1.
        pub const WR_DIS = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Otp block0 write disable data.
          BLOCK0_WR_DIS: u32,

        }), @ptrFromInt(0x600b3c00));

        /// Otp debuger block0 data register2.
        pub const BLK0_BACKUP1_W1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Otp block0 backup1 word1 data.
          OTP_BEBUG_BLOCK0_BACKUP1_W1: u32,

        }), @ptrFromInt(0x600b3c04));

        /// Otp debuger block0 data register3.
        pub const BLK0_BACKUP1_W2 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Otp block0 backup1 word2 data.
          OTP_BEBUG_BLOCK0_BACKUP1_W2: u32,

        }), @ptrFromInt(0x600b3c08));

        /// Otp debuger block0 data register4.
        pub const BLK0_BACKUP1_W3 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Otp block0 backup1 word3 data.
          OTP_BEBUG_BLOCK0_BACKUP1_W3: u32,

        }), @ptrFromInt(0x600b3c0c));

        /// Otp debuger block0 data register5.
        pub const BLK0_BACKUP1_W4 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Otp block0 backup1 word4 data.
          OTP_BEBUG_BLOCK0_BACKUP1_W4: u32,

        }), @ptrFromInt(0x600b3c10));

        /// Otp debuger block0 data register6.
        pub const BLK0_BACKUP1_W5 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Otp block0 backup1 word5 data.
          OTP_BEBUG_BLOCK0_BACKUP1_W5: u32,

        }), @ptrFromInt(0x600b3c14));

        /// Otp debuger block0 data register7.
        pub const BLK0_BACKUP2_W1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Otp block0 backup2 word1 data.
          OTP_BEBUG_BLOCK0_BACKUP2_W1: u32,

        }), @ptrFromInt(0x600b3c18));

        /// Otp debuger block0 data register8.
        pub const BLK0_BACKUP2_W2 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Otp block0 backup2 word2 data.
          OTP_BEBUG_BLOCK0_BACKUP2_W2: u32,

        }), @ptrFromInt(0x600b3c1c));

        /// Otp debuger block0 data register9.
        pub const BLK0_BACKUP2_W3 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Otp block0 backup2 word3 data.
          OTP_BEBUG_BLOCK0_BACKUP2_W3: u32,

        }), @ptrFromInt(0x600b3c20));

        /// Otp debuger block0 data register10.
        pub const BLK0_BACKUP2_W4 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Otp block0 backup2 word4 data.
          OTP_BEBUG_BLOCK0_BACKUP2_W4: u32,

        }), @ptrFromInt(0x600b3c24));

        /// Otp debuger block0 data register11.
        pub const BLK0_BACKUP2_W5 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Otp block0 backup2 word5 data.
          OTP_BEBUG_BLOCK0_BACKUP2_W5: u32,

        }), @ptrFromInt(0x600b3c28));

        /// Otp debuger block0 data register12.
        pub const BLK0_BACKUP3_W1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Otp block0 backup3 word1 data.
          OTP_BEBUG_BLOCK0_BACKUP3_W1: u32,

        }), @ptrFromInt(0x600b3c2c));

        /// Otp debuger block0 data register13.
        pub const BLK0_BACKUP3_W2 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Otp block0 backup3 word2 data.
          OTP_BEBUG_BLOCK0_BACKUP3_W2: u32,

        }), @ptrFromInt(0x600b3c30));

        /// Otp debuger block0 data register14.
        pub const BLK0_BACKUP3_W3 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Otp block0 backup3 word3 data.
          OTP_BEBUG_BLOCK0_BACKUP3_W3: u32,

        }), @ptrFromInt(0x600b3c34));

        /// Otp debuger block0 data register15.
        pub const BLK0_BACKUP3_W4 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Otp block0 backup3 word4 data.
          OTP_BEBUG_BLOCK0_BACKUP3_W4: u32,

        }), @ptrFromInt(0x600b3c38));

        /// Otp debuger block0 data register16.
        pub const BLK0_BACKUP3_W5 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Otp block0 backup3 word5 data.
          OTP_BEBUG_BLOCK0_BACKUP3_W5: u32,

        }), @ptrFromInt(0x600b3c3c));

        /// Otp debuger block0 data register17.
        pub const BLK0_BACKUP4_W1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Otp block0 backup4 word1 data.
          OTP_BEBUG_BLOCK0_BACKUP4_W1: u32,

        }), @ptrFromInt(0x600b3c40));

        /// Otp debuger block0 data register18.
        pub const BLK0_BACKUP4_W2 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Otp block0 backup4 word2 data.
          OTP_BEBUG_BLOCK0_BACKUP4_W2: u32,

        }), @ptrFromInt(0x600b3c44));

        /// Otp debuger block0 data register19.
        pub const BLK0_BACKUP4_W3 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Otp block0 backup4 word3 data.
          OTP_BEBUG_BLOCK0_BACKUP4_W3: u32,

        }), @ptrFromInt(0x600b3c48));

        /// Otp debuger block0 data register20.
        pub const BLK0_BACKUP4_W4 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Otp block0 backup4 word4 data.
          OTP_BEBUG_BLOCK0_BACKUP4_W4: u32,

        }), @ptrFromInt(0x600b3c4c));

        /// Otp debuger block0 data register21.
        pub const BLK0_BACKUP4_W5 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Otp block0 backup4 word5 data.
          OTP_BEBUG_BLOCK0_BACKUP4_W5: u32,

        }), @ptrFromInt(0x600b3c50));

        /// Otp debuger block1 data register1.
        pub const BLK1_W1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Otp block1word1 data.
          BLOCK1_W1: u32,

        }), @ptrFromInt(0x600b3c54));

        /// Otp debuger block1 data register2.
        pub const BLK1_W2 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Otp block1word2 data.
          BLOCK1_W2: u32,

        }), @ptrFromInt(0x600b3c58));

        /// Otp debuger block1 data register3.
        pub const BLK1_W3 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Otp block1word3 data.
          BLOCK1_W3: u32,

        }), @ptrFromInt(0x600b3c5c));

        /// Otp debuger block1 data register4.
        pub const BLK1_W4 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Otp block1word4 data.
          BLOCK1_W4: u32,

        }), @ptrFromInt(0x600b3c60));

        /// Otp debuger block1 data register5.
        pub const BLK1_W5 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Otp block1word5 data.
          BLOCK1_W5: u32,

        }), @ptrFromInt(0x600b3c64));

        /// Otp debuger block1 data register6.
        pub const BLK1_W6 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Otp block1word6 data.
          BLOCK1_W6: u32,

        }), @ptrFromInt(0x600b3c68));

        /// Otp debuger block1 data register7.
        pub const BLK1_W7 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Otp block1word7 data.
          BLOCK1_W7: u32,

        }), @ptrFromInt(0x600b3c6c));

        /// Otp debuger block1 data register8.
        pub const BLK1_W8 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Otp block1word8 data.
          BLOCK1_W8: u32,

        }), @ptrFromInt(0x600b3c70));

        /// Otp debuger block1 data register9.
        pub const BLK1_W9 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Otp block1word9 data.
          BLOCK1_W9: u32,

        }), @ptrFromInt(0x600b3c74));

        /// Otp debuger block2 data register1.
        pub const BLK2_W1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Otp block2 word1 data.
          BLOCK2_W1: u32,

        }), @ptrFromInt(0x600b3c78));

        /// Otp debuger block2 data register2.
        pub const BLK2_W2 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Otp block2 word2 data.
          BLOCK2_W2: u32,

        }), @ptrFromInt(0x600b3c7c));

        /// Otp debuger block2 data register3.
        pub const BLK2_W3 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Otp block2 word3 data.
          BLOCK2_W3: u32,

        }), @ptrFromInt(0x600b3c80));

        /// Otp debuger block2 data register4.
        pub const BLK2_W4 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Otp block2 word4 data.
          BLOCK2_W4: u32,

        }), @ptrFromInt(0x600b3c84));

        /// Otp debuger block2 data register5.
        pub const BLK2_W5 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Otp block2 word5 data.
          BLOCK2_W5: u32,

        }), @ptrFromInt(0x600b3c88));

        /// Otp debuger block2 data register6.
        pub const BLK2_W6 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Otp block2 word6 data.
          BLOCK2_W6: u32,

        }), @ptrFromInt(0x600b3c8c));

        /// Otp debuger block2 data register7.
        pub const BLK2_W7 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Otp block2 word7 data.
          BLOCK2_W7: u32,

        }), @ptrFromInt(0x600b3c90));

        /// Otp debuger block2 data register8.
        pub const BLK2_W8 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Otp block2 word8 data.
          BLOCK2_W8: u32,

        }), @ptrFromInt(0x600b3c94));

        /// Otp debuger block2 data register9.
        pub const BLK2_W9 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Otp block2 word9 data.
          BLOCK2_W9: u32,

        }), @ptrFromInt(0x600b3c98));

        /// Otp debuger block2 data register10.
        pub const BLK2_W10 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Otp block2 word10 data.
          BLOCK2_W10: u32,

        }), @ptrFromInt(0x600b3c9c));

        /// Otp debuger block2 data register11.
        pub const BLK2_W11 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Otp block2 word11 data.
          BLOCK2_W11: u32,

        }), @ptrFromInt(0x600b3ca0));

        /// Otp debuger block3 data register1.
        pub const BLK3_W1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Otp block3 word1 data.
          BLOCK3_W1: u32,

        }), @ptrFromInt(0x600b3ca4));

        /// Otp debuger block3 data register2.
        pub const BLK3_W2 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Otp block3 word2 data.
          BLOCK3_W2: u32,

        }), @ptrFromInt(0x600b3ca8));

        /// Otp debuger block3 data register3.
        pub const BLK3_W3 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Otp block3 word3 data.
          BLOCK3_W3: u32,

        }), @ptrFromInt(0x600b3cac));

        /// Otp debuger block3 data register4.
        pub const BLK3_W4 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Otp block3 word4 data.
          BLOCK3_W4: u32,

        }), @ptrFromInt(0x600b3cb0));

        /// Otp debuger block3 data register5.
        pub const BLK3_W5 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Otp block3 word5 data.
          BLOCK3_W5: u32,

        }), @ptrFromInt(0x600b3cb4));

        /// Otp debuger block3 data register6.
        pub const BLK3_W6 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Otp block3 word6 data.
          BLOCK3_W6: u32,

        }), @ptrFromInt(0x600b3cb8));

        /// Otp debuger block3 data register7.
        pub const BLK3_W7 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Otp block3 word7 data.
          BLOCK3_W7: u32,

        }), @ptrFromInt(0x600b3cbc));

        /// Otp debuger block3 data register8.
        pub const BLK3_W8 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Otp block3 word8 data.
          BLOCK3_W8: u32,

        }), @ptrFromInt(0x600b3cc0));

        /// Otp debuger block3 data register9.
        pub const BLK3_W9 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Otp block3 word9 data.
          BLOCK3_W9: u32,

        }), @ptrFromInt(0x600b3cc4));

        /// Otp debuger block3 data register10.
        pub const BLK3_W10 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Otp block3 word10 data.
          BLOCK3_W10: u32,

        }), @ptrFromInt(0x600b3cc8));

        /// Otp debuger block3 data register11.
        pub const BLK3_W11 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Otp block3 word11 data.
          BLOCK3_W11: u32,

        }), @ptrFromInt(0x600b3ccc));

        /// Otp debuger block4 data register1.
        pub const BLK4_W1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Otp block4 word1 data.
          BLOCK4_W1: u32,

        }), @ptrFromInt(0x600b3cd0));

        /// Otp debuger block4 data register2.
        pub const BLK4_W2 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Otp block4 word2 data.
          BLOCK4_W2: u32,

        }), @ptrFromInt(0x600b3cd4));

        /// Otp debuger block4 data register3.
        pub const BLK4_W3 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Otp block4 word3 data.
          BLOCK4_W3: u32,

        }), @ptrFromInt(0x600b3cd8));

        /// Otp debuger block4 data register4.
        pub const BLK4_W4 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Otp block4 word4 data.
          BLOCK4_W4: u32,

        }), @ptrFromInt(0x600b3cdc));

        /// Otp debuger block4 data register5.
        pub const BLK4_W5 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Otp block4 word5 data.
          BLOCK4_W5: u32,

        }), @ptrFromInt(0x600b3ce0));

        /// Otp debuger block4 data register6.
        pub const BLK4_W6 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Otp block4 word6 data.
          BLOCK4_W6: u32,

        }), @ptrFromInt(0x600b3ce4));

        /// Otp debuger block4 data register7.
        pub const BLK4_W7 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Otp block4 word7 data.
          BLOCK4_W7: u32,

        }), @ptrFromInt(0x600b3ce8));

        /// Otp debuger block4 data register8.
        pub const BLK4_W8 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Otp block4 word8 data.
          BLOCK4_W8: u32,

        }), @ptrFromInt(0x600b3cec));

        /// Otp debuger block4 data register9.
        pub const BLK4_W9 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Otp block4 word9 data.
          BLOCK4_W9: u32,

        }), @ptrFromInt(0x600b3cf0));

        /// Otp debuger block4 data registe10.
        pub const BLK4_W10 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Otp block4 word10 data.
          BLOCK4_W10: u32,

        }), @ptrFromInt(0x600b3cf4));

        /// Otp debuger block4 data register11.
        pub const BLK4_W11 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Otp block4 word11 data.
          BLOCK4_W11: u32,

        }), @ptrFromInt(0x600b3cf8));

        /// Otp debuger block5 data register1.
        pub const BLK5_W1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Otp block5 word1 data.
          BLOCK5_W1: u32,

        }), @ptrFromInt(0x600b3cfc));

        /// Otp debuger block5 data register2.
        pub const BLK5_W2 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Otp block5 word2 data.
          BLOCK5_W2: u32,

        }), @ptrFromInt(0x600b3d00));

        /// Otp debuger block5 data register3.
        pub const BLK5_W3 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Otp block5 word3 data.
          BLOCK5_W3: u32,

        }), @ptrFromInt(0x600b3d04));

        /// Otp debuger block5 data register4.
        pub const BLK5_W4 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Otp block5 word4 data.
          BLOCK5_W4: u32,

        }), @ptrFromInt(0x600b3d08));

        /// Otp debuger block5 data register5.
        pub const BLK5_W5 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Otp block5 word5 data.
          BLOCK5_W5: u32,

        }), @ptrFromInt(0x600b3d0c));

        /// Otp debuger block5 data register6.
        pub const BLK5_W6 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Otp block5 word6 data.
          BLOCK5_W6: u32,

        }), @ptrFromInt(0x600b3d10));

        /// Otp debuger block5 data register7.
        pub const BLK5_W7 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Otp block5 word7 data.
          BLOCK5_W7: u32,

        }), @ptrFromInt(0x600b3d14));

        /// Otp debuger block5 data register8.
        pub const BLK5_W8 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Otp block5 word8 data.
          BLOCK5_W8: u32,

        }), @ptrFromInt(0x600b3d18));

        /// Otp debuger block5 data register9.
        pub const BLK5_W9 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Otp block5 word9 data.
          BLOCK5_W9: u32,

        }), @ptrFromInt(0x600b3d1c));

        /// Otp debuger block5 data register10.
        pub const BLK5_W10 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Otp block5 word10 data.
          BLOCK5_W10: u32,

        }), @ptrFromInt(0x600b3d20));

        /// Otp debuger block5 data register11.
        pub const BLK5_W11 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Otp block5 word11 data.
          BLOCK5_W11: u32,

        }), @ptrFromInt(0x600b3d24));

        /// Otp debuger block6 data register1.
        pub const BLK6_W1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Otp block6 word1 data.
          BLOCK6_W1: u32,

        }), @ptrFromInt(0x600b3d28));

        /// Otp debuger block6 data register2.
        pub const BLK6_W2 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Otp block6 word2 data.
          BLOCK6_W2: u32,

        }), @ptrFromInt(0x600b3d2c));

        /// Otp debuger block6 data register3.
        pub const BLK6_W3 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Otp block6 word3 data.
          BLOCK6_W3: u32,

        }), @ptrFromInt(0x600b3d30));

        /// Otp debuger block6 data register4.
        pub const BLK6_W4 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Otp block6 word4 data.
          BLOCK6_W4: u32,

        }), @ptrFromInt(0x600b3d34));

        /// Otp debuger block6 data register5.
        pub const BLK6_W5 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Otp block6 word5 data.
          BLOCK6_W5: u32,

        }), @ptrFromInt(0x600b3d38));

        /// Otp debuger block6 data register6.
        pub const BLK6_W6 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Otp block6 word6 data.
          BLOCK6_W6: u32,

        }), @ptrFromInt(0x600b3d3c));

        /// Otp debuger block6 data register7.
        pub const BLK6_W7 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Otp block6 word7 data.
          BLOCK6_W7: u32,

        }), @ptrFromInt(0x600b3d40));

        /// Otp debuger block6 data register8.
        pub const BLK6_W8 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Otp block6 word8 data.
          BLOCK6_W8: u32,

        }), @ptrFromInt(0x600b3d44));

        /// Otp debuger block6 data register9.
        pub const BLK6_W9 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Otp block6 word9 data.
          BLOCK6_W9: u32,

        }), @ptrFromInt(0x600b3d48));

        /// Otp debuger block6 data register10.
        pub const BLK6_W10 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Otp block6 word10 data.
          BLOCK6_W10: u32,

        }), @ptrFromInt(0x600b3d4c));

        /// Otp debuger block6 data register11.
        pub const BLK6_W11 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Otp block6 word11 data.
          BLOCK6_W11: u32,

        }), @ptrFromInt(0x600b3d50));

        /// Otp debuger block7 data register1.
        pub const BLK7_W1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Otp block7 word1 data.
          BLOCK7_W1: u32,

        }), @ptrFromInt(0x600b3d54));

        /// Otp debuger block7 data register2.
        pub const BLK7_W2 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Otp block7 word2 data.
          BLOCK7_W2: u32,

        }), @ptrFromInt(0x600b3d58));

        /// Otp debuger block7 data register3.
        pub const BLK7_W3 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Otp block7 word3 data.
          BLOCK7_W3: u32,

        }), @ptrFromInt(0x600b3d5c));

        /// Otp debuger block7 data register4.
        pub const BLK7_W4 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Otp block7 word4 data.
          BLOCK7_W4: u32,

        }), @ptrFromInt(0x600b3d60));

        /// Otp debuger block7 data register5.
        pub const BLK7_W5 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Otp block7 word5 data.
          BLOCK7_W5: u32,

        }), @ptrFromInt(0x600b3d64));

        /// Otp debuger block7 data register6.
        pub const BLK7_W6 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Otp block7 word6 data.
          BLOCK7_W6: u32,

        }), @ptrFromInt(0x600b3d68));

        /// Otp debuger block7 data register7.
        pub const BLK7_W7 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Otp block7 word7 data.
          BLOCK7_W7: u32,

        }), @ptrFromInt(0x600b3d6c));

        /// Otp debuger block7 data register8.
        pub const BLK7_W8 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Otp block7 word8 data.
          BLOCK7_W8: u32,

        }), @ptrFromInt(0x600b3d70));

        /// Otp debuger block7 data register9.
        pub const BLK7_W9 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Otp block7 word9 data.
          BLOCK7_W9: u32,

        }), @ptrFromInt(0x600b3d74));

        /// Otp debuger block7 data register10.
        pub const BLK7_W10 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Otp block7 word10 data.
          BLOCK7_W10: u32,

        }), @ptrFromInt(0x600b3d78));

        /// Otp debuger block7 data register11.
        pub const BLK7_W11 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Otp block7 word11 data.
          BLOCK7_W11: u32,

        }), @ptrFromInt(0x600b3d7c));

        /// Otp debuger block8 data register1.
        pub const BLK8_W1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Otp block8 word1 data.
          BLOCK8_W1: u32,

        }), @ptrFromInt(0x600b3d80));

        /// Otp debuger block8 data register2.
        pub const BLK8_W2 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Otp block8 word2 data.
          BLOCK8_W2: u32,

        }), @ptrFromInt(0x600b3d84));

        /// Otp debuger block8 data register3.
        pub const BLK8_W3 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Otp block8 word3 data.
          BLOCK8_W3: u32,

        }), @ptrFromInt(0x600b3d88));

        /// Otp debuger block8 data register4.
        pub const BLK8_W4 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Otp block8 word4 data.
          BLOCK8_W4: u32,

        }), @ptrFromInt(0x600b3d8c));

        /// Otp debuger block8 data register5.
        pub const BLK8_W5 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Otp block8 word5 data.
          BLOCK8_W5: u32,

        }), @ptrFromInt(0x600b3d90));

        /// Otp debuger block8 data register6.
        pub const BLK8_W6 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Otp block8 word6 data.
          BLOCK8_W6: u32,

        }), @ptrFromInt(0x600b3d94));

        /// Otp debuger block8 data register7.
        pub const BLK8_W7 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Otp block8 word7 data.
          BLOCK8_W7: u32,

        }), @ptrFromInt(0x600b3d98));

        /// Otp debuger block8 data register8.
        pub const BLK8_W8 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Otp block8 word8 data.
          BLOCK8_W8: u32,

        }), @ptrFromInt(0x600b3d9c));

        /// Otp debuger block8 data register9.
        pub const BLK8_W9 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Otp block8 word9 data.
          BLOCK8_W9: u32,

        }), @ptrFromInt(0x600b3da0));

        /// Otp debuger block8 data register10.
        pub const BLK8_W10 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Otp block8 word10 data.
          BLOCK8_W10: u32,

        }), @ptrFromInt(0x600b3da4));

        /// Otp debuger block8 data register11.
        pub const BLK8_W11 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Otp block8 word11 data.
          BLOCK8_W11: u32,

        }), @ptrFromInt(0x600b3da8));

        /// Otp debuger block9 data register1.
        pub const BLK9_W1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Otp block9 word1 data.
          BLOCK9_W1: u32,

        }), @ptrFromInt(0x600b3dac));

        /// Otp debuger block9 data register2.
        pub const BLK9_W2 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Otp block9 word2 data.
          BLOCK9_W2: u32,

        }), @ptrFromInt(0x600b3db0));

        /// Otp debuger block9 data register3.
        pub const BLK9_W3 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Otp block9 word3 data.
          BLOCK9_W3: u32,

        }), @ptrFromInt(0x600b3db4));

        /// Otp debuger block9 data register4.
        pub const BLK9_W4 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Otp block9 word4 data.
          BLOCK9_W4: u32,

        }), @ptrFromInt(0x600b3db8));

        /// Otp debuger block9 data register5.
        pub const BLK9_W5 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Otp block9 word5 data.
          BLOCK9_W5: u32,

        }), @ptrFromInt(0x600b3dbc));

        /// Otp debuger block9 data register6.
        pub const BLK9_W6 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Otp block9 word6 data.
          BLOCK9_W6: u32,

        }), @ptrFromInt(0x600b3dc0));

        /// Otp debuger block9 data register7.
        pub const BLK9_W7 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Otp block9 word7 data.
          BLOCK9_W7: u32,

        }), @ptrFromInt(0x600b3dc4));

        /// Otp debuger block9 data register8.
        pub const BLK9_W8 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Otp block9 word8 data.
          BLOCK9_W8: u32,

        }), @ptrFromInt(0x600b3dc8));

        /// Otp debuger block9 data register9.
        pub const BLK9_W9 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Otp block9 word9 data.
          BLOCK9_W9: u32,

        }), @ptrFromInt(0x600b3dcc));

        /// Otp debuger block9 data register10.
        pub const BLK9_W10 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Otp block9 word10 data.
          BLOCK9_W10: u32,

        }), @ptrFromInt(0x600b3dd0));

        /// Otp debuger block9 data register11.
        pub const BLK9_W11 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Otp block9 word11 data.
          BLOCK9_W11: u32,

        }), @ptrFromInt(0x600b3dd4));

        /// Otp debuger block10 data register1.
        pub const BLK10_W1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Otp block10 word1 data.
          BLOCK10_W1: u32,

        }), @ptrFromInt(0x600b3dd8));

        /// Otp debuger block10 data register2.
        pub const BLK10_W2 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Otp block10 word2 data.
          BLOCK10_W2: u32,

        }), @ptrFromInt(0x600b3ddc));

        /// Otp debuger block10 data register3.
        pub const BLK10_W3 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Otp block10 word3 data.
          BLOCK10_W3: u32,

        }), @ptrFromInt(0x600b3de0));

        /// Otp debuger block10 data register4.
        pub const BLK10_W4 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Otp block10 word4 data.
          BLOCK10_W4: u32,

        }), @ptrFromInt(0x600b3de4));

        /// Otp debuger block10 data register5.
        pub const BLK10_W5 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Otp block10 word5 data.
          BLOCK10_W5: u32,

        }), @ptrFromInt(0x600b3de8));

        /// Otp debuger block10 data register6.
        pub const BLK10_W6 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Otp block10 word6 data.
          BLOCK10_W6: u32,

        }), @ptrFromInt(0x600b3dec));

        /// Otp debuger block10 data register7.
        pub const BLK10_W7 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Otp block10 word7 data.
          BLOCK10_W7: u32,

        }), @ptrFromInt(0x600b3df0));

        /// Otp debuger block10 data register8.
        pub const BLK10_W8 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Otp block10 word8 data.
          BLOCK10_W8: u32,

        }), @ptrFromInt(0x600b3df4));

        /// Otp debuger block10 data register9.
        pub const BLK10_W9 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Otp block10 word9 data.
          BLOCK10_W9: u32,

        }), @ptrFromInt(0x600b3df8));

        /// Otp debuger block10 data register10.
        pub const BLK10_W10 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Otp block10 word10 data.
          BLOCK19_W10: u32,

        }), @ptrFromInt(0x600b3dfc));

        /// Otp debuger block10 data register11.
        pub const BLK10_W11 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Otp block10 word11 data.
          BLOCK10_W11: u32,

        }), @ptrFromInt(0x600b3e00));

        /// Otp debuger clk_en configuration register.
        pub const CLK = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Force clock on for this register file.
          EN: u1,

          /// [1:31] 
          res0: u31,

        }), @ptrFromInt(0x600b3e04));

        /// Otp_debuger apb2otp enable configuration register.
        pub const APB2OTP_EN = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Debug mode enable signal.
          APB2OTP_EN: u1,

          /// [1:31] 
          res0: u31,

        }), @ptrFromInt(0x600b3e08));

        /// eFuse version register.
        pub const DATE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:27] Stores otp_debug version.
          DATE: u28,

          /// [28:31] 
          res0: u4,

        }), @ptrFromInt(0x600b3e0c));

      };

      /// PARL_IO Peripheral
      pub const PARL_IO = struct {

        /// Parallel RX module configuration register0.
        pub const RX_CFG0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Write 0 to select eof generated manchnism by configured data byte length. Write 1 to select eof generated manchnism by external enable signal.
          RX_EOF_GEN_SEL: u1,

          /// [1:1] Write 1 to start rx global data sampling.
          RX_START: u1,

          /// [2:17] Configures rx receieved data byte length.
          RX_DATA_BYTELEN: u16,

          /// [18:18] Write 1 to enable software data sampling.
          RX_SW_EN: u1,

          /// [19:22] Pulse submode selection. 0000: positive pulse start(data bit included) &&positive pulse end(data bit included)0001: positive pulse start(data bit included) && positive pulse end (data bit excluded)0010: positive pulse start(data bit excluded) && positive pulse end (data bit included)0011: positive pulse start(data bit excluded) && positive pulse end (data bit excluded)0100: positive pulse start(data bit included) && length end0101: positive pulse start(data bit excluded) && length end0110: negative pulse start(data bit included) &&negative pulse end(data bit included)0111: negative pulse start(data bit included) && negative pulse end (data bit excluded)1000: negative pulse start(data bit excluded) && negative pulse end (data bit included)1001: negative pulse start(data bit excluded) && negative pulse end (data bit excluded)1010: negative pulse start(data bit included) && length end1011: negative pulse start(data bit excluded) && length end
          RX_PULSE_SUBMODE_SEL: u4,

          /// [23:23] Write 0 to sample data at high level of external enable signal. Write 1 to sample data at low level of external enable signal.
          RX_LEVEL_SUBMODE_SEL: u1,

          /// [24:25] Rx data sampling mode selection. 000: external level enable mode001: external pulse enable mode010: internal software enable mode
          RX_SMP_MODE_SEL: u2,

          /// [26:26] Write 0 to enable sampling data on the rising edge of rx clock. Write 0 to enable sampling data on the falling edge of rx clock.
          RX_CLK_EDGE_SEL: u1,

          /// [27:27] Write 0 to pack bits into 1byte from MSB when data bus width is 4/2/1 bits. Write 0 to pack bits into 1byte from LSB when data bus width is 4/2/1 bits.
          RX_BIT_PACK_ORDER: u1,

          /// [28:30] Rx data bus width selection. 100: bus width is 1 bit 011: bus width is 2 bits 010: bus width is 4 bits001: bus width is 8 bits000: bus width is 16 bits
          RX_BUS_WID_SEL: u3,

          /// [31:31] Write 1 to enable soft reset of async fifo in rx module.
          RX_FIFO_SRST: u1,

        }), @ptrFromInt(0x60015000));

        /// Parallel RX module configuration register1.
        pub const RX_CFG1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:1] 
          res0: u2,

          /// [2:2] Write 1 to update rx register configuration signals.
          RX_REG_UPDATE: u1,

          /// [3:3] Write 1 to enable timeout count to generate error eof.
          RX_TIMEOUT_EN: u1,

          /// [4:11] 
          res1: u8,

          /// [12:15] Configures rx external enable signal selection from 16 data lines.
          RX_EXT_EN_SEL: u4,

          /// [16:31] Configures rx threshold of timeout counter.
          RX_TIMEOUT_THRESHOLD: u16,

        }), @ptrFromInt(0x60015004));

        /// Parallel TX module configuration register0.
        pub const TX_CFG0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:1] 
          res0: u2,

          /// [2:17] Configures tx sending data byte length.
          TX_BYTELEN: u16,

          /// [18:18] Write 1 to enable output tx clock gating.
          TX_GATING_EN: u1,

          /// [19:19] Write 1 to start tx global data output.
          TX_START: u1,

          /// [20:20] Write 1 to enable tx hardware data valid signal.
          TX_HW_VALID_EN: u1,

          /// [21:24] 
          res1: u4,

          /// [25:25] Write 0 to enable sampling data on the rising edge of tx clock. Write 0 to enable sampling data on the falling edge of tx clock.
          TX_SMP_EDGE_SEL: u1,

          /// [26:26] Write 0 to unpack bits from 1byte from MSB when data bus width is 4/2/1 bits. Write 0 to unpack bits from 1byte from LSB when data bus width is 4/2/1 bits.
          TX_BIT_UNPACK_ORDER: u1,

          /// [27:29] Tx data bus width selection. 100: bus width is 1 bit011: bus width is 2 bits010: bus width is 4 bits001: bus width is 8 bits000: bus width is 16 bits
          TX_BUS_WID_SEL: u3,

          /// [30:30] Write 1 to enable soft reset of async fifo in tx module.
          TX_FIFO_SRST: u1,

          /// [31:31] 
          res2: u1,

        }), @ptrFromInt(0x60015008));

        /// Parallel TX module configuration register1.
        pub const TX_CFG1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:15] 
          res0: u16,

          /// [16:31] Configures data value on tx bus when IDLE state.
          TX_IDLE_VALUE: u16,

        }), @ptrFromInt(0x6001500c));

        /// Parallel IO module status register0.
        pub const ST = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:30] 
          res0: u31,

          /// [31:31] Represents the status that tx is ready.
          TX_READY: u1,

        }), @ptrFromInt(0x60015010));

        /// Parallel IO interrupt enable singal configuration register.
        pub const INT_ENA = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Write 1 to enable TX_FIFO_REMPTY_INTR.
          TX_FIFO_REMPTY_INT_ENA: u1,

          /// [1:1] Write 1 to enable RX_FIFO_WFULL_INTR.
          RX_FIFO_WFULL_INT_ENA: u1,

          /// [2:2] Write 1 to enable TX_EOF_INTR.
          TX_EOF_INT_ENA: u1,

          /// [3:31] 
          res0: u29,

        }), @ptrFromInt(0x60015014));

        /// Parallel IO interrupt raw singal status register.
        pub const INT_RAW = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] The raw interrupt status of TX_FIFO_REMPTY_INTR.
          TX_FIFO_REMPTY_INT_RAW: u1,

          /// [1:1] The raw interrupt status of RX_FIFO_WFULL_INTR.
          RX_FIFO_WFULL_INT_RAW: u1,

          /// [2:2] The raw interrupt status of TX_EOF_INTR.
          TX_EOF_INT_RAW: u1,

          /// [3:31] 
          res0: u29,

        }), @ptrFromInt(0x60015018));

        /// Parallel IO interrupt singal status register.
        pub const INT_ST = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] The masked interrupt status of TX_FIFO_REMPTY_INTR.
          TX_FIFO_REMPTY_INT_ST: u1,

          /// [1:1] The masked interrupt status of RX_FIFO_WFULL_INTR.
          RX_FIFO_WFULL_INT_ST: u1,

          /// [2:2] The masked interrupt status of TX_EOF_INTR.
          TX_EOF_INT_ST: u1,

          /// [3:31] 
          res0: u29,

        }), @ptrFromInt(0x6001501c));

        /// Parallel IO interruptclear singal configuration register.
        pub const INT_CLR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Write 1 to clear TX_FIFO_REMPTY_INTR.
          TX_FIFO_REMPTY_INT_CLR: u1,

          /// [1:1] Write 1 to clear RX_FIFO_WFULL_INTR.
          RX_FIFO_WFULL_INT_CLR: u1,

          /// [2:2] Write 1 to clear TX_EOF_INTR.
          TX_EOF_INT_CLR: u1,

          /// [3:31] 
          res0: u29,

        }), @ptrFromInt(0x60015020));

        /// Parallel IO clk configuration register
        pub const CLK = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Force clock on for this register file
          EN: u1,

          /// [1:31] 
          res0: u31,

        }), @ptrFromInt(0x60015120));

        /// Version register.
        pub const VERSION = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:27] Version of this register file
          DATE: u28,

          /// [28:31] 
          res0: u4,

        }), @ptrFromInt(0x600153fc));

      };

      /// PAU Peripheral
      pub const PAU = struct {

        /// Peri backup control register
        pub const REGDMA_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:2] backup error type
          FLOW_ERR: u3,

          /// [3:3] backup start signal
          START: u1,

          /// [4:4] backup direction(reg to mem / mem to reg)
          TO_MEM: u1,

          /// [5:6] Link select
          LINK_SEL: u2,

          /// [7:7] mac sw backup start signal
          START_MAC: u1,

          /// [8:8] mac sw backup direction(reg to mem / mem to reg)
          TO_MEM_MAC: u1,

          /// [9:9] mac hw/sw select
          SEL_MAC: u1,

          /// [10:31] 
          res0: u22,

        }), @ptrFromInt(0x60093000));

        /// Clock control register
        pub const REGDMA_CLK_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] clock enable
          CLK_EN: u1,

          /// [1:31] 
          res0: u31,

        }), @ptrFromInt(0x60093004));

        /// ETM start ctrl reg
        pub const REGDMA_ETM_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] etm_start_0 reg
          ETM_START_0: u1,

          /// [1:1] etm_start_1 reg
          ETM_START_1: u1,

          /// [2:2] etm_start_2 reg
          ETM_START_2: u1,

          /// [3:3] etm_start_3 reg
          ETM_START_3: u1,

          /// [4:31] 
          res0: u28,

        }), @ptrFromInt(0x60093008));

        /// link_0_addr
        pub const REGDMA_LINK_0_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] link_0_addr reg
          LINK_ADDR_0: u32,

        }), @ptrFromInt(0x6009300c));

        /// Link_1_addr
        pub const REGDMA_LINK_1_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Link_1_addr reg
          LINK_ADDR_1: u32,

        }), @ptrFromInt(0x60093010));

        /// Link_2_addr
        pub const REGDMA_LINK_2_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Link_2_addr reg
          LINK_ADDR_2: u32,

        }), @ptrFromInt(0x60093014));

        /// Link_3_addr
        pub const REGDMA_LINK_3_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Link_3_addr reg
          LINK_ADDR_3: u32,

        }), @ptrFromInt(0x60093018));

        /// Link_mac_addr
        pub const REGDMA_LINK_MAC_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Link_mac_addr reg
          LINK_ADDR_MAC: u32,

        }), @ptrFromInt(0x6009301c));

        /// current link addr
        pub const REGDMA_CURRENT_LINK_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] current link addr reg
          CURRENT_LINK_ADDR: u32,

        }), @ptrFromInt(0x60093020));

        /// Backup addr
        pub const REGDMA_BACKUP_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] backup addr reg
          BACKUP_ADDR: u32,

        }), @ptrFromInt(0x60093024));

        /// mem addr
        pub const REGDMA_MEM_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] mem addr reg
          MEM_ADDR: u32,

        }), @ptrFromInt(0x60093028));

        /// backup config
        pub const REGDMA_BKP_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:6] Link read_interval
          READ_INTERVAL: u7,

          /// [7:16] link wait timeout threshold
          LINK_TOUT_THRES: u10,

          /// [17:21] burst limit
          BURST_LIMIT: u5,

          /// [22:31] Backup timeout threshold
          BACKUP_TOUT_THRES: u10,

        }), @ptrFromInt(0x6009302c));

        /// retention dma link base
        pub const RETENTION_LINK_BASE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:26] retention dma link base
          LINK_BASE_ADDR: u27,

          /// [27:31] 
          res0: u5,

        }), @ptrFromInt(0x60093030));

        /// retention_cfg
        pub const RETENTION_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] retention inv scan out
          RET_INV_CFG: u32,

        }), @ptrFromInt(0x60093034));

        /// Read only register for error and done
        pub const INT_ENA = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] backup done flag
          DONE_INT_ENA: u1,

          /// [1:1] error flag
          ERROR_INT_ENA: u1,

          /// [2:31] 
          res0: u30,

        }), @ptrFromInt(0x60093038));

        /// Read only register for error and done
        pub const INT_RAW = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] backup done flag
          DONE_INT_RAW: u1,

          /// [1:1] error flag
          ERROR_INT_RAW: u1,

          /// [2:31] 
          res0: u30,

        }), @ptrFromInt(0x6009303c));

        /// Read only register for error and done
        pub const INT_CLR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] backup done flag
          DONE_INT_CLR: u1,

          /// [1:1] error flag
          ERROR_INT_CLR: u1,

          /// [2:31] 
          res0: u30,

        }), @ptrFromInt(0x60093040));

        /// Read only register for error and done
        pub const INT_ST = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] backup done flag
          DONE_INT_ST: u1,

          /// [1:1] error flag
          ERROR_INT_ST: u1,

          /// [2:31] 
          res0: u30,

        }), @ptrFromInt(0x60093044));

        /// Date register.
        pub const DATE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:27] REGDMA date information/ REGDMA version information.
          DATE: u28,

          /// [28:31] 
          res0: u4,

        }), @ptrFromInt(0x600933fc));

      };

      /// Pulse Count Controller
      pub const PCNT = struct {

        /// Configuration register 0 for unit %s
        pub const U0_CONF0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:9] This sets the maximum threshold, in APB_CLK cycles, for the filter.Any pulses with width less than this will be ignored when the filter is enabled.
          FILTER_THRES: u10,

          /// [10:10] This is the enable bit for unit %s's input filter.
          FILTER_EN: u1,

          /// [11:11] This is the enable bit for unit %s's zero comparator.
          THR_ZERO_EN: u1,

          /// [12:12] This is the enable bit for unit %s's thr_h_lim comparator.
          THR_H_LIM_EN: u1,

          /// [13:13] This is the enable bit for unit %s's thr_l_lim comparator.
          THR_L_LIM_EN: u1,

          /// [14:14] This is the enable bit for unit %s's thres0 comparator.
          THR_THRES0_EN: u1,

          /// [15:15] This is the enable bit for unit %s's thres1 comparator.
          THR_THRES1_EN: u1,

          /// [16:17] This register sets the behavior when the signal input of channel 0 detects a negative edge.1: Increase the counter.2: Decrease the counter.0, 3: No effect on counter
          CH0_NEG_MODE: u2,

          /// [18:19] This register sets the behavior when the signal input of channel 0 detects a positive edge.1: Increase the counter.2: Decrease the counter.0, 3: No effect on counter
          CH0_POS_MODE: u2,

          /// [20:21] This register configures how the CH%s_POS_MODE/CH%s_NEG_MODE settings will be modified when the control signal is high.0: No modification.1: Invert behavior (increase -> decrease, decrease -> increase).2, 3: Inhibit counter modification
          CH0_HCTRL_MODE: u2,

          /// [22:23] This register configures how the CH%s_POS_MODE/CH%s_NEG_MODE settings will be modified when the control signal is low.0: No modification.1: Invert behavior (increase -> decrease, decrease -> increase).2, 3: Inhibit counter modification
          CH0_LCTRL_MODE: u2,

          /// [24:25] This register sets the behavior when the signal input of channel 1 detects a negative edge.1: Increment the counter.2: Decrement the counter.0, 3: No effect on counter
          CH1_NEG_MODE: u2,

          /// [26:27] This register sets the behavior when the signal input of channel 1 detects a positive edge.1: Increment the counter.2: Decrement the counter.0, 3: No effect on counter
          CH1_POS_MODE: u2,

          /// [28:29] This register configures how the CH%s_POS_MODE/CH%s_NEG_MODE settings will be modified when the control signal is high.0: No modification.1: Invert behavior (increase -> decrease, decrease -> increase).2, 3: Inhibit counter modification
          CH1_HCTRL_MODE: u2,

          /// [30:31] This register configures how the CH%s_POS_MODE/CH%s_NEG_MODE settings will be modified when the control signal is low.0: No modification.1: Invert behavior (increase -> decrease, decrease -> increase).2, 3: Inhibit counter modification
          CH1_LCTRL_MODE: u2,

        }), @ptrFromInt(0x60012000));

        /// Configuration register 0 for unit %s
        pub const U1_CONF0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:9] This sets the maximum threshold, in APB_CLK cycles, for the filter.Any pulses with width less than this will be ignored when the filter is enabled.
          FILTER_THRES: u10,

          /// [10:10] This is the enable bit for unit %s's input filter.
          FILTER_EN: u1,

          /// [11:11] This is the enable bit for unit %s's zero comparator.
          THR_ZERO_EN: u1,

          /// [12:12] This is the enable bit for unit %s's thr_h_lim comparator.
          THR_H_LIM_EN: u1,

          /// [13:13] This is the enable bit for unit %s's thr_l_lim comparator.
          THR_L_LIM_EN: u1,

          /// [14:14] This is the enable bit for unit %s's thres0 comparator.
          THR_THRES0_EN: u1,

          /// [15:15] This is the enable bit for unit %s's thres1 comparator.
          THR_THRES1_EN: u1,

          /// [16:17] This register sets the behavior when the signal input of channel 0 detects a negative edge.1: Increase the counter.2: Decrease the counter.0, 3: No effect on counter
          CH0_NEG_MODE: u2,

          /// [18:19] This register sets the behavior when the signal input of channel 0 detects a positive edge.1: Increase the counter.2: Decrease the counter.0, 3: No effect on counter
          CH0_POS_MODE: u2,

          /// [20:21] This register configures how the CH%s_POS_MODE/CH%s_NEG_MODE settings will be modified when the control signal is high.0: No modification.1: Invert behavior (increase -> decrease, decrease -> increase).2, 3: Inhibit counter modification
          CH0_HCTRL_MODE: u2,

          /// [22:23] This register configures how the CH%s_POS_MODE/CH%s_NEG_MODE settings will be modified when the control signal is low.0: No modification.1: Invert behavior (increase -> decrease, decrease -> increase).2, 3: Inhibit counter modification
          CH0_LCTRL_MODE: u2,

          /// [24:25] This register sets the behavior when the signal input of channel 1 detects a negative edge.1: Increment the counter.2: Decrement the counter.0, 3: No effect on counter
          CH1_NEG_MODE: u2,

          /// [26:27] This register sets the behavior when the signal input of channel 1 detects a positive edge.1: Increment the counter.2: Decrement the counter.0, 3: No effect on counter
          CH1_POS_MODE: u2,

          /// [28:29] This register configures how the CH%s_POS_MODE/CH%s_NEG_MODE settings will be modified when the control signal is high.0: No modification.1: Invert behavior (increase -> decrease, decrease -> increase).2, 3: Inhibit counter modification
          CH1_HCTRL_MODE: u2,

          /// [30:31] This register configures how the CH%s_POS_MODE/CH%s_NEG_MODE settings will be modified when the control signal is low.0: No modification.1: Invert behavior (increase -> decrease, decrease -> increase).2, 3: Inhibit counter modification
          CH1_LCTRL_MODE: u2,

        }), @ptrFromInt(0x60012004));

        /// Configuration register 0 for unit %s
        pub const U2_CONF0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:9] This sets the maximum threshold, in APB_CLK cycles, for the filter.Any pulses with width less than this will be ignored when the filter is enabled.
          FILTER_THRES: u10,

          /// [10:10] This is the enable bit for unit %s's input filter.
          FILTER_EN: u1,

          /// [11:11] This is the enable bit for unit %s's zero comparator.
          THR_ZERO_EN: u1,

          /// [12:12] This is the enable bit for unit %s's thr_h_lim comparator.
          THR_H_LIM_EN: u1,

          /// [13:13] This is the enable bit for unit %s's thr_l_lim comparator.
          THR_L_LIM_EN: u1,

          /// [14:14] This is the enable bit for unit %s's thres0 comparator.
          THR_THRES0_EN: u1,

          /// [15:15] This is the enable bit for unit %s's thres1 comparator.
          THR_THRES1_EN: u1,

          /// [16:17] This register sets the behavior when the signal input of channel 0 detects a negative edge.1: Increase the counter.2: Decrease the counter.0, 3: No effect on counter
          CH0_NEG_MODE: u2,

          /// [18:19] This register sets the behavior when the signal input of channel 0 detects a positive edge.1: Increase the counter.2: Decrease the counter.0, 3: No effect on counter
          CH0_POS_MODE: u2,

          /// [20:21] This register configures how the CH%s_POS_MODE/CH%s_NEG_MODE settings will be modified when the control signal is high.0: No modification.1: Invert behavior (increase -> decrease, decrease -> increase).2, 3: Inhibit counter modification
          CH0_HCTRL_MODE: u2,

          /// [22:23] This register configures how the CH%s_POS_MODE/CH%s_NEG_MODE settings will be modified when the control signal is low.0: No modification.1: Invert behavior (increase -> decrease, decrease -> increase).2, 3: Inhibit counter modification
          CH0_LCTRL_MODE: u2,

          /// [24:25] This register sets the behavior when the signal input of channel 1 detects a negative edge.1: Increment the counter.2: Decrement the counter.0, 3: No effect on counter
          CH1_NEG_MODE: u2,

          /// [26:27] This register sets the behavior when the signal input of channel 1 detects a positive edge.1: Increment the counter.2: Decrement the counter.0, 3: No effect on counter
          CH1_POS_MODE: u2,

          /// [28:29] This register configures how the CH%s_POS_MODE/CH%s_NEG_MODE settings will be modified when the control signal is high.0: No modification.1: Invert behavior (increase -> decrease, decrease -> increase).2, 3: Inhibit counter modification
          CH1_HCTRL_MODE: u2,

          /// [30:31] This register configures how the CH%s_POS_MODE/CH%s_NEG_MODE settings will be modified when the control signal is low.0: No modification.1: Invert behavior (increase -> decrease, decrease -> increase).2, 3: Inhibit counter modification
          CH1_LCTRL_MODE: u2,

        }), @ptrFromInt(0x60012008));

        /// Configuration register 0 for unit %s
        pub const U3_CONF0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:9] This sets the maximum threshold, in APB_CLK cycles, for the filter.Any pulses with width less than this will be ignored when the filter is enabled.
          FILTER_THRES: u10,

          /// [10:10] This is the enable bit for unit %s's input filter.
          FILTER_EN: u1,

          /// [11:11] This is the enable bit for unit %s's zero comparator.
          THR_ZERO_EN: u1,

          /// [12:12] This is the enable bit for unit %s's thr_h_lim comparator.
          THR_H_LIM_EN: u1,

          /// [13:13] This is the enable bit for unit %s's thr_l_lim comparator.
          THR_L_LIM_EN: u1,

          /// [14:14] This is the enable bit for unit %s's thres0 comparator.
          THR_THRES0_EN: u1,

          /// [15:15] This is the enable bit for unit %s's thres1 comparator.
          THR_THRES1_EN: u1,

          /// [16:17] This register sets the behavior when the signal input of channel 0 detects a negative edge.1: Increase the counter.2: Decrease the counter.0, 3: No effect on counter
          CH0_NEG_MODE: u2,

          /// [18:19] This register sets the behavior when the signal input of channel 0 detects a positive edge.1: Increase the counter.2: Decrease the counter.0, 3: No effect on counter
          CH0_POS_MODE: u2,

          /// [20:21] This register configures how the CH%s_POS_MODE/CH%s_NEG_MODE settings will be modified when the control signal is high.0: No modification.1: Invert behavior (increase -> decrease, decrease -> increase).2, 3: Inhibit counter modification
          CH0_HCTRL_MODE: u2,

          /// [22:23] This register configures how the CH%s_POS_MODE/CH%s_NEG_MODE settings will be modified when the control signal is low.0: No modification.1: Invert behavior (increase -> decrease, decrease -> increase).2, 3: Inhibit counter modification
          CH0_LCTRL_MODE: u2,

          /// [24:25] This register sets the behavior when the signal input of channel 1 detects a negative edge.1: Increment the counter.2: Decrement the counter.0, 3: No effect on counter
          CH1_NEG_MODE: u2,

          /// [26:27] This register sets the behavior when the signal input of channel 1 detects a positive edge.1: Increment the counter.2: Decrement the counter.0, 3: No effect on counter
          CH1_POS_MODE: u2,

          /// [28:29] This register configures how the CH%s_POS_MODE/CH%s_NEG_MODE settings will be modified when the control signal is high.0: No modification.1: Invert behavior (increase -> decrease, decrease -> increase).2, 3: Inhibit counter modification
          CH1_HCTRL_MODE: u2,

          /// [30:31] This register configures how the CH%s_POS_MODE/CH%s_NEG_MODE settings will be modified when the control signal is low.0: No modification.1: Invert behavior (increase -> decrease, decrease -> increase).2, 3: Inhibit counter modification
          CH1_LCTRL_MODE: u2,

        }), @ptrFromInt(0x6001200c));

        /// Configuration register 1 for unit %s
        pub const U0_CONF1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:15] This register is used to configure the thres0 value for unit %s.
          CNT_THRES0: u16,

          /// [16:31] This register is used to configure the thres1 value for unit %s.
          CNT_THRES1: u16,

        }), @ptrFromInt(0x60012004));

        /// Configuration register 1 for unit %s
        pub const U1_CONF1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:15] This register is used to configure the thres0 value for unit %s.
          CNT_THRES0: u16,

          /// [16:31] This register is used to configure the thres1 value for unit %s.
          CNT_THRES1: u16,

        }), @ptrFromInt(0x60012008));

        /// Configuration register 1 for unit %s
        pub const U2_CONF1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:15] This register is used to configure the thres0 value for unit %s.
          CNT_THRES0: u16,

          /// [16:31] This register is used to configure the thres1 value for unit %s.
          CNT_THRES1: u16,

        }), @ptrFromInt(0x6001200c));

        /// Configuration register 1 for unit %s
        pub const U3_CONF1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:15] This register is used to configure the thres0 value for unit %s.
          CNT_THRES0: u16,

          /// [16:31] This register is used to configure the thres1 value for unit %s.
          CNT_THRES1: u16,

        }), @ptrFromInt(0x60012010));

        /// Configuration register 2 for unit %s
        pub const U0_CONF2 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:15] This register is used to configure the thr_h_lim value for unit %s.
          CNT_H_LIM: u16,

          /// [16:31] This register is used to configure the thr_l_lim value for unit %s.
          CNT_L_LIM: u16,

        }), @ptrFromInt(0x60012008));

        /// Configuration register 2 for unit %s
        pub const U1_CONF2 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:15] This register is used to configure the thr_h_lim value for unit %s.
          CNT_H_LIM: u16,

          /// [16:31] This register is used to configure the thr_l_lim value for unit %s.
          CNT_L_LIM: u16,

        }), @ptrFromInt(0x6001200c));

        /// Configuration register 2 for unit %s
        pub const U2_CONF2 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:15] This register is used to configure the thr_h_lim value for unit %s.
          CNT_H_LIM: u16,

          /// [16:31] This register is used to configure the thr_l_lim value for unit %s.
          CNT_L_LIM: u16,

        }), @ptrFromInt(0x60012010));

        /// Configuration register 2 for unit %s
        pub const U3_CONF2 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:15] This register is used to configure the thr_h_lim value for unit %s.
          CNT_H_LIM: u16,

          /// [16:31] This register is used to configure the thr_l_lim value for unit %s.
          CNT_L_LIM: u16,

        }), @ptrFromInt(0x60012014));

        /// Counter value for unit %s
        pub const U0_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:15] This register stores the current pulse count value for unit %s.
          CNT: u16,

          /// [16:31] 
          res0: u16,

        }), @ptrFromInt(0x60012030));

        /// Counter value for unit %s
        pub const U1_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:15] This register stores the current pulse count value for unit %s.
          CNT: u16,

          /// [16:31] 
          res0: u16,

        }), @ptrFromInt(0x60012034));

        /// Counter value for unit %s
        pub const U2_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:15] This register stores the current pulse count value for unit %s.
          CNT: u16,

          /// [16:31] 
          res0: u16,

        }), @ptrFromInt(0x60012038));

        /// Counter value for unit %s
        pub const U3_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:15] This register stores the current pulse count value for unit %s.
          CNT: u16,

          /// [16:31] 
          res0: u16,

        }), @ptrFromInt(0x6001203c));

        /// Interrupt raw status register
        pub const INT_RAW = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] The raw interrupt status bit for the PCNT_CNT_THR_EVENT_U0_INT interrupt.
          CNT_THR_EVENT_U0: u1,

          /// [1:1] The raw interrupt status bit for the PCNT_CNT_THR_EVENT_U1_INT interrupt.
          CNT_THR_EVENT_U1: u1,

          /// [2:2] The raw interrupt status bit for the PCNT_CNT_THR_EVENT_U2_INT interrupt.
          CNT_THR_EVENT_U2: u1,

          /// [3:3] The raw interrupt status bit for the PCNT_CNT_THR_EVENT_U3_INT interrupt.
          CNT_THR_EVENT_U3: u1,

          /// [4:31] 
          res0: u28,

        }), @ptrFromInt(0x60012040));

        /// Interrupt status register
        pub const INT_ST = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] The masked interrupt status bit for the PCNT_CNT_THR_EVENT_U0_INT interrupt.
          CNT_THR_EVENT_U0: u1,

          /// [1:1] The masked interrupt status bit for the PCNT_CNT_THR_EVENT_U1_INT interrupt.
          CNT_THR_EVENT_U1: u1,

          /// [2:2] The masked interrupt status bit for the PCNT_CNT_THR_EVENT_U2_INT interrupt.
          CNT_THR_EVENT_U2: u1,

          /// [3:3] The masked interrupt status bit for the PCNT_CNT_THR_EVENT_U3_INT interrupt.
          CNT_THR_EVENT_U3: u1,

          /// [4:31] 
          res0: u28,

        }), @ptrFromInt(0x60012044));

        /// Interrupt enable register
        pub const INT_ENA = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] The interrupt enable bit for the PCNT_CNT_THR_EVENT_U0_INT interrupt.
          CNT_THR_EVENT_U0: u1,

          /// [1:1] The interrupt enable bit for the PCNT_CNT_THR_EVENT_U1_INT interrupt.
          CNT_THR_EVENT_U1: u1,

          /// [2:2] The interrupt enable bit for the PCNT_CNT_THR_EVENT_U2_INT interrupt.
          CNT_THR_EVENT_U2: u1,

          /// [3:3] The interrupt enable bit for the PCNT_CNT_THR_EVENT_U3_INT interrupt.
          CNT_THR_EVENT_U3: u1,

          /// [4:31] 
          res0: u28,

        }), @ptrFromInt(0x60012048));

        /// Interrupt clear register
        pub const INT_CLR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Set this bit to clear the PCNT_CNT_THR_EVENT_U0_INT interrupt.
          CNT_THR_EVENT_U0: u1,

          /// [1:1] Set this bit to clear the PCNT_CNT_THR_EVENT_U1_INT interrupt.
          CNT_THR_EVENT_U1: u1,

          /// [2:2] Set this bit to clear the PCNT_CNT_THR_EVENT_U2_INT interrupt.
          CNT_THR_EVENT_U2: u1,

          /// [3:3] Set this bit to clear the PCNT_CNT_THR_EVENT_U3_INT interrupt.
          CNT_THR_EVENT_U3: u1,

          /// [4:31] 
          res0: u28,

        }), @ptrFromInt(0x6001204c));

        /// PNCT UNIT%s status register
        pub const U0_STATUS = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:1] The pulse counter status of PCNT_U%s corresponding to 0. 0: pulse counter decreases from positive to 0. 1: pulse counter increases from negative to 0. 2: pulse counter is negative. 3: pulse counter is positive.
          ZERO_MODE: u2,

          /// [2:2] The latched value of thres1 event of PCNT_U%s when threshold event interrupt is valid. 1: the current pulse counter equals to thres1 and thres1 event is valid. 0: others
          THRES1: u1,

          /// [3:3] The latched value of thres0 event of PCNT_U%s when threshold event interrupt is valid. 1: the current pulse counter equals to thres0 and thres0 event is valid. 0: others
          THRES0: u1,

          /// [4:4] The latched value of low limit event of PCNT_U%s when threshold event interrupt is valid. 1: the current pulse counter equals to thr_l_lim and low limit event is valid. 0: others
          L_LIM: u1,

          /// [5:5] The latched value of high limit event of PCNT_U%s when threshold event interrupt is valid. 1: the current pulse counter equals to thr_h_lim and high limit event is valid. 0: others
          H_LIM: u1,

          /// [6:6] The latched value of zero threshold event of PCNT_U%s when threshold event interrupt is valid. 1: the current pulse counter equals to 0 and zero threshold event is valid. 0: others
          ZERO: u1,

          /// [7:31] 
          res0: u25,

        }), @ptrFromInt(0x60012050));

        /// PNCT UNIT%s status register
        pub const U1_STATUS = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:1] The pulse counter status of PCNT_U%s corresponding to 0. 0: pulse counter decreases from positive to 0. 1: pulse counter increases from negative to 0. 2: pulse counter is negative. 3: pulse counter is positive.
          ZERO_MODE: u2,

          /// [2:2] The latched value of thres1 event of PCNT_U%s when threshold event interrupt is valid. 1: the current pulse counter equals to thres1 and thres1 event is valid. 0: others
          THRES1: u1,

          /// [3:3] The latched value of thres0 event of PCNT_U%s when threshold event interrupt is valid. 1: the current pulse counter equals to thres0 and thres0 event is valid. 0: others
          THRES0: u1,

          /// [4:4] The latched value of low limit event of PCNT_U%s when threshold event interrupt is valid. 1: the current pulse counter equals to thr_l_lim and low limit event is valid. 0: others
          L_LIM: u1,

          /// [5:5] The latched value of high limit event of PCNT_U%s when threshold event interrupt is valid. 1: the current pulse counter equals to thr_h_lim and high limit event is valid. 0: others
          H_LIM: u1,

          /// [6:6] The latched value of zero threshold event of PCNT_U%s when threshold event interrupt is valid. 1: the current pulse counter equals to 0 and zero threshold event is valid. 0: others
          ZERO: u1,

          /// [7:31] 
          res0: u25,

        }), @ptrFromInt(0x60012054));

        /// PNCT UNIT%s status register
        pub const U2_STATUS = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:1] The pulse counter status of PCNT_U%s corresponding to 0. 0: pulse counter decreases from positive to 0. 1: pulse counter increases from negative to 0. 2: pulse counter is negative. 3: pulse counter is positive.
          ZERO_MODE: u2,

          /// [2:2] The latched value of thres1 event of PCNT_U%s when threshold event interrupt is valid. 1: the current pulse counter equals to thres1 and thres1 event is valid. 0: others
          THRES1: u1,

          /// [3:3] The latched value of thres0 event of PCNT_U%s when threshold event interrupt is valid. 1: the current pulse counter equals to thres0 and thres0 event is valid. 0: others
          THRES0: u1,

          /// [4:4] The latched value of low limit event of PCNT_U%s when threshold event interrupt is valid. 1: the current pulse counter equals to thr_l_lim and low limit event is valid. 0: others
          L_LIM: u1,

          /// [5:5] The latched value of high limit event of PCNT_U%s when threshold event interrupt is valid. 1: the current pulse counter equals to thr_h_lim and high limit event is valid. 0: others
          H_LIM: u1,

          /// [6:6] The latched value of zero threshold event of PCNT_U%s when threshold event interrupt is valid. 1: the current pulse counter equals to 0 and zero threshold event is valid. 0: others
          ZERO: u1,

          /// [7:31] 
          res0: u25,

        }), @ptrFromInt(0x60012058));

        /// PNCT UNIT%s status register
        pub const U3_STATUS = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:1] The pulse counter status of PCNT_U%s corresponding to 0. 0: pulse counter decreases from positive to 0. 1: pulse counter increases from negative to 0. 2: pulse counter is negative. 3: pulse counter is positive.
          ZERO_MODE: u2,

          /// [2:2] The latched value of thres1 event of PCNT_U%s when threshold event interrupt is valid. 1: the current pulse counter equals to thres1 and thres1 event is valid. 0: others
          THRES1: u1,

          /// [3:3] The latched value of thres0 event of PCNT_U%s when threshold event interrupt is valid. 1: the current pulse counter equals to thres0 and thres0 event is valid. 0: others
          THRES0: u1,

          /// [4:4] The latched value of low limit event of PCNT_U%s when threshold event interrupt is valid. 1: the current pulse counter equals to thr_l_lim and low limit event is valid. 0: others
          L_LIM: u1,

          /// [5:5] The latched value of high limit event of PCNT_U%s when threshold event interrupt is valid. 1: the current pulse counter equals to thr_h_lim and high limit event is valid. 0: others
          H_LIM: u1,

          /// [6:6] The latched value of zero threshold event of PCNT_U%s when threshold event interrupt is valid. 1: the current pulse counter equals to 0 and zero threshold event is valid. 0: others
          ZERO: u1,

          /// [7:31] 
          res0: u25,

        }), @ptrFromInt(0x6001205c));

        /// Control register for all counters
        pub const CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Set this bit to clear unit 0's counter.
          CNT_RST_U0: u1,

          /// [1:1] Set this bit to freeze unit 0's counter.
          CNT_PAUSE_U0: u1,

          /// [2:2] Set this bit to clear unit 1's counter.
          CNT_RST_U1: u1,

          /// [3:3] Set this bit to freeze unit 1's counter.
          CNT_PAUSE_U1: u1,

          /// [4:4] Set this bit to clear unit 2's counter.
          CNT_RST_U2: u1,

          /// [5:5] Set this bit to freeze unit 2's counter.
          CNT_PAUSE_U2: u1,

          /// [6:6] Set this bit to clear unit 3's counter.
          CNT_RST_U3: u1,

          /// [7:7] Set this bit to freeze unit 3's counter.
          CNT_PAUSE_U3: u1,

          /// [8:15] 
          res0: u8,

          /// [16:16] The registers clock gate enable signal of PCNT module. 1: the registers can be read and written by application. 0: the registers can not be read or written by application
          CLK_EN: u1,

          /// [17:31] 
          res1: u15,

        }), @ptrFromInt(0x60012060));

        /// PCNT version control register
        pub const DATE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] This is the PCNT version control register.
          DATE: u32,

        }), @ptrFromInt(0x600120fc));

      };

      /// PCR Peripheral
      pub const PCR = struct {

        /// UART0 configuration register
        pub const UART0_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Set 1 to enable uart0 apb clock
          UART0_CLK_EN: u1,

          /// [1:1] Set 0 to reset uart0 module
          UART0_RST_EN: u1,

          /// [2:31] 
          res0: u30,

        }), @ptrFromInt(0x60096000));

        /// UART0_SCLK configuration register
        pub const UART0_SCLK_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] Thedenominator of the frequency divider factor of the uart0 function clock.
          UART0_SCLK_DIV_A: u6,

          /// [6:11] The numerator of the frequency divider factor of the uart0 function clock.
          UART0_SCLK_DIV_B: u6,

          /// [12:19] The integral part of the frequency divider factor of the uart0 function clock.
          UART0_SCLK_DIV_NUM: u8,

          /// [20:21] set this field to select clock-source. 0: do not select anyone clock, 1: 80MHz, 2: FOSC, 3(default): XTAL.
          UART0_SCLK_SEL: u2,

          /// [22:22] Set 1 to enable uart0 function clock
          UART0_SCLK_EN: u1,

          /// [23:31] 
          res0: u9,

        }), @ptrFromInt(0x60096004));

        /// UART0 power control register
        pub const UART0_PD_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] 
          res0: u1,

          /// [1:1] Set this bit to force power down UART0 memory.
          UART0_MEM_FORCE_PU: u1,

          /// [2:2] Set this bit to force power up UART0 memory.
          UART0_MEM_FORCE_PD: u1,

          /// [3:31] 
          res1: u29,

        }), @ptrFromInt(0x60096008));

        /// UART1 configuration register
        pub const UART1_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Set 1 to enable uart1 apb clock
          UART1_CLK_EN: u1,

          /// [1:1] Set 0 to reset uart1 module
          UART1_RST_EN: u1,

          /// [2:31] 
          res0: u30,

        }), @ptrFromInt(0x6009600c));

        /// UART1_SCLK configuration register
        pub const UART1_SCLK_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] Thedenominator of the frequency divider factor of the uart1 function clock.
          UART1_SCLK_DIV_A: u6,

          /// [6:11] The numerator of the frequency divider factor of the uart1 function clock.
          UART1_SCLK_DIV_B: u6,

          /// [12:19] The integral part of the frequency divider factor of the uart1 function clock.
          UART1_SCLK_DIV_NUM: u8,

          /// [20:21] set this field to select clock-source. 0: do not select anyone clock, 1: 80MHz, 2: FOSC, 3(default): XTAL.
          UART1_SCLK_SEL: u2,

          /// [22:22] Set 1 to enable uart0 function clock
          UART1_SCLK_EN: u1,

          /// [23:31] 
          res0: u9,

        }), @ptrFromInt(0x60096010));

        /// UART1 power control register
        pub const UART1_PD_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] 
          res0: u1,

          /// [1:1] Set this bit to force power down UART1 memory.
          UART1_MEM_FORCE_PU: u1,

          /// [2:2] Set this bit to force power up UART1 memory.
          UART1_MEM_FORCE_PD: u1,

          /// [3:31] 
          res1: u29,

        }), @ptrFromInt(0x60096014));

        /// MSPI configuration register
        pub const MSPI_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Set 1 to enable mspi clock, include mspi pll clock
          MSPI_CLK_EN: u1,

          /// [1:1] Set 0 to reset mspi module
          MSPI_RST_EN: u1,

          /// [2:2] Set 1 to enable mspi pll clock
          MSPI_PLL_CLK_EN: u1,

          /// [3:31] 
          res0: u29,

        }), @ptrFromInt(0x60096018));

        /// MSPI_CLK configuration register
        pub const MSPI_CLK_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] Set as one within (0,1,2) to generate div1(default)/div2/div4 of low-speed clock-source to drive clk_mspi_fast. Only avaiable whe the clck-source is a low-speed clock-source such as XTAL/FOSC.
          MSPI_FAST_LS_DIV_NUM: u8,

          /// [8:15] Set as one within (3,4,5) to generate div4(default)/div5/div6 of high-speed clock-source to drive clk_mspi_fast. Only avaiable whe the clck-source is a high-speed clock-source such as SPLL.
          MSPI_FAST_HS_DIV_NUM: u8,

          /// [16:31] 
          res0: u16,

        }), @ptrFromInt(0x6009601c));

        /// I2C configuration register
        pub const I2C0_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Set 1 to enable i2c apb clock
          I2C0_CLK_EN: u1,

          /// [1:1] Set 0 to reset i2c module
          I2C0_RST_EN: u1,

          /// [2:31] 
          res0: u30,

        }), @ptrFromInt(0x60096020));

        /// I2C_SCLK configuration register
        pub const I2C_SCLK_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] Thedenominator of the frequency divider factor of the i2c function clock.
          I2C_SCLK_DIV_A: u6,

          /// [6:11] The numerator of the frequency divider factor of the i2c function clock.
          I2C_SCLK_DIV_B: u6,

          /// [12:19] The integral part of the frequency divider factor of the i2c function clock.
          I2C_SCLK_DIV_NUM: u8,

          /// [20:20] set this field to select clock-source. 0(default): XTAL, 1: FOSC.
          I2C_SCLK_SEL: u1,

          /// [21:21] 
          res0: u1,

          /// [22:22] Set 1 to enable i2c function clock
          I2C_SCLK_EN: u1,

          /// [23:31] 
          res1: u9,

        }), @ptrFromInt(0x60096024));

        /// UHCI configuration register
        pub const UHCI_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Set 1 to enable uhci clock
          UHCI_CLK_EN: u1,

          /// [1:1] Set 0 to reset uhci module
          UHCI_RST_EN: u1,

          /// [2:31] 
          res0: u30,

        }), @ptrFromInt(0x60096028));

        /// RMT configuration register
        pub const RMT_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Set 1 to enable rmt apb clock
          RMT_CLK_EN: u1,

          /// [1:1] Set 0 to reset rmt module
          RMT_RST_EN: u1,

          /// [2:31] 
          res0: u30,

        }), @ptrFromInt(0x6009602c));

        /// RMT_SCLK configuration register
        pub const RMT_SCLK_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] Thedenominator of the frequency divider factor of the rmt function clock.
          SCLK_DIV_A: u6,

          /// [6:11] The numerator of the frequency divider factor of the rmt function clock.
          SCLK_DIV_B: u6,

          /// [12:19] The integral part of the frequency divider factor of the rmt function clock.
          SCLK_DIV_NUM: u8,

          /// [20:21] set this field to select clock-source. 0: do not select anyone clock, 1(default): 80MHz, 2: FOSC, 3: XTAL.
          SCLK_SEL: u2,

          /// [22:22] Set 1 to enable rmt function clock
          SCLK_EN: u1,

          /// [23:31] 
          res0: u9,

        }), @ptrFromInt(0x60096030));

        /// LEDC configuration register
        pub const LEDC_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Set 1 to enable ledc apb clock
          LEDC_CLK_EN: u1,

          /// [1:1] Set 0 to reset ledc module
          LEDC_RST_EN: u1,

          /// [2:31] 
          res0: u30,

        }), @ptrFromInt(0x60096034));

        /// LEDC_SCLK configuration register
        pub const LEDC_SCLK_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:19] 
          res0: u20,

          /// [20:21] set this field to select clock-source. 0(default): do not select anyone clock, 1: 80MHz, 2: FOSC, 3: XTAL.
          LEDC_SCLK_SEL: u2,

          /// [22:22] Set 1 to enable ledc function clock
          LEDC_SCLK_EN: u1,

          /// [23:31] 
          res1: u9,

        }), @ptrFromInt(0x60096038));

        /// TIMERGROUP0 configuration register
        pub const TIMERGROUP0_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Set 1 to enable timer_group0 apb clock
          TG0_CLK_EN: u1,

          /// [1:1] Set 0 to reset timer_group0 module
          TG0_RST_EN: u1,

          /// [2:31] 
          res0: u30,

        }), @ptrFromInt(0x6009603c));

        /// TIMERGROUP0_TIMER_CLK configuration register
        pub const TIMERGROUP0_TIMER_CLK_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:19] 
          res0: u20,

          /// [20:21] set this field to select clock-source. 0(default): XTAL, 1: 80MHz, 2: FOSC, 3: reserved.
          TG0_TIMER_CLK_SEL: u2,

          /// [22:22] Set 1 to enable timer_group0 timer clock
          TG0_TIMER_CLK_EN: u1,

          /// [23:31] 
          res1: u9,

        }), @ptrFromInt(0x60096040));

        /// TIMERGROUP0_WDT_CLK configuration register
        pub const TIMERGROUP0_WDT_CLK_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:19] 
          res0: u20,

          /// [20:21] set this field to select clock-source. 0(default): XTAL, 1: 80MHz, 2: FOSC, 3: reserved.
          TG0_WDT_CLK_SEL: u2,

          /// [22:22] Set 1 to enable timer_group0 wdt clock
          TG0_WDT_CLK_EN: u1,

          /// [23:31] 
          res1: u9,

        }), @ptrFromInt(0x60096044));

        /// TIMERGROUP1 configuration register
        pub const TIMERGROUP1_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Set 1 to enable timer_group1 apb clock
          TG1_CLK_EN: u1,

          /// [1:1] Set 0 to reset timer_group1 module
          TG1_RST_EN: u1,

          /// [2:31] 
          res0: u30,

        }), @ptrFromInt(0x60096048));

        /// TIMERGROUP1_TIMER_CLK configuration register
        pub const TIMERGROUP1_TIMER_CLK_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:19] 
          res0: u20,

          /// [20:21] set this field to select clock-source. 0(default): XTAL, 1: 80MHz, 2: FOSC, 3: reserved.
          TG1_TIMER_CLK_SEL: u2,

          /// [22:22] Set 1 to enable timer_group1 timer clock
          TG1_TIMER_CLK_EN: u1,

          /// [23:31] 
          res1: u9,

        }), @ptrFromInt(0x6009604c));

        /// TIMERGROUP1_WDT_CLK configuration register
        pub const TIMERGROUP1_WDT_CLK_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:19] 
          res0: u20,

          /// [20:21] set this field to select clock-source. 0(default): XTAL, 1: 80MHz, 2: FOSC, 3: reserved.
          TG1_WDT_CLK_SEL: u2,

          /// [22:22] Set 1 to enable timer_group0 wdt clock
          TG1_WDT_CLK_EN: u1,

          /// [23:31] 
          res1: u9,

        }), @ptrFromInt(0x60096050));

        /// SYSTIMER configuration register
        pub const SYSTIMER_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Set 1 to enable systimer apb clock
          SYSTIMER_CLK_EN: u1,

          /// [1:1] Set 0 to reset systimer module
          SYSTIMER_RST_EN: u1,

          /// [2:31] 
          res0: u30,

        }), @ptrFromInt(0x60096054));

        /// SYSTIMER_FUNC_CLK configuration register
        pub const SYSTIMER_FUNC_CLK_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:19] 
          res0: u20,

          /// [20:20] set this field to select clock-source. 0(default): XTAL, 1: FOSC.
          SYSTIMER_FUNC_CLK_SEL: u1,

          /// [21:21] 
          res1: u1,

          /// [22:22] Set 1 to enable systimer function clock
          SYSTIMER_FUNC_CLK_EN: u1,

          /// [23:31] 
          res2: u9,

        }), @ptrFromInt(0x60096058));

        /// TWAI0 configuration register
        pub const TWAI0_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Set 1 to enable twai0 apb clock
          TWAI0_CLK_EN: u1,

          /// [1:1] Set 0 to reset twai0 module
          TWAI0_RST_EN: u1,

          /// [2:31] 
          res0: u30,

        }), @ptrFromInt(0x6009605c));

        /// TWAI0_FUNC_CLK configuration register
        pub const TWAI0_FUNC_CLK_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:19] 
          res0: u20,

          /// [20:20] set this field to select clock-source. 0(default): XTAL, 1: FOSC.
          TWAI0_FUNC_CLK_SEL: u1,

          /// [21:21] 
          res1: u1,

          /// [22:22] Set 1 to enable twai0 function clock
          TWAI0_FUNC_CLK_EN: u1,

          /// [23:31] 
          res2: u9,

        }), @ptrFromInt(0x60096060));

        /// TWAI1 configuration register
        pub const TWAI1_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Set 1 to enable twai1 apb clock
          TWAI1_CLK_EN: u1,

          /// [1:1] Set 0 to reset twai1 module
          TWAI1_RST_EN: u1,

          /// [2:31] 
          res0: u30,

        }), @ptrFromInt(0x60096064));

        /// TWAI1_FUNC_CLK configuration register
        pub const TWAI1_FUNC_CLK_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:19] 
          res0: u20,

          /// [20:20] set this field to select clock-source. 0(default): XTAL, 1: FOSC.
          TWAI1_FUNC_CLK_SEL: u1,

          /// [21:21] 
          res1: u1,

          /// [22:22] Set 1 to enable twai1 function clock
          TWAI1_FUNC_CLK_EN: u1,

          /// [23:31] 
          res2: u9,

        }), @ptrFromInt(0x60096068));

        /// I2S configuration register
        pub const I2S_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Set 1 to enable i2s apb clock
          I2S_CLK_EN: u1,

          /// [1:1] Set 0 to reset i2s module
          I2S_RST_EN: u1,

          /// [2:31] 
          res0: u30,

        }), @ptrFromInt(0x6009606c));

        /// I2S_TX_CLKM configuration register
        pub const I2S_TX_CLKM_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:11] 
          res0: u12,

          /// [12:19] Integral I2S TX clock divider value. f_I2S_CLK = f_I2S_CLK_S/(N+b/a). There will be (a-b) * n-div and b * (n+1)-div.So the average combination will be:for b <= a/2, z * [x * n-div + (n+1)-div] + y * n-div. For b > a/2, z * [n-div + x * (n+1)-div] + y * (n+1)-div.
          I2S_TX_CLKM_DIV_NUM: u8,

          /// [20:21] Select I2S Tx module source clock. 0: XTAL clock. 1: APLL. 2: CLK160. 3: I2S_MCLK_in.
          I2S_TX_CLKM_SEL: u2,

          /// [22:22] Set 1 to enable i2s_tx function clock
          I2S_TX_CLKM_EN: u1,

          /// [23:31] 
          res1: u9,

        }), @ptrFromInt(0x60096070));

        /// I2S_TX_CLKM_DIV configuration register
        pub const I2S_TX_CLKM_DIV_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:8] For b <= a/2, the value of I2S_TX_CLKM_DIV_Z is b. For b > a/2, the value of I2S_TX_CLKM_DIV_Z is (a-b).
          I2S_TX_CLKM_DIV_Z: u9,

          /// [9:17] For b <= a/2, the value of I2S_TX_CLKM_DIV_Y is (a%b) . For b > a/2, the value of I2S_TX_CLKM_DIV_Y is (a%(a-b)).
          I2S_TX_CLKM_DIV_Y: u9,

          /// [18:26] For b <= a/2, the value of I2S_TX_CLKM_DIV_X is (a/b) - 1. For b > a/2, the value of I2S_TX_CLKM_DIV_X is (a/(a-b)) - 1.
          I2S_TX_CLKM_DIV_X: u9,

          /// [27:27] For b <= a/2, the value of I2S_TX_CLKM_DIV_YN1 is 0 . For b > a/2, the value of I2S_TX_CLKM_DIV_YN1 is 1.
          I2S_TX_CLKM_DIV_YN1: u1,

          /// [28:31] 
          res0: u4,

        }), @ptrFromInt(0x60096074));

        /// I2S_RX_CLKM configuration register
        pub const I2S_RX_CLKM_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:11] 
          res0: u12,

          /// [12:19] Integral I2S clock divider value
          I2S_RX_CLKM_DIV_NUM: u8,

          /// [20:21] Select I2S Rx module source clock. 0: no clock. 1: APLL. 2: CLK160. 3: I2S_MCLK_in.
          I2S_RX_CLKM_SEL: u2,

          /// [22:22] Set 1 to enable i2s_rx function clock
          I2S_RX_CLKM_EN: u1,

          /// [23:23] This field is used to select master-clock. 0(default): clk_i2s_rx, 1: clk_i2s_tx
          I2S_MCLK_SEL: u1,

          /// [24:31] 
          res1: u8,

        }), @ptrFromInt(0x60096078));

        /// I2S_RX_CLKM_DIV configuration register
        pub const I2S_RX_CLKM_DIV_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:8] For b <= a/2, the value of I2S_RX_CLKM_DIV_Z is b. For b > a/2, the value of I2S_RX_CLKM_DIV_Z is (a-b).
          I2S_RX_CLKM_DIV_Z: u9,

          /// [9:17] For b <= a/2, the value of I2S_RX_CLKM_DIV_Y is (a%b) . For b > a/2, the value of I2S_RX_CLKM_DIV_Y is (a%(a-b)).
          I2S_RX_CLKM_DIV_Y: u9,

          /// [18:26] For b <= a/2, the value of I2S_RX_CLKM_DIV_X is (a/b) - 1. For b > a/2, the value of I2S_RX_CLKM_DIV_X is (a/(a-b)) - 1.
          I2S_RX_CLKM_DIV_X: u9,

          /// [27:27] For b <= a/2, the value of I2S_RX_CLKM_DIV_YN1 is 0 . For b > a/2, the value of I2S_RX_CLKM_DIV_YN1 is 1.
          I2S_RX_CLKM_DIV_YN1: u1,

          /// [28:31] 
          res0: u4,

        }), @ptrFromInt(0x6009607c));

        /// SARADC configuration register
        pub const SARADC_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] no use
          SARADC_CLK_EN: u1,

          /// [1:1] Set 0 to reset function_register of saradc module
          SARADC_RST_EN: u1,

          /// [2:2] Set 1 to enable saradc apb clock
          SARADC_REG_CLK_EN: u1,

          /// [3:3] Set 0 to reset apb_register of saradc module
          SARADC_REG_RST_EN: u1,

          /// [4:31] 
          res0: u28,

        }), @ptrFromInt(0x60096080));

        /// SARADC_CLKM configuration register
        pub const SARADC_CLKM_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] Thedenominator of the frequency divider factor of the saradc function clock.
          SARADC_CLKM_DIV_A: u6,

          /// [6:11] The numerator of the frequency divider factor of the saradc function clock.
          SARADC_CLKM_DIV_B: u6,

          /// [12:19] The integral part of the frequency divider factor of the saradc function clock.
          SARADC_CLKM_DIV_NUM: u8,

          /// [20:21] set this field to select clock-source. 0(default): XTAL, 1: 240MHz, 2: FOSC, 3: reserved.
          SARADC_CLKM_SEL: u2,

          /// [22:22] Set 1 to enable saradc function clock
          SARADC_CLKM_EN: u1,

          /// [23:31] 
          res0: u9,

        }), @ptrFromInt(0x60096084));

        /// TSENS_CLK configuration register
        pub const TSENS_CLK_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:19] 
          res0: u20,

          /// [20:20] set this field to select clock-source. 0(default): FOSC, 1: XTAL.
          TSENS_CLK_SEL: u1,

          /// [21:21] 
          res1: u1,

          /// [22:22] Set 1 to enable tsens clock
          TSENS_CLK_EN: u1,

          /// [23:23] Set 0 to reset tsens module
          TSENS_RST_EN: u1,

          /// [24:31] 
          res2: u8,

        }), @ptrFromInt(0x60096088));

        /// USB_DEVICE configuration register
        pub const USB_DEVICE_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Set 1 to enable usb_device clock
          USB_DEVICE_CLK_EN: u1,

          /// [1:1] Set 0 to reset usb_device module
          USB_DEVICE_RST_EN: u1,

          /// [2:31] 
          res0: u30,

        }), @ptrFromInt(0x6009608c));

        /// INTMTX configuration register
        pub const INTMTX_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Set 1 to enable intmtx clock
          INTMTX_CLK_EN: u1,

          /// [1:1] Set 0 to reset intmtx module
          INTMTX_RST_EN: u1,

          /// [2:31] 
          res0: u30,

        }), @ptrFromInt(0x60096090));

        /// PCNT configuration register
        pub const PCNT_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Set 1 to enable pcnt clock
          PCNT_CLK_EN: u1,

          /// [1:1] Set 0 to reset pcnt module
          PCNT_RST_EN: u1,

          /// [2:31] 
          res0: u30,

        }), @ptrFromInt(0x60096094));

        /// ETM configuration register
        pub const ETM_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Set 1 to enable etm clock
          ETM_CLK_EN: u1,

          /// [1:1] Set 0 to reset etm module
          ETM_RST_EN: u1,

          /// [2:31] 
          res0: u30,

        }), @ptrFromInt(0x60096098));

        /// PWM configuration register
        pub const PWM_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Set 1 to enable pwm clock
          PWM_CLK_EN: u1,

          /// [1:1] Set 0 to reset pwm module
          PWM_RST_EN: u1,

          /// [2:31] 
          res0: u30,

        }), @ptrFromInt(0x6009609c));

        /// PWM_CLK configuration register
        pub const PWM_CLK_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:11] 
          res0: u12,

          /// [12:19] The integral part of the frequency divider factor of the pwm function clock.
          PWM_DIV_NUM: u8,

          /// [20:21] set this field to select clock-source. 0(default): do not select anyone clock, 1: 160MHz, 2: XTAL, 3: FOSC.
          PWM_CLKM_SEL: u2,

          /// [22:22] set this field as 1 to activate pwm clkm.
          PWM_CLKM_EN: u1,

          /// [23:31] 
          res1: u9,

        }), @ptrFromInt(0x600960a0));

        /// PARL_IO configuration register
        pub const PARL_IO_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Set 1 to enable parl apb clock
          PARL_CLK_EN: u1,

          /// [1:1] Set 0 to reset parl apb reg
          PARL_RST_EN: u1,

          /// [2:31] 
          res0: u30,

        }), @ptrFromInt(0x600960a4));

        /// PARL_CLK_RX configuration register
        pub const PARL_CLK_RX_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:15] The integral part of the frequency divider factor of the parl rx clock.
          PARL_CLK_RX_DIV_NUM: u16,

          /// [16:17] set this field to select clock-source. 0(default): XTAL, 1: 240MHz, 2: FOSC, 3: user clock from pad.
          PARL_CLK_RX_SEL: u2,

          /// [18:18] Set 1 to enable parl rx clock
          PARL_CLK_RX_EN: u1,

          /// [19:19] Set 0 to reset parl rx module
          PARL_RX_RST_EN: u1,

          /// [20:31] 
          res0: u12,

        }), @ptrFromInt(0x600960a8));

        /// PARL_CLK_TX configuration register
        pub const PARL_CLK_TX_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:15] The integral part of the frequency divider factor of the parl tx clock.
          PARL_CLK_TX_DIV_NUM: u16,

          /// [16:17] set this field to select clock-source. 0(default): XTAL, 1: 240MHz, 2: FOSC, 3: user clock from pad.
          PARL_CLK_TX_SEL: u2,

          /// [18:18] Set 1 to enable parl tx clock
          PARL_CLK_TX_EN: u1,

          /// [19:19] Set 0 to reset parl tx module
          PARL_TX_RST_EN: u1,

          /// [20:31] 
          res0: u12,

        }), @ptrFromInt(0x600960ac));

        /// SDIO_SLAVE configuration register
        pub const SDIO_SLAVE_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Set 1 to enable sdio_slave clock
          SDIO_SLAVE_CLK_EN: u1,

          /// [1:1] Set 0 to reset sdio_slave module
          SDIO_SLAVE_RST_EN: u1,

          /// [2:31] 
          res0: u30,

        }), @ptrFromInt(0x600960b0));

        /// PVT_MONITOR configuration register
        pub const PVT_MONITOR_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Set 1 to enable apb clock of pvt module
          PVT_MONITOR_CLK_EN: u1,

          /// [1:1] Set 0 to reset all pvt monitor module
          PVT_MONITOR_RST_EN: u1,

          /// [2:2] Set 1 to enable function clock of modem pvt module
          PVT_MONITOR_SITE1_CLK_EN: u1,

          /// [3:3] Set 1 to enable function clock of cpu pvt module
          PVT_MONITOR_SITE2_CLK_EN: u1,

          /// [4:4] Set 1 to enable function clock of hp_peri pvt module
          PVT_MONITOR_SITE3_CLK_EN: u1,

          /// [5:31] 
          res0: u27,

        }), @ptrFromInt(0x600960b4));

        /// PVT_MONITOR function clock configuration register
        pub const PVT_MONITOR_FUNC_CLK_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:3] The integral part of the frequency divider factor of the pvt_monitor function clock.
          PVT_MONITOR_FUNC_CLK_DIV_NUM: u4,

          /// [4:19] 
          res0: u16,

          /// [20:20] set this field to select clock-source. 0: XTAL, 1(default): 160MHz drived by SPLL divided by 3.
          PVT_MONITOR_FUNC_CLK_SEL: u1,

          /// [21:21] 
          res1: u1,

          /// [22:22] Set 1 to enable source clock of pvt sitex
          PVT_MONITOR_FUNC_CLK_EN: u1,

          /// [23:31] 
          res2: u9,

        }), @ptrFromInt(0x600960b8));

        /// GDMA configuration register
        pub const GDMA_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Set 1 to enable gdma clock
          GDMA_CLK_EN: u1,

          /// [1:1] Set 0 to reset gdma module
          GDMA_RST_EN: u1,

          /// [2:31] 
          res0: u30,

        }), @ptrFromInt(0x600960bc));

        /// SPI2 configuration register
        pub const SPI2_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Set 1 to enable spi2 apb clock
          SPI2_CLK_EN: u1,

          /// [1:1] Set 0 to reset spi2 module
          SPI2_RST_EN: u1,

          /// [2:31] 
          res0: u30,

        }), @ptrFromInt(0x600960c0));

        /// SPI2_CLKM configuration register
        pub const SPI2_CLKM_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:19] 
          res0: u20,

          /// [20:21] set this field to select clock-source. 0(default): XTAL, 1: 80MHz, 2: FOSC, 3: reserved.
          SPI2_CLKM_SEL: u2,

          /// [22:22] Set 1 to enable spi2 function clock
          SPI2_CLKM_EN: u1,

          /// [23:31] 
          res1: u9,

        }), @ptrFromInt(0x600960c4));

        /// AES configuration register
        pub const AES_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Set 1 to enable aes clock
          AES_CLK_EN: u1,

          /// [1:1] Set 0 to reset aes module
          AES_RST_EN: u1,

          /// [2:31] 
          res0: u30,

        }), @ptrFromInt(0x600960c8));

        /// SHA configuration register
        pub const SHA_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Set 1 to enable sha clock
          SHA_CLK_EN: u1,

          /// [1:1] Set 0 to reset sha module
          SHA_RST_EN: u1,

          /// [2:31] 
          res0: u30,

        }), @ptrFromInt(0x600960cc));

        /// RSA configuration register
        pub const RSA_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Set 1 to enable rsa clock
          RSA_CLK_EN: u1,

          /// [1:1] Set 0 to reset rsa module
          RSA_RST_EN: u1,

          /// [2:31] 
          res0: u30,

        }), @ptrFromInt(0x600960d0));

        /// RSA power control register
        pub const RSA_PD_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Set this bit to power down rsa internal memory.
          RSA_MEM_PD: u1,

          /// [1:1] Set this bit to force power up rsa internal memory
          RSA_MEM_FORCE_PU: u1,

          /// [2:2] Set this bit to force power down rsa internal memory.
          RSA_MEM_FORCE_PD: u1,

          /// [3:31] 
          res0: u29,

        }), @ptrFromInt(0x600960d4));

        /// ECC configuration register
        pub const ECC_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Set 1 to enable ecc clock
          ECC_CLK_EN: u1,

          /// [1:1] Set 0 to reset ecc module
          ECC_RST_EN: u1,

          /// [2:31] 
          res0: u30,

        }), @ptrFromInt(0x600960d8));

        /// ECC power control register
        pub const ECC_PD_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Set this bit to power down ecc internal memory.
          ECC_MEM_PD: u1,

          /// [1:1] Set this bit to force power up ecc internal memory
          ECC_MEM_FORCE_PU: u1,

          /// [2:2] Set this bit to force power down ecc internal memory.
          ECC_MEM_FORCE_PD: u1,

          /// [3:31] 
          res0: u29,

        }), @ptrFromInt(0x600960dc));

        /// DS configuration register
        pub const DS_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Set 1 to enable ds clock
          DS_CLK_EN: u1,

          /// [1:1] Set 0 to reset ds module
          DS_RST_EN: u1,

          /// [2:31] 
          res0: u30,

        }), @ptrFromInt(0x600960e0));

        /// HMAC configuration register
        pub const HMAC_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Set 1 to enable hmac clock
          HMAC_CLK_EN: u1,

          /// [1:1] Set 0 to reset hmac module
          HMAC_RST_EN: u1,

          /// [2:31] 
          res0: u30,

        }), @ptrFromInt(0x600960e4));

        /// IOMUX configuration register
        pub const IOMUX_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Set 1 to enable iomux apb clock
          IOMUX_CLK_EN: u1,

          /// [1:1] Set 0 to reset iomux module
          IOMUX_RST_EN: u1,

          /// [2:31] 
          res0: u30,

        }), @ptrFromInt(0x600960e8));

        /// IOMUX_CLK configuration register
        pub const IOMUX_CLK_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:19] 
          res0: u20,

          /// [20:21] set this field to select clock-source. 0: do not select anyone clock, 1: 80MHz, 2: FOSC, 3(default): XTAL.
          IOMUX_FUNC_CLK_SEL: u2,

          /// [22:22] Set 1 to enable iomux function clock
          IOMUX_FUNC_CLK_EN: u1,

          /// [23:31] 
          res1: u9,

        }), @ptrFromInt(0x600960ec));

        /// MEM_MONITOR configuration register
        pub const MEM_MONITOR_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Set 1 to enable mem_monitor clock
          MEM_MONITOR_CLK_EN: u1,

          /// [1:1] Set 0 to reset mem_monitor module
          MEM_MONITOR_RST_EN: u1,

          /// [2:31] 
          res0: u30,

        }), @ptrFromInt(0x600960f0));

        /// REGDMA configuration register
        pub const REGDMA_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Set 1 to enable regdma clock
          REGDMA_CLK_EN: u1,

          /// [1:1] Set 0 to reset regdma module
          REGDMA_RST_EN: u1,

          /// [2:31] 
          res0: u30,

        }), @ptrFromInt(0x600960f4));

        /// retention configuration register
        pub const RETENTION_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Set 1 to enable retention clock
          RETENTION_CLK_EN: u1,

          /// [1:1] Set 0 to reset retention module
          RETENTION_RST_EN: u1,

          /// [2:31] 
          res0: u30,

        }), @ptrFromInt(0x600960f8));

        /// TRACE configuration register
        pub const TRACE_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Set 1 to enable trace clock
          TRACE_CLK_EN: u1,

          /// [1:1] Set 0 to reset trace module
          TRACE_RST_EN: u1,

          /// [2:31] 
          res0: u30,

        }), @ptrFromInt(0x600960fc));

        /// ASSIST configuration register
        pub const ASSIST_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Set 1 to enable assist clock
          ASSIST_CLK_EN: u1,

          /// [1:1] Set 0 to reset assist module
          ASSIST_RST_EN: u1,

          /// [2:31] 
          res0: u30,

        }), @ptrFromInt(0x60096100));

        /// CACHE configuration register
        pub const CACHE_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Set 1 to enable cache clock
          CACHE_CLK_EN: u1,

          /// [1:1] Set 0 to reset cache module
          CACHE_RST_EN: u1,

          /// [2:31] 
          res0: u30,

        }), @ptrFromInt(0x60096104));

        /// MODEM_APB configuration register
        pub const MODEM_APB_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] This field indicates if modem_apb clock is enable. 0: disable, 1: enable(default).
          MODEM_APB_CLK_EN: u1,

          /// [1:1] Set this file as 1 to reset modem-subsystem.
          MODEM_RST_EN: u1,

          /// [2:31] 
          res0: u30,

        }), @ptrFromInt(0x60096108));

        /// TIMEOUT configuration register
        pub const TIMEOUT_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] 
          res0: u1,

          /// [1:1] Set 0 to reset cpu_peri timeout module
          CPU_TIMEOUT_RST_EN: u1,

          /// [2:2] Set 0 to reset hp_peri timeout module and hp_modem timeout module
          HP_TIMEOUT_RST_EN: u1,

          /// [3:31] 
          res1: u29,

        }), @ptrFromInt(0x6009610c));

        /// SYSCLK configuration register
        pub const SYSCLK_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] clk_hproot is div1 of low-speed clock-source if clck-source is a low-speed clock-source such as XTAL/FOSC.
          LS_DIV_NUM: u8,

          /// [8:15] clk_hproot is div3 of SPLL if the clock-source is high-speed clock SPLL.
          HS_DIV_NUM: u8,

          /// [16:17] This field is used to select clock source. 0: XTAL, 1: SPLL, 2: FOSC, 3: reserved.
          SOC_CLK_SEL: u2,

          /// [18:23] 
          res0: u6,

          /// [24:30] This field indicates the frequency(MHz) of XTAL.
          CLK_XTAL_FREQ: u7,

          /// [31:31] 
          res1: u1,

        }), @ptrFromInt(0x60096110));

        /// CPU_WAITI configuration register
        pub const CPU_WAITI_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:1] Reserved. This filed has been replaced by PCR_CPU_HS_DIV_NUM and PCR_CPU_LS_DIV_NUM
          CPUPERIOD_SEL: u2,

          /// [2:2] Reserved. This filed has been replaced by PCR_CPU_HS_DIV_NUM and PCR_CPU_LS_DIV_NUM
          PLL_FREQ_SEL: u1,

          /// [3:3] Set 1 to force cpu_waiti_clk enable.
          CPU_WAIT_MODE_FORCE_ON: u1,

          /// [4:7] This field used to set delay cycle when cpu enter waiti mode, after delay waiti_clk will close
          CPU_WAITI_DELAY_NUM: u4,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x60096114));

        /// CPU_FREQ configuration register
        pub const CPU_FREQ_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] Set as one within (0,1,3) to generate clk_cpu drived by clk_hproot. The clk_cpu is div1(default)/div2/div4 of clk_hproot. This field is only avaliable for low-speed clock-source such as XTAL/FOSC, and should be used together with PCR_AHB_LS_DIV_NUM.
          CPU_LS_DIV_NUM: u8,

          /// [8:15] Set as one within (0,1,3) to generate clk_cpu drived by clk_hproot. The clk_cpu is div1(default)/div2/div4 of clk_hproot. This field is only avaliable for high-speed clock-source such as SPLL, and should be used together with PCR_AHB_HS_DIV_NUM.
          CPU_HS_DIV_NUM: u8,

          /// [16:16] Given that PCR_CPU_HS_DIV_NUM is 0, set this field as 1 to force clk_cpu at 120MHz. Only avaliable when PCR_CPU_HS_DIV_NUM is 0 and clk_cpu is driven by SPLL.
          CPU_HS_120M_FORCE: u1,

          /// [17:31] 
          res0: u15,

        }), @ptrFromInt(0x60096118));

        /// AHB_FREQ configuration register
        pub const AHB_FREQ_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] Set as one within (0,1,3,7) to generate clk_ahb drived by clk_hproot. The clk_ahb is div1(default)/div2/div4/div8 of clk_hproot. This field is only avaliable for low-speed clock-source such as XTAL/FOSC, and should be used together with PCR_CPU_LS_DIV_NUM.
          AHB_LS_DIV_NUM: u8,

          /// [8:15] Set as one within (3,7,15) to generate clk_ahb drived by clk_hproot. The clk_ahb is div4(default)/div8/div16 of clk_hproot. This field is only avaliable for high-speed clock-source such as SPLL, and should be used together with PCR_CPU_HS_DIV_NUM.
          AHB_HS_DIV_NUM: u8,

          /// [16:31] 
          res0: u16,

        }), @ptrFromInt(0x6009611c));

        /// APB_FREQ configuration register
        pub const APB_FREQ_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] If this field's value is grater than PCR_APB_DIV_NUM, the clk_apb will be automatically down to clk_apb_decrease only when no access is on apb-bus, and will recover to the previous frequency when a new access appears on apb-bus. Set as one within (0,1,3) to set clk_apb_decrease as div1/div2/div4(default) of clk_ahb. Note that enable this function will reduce performance. Users can set this field as zero to disable the auto-decrease-apb-freq function. By default, this function is disable.
          APB_DECREASE_DIV_NUM: u8,

          /// [8:15] Set as one within (0,1,3) to generate clk_apb drived by clk_ahb. The clk_apb is div1(default)/div2/div4 of clk_ahb.
          APB_DIV_NUM: u8,

          /// [16:31] 
          res0: u16,

        }), @ptrFromInt(0x60096120));

        /// SYSCLK frequency query 0 register
        pub const SYSCLK_FREQ_QUERY_0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] This field indicates the frequency(MHz) of FOSC.
          FOSC_FREQ: u8,

          /// [8:17] This field indicates the frequency(MHz) of SPLL.
          PLL_FREQ: u10,

          /// [18:31] 
          res0: u14,

        }), @ptrFromInt(0x60096124));

        /// SPLL DIV clock-gating configuration register
        pub const PLL_DIV_CLK_EN = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] This field is used to open 240 MHz clock (div2 of SPLL) drived from SPLL. 0: close, 1: open(default). Only avaliable when high-speed clock-source SPLL is active.
          PLL_240M_CLK_EN: u1,

          /// [1:1] This field is used to open 160 MHz clock (div3 of SPLL) drived from SPLL. 0: close, 1: open(default). Only avaliable when high-speed clock-source SPLL is active.
          PLL_160M_CLK_EN: u1,

          /// [2:2] This field is used to open 120 MHz clock (div4 of SPLL) drived from SPLL. 0: close, 1: open(default). Only avaliable when high-speed clock-source SPLL is active.
          PLL_120M_CLK_EN: u1,

          /// [3:3] This field is used to open 80 MHz clock (div6of SPLL) drived from SPLL. 0: close, 1: open(default). Only avaliable when high-speed clock-source SPLL is active.
          PLL_80M_CLK_EN: u1,

          /// [4:4] This field is used to open 48 MHz clock (div10 of SPLL) drived from SPLL. 0: close, 1: open(default). Only avaliable when high-speed clock-source SPLL is active.
          PLL_48M_CLK_EN: u1,

          /// [5:5] This field is used to open 40 MHz clock (div12 of SPLL) drived from SPLL. 0: close, 1: open(default). Only avaliable when high-speed clock-source SPLL is active.
          PLL_40M_CLK_EN: u1,

          /// [6:6] This field is used to open 20 MHz clock (div24 of SPLL) drived from SPLL. 0: close, 1: open(default). Only avaliable when high-speed clock-source SPLL is active.
          PLL_20M_CLK_EN: u1,

          /// [7:31] 
          res0: u25,

        }), @ptrFromInt(0x60096128));

        /// CLK_OUT_EN configuration register
        pub const CTRL_CLK_OUT_EN = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Set 1 to enable 20m clock
          CLK20_OEN: u1,

          /// [1:1] Set 1 to enable 22m clock
          CLK22_OEN: u1,

          /// [2:2] Set 1 to enable 44m clock
          CLK44_OEN: u1,

          /// [3:3] Set 1 to enable bb clock
          CLK_BB_OEN: u1,

          /// [4:4] Set 1 to enable 80m clock
          CLK80_OEN: u1,

          /// [5:5] Set 1 to enable 160m clock
          CLK160_OEN: u1,

          /// [6:6] Set 1 to enable 320m clock
          CLK_320M_OEN: u1,

          /// [7:7] Reserved
          CLK_ADC_INF_OEN: u1,

          /// [8:8] Reserved
          CLK_DAC_CPU_OEN: u1,

          /// [9:9] Set 1 to enable 40x_bb clock
          CLK40X_BB_OEN: u1,

          /// [10:10] Set 1 to enable xtal clock
          CLK_XTAL_OEN: u1,

          /// [11:31] 
          res0: u21,

        }), @ptrFromInt(0x6009612c));

        /// TICK configuration register
        pub const CTRL_TICK_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] ******* Description ***********
          XTAL_TICK_NUM: u8,

          /// [8:15] ******* Description ***********
          FOSC_TICK_NUM: u8,

          /// [16:16] ******* Description ***********
          TICK_ENABLE: u1,

          /// [17:17] ******* Description ***********
          RST_TICK_CNT: u1,

          /// [18:31] 
          res0: u14,

        }), @ptrFromInt(0x60096130));

        /// 32KHz clock configuration register
        pub const CTRL_32K_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:1] This field indicates which one 32KHz clock will be used by MODEM_SYSTEM and timergroup. 0: OSC32K(default), 1: XTAL32K, 2/3: 32KHz from pad GPIO0.
          CLK_32K_SEL: u2,

          /// [2:31] 
          res0: u30,

        }), @ptrFromInt(0x60096134));

        /// HP SRAM/ROM configuration register
        pub const SRAM_POWER_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:3] Set this bit to force power up SRAM
          SRAM_FORCE_PU: u4,

          /// [4:7] Set this bit to force power down SRAM.
          SRAM_FORCE_PD: u4,

          /// [8:11] 1: Force to open the clock and bypass the gate-clock when accessing the SRAM. 0: A gate-clock will be used when accessing the SRAM.
          SRAM_CLKGATE_FORCE_ON: u4,

          /// [12:14] Set this bit to force power up ROM
          ROM_FORCE_PU: u3,

          /// [15:17] Set this bit to force power down ROM.
          ROM_FORCE_PD: u3,

          /// [18:20] 1: Force to open the clock and bypass the gate-clock when accessing the ROM. 0: A gate-clock will be used when accessing the ROM.
          ROM_CLKGATE_FORCE_ON: u3,

          /// [21:31] 
          res0: u11,

        }), @ptrFromInt(0x60096138));

        /// reset event bypass backdoor configuration register
        pub const RESET_EVENT_BYPASS = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] This field is used to control reset event relationship for tee_reg/apm_reg/hp_system_reg. 1: tee_reg/apm_reg/hp_system_reg will only be reset by power-reset. some reset event will be bypass. 0: tee_reg/apm_reg/hp_system_reg will not only be reset by power-reset, but also some reset event.
          APM: u1,

          /// [1:1] This field is used to control reset event relationship for system-bus. 1: system bus (including arbiter/router) will only be reset by power-reset. some reset event will be bypass. 0: system bus (including arbiter/router) will not only be reset by power-reset, but also some reset event.
          RESET_EVENT_BYPASS: u1,

          /// [2:31] 
          res0: u30,

        }), @ptrFromInt(0x60096ff0));

        /// fpga debug register
        pub const FPGA_DEBUG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Only used in fpga debug.
          FPGA_DEBUG: u32,

        }), @ptrFromInt(0x60096ff4));

        /// PCR clock gating configure register
        pub const CLOCK_GATE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Set this bit as 1 to force on clock gating.
          CLK_EN: u1,

          /// [1:31] 
          res0: u31,

        }), @ptrFromInt(0x60096ff8));

        /// Date register.
        pub const DATE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:27] PCR version information.
          DATE: u28,

          /// [28:31] 
          res0: u4,

        }), @ptrFromInt(0x60096ffc));

      };

      /// PMU Peripheral
      pub const PMU = struct {

        /// need_des
        pub const HP_ACTIVE_DIG_POWER = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:20] 
          res0: u21,

          /// [21:21] need_des
          HP_ACTIVE_VDD_SPI_PD_EN: u1,

          /// [22:22] need_des
          HP_ACTIVE_HP_MEM_DSLP: u1,

          /// [23:26] need_des
          HP_ACTIVE_PD_HP_MEM_PD_EN: u4,

          /// [27:27] need_des
          HP_ACTIVE_PD_HP_WIFI_PD_EN: u1,

          /// [28:28] 
          res1: u1,

          /// [29:29] need_des
          HP_ACTIVE_PD_HP_CPU_PD_EN: u1,

          /// [30:30] need_des
          HP_ACTIVE_PD_HP_AON_PD_EN: u1,

          /// [31:31] need_des
          HP_ACTIVE_PD_TOP_PD_EN: u1,

        }), @ptrFromInt(0x600b0000));

        /// need_des
        pub const HP_ACTIVE_ICG_HP_FUNC = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] need_des
          HP_ACTIVE_DIG_ICG_FUNC_EN: u32,

        }), @ptrFromInt(0x600b0004));

        /// need_des
        pub const HP_ACTIVE_ICG_HP_APB = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] need_des
          HP_ACTIVE_DIG_ICG_APB_EN: u32,

        }), @ptrFromInt(0x600b0008));

        /// need_des
        pub const HP_ACTIVE_ICG_MODEM = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:29] 
          res0: u30,

          /// [30:31] need_des
          HP_ACTIVE_DIG_ICG_MODEM_CODE: u2,

        }), @ptrFromInt(0x600b000c));

        /// need_des
        pub const HP_ACTIVE_HP_SYS_CNTL = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:23] 
          res0: u24,

          /// [24:24] need_des
          HP_ACTIVE_UART_WAKEUP_EN: u1,

          /// [25:25] need_des
          HP_ACTIVE_LP_PAD_HOLD_ALL: u1,

          /// [26:26] need_des
          HP_ACTIVE_HP_PAD_HOLD_ALL: u1,

          /// [27:27] need_des
          HP_ACTIVE_DIG_PAD_SLP_SEL: u1,

          /// [28:28] need_des
          HP_ACTIVE_DIG_PAUSE_WDT: u1,

          /// [29:29] need_des
          HP_ACTIVE_DIG_CPU_STALL: u1,

          /// [30:31] 
          res1: u2,

        }), @ptrFromInt(0x600b0010));

        /// need_des
        pub const HP_ACTIVE_HP_CK_POWER = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:25] 
          res0: u26,

          /// [26:26] need_des
          HP_ACTIVE_I2C_ISO_EN: u1,

          /// [27:27] need_des
          HP_ACTIVE_I2C_RETENTION: u1,

          /// [28:28] need_des
          HP_ACTIVE_XPD_BB_I2C: u1,

          /// [29:29] need_des
          HP_ACTIVE_XPD_BBPLL_I2C: u1,

          /// [30:30] need_des
          HP_ACTIVE_XPD_BBPLL: u1,

          /// [31:31] 
          res1: u1,

        }), @ptrFromInt(0x600b0014));

        /// need_des
        pub const HP_ACTIVE_BIAS = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:24] 
          res0: u25,

          /// [25:25] need_des
          HP_ACTIVE_XPD_BIAS: u1,

          /// [26:29] need_des
          HP_ACTIVE_DBG_ATTEN: u4,

          /// [30:30] need_des
          HP_ACTIVE_PD_CUR: u1,

          /// [31:31] need_des
          SLEEP: u1,

        }), @ptrFromInt(0x600b0018));

        /// need_des
        pub const HP_ACTIVE_BACKUP = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:3] 
          res0: u4,

          /// [4:5] need_des
          HP_SLEEP2ACTIVE_BACKUP_MODEM_CLK_CODE: u2,

          /// [6:7] need_des
          HP_MODEM2ACTIVE_BACKUP_MODEM_CLK_CODE: u2,

          /// [8:9] 
          res1: u2,

          /// [10:10] need_des
          HP_ACTIVE_RETENTION_MODE: u1,

          /// [11:11] need_des
          HP_SLEEP2ACTIVE_RETENTION_EN: u1,

          /// [12:12] need_des
          HP_MODEM2ACTIVE_RETENTION_EN: u1,

          /// [13:13] 
          res2: u1,

          /// [14:15] need_des
          HP_SLEEP2ACTIVE_BACKUP_CLK_SEL: u2,

          /// [16:17] need_des
          HP_MODEM2ACTIVE_BACKUP_CLK_SEL: u2,

          /// [18:19] 
          res3: u2,

          /// [20:22] need_des
          HP_SLEEP2ACTIVE_BACKUP_MODE: u3,

          /// [23:25] need_des
          HP_MODEM2ACTIVE_BACKUP_MODE: u3,

          /// [26:28] 
          res4: u3,

          /// [29:29] need_des
          HP_SLEEP2ACTIVE_BACKUP_EN: u1,

          /// [30:30] need_des
          HP_MODEM2ACTIVE_BACKUP_EN: u1,

          /// [31:31] 
          res5: u1,

        }), @ptrFromInt(0x600b001c));

        /// need_des
        pub const HP_ACTIVE_BACKUP_CLK = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] need_des
          HP_ACTIVE_BACKUP_ICG_FUNC_EN: u32,

        }), @ptrFromInt(0x600b0020));

        /// need_des
        pub const HP_ACTIVE_SYSCLK = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:25] 
          res0: u26,

          /// [26:26] need_des
          HP_ACTIVE_DIG_SYS_CLK_NO_DIV: u1,

          /// [27:27] need_des
          HP_ACTIVE_ICG_SYS_CLOCK_EN: u1,

          /// [28:28] need_des
          HP_ACTIVE_SYS_CLK_SLP_SEL: u1,

          /// [29:29] need_des
          HP_ACTIVE_ICG_SLP_SEL: u1,

          /// [30:31] need_des
          HP_ACTIVE_DIG_SYS_CLK_SEL: u2,

        }), @ptrFromInt(0x600b0024));

        /// need_des
        pub const HP_ACTIVE_HP_REGULATOR0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:3] 
          res0: u4,

          /// [4:8] need_des
          LP_DBIAS_VOL: u5,

          /// [9:13] need_des
          HP_DBIAS_VOL: u5,

          /// [14:14] need_des
          DIG_REGULATOR0_DBIAS_SEL: u1,

          /// [15:15] need_des
          DIG_DBIAS_INIT: u1,

          /// [16:16] need_des
          HP_ACTIVE_HP_REGULATOR_SLP_MEM_XPD: u1,

          /// [17:17] need_des
          HP_ACTIVE_HP_REGULATOR_SLP_LOGIC_XPD: u1,

          /// [18:18] need_des
          HP_ACTIVE_HP_REGULATOR_XPD: u1,

          /// [19:22] need_des
          HP_ACTIVE_HP_REGULATOR_SLP_MEM_DBIAS: u4,

          /// [23:26] need_des
          HP_ACTIVE_HP_REGULATOR_SLP_LOGIC_DBIAS: u4,

          /// [27:31] need_des
          HP_ACTIVE_HP_REGULATOR_DBIAS: u5,

        }), @ptrFromInt(0x600b0028));

        /// need_des
        pub const HP_ACTIVE_HP_REGULATOR1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] 
          res0: u8,

          /// [8:31] need_des
          HP_ACTIVE_HP_REGULATOR_DRV_B: u24,

        }), @ptrFromInt(0x600b002c));

        /// need_des
        pub const HP_ACTIVE_XTAL = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:30] 
          res0: u31,

          /// [31:31] need_des
          HP_ACTIVE_XPD_XTAL: u1,

        }), @ptrFromInt(0x600b0030));

        /// need_des
        pub const HP_MODEM_DIG_POWER = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:20] 
          res0: u21,

          /// [21:21] need_des
          HP_MODEM_VDD_SPI_PD_EN: u1,

          /// [22:22] need_des
          HP_MODEM_HP_MEM_DSLP: u1,

          /// [23:26] need_des
          HP_MODEM_PD_HP_MEM_PD_EN: u4,

          /// [27:27] need_des
          HP_MODEM_PD_HP_WIFI_PD_EN: u1,

          /// [28:28] 
          res1: u1,

          /// [29:29] need_des
          HP_MODEM_PD_HP_CPU_PD_EN: u1,

          /// [30:30] need_des
          HP_MODEM_PD_HP_AON_PD_EN: u1,

          /// [31:31] need_des
          HP_MODEM_PD_TOP_PD_EN: u1,

        }), @ptrFromInt(0x600b0034));

        /// need_des
        pub const HP_MODEM_ICG_HP_FUNC = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] need_des
          HP_MODEM_DIG_ICG_FUNC_EN: u32,

        }), @ptrFromInt(0x600b0038));

        /// need_des
        pub const HP_MODEM_ICG_HP_APB = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] need_des
          HP_MODEM_DIG_ICG_APB_EN: u32,

        }), @ptrFromInt(0x600b003c));

        /// need_des
        pub const HP_MODEM_ICG_MODEM = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:29] 
          res0: u30,

          /// [30:31] need_des
          HP_MODEM_DIG_ICG_MODEM_CODE: u2,

        }), @ptrFromInt(0x600b0040));

        /// need_des
        pub const HP_MODEM_HP_SYS_CNTL = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:23] 
          res0: u24,

          /// [24:24] need_des
          HP_MODEM_UART_WAKEUP_EN: u1,

          /// [25:25] need_des
          HP_MODEM_LP_PAD_HOLD_ALL: u1,

          /// [26:26] need_des
          HP_MODEM_HP_PAD_HOLD_ALL: u1,

          /// [27:27] need_des
          HP_MODEM_DIG_PAD_SLP_SEL: u1,

          /// [28:28] need_des
          HP_MODEM_DIG_PAUSE_WDT: u1,

          /// [29:29] need_des
          HP_MODEM_DIG_CPU_STALL: u1,

          /// [30:31] 
          res1: u2,

        }), @ptrFromInt(0x600b0044));

        /// need_des
        pub const HP_MODEM_HP_CK_POWER = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:25] 
          res0: u26,

          /// [26:26] need_des
          HP_MODEM_I2C_ISO_EN: u1,

          /// [27:27] need_des
          HP_MODEM_I2C_RETENTION: u1,

          /// [28:28] need_des
          HP_MODEM_XPD_BB_I2C: u1,

          /// [29:29] need_des
          HP_MODEM_XPD_BBPLL_I2C: u1,

          /// [30:30] need_des
          HP_MODEM_XPD_BBPLL: u1,

          /// [31:31] 
          res1: u1,

        }), @ptrFromInt(0x600b0048));

        /// need_des
        pub const HP_MODEM_BIAS = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:24] 
          res0: u25,

          /// [25:25] need_des
          HP_MODEM_XPD_BIAS: u1,

          /// [26:29] need_des
          HP_MODEM_DBG_ATTEN: u4,

          /// [30:30] need_des
          HP_MODEM_PD_CUR: u1,

          /// [31:31] need_des
          SLEEP: u1,

        }), @ptrFromInt(0x600b004c));

        /// need_des
        pub const HP_MODEM_BACKUP = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:3] 
          res0: u4,

          /// [4:5] need_des
          HP_SLEEP2MODEM_BACKUP_MODEM_CLK_CODE: u2,

          /// [6:9] 
          res1: u4,

          /// [10:10] need_des
          HP_MODEM_RETENTION_MODE: u1,

          /// [11:11] need_des
          HP_SLEEP2MODEM_RETENTION_EN: u1,

          /// [12:13] 
          res2: u2,

          /// [14:15] need_des
          HP_SLEEP2MODEM_BACKUP_CLK_SEL: u2,

          /// [16:19] 
          res3: u4,

          /// [20:22] need_des
          HP_SLEEP2MODEM_BACKUP_MODE: u3,

          /// [23:28] 
          res4: u6,

          /// [29:29] need_des
          HP_SLEEP2MODEM_BACKUP_EN: u1,

          /// [30:31] 
          res5: u2,

        }), @ptrFromInt(0x600b0050));

        /// need_des
        pub const HP_MODEM_BACKUP_CLK = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] need_des
          HP_MODEM_BACKUP_ICG_FUNC_EN: u32,

        }), @ptrFromInt(0x600b0054));

        /// need_des
        pub const HP_MODEM_SYSCLK = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:25] 
          res0: u26,

          /// [26:26] need_des
          HP_MODEM_DIG_SYS_CLK_NO_DIV: u1,

          /// [27:27] need_des
          HP_MODEM_ICG_SYS_CLOCK_EN: u1,

          /// [28:28] need_des
          HP_MODEM_SYS_CLK_SLP_SEL: u1,

          /// [29:29] need_des
          HP_MODEM_ICG_SLP_SEL: u1,

          /// [30:31] need_des
          HP_MODEM_DIG_SYS_CLK_SEL: u2,

        }), @ptrFromInt(0x600b0058));

        /// need_des
        pub const HP_MODEM_HP_REGULATOR0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:15] 
          res0: u16,

          /// [16:16] need_des
          HP_MODEM_HP_REGULATOR_SLP_MEM_XPD: u1,

          /// [17:17] need_des
          HP_MODEM_HP_REGULATOR_SLP_LOGIC_XPD: u1,

          /// [18:18] need_des
          HP_MODEM_HP_REGULATOR_XPD: u1,

          /// [19:22] need_des
          HP_MODEM_HP_REGULATOR_SLP_MEM_DBIAS: u4,

          /// [23:26] need_des
          HP_MODEM_HP_REGULATOR_SLP_LOGIC_DBIAS: u4,

          /// [27:31] need_des
          HP_MODEM_HP_REGULATOR_DBIAS: u5,

        }), @ptrFromInt(0x600b005c));

        /// need_des
        pub const HP_MODEM_HP_REGULATOR1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] 
          res0: u8,

          /// [8:31] need_des
          HP_MODEM_HP_REGULATOR_DRV_B: u24,

        }), @ptrFromInt(0x600b0060));

        /// need_des
        pub const HP_MODEM_XTAL = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:30] 
          res0: u31,

          /// [31:31] need_des
          HP_MODEM_XPD_XTAL: u1,

        }), @ptrFromInt(0x600b0064));

        /// need_des
        pub const HP_SLEEP_DIG_POWER = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:20] 
          res0: u21,

          /// [21:21] need_des
          HP_SLEEP_VDD_SPI_PD_EN: u1,

          /// [22:22] need_des
          HP_SLEEP_HP_MEM_DSLP: u1,

          /// [23:26] need_des
          HP_SLEEP_PD_HP_MEM_PD_EN: u4,

          /// [27:27] need_des
          HP_SLEEP_PD_HP_WIFI_PD_EN: u1,

          /// [28:28] 
          res1: u1,

          /// [29:29] need_des
          HP_SLEEP_PD_HP_CPU_PD_EN: u1,

          /// [30:30] need_des
          HP_SLEEP_PD_HP_AON_PD_EN: u1,

          /// [31:31] need_des
          HP_SLEEP_PD_TOP_PD_EN: u1,

        }), @ptrFromInt(0x600b0068));

        /// need_des
        pub const HP_SLEEP_ICG_HP_FUNC = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] need_des
          HP_SLEEP_DIG_ICG_FUNC_EN: u32,

        }), @ptrFromInt(0x600b006c));

        /// need_des
        pub const HP_SLEEP_ICG_HP_APB = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] need_des
          HP_SLEEP_DIG_ICG_APB_EN: u32,

        }), @ptrFromInt(0x600b0070));

        /// need_des
        pub const HP_SLEEP_ICG_MODEM = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:29] 
          res0: u30,

          /// [30:31] need_des
          HP_SLEEP_DIG_ICG_MODEM_CODE: u2,

        }), @ptrFromInt(0x600b0074));

        /// need_des
        pub const HP_SLEEP_HP_SYS_CNTL = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:23] 
          res0: u24,

          /// [24:24] need_des
          HP_SLEEP_UART_WAKEUP_EN: u1,

          /// [25:25] need_des
          HP_SLEEP_LP_PAD_HOLD_ALL: u1,

          /// [26:26] need_des
          HP_SLEEP_HP_PAD_HOLD_ALL: u1,

          /// [27:27] need_des
          HP_SLEEP_DIG_PAD_SLP_SEL: u1,

          /// [28:28] need_des
          HP_SLEEP_DIG_PAUSE_WDT: u1,

          /// [29:29] need_des
          HP_SLEEP_DIG_CPU_STALL: u1,

          /// [30:31] 
          res1: u2,

        }), @ptrFromInt(0x600b0078));

        /// need_des
        pub const HP_SLEEP_HP_CK_POWER = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:25] 
          res0: u26,

          /// [26:26] need_des
          HP_SLEEP_I2C_ISO_EN: u1,

          /// [27:27] need_des
          HP_SLEEP_I2C_RETENTION: u1,

          /// [28:28] need_des
          HP_SLEEP_XPD_BB_I2C: u1,

          /// [29:29] need_des
          HP_SLEEP_XPD_BBPLL_I2C: u1,

          /// [30:30] need_des
          HP_SLEEP_XPD_BBPLL: u1,

          /// [31:31] 
          res1: u1,

        }), @ptrFromInt(0x600b007c));

        /// need_des
        pub const HP_SLEEP_BIAS = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:24] 
          res0: u25,

          /// [25:25] need_des
          HP_SLEEP_XPD_BIAS: u1,

          /// [26:29] need_des
          HP_SLEEP_DBG_ATTEN: u4,

          /// [30:30] need_des
          HP_SLEEP_PD_CUR: u1,

          /// [31:31] need_des
          SLEEP: u1,

        }), @ptrFromInt(0x600b0080));

        /// need_des
        pub const HP_SLEEP_BACKUP = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] 
          res0: u6,

          /// [6:7] need_des
          HP_MODEM2SLEEP_BACKUP_MODEM_CLK_CODE: u2,

          /// [8:9] need_des
          HP_ACTIVE2SLEEP_BACKUP_MODEM_CLK_CODE: u2,

          /// [10:10] need_des
          HP_SLEEP_RETENTION_MODE: u1,

          /// [11:11] 
          res1: u1,

          /// [12:12] need_des
          HP_MODEM2SLEEP_RETENTION_EN: u1,

          /// [13:13] need_des
          HP_ACTIVE2SLEEP_RETENTION_EN: u1,

          /// [14:15] 
          res2: u2,

          /// [16:17] need_des
          HP_MODEM2SLEEP_BACKUP_CLK_SEL: u2,

          /// [18:19] need_des
          HP_ACTIVE2SLEEP_BACKUP_CLK_SEL: u2,

          /// [20:22] 
          res3: u3,

          /// [23:25] need_des
          HP_MODEM2SLEEP_BACKUP_MODE: u3,

          /// [26:28] need_des
          HP_ACTIVE2SLEEP_BACKUP_MODE: u3,

          /// [29:29] 
          res4: u1,

          /// [30:30] need_des
          HP_MODEM2SLEEP_BACKUP_EN: u1,

          /// [31:31] need_des
          HP_ACTIVE2SLEEP_BACKUP_EN: u1,

        }), @ptrFromInt(0x600b0084));

        /// need_des
        pub const HP_SLEEP_BACKUP_CLK = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] need_des
          HP_SLEEP_BACKUP_ICG_FUNC_EN: u32,

        }), @ptrFromInt(0x600b0088));

        /// need_des
        pub const HP_SLEEP_SYSCLK = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:25] 
          res0: u26,

          /// [26:26] need_des
          HP_SLEEP_DIG_SYS_CLK_NO_DIV: u1,

          /// [27:27] need_des
          HP_SLEEP_ICG_SYS_CLOCK_EN: u1,

          /// [28:28] need_des
          HP_SLEEP_SYS_CLK_SLP_SEL: u1,

          /// [29:29] need_des
          HP_SLEEP_ICG_SLP_SEL: u1,

          /// [30:31] need_des
          HP_SLEEP_DIG_SYS_CLK_SEL: u2,

        }), @ptrFromInt(0x600b008c));

        /// need_des
        pub const HP_SLEEP_HP_REGULATOR0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:15] 
          res0: u16,

          /// [16:16] need_des
          HP_SLEEP_HP_REGULATOR_SLP_MEM_XPD: u1,

          /// [17:17] need_des
          HP_SLEEP_HP_REGULATOR_SLP_LOGIC_XPD: u1,

          /// [18:18] need_des
          HP_SLEEP_HP_REGULATOR_XPD: u1,

          /// [19:22] need_des
          HP_SLEEP_HP_REGULATOR_SLP_MEM_DBIAS: u4,

          /// [23:26] need_des
          HP_SLEEP_HP_REGULATOR_SLP_LOGIC_DBIAS: u4,

          /// [27:31] need_des
          HP_SLEEP_HP_REGULATOR_DBIAS: u5,

        }), @ptrFromInt(0x600b0090));

        /// need_des
        pub const HP_SLEEP_HP_REGULATOR1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] 
          res0: u8,

          /// [8:31] need_des
          HP_SLEEP_HP_REGULATOR_DRV_B: u24,

        }), @ptrFromInt(0x600b0094));

        /// need_des
        pub const HP_SLEEP_XTAL = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:30] 
          res0: u31,

          /// [31:31] need_des
          HP_SLEEP_XPD_XTAL: u1,

        }), @ptrFromInt(0x600b0098));

        /// need_des
        pub const HP_SLEEP_LP_REGULATOR0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:20] 
          res0: u21,

          /// [21:21] need_des
          HP_SLEEP_LP_REGULATOR_SLP_XPD: u1,

          /// [22:22] need_des
          HP_SLEEP_LP_REGULATOR_XPD: u1,

          /// [23:26] need_des
          HP_SLEEP_LP_REGULATOR_SLP_DBIAS: u4,

          /// [27:31] need_des
          HP_SLEEP_LP_REGULATOR_DBIAS: u5,

        }), @ptrFromInt(0x600b009c));

        /// need_des
        pub const HP_SLEEP_LP_REGULATOR1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:27] 
          res0: u28,

          /// [28:31] need_des
          HP_SLEEP_LP_REGULATOR_DRV_B: u4,

        }), @ptrFromInt(0x600b00a0));

        /// need_des
        pub const HP_SLEEP_LP_DCDC_RESERVE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] need_des
          HP_SLEEP_LP_DCDC_RESERVE: u32,

        }), @ptrFromInt(0x600b00a4));

        /// need_des
        pub const HP_SLEEP_LP_DIG_POWER = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:29] 
          res0: u30,

          /// [30:30] need_des
          HP_SLEEP_LP_MEM_DSLP: u1,

          /// [31:31] need_des
          HP_SLEEP_PD_LP_PERI_PD_EN: u1,

        }), @ptrFromInt(0x600b00a8));

        /// need_des
        pub const HP_SLEEP_LP_CK_POWER = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:27] 
          res0: u28,

          /// [28:28] need_des
          HP_SLEEP_XPD_XTAL32K: u1,

          /// [29:29] need_des
          HP_SLEEP_XPD_RC32K: u1,

          /// [30:30] need_des
          HP_SLEEP_XPD_FOSC_CLK: u1,

          /// [31:31] need_des
          HP_SLEEP_PD_OSC_CLK: u1,

        }), @ptrFromInt(0x600b00ac));

        /// need_des
        pub const LP_SLEEP_LP_BIAS_RESERVE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] need_des
          LP_SLEEP_LP_BIAS_RESERVE: u32,

        }), @ptrFromInt(0x600b00b0));

        /// need_des
        pub const LP_SLEEP_LP_REGULATOR0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:20] 
          res0: u21,

          /// [21:21] need_des
          LP_SLEEP_LP_REGULATOR_SLP_XPD: u1,

          /// [22:22] need_des
          LP_SLEEP_LP_REGULATOR_XPD: u1,

          /// [23:26] need_des
          LP_SLEEP_LP_REGULATOR_SLP_DBIAS: u4,

          /// [27:31] need_des
          LP_SLEEP_LP_REGULATOR_DBIAS: u5,

        }), @ptrFromInt(0x600b00b4));

        /// need_des
        pub const LP_SLEEP_LP_REGULATOR1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:27] 
          res0: u28,

          /// [28:31] need_des
          LP_SLEEP_LP_REGULATOR_DRV_B: u4,

        }), @ptrFromInt(0x600b00b8));

        /// need_des
        pub const LP_SLEEP_XTAL = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:30] 
          res0: u31,

          /// [31:31] need_des
          LP_SLEEP_XPD_XTAL: u1,

        }), @ptrFromInt(0x600b00bc));

        /// need_des
        pub const LP_SLEEP_LP_DIG_POWER = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:29] 
          res0: u30,

          /// [30:30] need_des
          LP_SLEEP_LP_MEM_DSLP: u1,

          /// [31:31] need_des
          LP_SLEEP_PD_LP_PERI_PD_EN: u1,

        }), @ptrFromInt(0x600b00c0));

        /// need_des
        pub const LP_SLEEP_LP_CK_POWER = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:27] 
          res0: u28,

          /// [28:28] need_des
          LP_SLEEP_XPD_XTAL32K: u1,

          /// [29:29] need_des
          LP_SLEEP_XPD_RC32K: u1,

          /// [30:30] need_des
          LP_SLEEP_XPD_FOSC_CLK: u1,

          /// [31:31] need_des
          LP_SLEEP_PD_OSC_CLK: u1,

        }), @ptrFromInt(0x600b00c4));

        /// need_des
        pub const LP_SLEEP_BIAS = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:24] 
          res0: u25,

          /// [25:25] need_des
          LP_SLEEP_XPD_BIAS: u1,

          /// [26:29] need_des
          LP_SLEEP_DBG_ATTEN: u4,

          /// [30:30] need_des
          LP_SLEEP_PD_CUR: u1,

          /// [31:31] need_des
          SLEEP: u1,

        }), @ptrFromInt(0x600b00c8));

        /// need_des
        pub const IMM_HP_CK_POWER = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] need_des
          TIE_LOW_GLOBAL_BBPLL_ICG: u1,

          /// [1:1] need_des
          TIE_LOW_GLOBAL_XTAL_ICG: u1,

          /// [2:2] need_des
          TIE_LOW_I2C_RETENTION: u1,

          /// [3:3] need_des
          TIE_LOW_XPD_BB_I2C: u1,

          /// [4:4] need_des
          TIE_LOW_XPD_BBPLL_I2C: u1,

          /// [5:5] need_des
          TIE_LOW_XPD_BBPLL: u1,

          /// [6:6] need_des
          TIE_LOW_XPD_XTAL: u1,

          /// [7:24] 
          res0: u18,

          /// [25:25] need_des
          TIE_HIGH_GLOBAL_BBPLL_ICG: u1,

          /// [26:26] need_des
          TIE_HIGH_GLOBAL_XTAL_ICG: u1,

          /// [27:27] need_des
          TIE_HIGH_I2C_RETENTION: u1,

          /// [28:28] need_des
          TIE_HIGH_XPD_BB_I2C: u1,

          /// [29:29] need_des
          TIE_HIGH_XPD_BBPLL_I2C: u1,

          /// [30:30] need_des
          TIE_HIGH_XPD_BBPLL: u1,

          /// [31:31] need_des
          TIE_HIGH_XPD_XTAL: u1,

        }), @ptrFromInt(0x600b00cc));

        /// need_des
        pub const IMM_SLEEP_SYSCLK = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:27] 
          res0: u28,

          /// [28:28] need_des
          UPDATE_DIG_ICG_SWITCH: u1,

          /// [29:29] need_des
          TIE_LOW_ICG_SLP_SEL: u1,

          /// [30:30] need_des
          TIE_HIGH_ICG_SLP_SEL: u1,

          /// [31:31] need_des
          UPDATE_DIG_SYS_CLK_SEL: u1,

        }), @ptrFromInt(0x600b00d0));

        /// need_des
        pub const IMM_HP_FUNC_ICG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:30] 
          res0: u31,

          /// [31:31] need_des
          UPDATE_DIG_ICG_FUNC_EN: u1,

        }), @ptrFromInt(0x600b00d4));

        /// need_des
        pub const IMM_HP_APB_ICG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:30] 
          res0: u31,

          /// [31:31] need_des
          UPDATE_DIG_ICG_APB_EN: u1,

        }), @ptrFromInt(0x600b00d8));

        /// need_des
        pub const IMM_MODEM_ICG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:30] 
          res0: u31,

          /// [31:31] need_des
          UPDATE_DIG_ICG_MODEM_EN: u1,

        }), @ptrFromInt(0x600b00dc));

        /// need_des
        pub const IMM_LP_ICG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:29] 
          res0: u30,

          /// [30:30] need_des
          TIE_LOW_LP_ROOTCLK_SEL: u1,

          /// [31:31] need_des
          TIE_HIGH_LP_ROOTCLK_SEL: u1,

        }), @ptrFromInt(0x600b00e0));

        /// need_des
        pub const IMM_PAD_HOLD_ALL = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:27] 
          res0: u28,

          /// [28:28] need_des
          TIE_HIGH_LP_PAD_HOLD_ALL: u1,

          /// [29:29] need_des
          TIE_LOW_LP_PAD_HOLD_ALL: u1,

          /// [30:30] need_des
          TIE_HIGH_HP_PAD_HOLD_ALL: u1,

          /// [31:31] need_des
          TIE_LOW_HP_PAD_HOLD_ALL: u1,

        }), @ptrFromInt(0x600b00e4));

        /// need_des
        pub const IMM_I2C_ISO = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:29] 
          res0: u30,

          /// [30:30] need_des
          TIE_HIGH_I2C_ISO_EN: u1,

          /// [31:31] need_des
          TIE_LOW_I2C_ISO_EN: u1,

        }), @ptrFromInt(0x600b00e8));

        /// need_des
        pub const POWER_WAIT_TIMER0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:4] 
          res0: u5,

          /// [5:13] need_des
          DG_HP_POWERDOWN_TIMER: u9,

          /// [14:22] need_des
          DG_HP_POWERUP_TIMER: u9,

          /// [23:31] need_des
          DG_HP_WAIT_TIMER: u9,

        }), @ptrFromInt(0x600b00ec));

        /// need_des
        pub const POWER_WAIT_TIMER1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:8] 
          res0: u9,

          /// [9:15] need_des
          DG_LP_POWERDOWN_TIMER: u7,

          /// [16:22] need_des
          DG_LP_POWERUP_TIMER: u7,

          /// [23:31] need_des
          DG_LP_WAIT_TIMER: u9,

        }), @ptrFromInt(0x600b00f0));

        /// need_des
        pub const POWER_PD_TOP_CNTL = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] need_des
          FORCE_TOP_RESET: u1,

          /// [1:1] need_des
          FORCE_TOP_ISO: u1,

          /// [2:2] need_des
          FORCE_TOP_PU: u1,

          /// [3:3] need_des
          FORCE_TOP_NO_RESET: u1,

          /// [4:4] need_des
          FORCE_TOP_NO_ISO: u1,

          /// [5:5] need_des
          FORCE_TOP_PD: u1,

          /// [6:10] need_des
          PD_TOP_MASK: u5,

          /// [11:26] 
          res0: u16,

          /// [27:31] need_des
          PD_TOP_PD_MASK: u5,

        }), @ptrFromInt(0x600b00f4));

        /// need_des
        pub const POWER_PD_HPAON_CNTL = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] need_des
          FORCE_HP_AON_RESET: u1,

          /// [1:1] need_des
          FORCE_HP_AON_ISO: u1,

          /// [2:2] need_des
          FORCE_HP_AON_PU: u1,

          /// [3:3] need_des
          FORCE_HP_AON_NO_RESET: u1,

          /// [4:4] need_des
          FORCE_HP_AON_NO_ISO: u1,

          /// [5:5] need_des
          FORCE_HP_AON_PD: u1,

          /// [6:10] need_des
          PD_HP_AON_MASK: u5,

          /// [11:26] 
          res0: u16,

          /// [27:31] need_des
          PD_HP_AON_PD_MASK: u5,

        }), @ptrFromInt(0x600b00f8));

        /// need_des
        pub const POWER_PD_HPCPU_CNTL = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] need_des
          FORCE_HP_CPU_RESET: u1,

          /// [1:1] need_des
          FORCE_HP_CPU_ISO: u1,

          /// [2:2] need_des
          FORCE_HP_CPU_PU: u1,

          /// [3:3] need_des
          FORCE_HP_CPU_NO_RESET: u1,

          /// [4:4] need_des
          FORCE_HP_CPU_NO_ISO: u1,

          /// [5:5] need_des
          FORCE_HP_CPU_PD: u1,

          /// [6:10] need_des
          PD_HP_CPU_MASK: u5,

          /// [11:26] 
          res0: u16,

          /// [27:31] need_des
          PD_HP_CPU_PD_MASK: u5,

        }), @ptrFromInt(0x600b00fc));

        /// need_des
        pub const POWER_PD_HPPERI_RESERVE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] need_des
          HP_PERI_RESERVE: u32,

        }), @ptrFromInt(0x600b0100));

        /// need_des
        pub const POWER_PD_HPWIFI_CNTL = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] need_des
          FORCE_HP_WIFI_RESET: u1,

          /// [1:1] need_des
          FORCE_HP_WIFI_ISO: u1,

          /// [2:2] need_des
          FORCE_HP_WIFI_PU: u1,

          /// [3:3] need_des
          FORCE_HP_WIFI_NO_RESET: u1,

          /// [4:4] need_des
          FORCE_HP_WIFI_NO_ISO: u1,

          /// [5:5] need_des
          FORCE_HP_WIFI_PD: u1,

          /// [6:10] need_des
          PD_HP_WIFI_MASK: u5,

          /// [11:26] 
          res0: u16,

          /// [27:31] need_des
          PD_HP_WIFI_PD_MASK: u5,

        }), @ptrFromInt(0x600b0104));

        /// need_des
        pub const POWER_PD_LPPERI_CNTL = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] need_des
          FORCE_LP_PERI_RESET: u1,

          /// [1:1] need_des
          FORCE_LP_PERI_ISO: u1,

          /// [2:2] need_des
          FORCE_LP_PERI_PU: u1,

          /// [3:3] need_des
          FORCE_LP_PERI_NO_RESET: u1,

          /// [4:4] need_des
          FORCE_LP_PERI_NO_ISO: u1,

          /// [5:5] need_des
          FORCE_LP_PERI_PD: u1,

          /// [6:31] 
          res0: u26,

        }), @ptrFromInt(0x600b0108));

        /// need_des
        pub const POWER_PD_MEM_CNTL = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:3] need_des
          FORCE_HP_MEM_ISO: u4,

          /// [4:7] need_des
          FORCE_HP_MEM_PD: u4,

          /// [8:23] 
          res0: u16,

          /// [24:27] need_des
          FORCE_HP_MEM_NO_ISO: u4,

          /// [28:31] need_des
          FORCE_HP_MEM_PU: u4,

        }), @ptrFromInt(0x600b010c));

        /// need_des
        pub const POWER_PD_MEM_MASK = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:4] need_des
          PD_HP_MEM2_PD_MASK: u5,

          /// [5:9] need_des
          PD_HP_MEM1_PD_MASK: u5,

          /// [10:14] need_des
          PD_HP_MEM0_PD_MASK: u5,

          /// [15:16] 
          res0: u2,

          /// [17:21] need_des
          PD_HP_MEM2_MASK: u5,

          /// [22:26] need_des
          PD_HP_MEM1_MASK: u5,

          /// [27:31] need_des
          PD_HP_MEM0_MASK: u5,

        }), @ptrFromInt(0x600b0110));

        /// need_des
        pub const POWER_HP_PAD = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] need_des
          FORCE_HP_PAD_NO_ISO_ALL: u1,

          /// [1:1] need_des
          FORCE_HP_PAD_ISO_ALL: u1,

          /// [2:31] 
          res0: u30,

        }), @ptrFromInt(0x600b0114));

        /// need_des
        pub const POWER_VDD_SPI_CNTL = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:17] 
          res0: u18,

          /// [18:28] need_des
          VDD_SPI_PWR_WAIT: u11,

          /// [29:30] need_des
          VDD_SPI_PWR_SW: u2,

          /// [31:31] need_des
          VDD_SPI_PWR_SEL_SW: u1,

        }), @ptrFromInt(0x600b0118));

        /// need_des
        pub const POWER_CK_WAIT_CNTL = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:15] need_des
          WAIT_XTL_STABLE: u16,

          /// [16:31] need_des
          WAIT_PLL_STABLE: u16,

        }), @ptrFromInt(0x600b011c));

        /// need_des
        pub const SLP_WAKEUP_CNTL0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:30] 
          res0: u31,

          /// [31:31] need_des
          SLEEP_REQ: u1,

        }), @ptrFromInt(0x600b0120));

        /// need_des
        pub const SLP_WAKEUP_CNTL1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:30] need_des
          SLEEP_REJECT_ENA: u31,

          /// [31:31] need_des
          SLP_REJECT_EN: u1,

        }), @ptrFromInt(0x600b0124));

        /// need_des
        pub const SLP_WAKEUP_CNTL2 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] need_des
          WAKEUP_ENA: u32,

        }), @ptrFromInt(0x600b0128));

        /// need_des
        pub const SLP_WAKEUP_CNTL3 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] need_des
          LP_MIN_SLP_VAL: u8,

          /// [8:15] need_des
          HP_MIN_SLP_VAL: u8,

          /// [16:17] need_des
          SLEEP_PRT_SEL: u2,

          /// [18:31] 
          res0: u14,

        }), @ptrFromInt(0x600b012c));

        /// need_des
        pub const SLP_WAKEUP_CNTL4 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:30] 
          res0: u31,

          /// [31:31] need_des
          SLP_REJECT_CAUSE_CLR: u1,

        }), @ptrFromInt(0x600b0130));

        /// need_des
        pub const SLP_WAKEUP_CNTL5 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:19] need_des
          MODEM_WAIT_TARGET: u20,

          /// [20:23] 
          res0: u4,

          /// [24:31] need_des
          LP_ANA_WAIT_TARGET: u8,

        }), @ptrFromInt(0x600b0134));

        /// need_des
        pub const SLP_WAKEUP_CNTL6 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:19] need_des
          SOC_WAKEUP_WAIT: u20,

          /// [20:29] 
          res0: u10,

          /// [30:31] need_des
          SOC_WAKEUP_WAIT_CFG: u2,

        }), @ptrFromInt(0x600b0138));

        /// need_des
        pub const SLP_WAKEUP_CNTL7 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:15] 
          res0: u16,

          /// [16:31] need_des
          ANA_WAIT_TARGET: u16,

        }), @ptrFromInt(0x600b013c));

        /// need_des
        pub const SLP_WAKEUP_STATUS0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] need_des
          WAKEUP_CAUSE: u32,

        }), @ptrFromInt(0x600b0140));

        /// need_des
        pub const SLP_WAKEUP_STATUS1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] need_des
          REJECT_CAUSE: u32,

        }), @ptrFromInt(0x600b0144));

        /// need_des
        pub const HP_CK_POWERON = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] need_des
          I2C_POR_WAIT_TARGET: u8,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x600b0148));

        /// need_des
        pub const HP_CK_CNTL = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] need_des
          MODIFY_ICG_CNTL_WAIT: u8,

          /// [8:15] need_des
          SWITCH_ICG_CNTL_WAIT: u8,

          /// [16:31] 
          res0: u16,

        }), @ptrFromInt(0x600b014c));

        /// need_des
        pub const POR_STATUS = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:30] 
          res0: u31,

          /// [31:31] need_des
          POR_DONE: u1,

        }), @ptrFromInt(0x600b0150));

        /// need_des
        pub const RF_PWC = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:25] 
          res0: u26,

          /// [26:26] need_des
          PERIF_I2C_RSTB: u1,

          /// [27:27] need_des
          XPD_PERIF_I2C: u1,

          /// [28:28] need_des
          XPD_TXRF_I2C: u1,

          /// [29:29] need_des
          XPD_RFRX_PBUS: u1,

          /// [30:30] need_des
          XPD_CKGEN_I2C: u1,

          /// [31:31] need_des
          XPD_PLL_I2C: u1,

        }), @ptrFromInt(0x600b0154));

        /// need_des
        pub const BACKUP_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:30] 
          res0: u31,

          /// [31:31] need_des
          BACKUP_SYS_CLK_NO_DIV: u1,

        }), @ptrFromInt(0x600b0158));

        /// need_des
        pub const INT_RAW = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:26] 
          res0: u27,

          /// [27:27] need_des
          LP_CPU_EXC_INT_RAW: u1,

          /// [28:28] need_des
          SDIO_IDLE_INT_RAW: u1,

          /// [29:29] need_des
          SW_INT_RAW: u1,

          /// [30:30] need_des
          SOC_SLEEP_REJECT_INT_RAW: u1,

          /// [31:31] need_des
          SOC_WAKEUP_INT_RAW: u1,

        }), @ptrFromInt(0x600b015c));

        /// need_des
        pub const HP_INT_ST = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:26] 
          res0: u27,

          /// [27:27] need_des
          LP_CPU_EXC_INT_ST: u1,

          /// [28:28] need_des
          SDIO_IDLE_INT_ST: u1,

          /// [29:29] need_des
          SW_INT_ST: u1,

          /// [30:30] need_des
          SOC_SLEEP_REJECT_INT_ST: u1,

          /// [31:31] need_des
          SOC_WAKEUP_INT_ST: u1,

        }), @ptrFromInt(0x600b0160));

        /// need_des
        pub const HP_INT_ENA = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:26] 
          res0: u27,

          /// [27:27] need_des
          LP_CPU_EXC_INT_ENA: u1,

          /// [28:28] need_des
          SDIO_IDLE_INT_ENA: u1,

          /// [29:29] need_des
          SW_INT_ENA: u1,

          /// [30:30] need_des
          SOC_SLEEP_REJECT_INT_ENA: u1,

          /// [31:31] need_des
          SOC_WAKEUP_INT_ENA: u1,

        }), @ptrFromInt(0x600b0164));

        /// need_des
        pub const HP_INT_CLR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:26] 
          res0: u27,

          /// [27:27] need_des
          LP_CPU_EXC_INT_CLR: u1,

          /// [28:28] need_des
          SDIO_IDLE_INT_CLR: u1,

          /// [29:29] need_des
          SW_INT_CLR: u1,

          /// [30:30] need_des
          SOC_SLEEP_REJECT_INT_CLR: u1,

          /// [31:31] need_des
          SOC_WAKEUP_INT_CLR: u1,

        }), @ptrFromInt(0x600b0168));

        /// need_des
        pub const LP_INT_RAW = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:19] 
          res0: u20,

          /// [20:20] need_des
          LP_CPU_WAKEUP_INT_RAW: u1,

          /// [21:21] need_des
          MODEM_SWITCH_ACTIVE_END_INT_RAW: u1,

          /// [22:22] need_des
          SLEEP_SWITCH_ACTIVE_END_INT_RAW: u1,

          /// [23:23] need_des
          SLEEP_SWITCH_MODEM_END_INT_RAW: u1,

          /// [24:24] need_des
          MODEM_SWITCH_SLEEP_END_INT_RAW: u1,

          /// [25:25] need_des
          ACTIVE_SWITCH_SLEEP_END_INT_RAW: u1,

          /// [26:26] need_des
          MODEM_SWITCH_ACTIVE_START_INT_RAW: u1,

          /// [27:27] need_des
          SLEEP_SWITCH_ACTIVE_START_INT_RAW: u1,

          /// [28:28] need_des
          SLEEP_SWITCH_MODEM_START_INT_RAW: u1,

          /// [29:29] need_des
          MODEM_SWITCH_SLEEP_START_INT_RAW: u1,

          /// [30:30] need_des
          ACTIVE_SWITCH_SLEEP_START_INT_RAW: u1,

          /// [31:31] need_des
          HP_SW_TRIGGER_INT_RAW: u1,

        }), @ptrFromInt(0x600b016c));

        /// need_des
        pub const LP_INT_ST = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:19] 
          res0: u20,

          /// [20:20] need_des
          LP_CPU_WAKEUP_INT_ST: u1,

          /// [21:21] need_des
          MODEM_SWITCH_ACTIVE_END_INT_ST: u1,

          /// [22:22] need_des
          SLEEP_SWITCH_ACTIVE_END_INT_ST: u1,

          /// [23:23] need_des
          SLEEP_SWITCH_MODEM_END_INT_ST: u1,

          /// [24:24] need_des
          MODEM_SWITCH_SLEEP_END_INT_ST: u1,

          /// [25:25] need_des
          ACTIVE_SWITCH_SLEEP_END_INT_ST: u1,

          /// [26:26] need_des
          MODEM_SWITCH_ACTIVE_START_INT_ST: u1,

          /// [27:27] need_des
          SLEEP_SWITCH_ACTIVE_START_INT_ST: u1,

          /// [28:28] need_des
          SLEEP_SWITCH_MODEM_START_INT_ST: u1,

          /// [29:29] need_des
          MODEM_SWITCH_SLEEP_START_INT_ST: u1,

          /// [30:30] need_des
          ACTIVE_SWITCH_SLEEP_START_INT_ST: u1,

          /// [31:31] need_des
          HP_SW_TRIGGER_INT_ST: u1,

        }), @ptrFromInt(0x600b0170));

        /// need_des
        pub const LP_INT_ENA = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:19] 
          res0: u20,

          /// [20:20] need_des
          LP_CPU_WAKEUP_INT_ENA: u1,

          /// [21:21] need_des
          MODEM_SWITCH_ACTIVE_END_INT_ENA: u1,

          /// [22:22] need_des
          SLEEP_SWITCH_ACTIVE_END_INT_ENA: u1,

          /// [23:23] need_des
          SLEEP_SWITCH_MODEM_END_INT_ENA: u1,

          /// [24:24] need_des
          MODEM_SWITCH_SLEEP_END_INT_ENA: u1,

          /// [25:25] need_des
          ACTIVE_SWITCH_SLEEP_END_INT_ENA: u1,

          /// [26:26] need_des
          MODEM_SWITCH_ACTIVE_START_INT_ENA: u1,

          /// [27:27] need_des
          SLEEP_SWITCH_ACTIVE_START_INT_ENA: u1,

          /// [28:28] need_des
          SLEEP_SWITCH_MODEM_START_INT_ENA: u1,

          /// [29:29] need_des
          MODEM_SWITCH_SLEEP_START_INT_ENA: u1,

          /// [30:30] need_des
          ACTIVE_SWITCH_SLEEP_START_INT_ENA: u1,

          /// [31:31] need_des
          HP_SW_TRIGGER_INT_ENA: u1,

        }), @ptrFromInt(0x600b0174));

        /// need_des
        pub const LP_INT_CLR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:19] 
          res0: u20,

          /// [20:20] need_des
          LP_CPU_WAKEUP_INT_CLR: u1,

          /// [21:21] need_des
          MODEM_SWITCH_ACTIVE_END_INT_CLR: u1,

          /// [22:22] need_des
          SLEEP_SWITCH_ACTIVE_END_INT_CLR: u1,

          /// [23:23] need_des
          SLEEP_SWITCH_MODEM_END_INT_CLR: u1,

          /// [24:24] need_des
          MODEM_SWITCH_SLEEP_END_INT_CLR: u1,

          /// [25:25] need_des
          ACTIVE_SWITCH_SLEEP_END_INT_CLR: u1,

          /// [26:26] need_des
          MODEM_SWITCH_ACTIVE_START_INT_CLR: u1,

          /// [27:27] need_des
          SLEEP_SWITCH_ACTIVE_START_INT_CLR: u1,

          /// [28:28] need_des
          SLEEP_SWITCH_MODEM_START_INT_CLR: u1,

          /// [29:29] need_des
          MODEM_SWITCH_SLEEP_START_INT_CLR: u1,

          /// [30:30] need_des
          ACTIVE_SWITCH_SLEEP_START_INT_CLR: u1,

          /// [31:31] need_des
          HP_SW_TRIGGER_INT_CLR: u1,

        }), @ptrFromInt(0x600b0178));

        /// need_des
        pub const LP_CPU_PWR0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] need_des
          LP_CPU_WAITI_RDY: u1,

          /// [1:1] need_des
          LP_CPU_STALL_RDY: u1,

          /// [2:17] 
          res0: u16,

          /// [18:18] need_des
          LP_CPU_FORCE_STALL: u1,

          /// [19:19] need_des
          LP_CPU_SLP_WAITI_FLAG_EN: u1,

          /// [20:20] need_des
          LP_CPU_SLP_STALL_FLAG_EN: u1,

          /// [21:28] need_des
          LP_CPU_SLP_STALL_WAIT: u8,

          /// [29:29] need_des
          LP_CPU_SLP_STALL_EN: u1,

          /// [30:30] need_des
          LP_CPU_SLP_RESET_EN: u1,

          /// [31:31] need_des
          LP_CPU_SLP_BYPASS_INTR_EN: u1,

        }), @ptrFromInt(0x600b017c));

        /// need_des
        pub const LP_CPU_PWR1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:15] need_des
          LP_CPU_WAKEUP_EN: u16,

          /// [16:30] 
          res0: u15,

          /// [31:31] need_des
          LP_CPU_SLEEP_REQ: u1,

        }), @ptrFromInt(0x600b0180));

        /// need_des
        pub const HP_LP_CPU_COMM = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:29] 
          res0: u30,

          /// [30:30] need_des
          LP_TRIGGER_HP: u1,

          /// [31:31] need_des
          HP_TRIGGER_LP: u1,

        }), @ptrFromInt(0x600b0184));

        /// need_des
        pub const HP_REGULATOR_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:30] 
          res0: u31,

          /// [31:31] need_des
          DIG_REGULATOR_EN_CAL: u1,

        }), @ptrFromInt(0x600b0188));

        /// need_des
        pub const MAIN_STATE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:10] 
          res0: u11,

          /// [11:17] need_des
          MAIN_LAST_ST_STATE: u7,

          /// [18:24] need_des
          MAIN_TAR_ST_STATE: u7,

          /// [25:31] need_des
          MAIN_CUR_ST_STATE: u7,

        }), @ptrFromInt(0x600b018c));

        /// need_des
        pub const PWR_STATE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:12] 
          res0: u13,

          /// [13:17] need_des
          BACKUP_ST_STATE: u5,

          /// [18:22] need_des
          LP_PWR_ST_STATE: u5,

          /// [23:31] need_des
          HP_PWR_ST_STATE: u9,

        }), @ptrFromInt(0x600b0190));

        /// need_des
        pub const CLK_STATE0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] need_des
          STABLE_XPD_BBPLL_STATE: u1,

          /// [1:1] need_des
          STABLE_XPD_XTAL_STATE: u1,

          /// [2:14] 
          res0: u13,

          /// [15:15] need_des
          SYS_CLK_SLP_SEL_STATE: u1,

          /// [16:17] need_des
          SYS_CLK_SEL_STATE: u2,

          /// [18:18] need_des
          SYS_CLK_NO_DIV_STATE: u1,

          /// [19:19] need_des
          ICG_SYS_CLK_EN_STATE: u1,

          /// [20:20] need_des
          ICG_MODEM_SWITCH_STATE: u1,

          /// [21:22] need_des
          ICG_MODEM_CODE_STATE: u2,

          /// [23:23] need_des
          ICG_SLP_SEL_STATE: u1,

          /// [24:24] need_des
          ICG_GLOBAL_XTAL_STATE: u1,

          /// [25:25] need_des
          ICG_GLOBAL_PLL_STATE: u1,

          /// [26:26] need_des
          ANA_I2C_ISO_EN_STATE: u1,

          /// [27:27] need_des
          ANA_I2C_RETENTION_STATE: u1,

          /// [28:28] need_des
          ANA_XPD_BB_I2C_STATE: u1,

          /// [29:29] need_des
          ANA_XPD_BBPLL_I2C_STATE: u1,

          /// [30:30] need_des
          ANA_XPD_BBPLL_STATE: u1,

          /// [31:31] need_des
          ANA_XPD_XTAL_STATE: u1,

        }), @ptrFromInt(0x600b0194));

        /// need_des
        pub const CLK_STATE1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] need_des
          ICG_FUNC_EN_STATE: u32,

        }), @ptrFromInt(0x600b0198));

        /// need_des
        pub const CLK_STATE2 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] need_des
          ICG_APB_EN_STATE: u32,

        }), @ptrFromInt(0x600b019c));

        /// need_des
        pub const VDD_SPI_STATUS = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:30] 
          res0: u31,

          /// [31:31] need_des
          STABLE_VDD_SPI_PWR_DRV: u1,

        }), @ptrFromInt(0x600b01a0));

        /// need_des
        pub const DATE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:30] need_des
          PMU_DATE: u31,

          /// [31:31] need_des
          CLK_EN: u1,

        }), @ptrFromInt(0x600b03fc));

      };

      /// Remote Control
      pub const RMT = struct {

        /// The read and writedata register for CHANNEL%s by apb fifo access.
        pub const CH0DATA = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Read and write data for channel %s via APB FIFO.
          DATA: u32,

        }), @ptrFromInt(0x60006000));

        /// The read and writedata register for CHANNEL%s by apb fifo access.
        pub const CH1DATA = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Read and write data for channel %s via APB FIFO.
          DATA: u32,

        }), @ptrFromInt(0x60006004));

        /// The read and writedata register for CHANNEL%s by apb fifo access.
        pub const CH2DATA = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Read and write data for channel %s via APB FIFO.
          DATA: u32,

        }), @ptrFromInt(0x60006008));

        /// The read and writedata register for CHANNEL%s by apb fifo access.
        pub const CH3DATA = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Read and write data for channel %s via APB FIFO.
          DATA: u32,

        }), @ptrFromInt(0x6000600c));

        /// Channel %s configure register 0
        pub const CH0_TX_CONF0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Set this bit to start sending data on CHANNEL%s.
          TX_START: u1,

          /// [1:1] Set this bit to reset read ram address for CHANNEL%s by accessing transmitter.
          MEM_RD_RST: u1,

          /// [2:2] Set this bit to reset W/R ram address for CHANNEL%s by accessing apb fifo.
          APB_MEM_RST: u1,

          /// [3:3] Set this bit to restart transmissionfrom the first data to the last data in CHANNEL%s.
          TX_CONTI_MODE: u1,

          /// [4:4] This is the channel %s enable bit for wraparound mode: it will resume sending at the start when the data to be sent is more than its memory size.
          MEM_TX_WRAP_EN: u1,

          /// [5:5] This bit configures the level of output signal in CHANNEL%s when the latter is in IDLE state.
          IDLE_OUT_LV: u1,

          /// [6:6] This is the output enable-control bit for CHANNEL%s in IDLE state.
          IDLE_OUT_EN: u1,

          /// [7:7] Set this bit to stop the transmitter of CHANNEL%s sending data out.
          TX_STOP: u1,

          /// [8:15] This register is used to configure the divider for clock of CHANNEL%s.
          DIV_CNT: u8,

          /// [16:18] This register is used to configure the maximum size of memory allocated to CHANNEL%s.
          MEM_SIZE: u3,

          /// [19:19] 
          res0: u1,

          /// [20:20] 1: Add carrier modulation on the output signal only at the send data state for CHANNEL%s. 0: Add carrier modulation on the output signal at all state for CHANNEL%s. Only valid when RMT_CARRIER_EN_CH%s is 1.
          CARRIER_EFF_EN: u1,

          /// [21:21] This is the carrier modulation enable-control bit for CHANNEL%s. 1: Add carrier modulation in the output signal. 0: No carrier modulation in sig_out.
          CARRIER_EN: u1,

          /// [22:22] This bit is used to configure the position of carrier wave for CHANNEL%s.1'h0: add carrier wave on low level.1'h1: add carrier wave on high level.
          CARRIER_OUT_LV: u1,

          /// [23:23] Reserved
          AFIFO_RST: u1,

          /// [24:24] synchronization bit for CHANNEL%s
          CONF_UPDATE: u1,

          /// [25:31] 
          res1: u7,

        }), @ptrFromInt(0x60006010));

        /// Channel %s configure register 0
        pub const CH1_TX_CONF0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Set this bit to start sending data on CHANNEL%s.
          TX_START: u1,

          /// [1:1] Set this bit to reset read ram address for CHANNEL%s by accessing transmitter.
          MEM_RD_RST: u1,

          /// [2:2] Set this bit to reset W/R ram address for CHANNEL%s by accessing apb fifo.
          APB_MEM_RST: u1,

          /// [3:3] Set this bit to restart transmissionfrom the first data to the last data in CHANNEL%s.
          TX_CONTI_MODE: u1,

          /// [4:4] This is the channel %s enable bit for wraparound mode: it will resume sending at the start when the data to be sent is more than its memory size.
          MEM_TX_WRAP_EN: u1,

          /// [5:5] This bit configures the level of output signal in CHANNEL%s when the latter is in IDLE state.
          IDLE_OUT_LV: u1,

          /// [6:6] This is the output enable-control bit for CHANNEL%s in IDLE state.
          IDLE_OUT_EN: u1,

          /// [7:7] Set this bit to stop the transmitter of CHANNEL%s sending data out.
          TX_STOP: u1,

          /// [8:15] This register is used to configure the divider for clock of CHANNEL%s.
          DIV_CNT: u8,

          /// [16:18] This register is used to configure the maximum size of memory allocated to CHANNEL%s.
          MEM_SIZE: u3,

          /// [19:19] 
          res0: u1,

          /// [20:20] 1: Add carrier modulation on the output signal only at the send data state for CHANNEL%s. 0: Add carrier modulation on the output signal at all state for CHANNEL%s. Only valid when RMT_CARRIER_EN_CH%s is 1.
          CARRIER_EFF_EN: u1,

          /// [21:21] This is the carrier modulation enable-control bit for CHANNEL%s. 1: Add carrier modulation in the output signal. 0: No carrier modulation in sig_out.
          CARRIER_EN: u1,

          /// [22:22] This bit is used to configure the position of carrier wave for CHANNEL%s.1'h0: add carrier wave on low level.1'h1: add carrier wave on high level.
          CARRIER_OUT_LV: u1,

          /// [23:23] Reserved
          AFIFO_RST: u1,

          /// [24:24] synchronization bit for CHANNEL%s
          CONF_UPDATE: u1,

          /// [25:31] 
          res1: u7,

        }), @ptrFromInt(0x60006014));

        /// Channel %s configure register 0
        pub const CH0_RX_CONF0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] This register is used to configure the divider for clock of CHANNEL%s.
          DIV_CNT: u8,

          /// [8:22] When no edge is detected on the input signal and continuous clock cycles is longer than this register value, received process is finished.
          IDLE_THRES: u15,

          /// [23:25] This register is used to configure the maximum size of memory allocated to CHANNEL%s.
          MEM_SIZE: u3,

          /// [26:27] 
          res0: u2,

          /// [28:28] This is the carrier modulation enable-control bit for CHANNEL%s. 1: Add carrier modulation in the output signal. 0: No carrier modulation in sig_out.
          CARRIER_EN: u1,

          /// [29:29] This bit is used to configure the position of carrier wave for CHANNEL%s.1'h0: add carrier wave on low level.1'h1: add carrier wave on high level.
          CARRIER_OUT_LV: u1,

          /// [30:31] 
          res1: u2,

        }), @ptrFromInt(0x60006018));

        /// Channel %s configure register 0
        pub const CH1_RX_CONF0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] This register is used to configure the divider for clock of CHANNEL%s.
          DIV_CNT: u8,

          /// [8:22] When no edge is detected on the input signal and continuous clock cycles is longer than this register value, received process is finished.
          IDLE_THRES: u15,

          /// [23:25] This register is used to configure the maximum size of memory allocated to CHANNEL%s.
          MEM_SIZE: u3,

          /// [26:27] 
          res0: u2,

          /// [28:28] This is the carrier modulation enable-control bit for CHANNEL%s. 1: Add carrier modulation in the output signal. 0: No carrier modulation in sig_out.
          CARRIER_EN: u1,

          /// [29:29] This bit is used to configure the position of carrier wave for CHANNEL%s.1'h0: add carrier wave on low level.1'h1: add carrier wave on high level.
          CARRIER_OUT_LV: u1,

          /// [30:31] 
          res1: u2,

        }), @ptrFromInt(0x6000601c));

        /// Channel %s configure register 1
        pub const CH0_RX_CONF1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Set this bit to enable receiver to receive data on CHANNEL%s.
          RX_EN: u1,

          /// [1:1] Set this bit to reset write ram address for CHANNEL%s by accessing receiver.
          MEM_WR_RST: u1,

          /// [2:2] Set this bit to reset W/R ram address for CHANNEL%s by accessing apb fifo.
          APB_MEM_RST: u1,

          /// [3:3] This register marks the ownership of CHANNEL%s's ram block.1'h1: Receiver is using the ram. 1'h0: APB bus is using the ram.
          MEM_OWNER: u1,

          /// [4:4] This is the receive filter's enable bit for CHANNEL%s.
          RX_FILTER_EN: u1,

          /// [5:12] Ignores the input pulse when its width is smaller than this register value in APB clock periods (in receive mode).
          RX_FILTER_THRES: u8,

          /// [13:13] This is the channel %s enable bit for wraparound mode: it will resume receiving at the start when the data to be received is more than its memory size.
          MEM_RX_WRAP_EN: u1,

          /// [14:14] Reserved
          AFIFO_RST: u1,

          /// [15:15] synchronization bit for CHANNEL%s
          CONF_UPDATE: u1,

          /// [16:31] 
          res0: u16,

        }), @ptrFromInt(0x6000601c));

        /// Channel %s configure register 1
        pub const CH1_RX_CONF1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Set this bit to enable receiver to receive data on CHANNEL%s.
          RX_EN: u1,

          /// [1:1] Set this bit to reset write ram address for CHANNEL%s by accessing receiver.
          MEM_WR_RST: u1,

          /// [2:2] Set this bit to reset W/R ram address for CHANNEL%s by accessing apb fifo.
          APB_MEM_RST: u1,

          /// [3:3] This register marks the ownership of CHANNEL%s's ram block.1'h1: Receiver is using the ram. 1'h0: APB bus is using the ram.
          MEM_OWNER: u1,

          /// [4:4] This is the receive filter's enable bit for CHANNEL%s.
          RX_FILTER_EN: u1,

          /// [5:12] Ignores the input pulse when its width is smaller than this register value in APB clock periods (in receive mode).
          RX_FILTER_THRES: u8,

          /// [13:13] This is the channel %s enable bit for wraparound mode: it will resume receiving at the start when the data to be received is more than its memory size.
          MEM_RX_WRAP_EN: u1,

          /// [14:14] Reserved
          AFIFO_RST: u1,

          /// [15:15] synchronization bit for CHANNEL%s
          CONF_UPDATE: u1,

          /// [16:31] 
          res0: u16,

        }), @ptrFromInt(0x60006020));

        /// Channel %s status register
        pub const CH0_TX_STATUS = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:8] This register records the memory address offset when transmitter of CHANNEL%s is using the RAM.
          MEM_RADDR_EX: u9,

          /// [9:11] This register records the FSM status of CHANNEL%s.
          STATE: u3,

          /// [12:20] This register records the memory address offset when writes RAM over APB bus.
          APB_MEM_WADDR: u9,

          /// [21:21] This status bit will be set if the offset address out of memory size when reading via APB bus.
          APB_MEM_RD_ERR: u1,

          /// [22:22] This status bit will be set when the data to be set is more than memory size and the wraparound mode is disabled.
          MEM_EMPTY: u1,

          /// [23:23] This status bit will be set if the offset address out of memory size when writes via APB bus.
          APB_MEM_WR_ERR: u1,

          /// [24:31] This register records the memory address offset when reading RAM over APB bus.
          APB_MEM_RADDR: u8,

        }), @ptrFromInt(0x60006028));

        /// Channel %s status register
        pub const CH1_TX_STATUS = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:8] This register records the memory address offset when transmitter of CHANNEL%s is using the RAM.
          MEM_RADDR_EX: u9,

          /// [9:11] This register records the FSM status of CHANNEL%s.
          STATE: u3,

          /// [12:20] This register records the memory address offset when writes RAM over APB bus.
          APB_MEM_WADDR: u9,

          /// [21:21] This status bit will be set if the offset address out of memory size when reading via APB bus.
          APB_MEM_RD_ERR: u1,

          /// [22:22] This status bit will be set when the data to be set is more than memory size and the wraparound mode is disabled.
          MEM_EMPTY: u1,

          /// [23:23] This status bit will be set if the offset address out of memory size when writes via APB bus.
          APB_MEM_WR_ERR: u1,

          /// [24:31] This register records the memory address offset when reading RAM over APB bus.
          APB_MEM_RADDR: u8,

        }), @ptrFromInt(0x6000602c));

        /// Channel %s status register
        pub const CH0_RX_STATUS = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:8] This register records the memory address offset when receiver of CHANNEL%s is using the RAM.
          MEM_WADDR_EX: u9,

          /// [9:11] 
          res0: u3,

          /// [12:20] This register records the memory address offset when reads RAM over APB bus.
          APB_MEM_RADDR: u9,

          /// [21:21] 
          res1: u1,

          /// [22:24] This register records the FSM status of CHANNEL%s.
          STATE: u3,

          /// [25:25] This status bit will be set when the ownership of memory block is wrong.
          MEM_OWNER_ERR: u1,

          /// [26:26] This status bit will be set if the receiver receives more data than the memory size.
          MEM_FULL: u1,

          /// [27:27] This status bit will be set if the offset address out of memory size when reads via APB bus.
          APB_MEM_RD_ERR: u1,

          /// [28:31] 
          res2: u4,

        }), @ptrFromInt(0x60006030));

        /// Channel %s status register
        pub const CH1_RX_STATUS = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:8] This register records the memory address offset when receiver of CHANNEL%s is using the RAM.
          MEM_WADDR_EX: u9,

          /// [9:11] 
          res0: u3,

          /// [12:20] This register records the memory address offset when reads RAM over APB bus.
          APB_MEM_RADDR: u9,

          /// [21:21] 
          res1: u1,

          /// [22:24] This register records the FSM status of CHANNEL%s.
          STATE: u3,

          /// [25:25] This status bit will be set when the ownership of memory block is wrong.
          MEM_OWNER_ERR: u1,

          /// [26:26] This status bit will be set if the receiver receives more data than the memory size.
          MEM_FULL: u1,

          /// [27:27] This status bit will be set if the offset address out of memory size when reads via APB bus.
          APB_MEM_RD_ERR: u1,

          /// [28:31] 
          res2: u4,

        }), @ptrFromInt(0x60006034));

        /// Raw interrupt status
        pub const INT_RAW = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] The interrupt raw bit for CHANNEL%s. Triggered when transmission done.
          CH%s_TX_END: u1,

          /// [1:1] 
          res0: u1,

          /// [2:2] The interrupt raw bit for CHANNEL2. Triggered when reception done.
          CH%s_RX_END: u1,

          /// [3:3] 
          res1: u1,

          /// [4:4] The interrupt raw bit for CHANNEL4. Triggered when error occurs.
          CH%s_TX_ERR: u1,

          /// [5:5] 
          res2: u1,

          /// [6:6] The interrupt raw bit for CHANNEL6. Triggered when error occurs.
          CH%s_RX_ERR: u1,

          /// [7:7] 
          res3: u1,

          /// [8:8] The interrupt raw bit for CHANNEL%s. Triggered when transmitter sent more data than configured value.
          CH%s_TX_THR_EVENT: u1,

          /// [9:9] 
          res4: u1,

          /// [10:10] The interrupt raw bit for CHANNEL2. Triggered when receiver receive more data than configured value.
          CH%s_RX_THR_EVENT: u1,

          /// [11:11] 
          res5: u1,

          /// [12:12] The interrupt raw bit for CHANNEL%s. Triggered when the loop count reaches the configured threshold value.
          CH%s_TX_LOOP: u1,

          /// [13:31] 
          res6: u19,

        }), @ptrFromInt(0x60006038));

        /// Masked interrupt status
        pub const INT_ST = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] The masked interrupt status bit for CH%s_TX_END_INT.
          CH%s_TX_END: u1,

          /// [1:1] 
          res0: u1,

          /// [2:2] The masked interrupt status bit for CH2_RX_END_INT.
          CH%s_RX_END: u1,

          /// [3:3] 
          res1: u1,

          /// [4:4] The masked interrupt status bit for CH4_ERR_INT.
          CH%s_TX_ERR: u1,

          /// [5:5] 
          res2: u1,

          /// [6:6] The masked interrupt status bit for CH6_ERR_INT.
          CH%s_RX_ERR: u1,

          /// [7:7] 
          res3: u1,

          /// [8:8] The masked interrupt status bit for CH%s_TX_THR_EVENT_INT.
          CH%s_TX_THR_EVENT: u1,

          /// [9:9] 
          res4: u1,

          /// [10:10] The masked interrupt status bit for CH2_RX_THR_EVENT_INT.
          CH%s_RX_THR_EVENT: u1,

          /// [11:11] 
          res5: u1,

          /// [12:12] The masked interrupt status bit for CH%s_TX_LOOP_INT.
          CH%s_X_LOOP: u1,

          /// [13:31] 
          res6: u19,

        }), @ptrFromInt(0x6000603c));

        /// Interrupt enable bits
        pub const INT_ENA = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] The interrupt enable bit for CH%s_TX_END_INT.
          CH%s_TX_END: u1,

          /// [1:1] 
          res0: u1,

          /// [2:2] The interrupt enable bit for CH2_RX_END_INT.
          CH%s_RX_END: u1,

          /// [3:3] 
          res1: u1,

          /// [4:4] The interrupt enable bit for CH4_ERR_INT.
          CH%s_TX_ERR: u1,

          /// [5:5] 
          res2: u1,

          /// [6:6] The interrupt enable bit for CH6_ERR_INT.
          CH%s_RX_ERR: u1,

          /// [7:7] 
          res3: u1,

          /// [8:8] The interrupt enable bit for CH%s_TX_THR_EVENT_INT.
          CH%s_TX_THR_EVENT: u1,

          /// [9:9] 
          res4: u1,

          /// [10:10] The interrupt enable bit for CH2_RX_THR_EVENT_INT.
          CH%s_RX_THR_EVENT: u1,

          /// [11:11] 
          res5: u1,

          /// [12:12] The interrupt enable bit for CH%s_TX_LOOP_INT.
          CH%s_X_LOOP: u1,

          /// [13:31] 
          res6: u19,

        }), @ptrFromInt(0x60006040));

        /// Interrupt clear bits
        pub const INT_CLR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Set this bit to clear theCH%s_TX_END_INT interrupt.
          CH%s_TX_END: u1,

          /// [1:1] 
          res0: u1,

          /// [2:2] Set this bit to clear theCH2_RX_END_INT interrupt.
          CH%s_RX_END: u1,

          /// [3:3] 
          res1: u1,

          /// [4:4] Set this bit to clear theCH4_ERR_INT interrupt.
          CH%s_TX_ERR: u1,

          /// [5:5] 
          res2: u1,

          /// [6:6] Set this bit to clear theCH6_ERR_INT interrupt.
          CH%s_RX_ERR: u1,

          /// [7:7] 
          res3: u1,

          /// [8:8] Set this bit to clear theCH%s_TX_THR_EVENT_INT interrupt.
          CH%s_TX_THR_EVENT: u1,

          /// [9:9] 
          res4: u1,

          /// [10:10] Set this bit to clear theCH2_RX_THR_EVENT_INT interrupt.
          CH%s_RX_THR_EVENT: u1,

          /// [11:11] 
          res5: u1,

          /// [12:12] Set this bit to clear theCH%s_TX_LOOP_INT interrupt.
          CH%s_TX_LOOP: u1,

          /// [13:31] 
          res6: u19,

        }), @ptrFromInt(0x60006044));

        /// Channel %s duty cycle configuration register
        pub const CH0CARRIER_DUTY = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:15] This register is used to configure carrier wave 's low level clock period for CHANNEL%s.
          CARRIER_LOW: u16,

          /// [16:31] This register is used to configure carrier wave 's high level clock period for CHANNEL%s.
          CARRIER_HIGH: u16,

        }), @ptrFromInt(0x60006048));

        /// Channel %s duty cycle configuration register
        pub const CH1CARRIER_DUTY = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:15] This register is used to configure carrier wave 's low level clock period for CHANNEL%s.
          CARRIER_LOW: u16,

          /// [16:31] This register is used to configure carrier wave 's high level clock period for CHANNEL%s.
          CARRIER_HIGH: u16,

        }), @ptrFromInt(0x6000604c));

        /// Channel %s carrier remove register
        pub const CH0_RX_CARRIER_RM = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:15] The low level period in a carrier modulation mode is (REG_RMT_REG_CARRIER_LOW_THRES_CH%s + 1) for channel %s.
          CARRIER_LOW_THRES: u16,

          /// [16:31] The high level period in a carrier modulation mode is (REG_RMT_REG_CARRIER_HIGH_THRES_CH%s + 1) for channel %s.
          CARRIER_HIGH_THRES: u16,

        }), @ptrFromInt(0x60006050));

        /// Channel %s carrier remove register
        pub const CH1_RX_CARRIER_RM = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:15] The low level period in a carrier modulation mode is (REG_RMT_REG_CARRIER_LOW_THRES_CH%s + 1) for channel %s.
          CARRIER_LOW_THRES: u16,

          /// [16:31] The high level period in a carrier modulation mode is (REG_RMT_REG_CARRIER_HIGH_THRES_CH%s + 1) for channel %s.
          CARRIER_HIGH_THRES: u16,

        }), @ptrFromInt(0x60006054));

        /// Channel %s Tx event configuration register
        pub const CH0_TX_LIM = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:8] This register is used to configure the maximum entries that CHANNEL%s can send out.
          TX_LIM: u9,

          /// [9:18] This register is used to configure the maximum loop count when tx_conti_mode is valid.
          TX_LOOP_NUM: u10,

          /// [19:19] This register is the enabled bit for loop count.
          TX_LOOP_CNT_EN: u1,

          /// [20:20] This register is used to reset the loop count when tx_conti_mode is valid.
          LOOP_COUNT_RESET: u1,

          /// [21:21] This bit is used to enable the loop send stop function after the loop counter counts toloop number for CHANNEL%s.
          LOOP_STOP_EN: u1,

          /// [22:31] 
          res0: u10,

        }), @ptrFromInt(0x60006058));

        /// Channel %s Tx event configuration register
        pub const CH1_TX_LIM = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:8] This register is used to configure the maximum entries that CHANNEL%s can send out.
          TX_LIM: u9,

          /// [9:18] This register is used to configure the maximum loop count when tx_conti_mode is valid.
          TX_LOOP_NUM: u10,

          /// [19:19] This register is the enabled bit for loop count.
          TX_LOOP_CNT_EN: u1,

          /// [20:20] This register is used to reset the loop count when tx_conti_mode is valid.
          LOOP_COUNT_RESET: u1,

          /// [21:21] This bit is used to enable the loop send stop function after the loop counter counts toloop number for CHANNEL%s.
          LOOP_STOP_EN: u1,

          /// [22:31] 
          res0: u10,

        }), @ptrFromInt(0x6000605c));

        /// Channel %s Rx event configuration register
        pub const CH0_RX_LIM = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:8] This register is used to configure the maximum entries that CHANNEL%s can receive.
          RMT_RX_LIM: u9,

          /// [9:31] 
          res0: u23,

        }), @ptrFromInt(0x60006060));

        /// Channel %s Rx event configuration register
        pub const CH1_RX_LIM = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:8] This register is used to configure the maximum entries that CHANNEL%s can receive.
          RMT_RX_LIM: u9,

          /// [9:31] 
          res0: u23,

        }), @ptrFromInt(0x60006064));

        /// RMT apb configuration register
        pub const SYS_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] 1'h1: access memory directly. 1'h0: access memory by FIFO.
          APB_FIFO_MASK: u1,

          /// [1:1] Set this bit to enable the clock for RMT memory.
          MEM_CLK_FORCE_ON: u1,

          /// [2:2] Set this bit to power down RMT memory.
          MEM_FORCE_PD: u1,

          /// [3:3] 1: Disable RMT memory light sleep power down function. 0: Power down RMT memory when RMT is in light sleep mode.
          MEM_FORCE_PU: u1,

          /// [4:11] the integral part of the fractional divisor
          SCLK_DIV_NUM: u8,

          /// [12:17] the numerator of the fractional part of the fractional divisor
          SCLK_DIV_A: u6,

          /// [18:23] the denominator of the fractional part of the fractional divisor
          SCLK_DIV_B: u6,

          /// [24:25] choose the clock source of rmt_sclk. 1:CLK_80Mhz,2:CLK_FOSC, 3:XTAL
          SCLK_SEL: u2,

          /// [26:26] rmt_sclk switch
          SCLK_ACTIVE: u1,

          /// [27:30] 
          res0: u4,

          /// [31:31] RMT register clock gate enable signal. 1: Power up the drive clock of registers. 0: Power down the drive clock of registers
          CLK_EN: u1,

        }), @ptrFromInt(0x60006068));

        /// RMT TX synchronous register
        pub const TX_SIM = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Set this bit to enable CHANNEL0 to start sending data synchronously with other enabled channels.
          CH0: u1,

          /// [1:1] Set this bit to enable CHANNEL1 to start sending data synchronously with other enabled channels.
          CH1: u1,

          /// [2:2] This register is used to enable multiple of channels to start sending data synchronously.
          EN: u1,

          /// [3:31] 
          res0: u29,

        }), @ptrFromInt(0x6000606c));

        /// RMT clock divider reset register
        pub const REF_CNT_RST = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] This register is used to reset the clock divider of CHANNEL0.
          TX_REF_CNT_RST: u1,

          /// [1:1] This register is used to reset the clock divider of CHANNEL1.
          TX_REF_CNT_RST_CH1: u1,

          /// [2:2] This register is used to reset the clock divider of CHANNEL2.
          RX_REF_CNT_RST_CH2: u1,

          /// [3:3] This register is used to reset the clock divider of CHANNEL3.
          RX_REF_CNT_RST_CH3: u1,

          /// [4:31] 
          res0: u28,

        }), @ptrFromInt(0x60006070));

        /// RMT version register
        pub const DATE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:27] This is the version register.
          RMT_DATE: u28,

          /// [28:31] 
          res0: u4,

        }), @ptrFromInt(0x600060cc));

      };

      /// Hardware Random Number Generator
      pub const RNG = struct {

        /// Random number data
        pub const DATA = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] 
          raw: u32,

        }), @ptrFromInt(0x600b2808));

      };

      /// RSA (Rivest Shamir Adleman) Accelerator
      pub const RSA = struct {

        /// The memory that stores M
        pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a000));

        /// The memory that stores M
        pub const M_MEM1 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a001));

        /// The memory that stores M
        pub const M_MEM2 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a002));

        /// The memory that stores M
        pub const M_MEM3 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a003));

        /// The memory that stores M
        pub const M_MEM4 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a004));

        /// The memory that stores M
        pub const M_MEM5 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a005));

        /// The memory that stores M
        pub const M_MEM6 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a006));

        /// The memory that stores M
        pub const M_MEM7 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a007));

        /// The memory that stores M
        pub const M_MEM8 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a008));

        /// The memory that stores M
        pub const M_MEM9 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a009));

        /// The memory that stores M
        pub const M_MEM10 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a00a));

        /// The memory that stores M
        pub const M_MEM11 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a00b));

        /// The memory that stores M
        pub const M_MEM12 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a00c));

        /// The memory that stores M
        pub const M_MEM13 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a00d));

        /// The memory that stores M
        pub const M_MEM14 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a00e));

        /// The memory that stores M
        pub const M_MEM15 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a00f));

        /// The memory that stores M
        pub const M_MEM16 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a010));

        /// The memory that stores M
        pub const M_MEM17 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a011));

        /// The memory that stores M
        pub const M_MEM18 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a012));

        /// The memory that stores M
        pub const M_MEM19 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a013));

        /// The memory that stores M
        pub const M_MEM20 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a014));

        /// The memory that stores M
        pub const M_MEM21 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a015));

        /// The memory that stores M
        pub const M_MEM22 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a016));

        /// The memory that stores M
        pub const M_MEM23 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a017));

        /// The memory that stores M
        pub const M_MEM24 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a018));

        /// The memory that stores M
        pub const M_MEM25 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a019));

        /// The memory that stores M
        pub const M_MEM26 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a01a));

        /// The memory that stores M
        pub const M_MEM27 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a01b));

        /// The memory that stores M
        pub const M_MEM28 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a01c));

        /// The memory that stores M
        pub const M_MEM29 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a01d));

        /// The memory that stores M
        pub const M_MEM30 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a01e));

        /// The memory that stores M
        pub const M_MEM31 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a01f));

        /// The memory that stores M
        pub const M_MEM32 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a020));

        /// The memory that stores M
        pub const M_MEM33 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a021));

        /// The memory that stores M
        pub const M_MEM34 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a022));

        /// The memory that stores M
        pub const M_MEM35 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a023));

        /// The memory that stores M
        pub const M_MEM36 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a024));

        /// The memory that stores M
        pub const M_MEM37 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a025));

        /// The memory that stores M
        pub const M_MEM38 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a026));

        /// The memory that stores M
        pub const M_MEM39 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a027));

        /// The memory that stores M
        pub const M_MEM40 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a028));

        /// The memory that stores M
        pub const M_MEM41 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a029));

        /// The memory that stores M
        pub const M_MEM42 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a02a));

        /// The memory that stores M
        pub const M_MEM43 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a02b));

        /// The memory that stores M
        pub const M_MEM44 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a02c));

        /// The memory that stores M
        pub const M_MEM45 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a02d));

        /// The memory that stores M
        pub const M_MEM46 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a02e));

        /// The memory that stores M
        pub const M_MEM47 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a02f));

        /// The memory that stores M
        pub const M_MEM48 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a030));

        /// The memory that stores M
        pub const M_MEM49 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a031));

        /// The memory that stores M
        pub const M_MEM50 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a032));

        /// The memory that stores M
        pub const M_MEM51 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a033));

        /// The memory that stores M
        pub const M_MEM52 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a034));

        /// The memory that stores M
        pub const M_MEM53 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a035));

        /// The memory that stores M
        pub const M_MEM54 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a036));

        /// The memory that stores M
        pub const M_MEM55 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a037));

        /// The memory that stores M
        pub const M_MEM56 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a038));

        /// The memory that stores M
        pub const M_MEM57 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a039));

        /// The memory that stores M
        pub const M_MEM58 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a03a));

        /// The memory that stores M
        pub const M_MEM59 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a03b));

        /// The memory that stores M
        pub const M_MEM60 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a03c));

        /// The memory that stores M
        pub const M_MEM61 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a03d));

        /// The memory that stores M
        pub const M_MEM62 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a03e));

        /// The memory that stores M
        pub const M_MEM63 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a03f));

        /// The memory that stores M
        pub const M_MEM64 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a040));

        /// The memory that stores M
        pub const M_MEM65 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a041));

        /// The memory that stores M
        pub const M_MEM66 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a042));

        /// The memory that stores M
        pub const M_MEM67 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a043));

        /// The memory that stores M
        pub const M_MEM68 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a044));

        /// The memory that stores M
        pub const M_MEM69 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a045));

        /// The memory that stores M
        pub const M_MEM70 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a046));

        /// The memory that stores M
        pub const M_MEM71 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a047));

        /// The memory that stores M
        pub const M_MEM72 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a048));

        /// The memory that stores M
        pub const M_MEM73 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a049));

        /// The memory that stores M
        pub const M_MEM74 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a04a));

        /// The memory that stores M
        pub const M_MEM75 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a04b));

        /// The memory that stores M
        pub const M_MEM76 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a04c));

        /// The memory that stores M
        pub const M_MEM77 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a04d));

        /// The memory that stores M
        pub const M_MEM78 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a04e));

        /// The memory that stores M
        pub const M_MEM79 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a04f));

        /// The memory that stores M
        pub const M_MEM80 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a050));

        /// The memory that stores M
        pub const M_MEM81 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a051));

        /// The memory that stores M
        pub const M_MEM82 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a052));

        /// The memory that stores M
        pub const M_MEM83 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a053));

        /// The memory that stores M
        pub const M_MEM84 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a054));

        /// The memory that stores M
        pub const M_MEM85 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a055));

        /// The memory that stores M
        pub const M_MEM86 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a056));

        /// The memory that stores M
        pub const M_MEM87 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a057));

        /// The memory that stores M
        pub const M_MEM88 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a058));

        /// The memory that stores M
        pub const M_MEM89 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a059));

        /// The memory that stores M
        pub const M_MEM90 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a05a));

        /// The memory that stores M
        pub const M_MEM91 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a05b));

        /// The memory that stores M
        pub const M_MEM92 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a05c));

        /// The memory that stores M
        pub const M_MEM93 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a05d));

        /// The memory that stores M
        pub const M_MEM94 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a05e));

        /// The memory that stores M
        pub const M_MEM95 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a05f));

        /// The memory that stores M
        pub const M_MEM96 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a060));

        /// The memory that stores M
        pub const M_MEM97 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a061));

        /// The memory that stores M
        pub const M_MEM98 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a062));

        /// The memory that stores M
        pub const M_MEM99 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a063));

        /// The memory that stores M
        pub const M_MEM100 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a064));

        /// The memory that stores M
        pub const M_MEM101 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a065));

        /// The memory that stores M
        pub const M_MEM102 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a066));

        /// The memory that stores M
        pub const M_MEM103 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a067));

        /// The memory that stores M
        pub const M_MEM104 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a068));

        /// The memory that stores M
        pub const M_MEM105 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a069));

        /// The memory that stores M
        pub const M_MEM106 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a06a));

        /// The memory that stores M
        pub const M_MEM107 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a06b));

        /// The memory that stores M
        pub const M_MEM108 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a06c));

        /// The memory that stores M
        pub const M_MEM109 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a06d));

        /// The memory that stores M
        pub const M_MEM110 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a06e));

        /// The memory that stores M
        pub const M_MEM111 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a06f));

        /// The memory that stores M
        pub const M_MEM112 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a070));

        /// The memory that stores M
        pub const M_MEM113 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a071));

        /// The memory that stores M
        pub const M_MEM114 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a072));

        /// The memory that stores M
        pub const M_MEM115 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a073));

        /// The memory that stores M
        pub const M_MEM116 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a074));

        /// The memory that stores M
        pub const M_MEM117 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a075));

        /// The memory that stores M
        pub const M_MEM118 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a076));

        /// The memory that stores M
        pub const M_MEM119 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a077));

        /// The memory that stores M
        pub const M_MEM120 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a078));

        /// The memory that stores M
        pub const M_MEM121 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a079));

        /// The memory that stores M
        pub const M_MEM122 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a07a));

        /// The memory that stores M
        pub const M_MEM123 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a07b));

        /// The memory that stores M
        pub const M_MEM124 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a07c));

        /// The memory that stores M
        pub const M_MEM125 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a07d));

        /// The memory that stores M
        pub const M_MEM126 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a07e));

        /// The memory that stores M
        pub const M_MEM127 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a07f));

        /// The memory that stores M
        pub const M_MEM128 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a080));

        /// The memory that stores M
        pub const M_MEM129 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a081));

        /// The memory that stores M
        pub const M_MEM130 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a082));

        /// The memory that stores M
        pub const M_MEM131 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a083));

        /// The memory that stores M
        pub const M_MEM132 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a084));

        /// The memory that stores M
        pub const M_MEM133 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a085));

        /// The memory that stores M
        pub const M_MEM134 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a086));

        /// The memory that stores M
        pub const M_MEM135 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a087));

        /// The memory that stores M
        pub const M_MEM136 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a088));

        /// The memory that stores M
        pub const M_MEM137 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a089));

        /// The memory that stores M
        pub const M_MEM138 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a08a));

        /// The memory that stores M
        pub const M_MEM139 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a08b));

        /// The memory that stores M
        pub const M_MEM140 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a08c));

        /// The memory that stores M
        pub const M_MEM141 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a08d));

        /// The memory that stores M
        pub const M_MEM142 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a08e));

        /// The memory that stores M
        pub const M_MEM143 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a08f));

        /// The memory that stores M
        pub const M_MEM144 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a090));

        /// The memory that stores M
        pub const M_MEM145 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a091));

        /// The memory that stores M
        pub const M_MEM146 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a092));

        /// The memory that stores M
        pub const M_MEM147 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a093));

        /// The memory that stores M
        pub const M_MEM148 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a094));

        /// The memory that stores M
        pub const M_MEM149 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a095));

        /// The memory that stores M
        pub const M_MEM150 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a096));

        /// The memory that stores M
        pub const M_MEM151 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a097));

        /// The memory that stores M
        pub const M_MEM152 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a098));

        /// The memory that stores M
        pub const M_MEM153 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a099));

        /// The memory that stores M
        pub const M_MEM154 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a09a));

        /// The memory that stores M
        pub const M_MEM155 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a09b));

        /// The memory that stores M
        pub const M_MEM156 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a09c));

        /// The memory that stores M
        pub const M_MEM157 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a09d));

        /// The memory that stores M
        pub const M_MEM158 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a09e));

        /// The memory that stores M
        pub const M_MEM159 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a09f));

        /// The memory that stores M
        pub const M_MEM160 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a0a0));

        /// The memory that stores M
        pub const M_MEM161 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a0a1));

        /// The memory that stores M
        pub const M_MEM162 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a0a2));

        /// The memory that stores M
        pub const M_MEM163 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a0a3));

        /// The memory that stores M
        pub const M_MEM164 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a0a4));

        /// The memory that stores M
        pub const M_MEM165 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a0a5));

        /// The memory that stores M
        pub const M_MEM166 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a0a6));

        /// The memory that stores M
        pub const M_MEM167 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a0a7));

        /// The memory that stores M
        pub const M_MEM168 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a0a8));

        /// The memory that stores M
        pub const M_MEM169 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a0a9));

        /// The memory that stores M
        pub const M_MEM170 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a0aa));

        /// The memory that stores M
        pub const M_MEM171 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a0ab));

        /// The memory that stores M
        pub const M_MEM172 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a0ac));

        /// The memory that stores M
        pub const M_MEM173 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a0ad));

        /// The memory that stores M
        pub const M_MEM174 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a0ae));

        /// The memory that stores M
        pub const M_MEM175 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a0af));

        /// The memory that stores M
        pub const M_MEM176 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a0b0));

        /// The memory that stores M
        pub const M_MEM177 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a0b1));

        /// The memory that stores M
        pub const M_MEM178 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a0b2));

        /// The memory that stores M
        pub const M_MEM179 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a0b3));

        /// The memory that stores M
        pub const M_MEM180 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a0b4));

        /// The memory that stores M
        pub const M_MEM181 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a0b5));

        /// The memory that stores M
        pub const M_MEM182 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a0b6));

        /// The memory that stores M
        pub const M_MEM183 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a0b7));

        /// The memory that stores M
        pub const M_MEM184 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a0b8));

        /// The memory that stores M
        pub const M_MEM185 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a0b9));

        /// The memory that stores M
        pub const M_MEM186 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a0ba));

        /// The memory that stores M
        pub const M_MEM187 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a0bb));

        /// The memory that stores M
        pub const M_MEM188 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a0bc));

        /// The memory that stores M
        pub const M_MEM189 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a0bd));

        /// The memory that stores M
        pub const M_MEM190 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a0be));

        /// The memory that stores M
        pub const M_MEM191 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a0bf));

        /// The memory that stores M
        pub const M_MEM192 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a0c0));

        /// The memory that stores M
        pub const M_MEM193 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a0c1));

        /// The memory that stores M
        pub const M_MEM194 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a0c2));

        /// The memory that stores M
        pub const M_MEM195 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a0c3));

        /// The memory that stores M
        pub const M_MEM196 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a0c4));

        /// The memory that stores M
        pub const M_MEM197 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a0c5));

        /// The memory that stores M
        pub const M_MEM198 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a0c6));

        /// The memory that stores M
        pub const M_MEM199 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a0c7));

        /// The memory that stores M
        pub const M_MEM200 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a0c8));

        /// The memory that stores M
        pub const M_MEM201 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a0c9));

        /// The memory that stores M
        pub const M_MEM202 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a0ca));

        /// The memory that stores M
        pub const M_MEM203 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a0cb));

        /// The memory that stores M
        pub const M_MEM204 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a0cc));

        /// The memory that stores M
        pub const M_MEM205 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a0cd));

        /// The memory that stores M
        pub const M_MEM206 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a0ce));

        /// The memory that stores M
        pub const M_MEM207 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a0cf));

        /// The memory that stores M
        pub const M_MEM208 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a0d0));

        /// The memory that stores M
        pub const M_MEM209 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a0d1));

        /// The memory that stores M
        pub const M_MEM210 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a0d2));

        /// The memory that stores M
        pub const M_MEM211 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a0d3));

        /// The memory that stores M
        pub const M_MEM212 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a0d4));

        /// The memory that stores M
        pub const M_MEM213 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a0d5));

        /// The memory that stores M
        pub const M_MEM214 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a0d6));

        /// The memory that stores M
        pub const M_MEM215 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a0d7));

        /// The memory that stores M
        pub const M_MEM216 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a0d8));

        /// The memory that stores M
        pub const M_MEM217 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a0d9));

        /// The memory that stores M
        pub const M_MEM218 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a0da));

        /// The memory that stores M
        pub const M_MEM219 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a0db));

        /// The memory that stores M
        pub const M_MEM220 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a0dc));

        /// The memory that stores M
        pub const M_MEM221 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a0dd));

        /// The memory that stores M
        pub const M_MEM222 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a0de));

        /// The memory that stores M
        pub const M_MEM223 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a0df));

        /// The memory that stores M
        pub const M_MEM224 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a0e0));

        /// The memory that stores M
        pub const M_MEM225 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a0e1));

        /// The memory that stores M
        pub const M_MEM226 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a0e2));

        /// The memory that stores M
        pub const M_MEM227 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a0e3));

        /// The memory that stores M
        pub const M_MEM228 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a0e4));

        /// The memory that stores M
        pub const M_MEM229 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a0e5));

        /// The memory that stores M
        pub const M_MEM230 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a0e6));

        /// The memory that stores M
        pub const M_MEM231 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a0e7));

        /// The memory that stores M
        pub const M_MEM232 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a0e8));

        /// The memory that stores M
        pub const M_MEM233 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a0e9));

        /// The memory that stores M
        pub const M_MEM234 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a0ea));

        /// The memory that stores M
        pub const M_MEM235 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a0eb));

        /// The memory that stores M
        pub const M_MEM236 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a0ec));

        /// The memory that stores M
        pub const M_MEM237 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a0ed));

        /// The memory that stores M
        pub const M_MEM238 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a0ee));

        /// The memory that stores M
        pub const M_MEM239 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a0ef));

        /// The memory that stores M
        pub const M_MEM240 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a0f0));

        /// The memory that stores M
        pub const M_MEM241 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a0f1));

        /// The memory that stores M
        pub const M_MEM242 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a0f2));

        /// The memory that stores M
        pub const M_MEM243 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a0f3));

        /// The memory that stores M
        pub const M_MEM244 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a0f4));

        /// The memory that stores M
        pub const M_MEM245 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a0f5));

        /// The memory that stores M
        pub const M_MEM246 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a0f6));

        /// The memory that stores M
        pub const M_MEM247 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a0f7));

        /// The memory that stores M
        pub const M_MEM248 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a0f8));

        /// The memory that stores M
        pub const M_MEM249 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a0f9));

        /// The memory that stores M
        pub const M_MEM250 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a0fa));

        /// The memory that stores M
        pub const M_MEM251 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a0fb));

        /// The memory that stores M
        pub const M_MEM252 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a0fc));

        /// The memory that stores M
        pub const M_MEM253 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a0fd));

        /// The memory that stores M
        pub const M_MEM254 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a0fe));

        /// The memory that stores M
        pub const M_MEM255 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a0ff));

        /// The memory that stores M
        pub const M_MEM256 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a100));

        /// The memory that stores M
        pub const M_MEM257 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a101));

        /// The memory that stores M
        pub const M_MEM258 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a102));

        /// The memory that stores M
        pub const M_MEM259 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a103));

        /// The memory that stores M
        pub const M_MEM260 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a104));

        /// The memory that stores M
        pub const M_MEM261 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a105));

        /// The memory that stores M
        pub const M_MEM262 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a106));

        /// The memory that stores M
        pub const M_MEM263 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a107));

        /// The memory that stores M
        pub const M_MEM264 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a108));

        /// The memory that stores M
        pub const M_MEM265 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a109));

        /// The memory that stores M
        pub const M_MEM266 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a10a));

        /// The memory that stores M
        pub const M_MEM267 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a10b));

        /// The memory that stores M
        pub const M_MEM268 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a10c));

        /// The memory that stores M
        pub const M_MEM269 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a10d));

        /// The memory that stores M
        pub const M_MEM270 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a10e));

        /// The memory that stores M
        pub const M_MEM271 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a10f));

        /// The memory that stores M
        pub const M_MEM272 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a110));

        /// The memory that stores M
        pub const M_MEM273 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a111));

        /// The memory that stores M
        pub const M_MEM274 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a112));

        /// The memory that stores M
        pub const M_MEM275 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a113));

        /// The memory that stores M
        pub const M_MEM276 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a114));

        /// The memory that stores M
        pub const M_MEM277 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a115));

        /// The memory that stores M
        pub const M_MEM278 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a116));

        /// The memory that stores M
        pub const M_MEM279 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a117));

        /// The memory that stores M
        pub const M_MEM280 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a118));

        /// The memory that stores M
        pub const M_MEM281 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a119));

        /// The memory that stores M
        pub const M_MEM282 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a11a));

        /// The memory that stores M
        pub const M_MEM283 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a11b));

        /// The memory that stores M
        pub const M_MEM284 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a11c));

        /// The memory that stores M
        pub const M_MEM285 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a11d));

        /// The memory that stores M
        pub const M_MEM286 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a11e));

        /// The memory that stores M
        pub const M_MEM287 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a11f));

        /// The memory that stores M
        pub const M_MEM288 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a120));

        /// The memory that stores M
        pub const M_MEM289 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a121));

        /// The memory that stores M
        pub const M_MEM290 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a122));

        /// The memory that stores M
        pub const M_MEM291 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a123));

        /// The memory that stores M
        pub const M_MEM292 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a124));

        /// The memory that stores M
        pub const M_MEM293 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a125));

        /// The memory that stores M
        pub const M_MEM294 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a126));

        /// The memory that stores M
        pub const M_MEM295 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a127));

        /// The memory that stores M
        pub const M_MEM296 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a128));

        /// The memory that stores M
        pub const M_MEM297 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a129));

        /// The memory that stores M
        pub const M_MEM298 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a12a));

        /// The memory that stores M
        pub const M_MEM299 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a12b));

        /// The memory that stores M
        pub const M_MEM300 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a12c));

        /// The memory that stores M
        pub const M_MEM301 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a12d));

        /// The memory that stores M
        pub const M_MEM302 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a12e));

        /// The memory that stores M
        pub const M_MEM303 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a12f));

        /// The memory that stores M
        pub const M_MEM304 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a130));

        /// The memory that stores M
        pub const M_MEM305 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a131));

        /// The memory that stores M
        pub const M_MEM306 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a132));

        /// The memory that stores M
        pub const M_MEM307 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a133));

        /// The memory that stores M
        pub const M_MEM308 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a134));

        /// The memory that stores M
        pub const M_MEM309 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a135));

        /// The memory that stores M
        pub const M_MEM310 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a136));

        /// The memory that stores M
        pub const M_MEM311 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a137));

        /// The memory that stores M
        pub const M_MEM312 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a138));

        /// The memory that stores M
        pub const M_MEM313 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a139));

        /// The memory that stores M
        pub const M_MEM314 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a13a));

        /// The memory that stores M
        pub const M_MEM315 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a13b));

        /// The memory that stores M
        pub const M_MEM316 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a13c));

        /// The memory that stores M
        pub const M_MEM317 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a13d));

        /// The memory that stores M
        pub const M_MEM318 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a13e));

        /// The memory that stores M
        pub const M_MEM319 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a13f));

        /// The memory that stores M
        pub const M_MEM320 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a140));

        /// The memory that stores M
        pub const M_MEM321 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a141));

        /// The memory that stores M
        pub const M_MEM322 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a142));

        /// The memory that stores M
        pub const M_MEM323 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a143));

        /// The memory that stores M
        pub const M_MEM324 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a144));

        /// The memory that stores M
        pub const M_MEM325 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a145));

        /// The memory that stores M
        pub const M_MEM326 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a146));

        /// The memory that stores M
        pub const M_MEM327 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a147));

        /// The memory that stores M
        pub const M_MEM328 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a148));

        /// The memory that stores M
        pub const M_MEM329 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a149));

        /// The memory that stores M
        pub const M_MEM330 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a14a));

        /// The memory that stores M
        pub const M_MEM331 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a14b));

        /// The memory that stores M
        pub const M_MEM332 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a14c));

        /// The memory that stores M
        pub const M_MEM333 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a14d));

        /// The memory that stores M
        pub const M_MEM334 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a14e));

        /// The memory that stores M
        pub const M_MEM335 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a14f));

        /// The memory that stores M
        pub const M_MEM336 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a150));

        /// The memory that stores M
        pub const M_MEM337 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a151));

        /// The memory that stores M
        pub const M_MEM338 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a152));

        /// The memory that stores M
        pub const M_MEM339 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a153));

        /// The memory that stores M
        pub const M_MEM340 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a154));

        /// The memory that stores M
        pub const M_MEM341 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a155));

        /// The memory that stores M
        pub const M_MEM342 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a156));

        /// The memory that stores M
        pub const M_MEM343 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a157));

        /// The memory that stores M
        pub const M_MEM344 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a158));

        /// The memory that stores M
        pub const M_MEM345 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a159));

        /// The memory that stores M
        pub const M_MEM346 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a15a));

        /// The memory that stores M
        pub const M_MEM347 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a15b));

        /// The memory that stores M
        pub const M_MEM348 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a15c));

        /// The memory that stores M
        pub const M_MEM349 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a15d));

        /// The memory that stores M
        pub const M_MEM350 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a15e));

        /// The memory that stores M
        pub const M_MEM351 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a15f));

        /// The memory that stores M
        pub const M_MEM352 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a160));

        /// The memory that stores M
        pub const M_MEM353 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a161));

        /// The memory that stores M
        pub const M_MEM354 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a162));

        /// The memory that stores M
        pub const M_MEM355 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a163));

        /// The memory that stores M
        pub const M_MEM356 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a164));

        /// The memory that stores M
        pub const M_MEM357 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a165));

        /// The memory that stores M
        pub const M_MEM358 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a166));

        /// The memory that stores M
        pub const M_MEM359 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a167));

        /// The memory that stores M
        pub const M_MEM360 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a168));

        /// The memory that stores M
        pub const M_MEM361 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a169));

        /// The memory that stores M
        pub const M_MEM362 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a16a));

        /// The memory that stores M
        pub const M_MEM363 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a16b));

        /// The memory that stores M
        pub const M_MEM364 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a16c));

        /// The memory that stores M
        pub const M_MEM365 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a16d));

        /// The memory that stores M
        pub const M_MEM366 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a16e));

        /// The memory that stores M
        pub const M_MEM367 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a16f));

        /// The memory that stores M
        pub const M_MEM368 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a170));

        /// The memory that stores M
        pub const M_MEM369 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a171));

        /// The memory that stores M
        pub const M_MEM370 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a172));

        /// The memory that stores M
        pub const M_MEM371 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a173));

        /// The memory that stores M
        pub const M_MEM372 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a174));

        /// The memory that stores M
        pub const M_MEM373 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a175));

        /// The memory that stores M
        pub const M_MEM374 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a176));

        /// The memory that stores M
        pub const M_MEM375 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a177));

        /// The memory that stores M
        pub const M_MEM376 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a178));

        /// The memory that stores M
        pub const M_MEM377 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a179));

        /// The memory that stores M
        pub const M_MEM378 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a17a));

        /// The memory that stores M
        pub const M_MEM379 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a17b));

        /// The memory that stores M
        pub const M_MEM380 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a17c));

        /// The memory that stores M
        pub const M_MEM381 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a17d));

        /// The memory that stores M
        pub const M_MEM382 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a17e));

        /// The memory that stores M
        pub const M_MEM383 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a17f));

        /// The memory that stores Z
        pub const Z_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a200));

        /// The memory that stores Z
        pub const Z_MEM1 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a201));

        /// The memory that stores Z
        pub const Z_MEM2 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a202));

        /// The memory that stores Z
        pub const Z_MEM3 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a203));

        /// The memory that stores Z
        pub const Z_MEM4 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a204));

        /// The memory that stores Z
        pub const Z_MEM5 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a205));

        /// The memory that stores Z
        pub const Z_MEM6 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a206));

        /// The memory that stores Z
        pub const Z_MEM7 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a207));

        /// The memory that stores Z
        pub const Z_MEM8 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a208));

        /// The memory that stores Z
        pub const Z_MEM9 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a209));

        /// The memory that stores Z
        pub const Z_MEM10 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a20a));

        /// The memory that stores Z
        pub const Z_MEM11 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a20b));

        /// The memory that stores Z
        pub const Z_MEM12 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a20c));

        /// The memory that stores Z
        pub const Z_MEM13 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a20d));

        /// The memory that stores Z
        pub const Z_MEM14 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a20e));

        /// The memory that stores Z
        pub const Z_MEM15 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a20f));

        /// The memory that stores Z
        pub const Z_MEM16 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a210));

        /// The memory that stores Z
        pub const Z_MEM17 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a211));

        /// The memory that stores Z
        pub const Z_MEM18 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a212));

        /// The memory that stores Z
        pub const Z_MEM19 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a213));

        /// The memory that stores Z
        pub const Z_MEM20 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a214));

        /// The memory that stores Z
        pub const Z_MEM21 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a215));

        /// The memory that stores Z
        pub const Z_MEM22 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a216));

        /// The memory that stores Z
        pub const Z_MEM23 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a217));

        /// The memory that stores Z
        pub const Z_MEM24 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a218));

        /// The memory that stores Z
        pub const Z_MEM25 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a219));

        /// The memory that stores Z
        pub const Z_MEM26 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a21a));

        /// The memory that stores Z
        pub const Z_MEM27 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a21b));

        /// The memory that stores Z
        pub const Z_MEM28 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a21c));

        /// The memory that stores Z
        pub const Z_MEM29 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a21d));

        /// The memory that stores Z
        pub const Z_MEM30 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a21e));

        /// The memory that stores Z
        pub const Z_MEM31 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a21f));

        /// The memory that stores Z
        pub const Z_MEM32 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a220));

        /// The memory that stores Z
        pub const Z_MEM33 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a221));

        /// The memory that stores Z
        pub const Z_MEM34 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a222));

        /// The memory that stores Z
        pub const Z_MEM35 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a223));

        /// The memory that stores Z
        pub const Z_MEM36 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a224));

        /// The memory that stores Z
        pub const Z_MEM37 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a225));

        /// The memory that stores Z
        pub const Z_MEM38 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a226));

        /// The memory that stores Z
        pub const Z_MEM39 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a227));

        /// The memory that stores Z
        pub const Z_MEM40 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a228));

        /// The memory that stores Z
        pub const Z_MEM41 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a229));

        /// The memory that stores Z
        pub const Z_MEM42 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a22a));

        /// The memory that stores Z
        pub const Z_MEM43 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a22b));

        /// The memory that stores Z
        pub const Z_MEM44 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a22c));

        /// The memory that stores Z
        pub const Z_MEM45 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a22d));

        /// The memory that stores Z
        pub const Z_MEM46 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a22e));

        /// The memory that stores Z
        pub const Z_MEM47 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a22f));

        /// The memory that stores Z
        pub const Z_MEM48 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a230));

        /// The memory that stores Z
        pub const Z_MEM49 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a231));

        /// The memory that stores Z
        pub const Z_MEM50 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a232));

        /// The memory that stores Z
        pub const Z_MEM51 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a233));

        /// The memory that stores Z
        pub const Z_MEM52 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a234));

        /// The memory that stores Z
        pub const Z_MEM53 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a235));

        /// The memory that stores Z
        pub const Z_MEM54 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a236));

        /// The memory that stores Z
        pub const Z_MEM55 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a237));

        /// The memory that stores Z
        pub const Z_MEM56 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a238));

        /// The memory that stores Z
        pub const Z_MEM57 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a239));

        /// The memory that stores Z
        pub const Z_MEM58 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a23a));

        /// The memory that stores Z
        pub const Z_MEM59 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a23b));

        /// The memory that stores Z
        pub const Z_MEM60 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a23c));

        /// The memory that stores Z
        pub const Z_MEM61 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a23d));

        /// The memory that stores Z
        pub const Z_MEM62 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a23e));

        /// The memory that stores Z
        pub const Z_MEM63 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a23f));

        /// The memory that stores Z
        pub const Z_MEM64 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a240));

        /// The memory that stores Z
        pub const Z_MEM65 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a241));

        /// The memory that stores Z
        pub const Z_MEM66 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a242));

        /// The memory that stores Z
        pub const Z_MEM67 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a243));

        /// The memory that stores Z
        pub const Z_MEM68 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a244));

        /// The memory that stores Z
        pub const Z_MEM69 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a245));

        /// The memory that stores Z
        pub const Z_MEM70 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a246));

        /// The memory that stores Z
        pub const Z_MEM71 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a247));

        /// The memory that stores Z
        pub const Z_MEM72 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a248));

        /// The memory that stores Z
        pub const Z_MEM73 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a249));

        /// The memory that stores Z
        pub const Z_MEM74 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a24a));

        /// The memory that stores Z
        pub const Z_MEM75 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a24b));

        /// The memory that stores Z
        pub const Z_MEM76 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a24c));

        /// The memory that stores Z
        pub const Z_MEM77 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a24d));

        /// The memory that stores Z
        pub const Z_MEM78 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a24e));

        /// The memory that stores Z
        pub const Z_MEM79 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a24f));

        /// The memory that stores Z
        pub const Z_MEM80 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a250));

        /// The memory that stores Z
        pub const Z_MEM81 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a251));

        /// The memory that stores Z
        pub const Z_MEM82 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a252));

        /// The memory that stores Z
        pub const Z_MEM83 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a253));

        /// The memory that stores Z
        pub const Z_MEM84 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a254));

        /// The memory that stores Z
        pub const Z_MEM85 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a255));

        /// The memory that stores Z
        pub const Z_MEM86 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a256));

        /// The memory that stores Z
        pub const Z_MEM87 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a257));

        /// The memory that stores Z
        pub const Z_MEM88 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a258));

        /// The memory that stores Z
        pub const Z_MEM89 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a259));

        /// The memory that stores Z
        pub const Z_MEM90 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a25a));

        /// The memory that stores Z
        pub const Z_MEM91 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a25b));

        /// The memory that stores Z
        pub const Z_MEM92 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a25c));

        /// The memory that stores Z
        pub const Z_MEM93 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a25d));

        /// The memory that stores Z
        pub const Z_MEM94 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a25e));

        /// The memory that stores Z
        pub const Z_MEM95 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a25f));

        /// The memory that stores Z
        pub const Z_MEM96 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a260));

        /// The memory that stores Z
        pub const Z_MEM97 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a261));

        /// The memory that stores Z
        pub const Z_MEM98 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a262));

        /// The memory that stores Z
        pub const Z_MEM99 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a263));

        /// The memory that stores Z
        pub const Z_MEM100 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a264));

        /// The memory that stores Z
        pub const Z_MEM101 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a265));

        /// The memory that stores Z
        pub const Z_MEM102 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a266));

        /// The memory that stores Z
        pub const Z_MEM103 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a267));

        /// The memory that stores Z
        pub const Z_MEM104 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a268));

        /// The memory that stores Z
        pub const Z_MEM105 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a269));

        /// The memory that stores Z
        pub const Z_MEM106 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a26a));

        /// The memory that stores Z
        pub const Z_MEM107 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a26b));

        /// The memory that stores Z
        pub const Z_MEM108 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a26c));

        /// The memory that stores Z
        pub const Z_MEM109 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a26d));

        /// The memory that stores Z
        pub const Z_MEM110 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a26e));

        /// The memory that stores Z
        pub const Z_MEM111 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a26f));

        /// The memory that stores Z
        pub const Z_MEM112 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a270));

        /// The memory that stores Z
        pub const Z_MEM113 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a271));

        /// The memory that stores Z
        pub const Z_MEM114 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a272));

        /// The memory that stores Z
        pub const Z_MEM115 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a273));

        /// The memory that stores Z
        pub const Z_MEM116 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a274));

        /// The memory that stores Z
        pub const Z_MEM117 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a275));

        /// The memory that stores Z
        pub const Z_MEM118 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a276));

        /// The memory that stores Z
        pub const Z_MEM119 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a277));

        /// The memory that stores Z
        pub const Z_MEM120 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a278));

        /// The memory that stores Z
        pub const Z_MEM121 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a279));

        /// The memory that stores Z
        pub const Z_MEM122 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a27a));

        /// The memory that stores Z
        pub const Z_MEM123 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a27b));

        /// The memory that stores Z
        pub const Z_MEM124 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a27c));

        /// The memory that stores Z
        pub const Z_MEM125 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a27d));

        /// The memory that stores Z
        pub const Z_MEM126 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a27e));

        /// The memory that stores Z
        pub const Z_MEM127 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a27f));

        /// The memory that stores Z
        pub const Z_MEM128 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a280));

        /// The memory that stores Z
        pub const Z_MEM129 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a281));

        /// The memory that stores Z
        pub const Z_MEM130 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a282));

        /// The memory that stores Z
        pub const Z_MEM131 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a283));

        /// The memory that stores Z
        pub const Z_MEM132 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a284));

        /// The memory that stores Z
        pub const Z_MEM133 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a285));

        /// The memory that stores Z
        pub const Z_MEM134 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a286));

        /// The memory that stores Z
        pub const Z_MEM135 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a287));

        /// The memory that stores Z
        pub const Z_MEM136 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a288));

        /// The memory that stores Z
        pub const Z_MEM137 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a289));

        /// The memory that stores Z
        pub const Z_MEM138 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a28a));

        /// The memory that stores Z
        pub const Z_MEM139 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a28b));

        /// The memory that stores Z
        pub const Z_MEM140 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a28c));

        /// The memory that stores Z
        pub const Z_MEM141 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a28d));

        /// The memory that stores Z
        pub const Z_MEM142 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a28e));

        /// The memory that stores Z
        pub const Z_MEM143 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a28f));

        /// The memory that stores Z
        pub const Z_MEM144 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a290));

        /// The memory that stores Z
        pub const Z_MEM145 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a291));

        /// The memory that stores Z
        pub const Z_MEM146 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a292));

        /// The memory that stores Z
        pub const Z_MEM147 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a293));

        /// The memory that stores Z
        pub const Z_MEM148 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a294));

        /// The memory that stores Z
        pub const Z_MEM149 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a295));

        /// The memory that stores Z
        pub const Z_MEM150 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a296));

        /// The memory that stores Z
        pub const Z_MEM151 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a297));

        /// The memory that stores Z
        pub const Z_MEM152 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a298));

        /// The memory that stores Z
        pub const Z_MEM153 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a299));

        /// The memory that stores Z
        pub const Z_MEM154 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a29a));

        /// The memory that stores Z
        pub const Z_MEM155 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a29b));

        /// The memory that stores Z
        pub const Z_MEM156 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a29c));

        /// The memory that stores Z
        pub const Z_MEM157 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a29d));

        /// The memory that stores Z
        pub const Z_MEM158 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a29e));

        /// The memory that stores Z
        pub const Z_MEM159 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a29f));

        /// The memory that stores Z
        pub const Z_MEM160 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a2a0));

        /// The memory that stores Z
        pub const Z_MEM161 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a2a1));

        /// The memory that stores Z
        pub const Z_MEM162 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a2a2));

        /// The memory that stores Z
        pub const Z_MEM163 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a2a3));

        /// The memory that stores Z
        pub const Z_MEM164 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a2a4));

        /// The memory that stores Z
        pub const Z_MEM165 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a2a5));

        /// The memory that stores Z
        pub const Z_MEM166 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a2a6));

        /// The memory that stores Z
        pub const Z_MEM167 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a2a7));

        /// The memory that stores Z
        pub const Z_MEM168 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a2a8));

        /// The memory that stores Z
        pub const Z_MEM169 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a2a9));

        /// The memory that stores Z
        pub const Z_MEM170 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a2aa));

        /// The memory that stores Z
        pub const Z_MEM171 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a2ab));

        /// The memory that stores Z
        pub const Z_MEM172 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a2ac));

        /// The memory that stores Z
        pub const Z_MEM173 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a2ad));

        /// The memory that stores Z
        pub const Z_MEM174 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a2ae));

        /// The memory that stores Z
        pub const Z_MEM175 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a2af));

        /// The memory that stores Z
        pub const Z_MEM176 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a2b0));

        /// The memory that stores Z
        pub const Z_MEM177 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a2b1));

        /// The memory that stores Z
        pub const Z_MEM178 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a2b2));

        /// The memory that stores Z
        pub const Z_MEM179 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a2b3));

        /// The memory that stores Z
        pub const Z_MEM180 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a2b4));

        /// The memory that stores Z
        pub const Z_MEM181 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a2b5));

        /// The memory that stores Z
        pub const Z_MEM182 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a2b6));

        /// The memory that stores Z
        pub const Z_MEM183 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a2b7));

        /// The memory that stores Z
        pub const Z_MEM184 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a2b8));

        /// The memory that stores Z
        pub const Z_MEM185 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a2b9));

        /// The memory that stores Z
        pub const Z_MEM186 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a2ba));

        /// The memory that stores Z
        pub const Z_MEM187 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a2bb));

        /// The memory that stores Z
        pub const Z_MEM188 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a2bc));

        /// The memory that stores Z
        pub const Z_MEM189 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a2bd));

        /// The memory that stores Z
        pub const Z_MEM190 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a2be));

        /// The memory that stores Z
        pub const Z_MEM191 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a2bf));

        /// The memory that stores Z
        pub const Z_MEM192 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a2c0));

        /// The memory that stores Z
        pub const Z_MEM193 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a2c1));

        /// The memory that stores Z
        pub const Z_MEM194 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a2c2));

        /// The memory that stores Z
        pub const Z_MEM195 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a2c3));

        /// The memory that stores Z
        pub const Z_MEM196 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a2c4));

        /// The memory that stores Z
        pub const Z_MEM197 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a2c5));

        /// The memory that stores Z
        pub const Z_MEM198 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a2c6));

        /// The memory that stores Z
        pub const Z_MEM199 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a2c7));

        /// The memory that stores Z
        pub const Z_MEM200 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a2c8));

        /// The memory that stores Z
        pub const Z_MEM201 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a2c9));

        /// The memory that stores Z
        pub const Z_MEM202 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a2ca));

        /// The memory that stores Z
        pub const Z_MEM203 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a2cb));

        /// The memory that stores Z
        pub const Z_MEM204 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a2cc));

        /// The memory that stores Z
        pub const Z_MEM205 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a2cd));

        /// The memory that stores Z
        pub const Z_MEM206 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a2ce));

        /// The memory that stores Z
        pub const Z_MEM207 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a2cf));

        /// The memory that stores Z
        pub const Z_MEM208 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a2d0));

        /// The memory that stores Z
        pub const Z_MEM209 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a2d1));

        /// The memory that stores Z
        pub const Z_MEM210 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a2d2));

        /// The memory that stores Z
        pub const Z_MEM211 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a2d3));

        /// The memory that stores Z
        pub const Z_MEM212 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a2d4));

        /// The memory that stores Z
        pub const Z_MEM213 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a2d5));

        /// The memory that stores Z
        pub const Z_MEM214 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a2d6));

        /// The memory that stores Z
        pub const Z_MEM215 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a2d7));

        /// The memory that stores Z
        pub const Z_MEM216 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a2d8));

        /// The memory that stores Z
        pub const Z_MEM217 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a2d9));

        /// The memory that stores Z
        pub const Z_MEM218 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a2da));

        /// The memory that stores Z
        pub const Z_MEM219 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a2db));

        /// The memory that stores Z
        pub const Z_MEM220 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a2dc));

        /// The memory that stores Z
        pub const Z_MEM221 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a2dd));

        /// The memory that stores Z
        pub const Z_MEM222 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a2de));

        /// The memory that stores Z
        pub const Z_MEM223 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a2df));

        /// The memory that stores Z
        pub const Z_MEM224 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a2e0));

        /// The memory that stores Z
        pub const Z_MEM225 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a2e1));

        /// The memory that stores Z
        pub const Z_MEM226 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a2e2));

        /// The memory that stores Z
        pub const Z_MEM227 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a2e3));

        /// The memory that stores Z
        pub const Z_MEM228 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a2e4));

        /// The memory that stores Z
        pub const Z_MEM229 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a2e5));

        /// The memory that stores Z
        pub const Z_MEM230 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a2e6));

        /// The memory that stores Z
        pub const Z_MEM231 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a2e7));

        /// The memory that stores Z
        pub const Z_MEM232 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a2e8));

        /// The memory that stores Z
        pub const Z_MEM233 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a2e9));

        /// The memory that stores Z
        pub const Z_MEM234 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a2ea));

        /// The memory that stores Z
        pub const Z_MEM235 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a2eb));

        /// The memory that stores Z
        pub const Z_MEM236 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a2ec));

        /// The memory that stores Z
        pub const Z_MEM237 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a2ed));

        /// The memory that stores Z
        pub const Z_MEM238 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a2ee));

        /// The memory that stores Z
        pub const Z_MEM239 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a2ef));

        /// The memory that stores Z
        pub const Z_MEM240 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a2f0));

        /// The memory that stores Z
        pub const Z_MEM241 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a2f1));

        /// The memory that stores Z
        pub const Z_MEM242 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a2f2));

        /// The memory that stores Z
        pub const Z_MEM243 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a2f3));

        /// The memory that stores Z
        pub const Z_MEM244 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a2f4));

        /// The memory that stores Z
        pub const Z_MEM245 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a2f5));

        /// The memory that stores Z
        pub const Z_MEM246 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a2f6));

        /// The memory that stores Z
        pub const Z_MEM247 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a2f7));

        /// The memory that stores Z
        pub const Z_MEM248 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a2f8));

        /// The memory that stores Z
        pub const Z_MEM249 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a2f9));

        /// The memory that stores Z
        pub const Z_MEM250 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a2fa));

        /// The memory that stores Z
        pub const Z_MEM251 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a2fb));

        /// The memory that stores Z
        pub const Z_MEM252 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a2fc));

        /// The memory that stores Z
        pub const Z_MEM253 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a2fd));

        /// The memory that stores Z
        pub const Z_MEM254 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a2fe));

        /// The memory that stores Z
        pub const Z_MEM255 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a2ff));

        /// The memory that stores Z
        pub const Z_MEM256 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a300));

        /// The memory that stores Z
        pub const Z_MEM257 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a301));

        /// The memory that stores Z
        pub const Z_MEM258 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a302));

        /// The memory that stores Z
        pub const Z_MEM259 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a303));

        /// The memory that stores Z
        pub const Z_MEM260 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a304));

        /// The memory that stores Z
        pub const Z_MEM261 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a305));

        /// The memory that stores Z
        pub const Z_MEM262 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a306));

        /// The memory that stores Z
        pub const Z_MEM263 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a307));

        /// The memory that stores Z
        pub const Z_MEM264 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a308));

        /// The memory that stores Z
        pub const Z_MEM265 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a309));

        /// The memory that stores Z
        pub const Z_MEM266 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a30a));

        /// The memory that stores Z
        pub const Z_MEM267 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a30b));

        /// The memory that stores Z
        pub const Z_MEM268 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a30c));

        /// The memory that stores Z
        pub const Z_MEM269 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a30d));

        /// The memory that stores Z
        pub const Z_MEM270 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a30e));

        /// The memory that stores Z
        pub const Z_MEM271 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a30f));

        /// The memory that stores Z
        pub const Z_MEM272 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a310));

        /// The memory that stores Z
        pub const Z_MEM273 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a311));

        /// The memory that stores Z
        pub const Z_MEM274 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a312));

        /// The memory that stores Z
        pub const Z_MEM275 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a313));

        /// The memory that stores Z
        pub const Z_MEM276 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a314));

        /// The memory that stores Z
        pub const Z_MEM277 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a315));

        /// The memory that stores Z
        pub const Z_MEM278 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a316));

        /// The memory that stores Z
        pub const Z_MEM279 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a317));

        /// The memory that stores Z
        pub const Z_MEM280 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a318));

        /// The memory that stores Z
        pub const Z_MEM281 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a319));

        /// The memory that stores Z
        pub const Z_MEM282 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a31a));

        /// The memory that stores Z
        pub const Z_MEM283 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a31b));

        /// The memory that stores Z
        pub const Z_MEM284 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a31c));

        /// The memory that stores Z
        pub const Z_MEM285 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a31d));

        /// The memory that stores Z
        pub const Z_MEM286 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a31e));

        /// The memory that stores Z
        pub const Z_MEM287 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a31f));

        /// The memory that stores Z
        pub const Z_MEM288 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a320));

        /// The memory that stores Z
        pub const Z_MEM289 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a321));

        /// The memory that stores Z
        pub const Z_MEM290 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a322));

        /// The memory that stores Z
        pub const Z_MEM291 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a323));

        /// The memory that stores Z
        pub const Z_MEM292 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a324));

        /// The memory that stores Z
        pub const Z_MEM293 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a325));

        /// The memory that stores Z
        pub const Z_MEM294 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a326));

        /// The memory that stores Z
        pub const Z_MEM295 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a327));

        /// The memory that stores Z
        pub const Z_MEM296 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a328));

        /// The memory that stores Z
        pub const Z_MEM297 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a329));

        /// The memory that stores Z
        pub const Z_MEM298 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a32a));

        /// The memory that stores Z
        pub const Z_MEM299 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a32b));

        /// The memory that stores Z
        pub const Z_MEM300 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a32c));

        /// The memory that stores Z
        pub const Z_MEM301 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a32d));

        /// The memory that stores Z
        pub const Z_MEM302 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a32e));

        /// The memory that stores Z
        pub const Z_MEM303 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a32f));

        /// The memory that stores Z
        pub const Z_MEM304 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a330));

        /// The memory that stores Z
        pub const Z_MEM305 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a331));

        /// The memory that stores Z
        pub const Z_MEM306 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a332));

        /// The memory that stores Z
        pub const Z_MEM307 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a333));

        /// The memory that stores Z
        pub const Z_MEM308 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a334));

        /// The memory that stores Z
        pub const Z_MEM309 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a335));

        /// The memory that stores Z
        pub const Z_MEM310 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a336));

        /// The memory that stores Z
        pub const Z_MEM311 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a337));

        /// The memory that stores Z
        pub const Z_MEM312 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a338));

        /// The memory that stores Z
        pub const Z_MEM313 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a339));

        /// The memory that stores Z
        pub const Z_MEM314 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a33a));

        /// The memory that stores Z
        pub const Z_MEM315 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a33b));

        /// The memory that stores Z
        pub const Z_MEM316 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a33c));

        /// The memory that stores Z
        pub const Z_MEM317 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a33d));

        /// The memory that stores Z
        pub const Z_MEM318 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a33e));

        /// The memory that stores Z
        pub const Z_MEM319 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a33f));

        /// The memory that stores Z
        pub const Z_MEM320 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a340));

        /// The memory that stores Z
        pub const Z_MEM321 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a341));

        /// The memory that stores Z
        pub const Z_MEM322 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a342));

        /// The memory that stores Z
        pub const Z_MEM323 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a343));

        /// The memory that stores Z
        pub const Z_MEM324 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a344));

        /// The memory that stores Z
        pub const Z_MEM325 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a345));

        /// The memory that stores Z
        pub const Z_MEM326 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a346));

        /// The memory that stores Z
        pub const Z_MEM327 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a347));

        /// The memory that stores Z
        pub const Z_MEM328 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a348));

        /// The memory that stores Z
        pub const Z_MEM329 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a349));

        /// The memory that stores Z
        pub const Z_MEM330 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a34a));

        /// The memory that stores Z
        pub const Z_MEM331 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a34b));

        /// The memory that stores Z
        pub const Z_MEM332 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a34c));

        /// The memory that stores Z
        pub const Z_MEM333 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a34d));

        /// The memory that stores Z
        pub const Z_MEM334 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a34e));

        /// The memory that stores Z
        pub const Z_MEM335 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a34f));

        /// The memory that stores Z
        pub const Z_MEM336 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a350));

        /// The memory that stores Z
        pub const Z_MEM337 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a351));

        /// The memory that stores Z
        pub const Z_MEM338 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a352));

        /// The memory that stores Z
        pub const Z_MEM339 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a353));

        /// The memory that stores Z
        pub const Z_MEM340 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a354));

        /// The memory that stores Z
        pub const Z_MEM341 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a355));

        /// The memory that stores Z
        pub const Z_MEM342 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a356));

        /// The memory that stores Z
        pub const Z_MEM343 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a357));

        /// The memory that stores Z
        pub const Z_MEM344 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a358));

        /// The memory that stores Z
        pub const Z_MEM345 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a359));

        /// The memory that stores Z
        pub const Z_MEM346 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a35a));

        /// The memory that stores Z
        pub const Z_MEM347 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a35b));

        /// The memory that stores Z
        pub const Z_MEM348 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a35c));

        /// The memory that stores Z
        pub const Z_MEM349 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a35d));

        /// The memory that stores Z
        pub const Z_MEM350 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a35e));

        /// The memory that stores Z
        pub const Z_MEM351 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a35f));

        /// The memory that stores Z
        pub const Z_MEM352 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a360));

        /// The memory that stores Z
        pub const Z_MEM353 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a361));

        /// The memory that stores Z
        pub const Z_MEM354 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a362));

        /// The memory that stores Z
        pub const Z_MEM355 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a363));

        /// The memory that stores Z
        pub const Z_MEM356 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a364));

        /// The memory that stores Z
        pub const Z_MEM357 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a365));

        /// The memory that stores Z
        pub const Z_MEM358 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a366));

        /// The memory that stores Z
        pub const Z_MEM359 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a367));

        /// The memory that stores Z
        pub const Z_MEM360 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a368));

        /// The memory that stores Z
        pub const Z_MEM361 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a369));

        /// The memory that stores Z
        pub const Z_MEM362 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a36a));

        /// The memory that stores Z
        pub const Z_MEM363 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a36b));

        /// The memory that stores Z
        pub const Z_MEM364 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a36c));

        /// The memory that stores Z
        pub const Z_MEM365 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a36d));

        /// The memory that stores Z
        pub const Z_MEM366 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a36e));

        /// The memory that stores Z
        pub const Z_MEM367 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a36f));

        /// The memory that stores Z
        pub const Z_MEM368 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a370));

        /// The memory that stores Z
        pub const Z_MEM369 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a371));

        /// The memory that stores Z
        pub const Z_MEM370 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a372));

        /// The memory that stores Z
        pub const Z_MEM371 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a373));

        /// The memory that stores Z
        pub const Z_MEM372 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a374));

        /// The memory that stores Z
        pub const Z_MEM373 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a375));

        /// The memory that stores Z
        pub const Z_MEM374 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a376));

        /// The memory that stores Z
        pub const Z_MEM375 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a377));

        /// The memory that stores Z
        pub const Z_MEM376 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a378));

        /// The memory that stores Z
        pub const Z_MEM377 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a379));

        /// The memory that stores Z
        pub const Z_MEM378 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a37a));

        /// The memory that stores Z
        pub const Z_MEM379 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a37b));

        /// The memory that stores Z
        pub const Z_MEM380 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a37c));

        /// The memory that stores Z
        pub const Z_MEM381 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a37d));

        /// The memory that stores Z
        pub const Z_MEM382 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a37e));

        /// The memory that stores Z
        pub const Z_MEM383 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a37f));

        /// The memory that stores Y
        pub const Y_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a400));

        /// The memory that stores Y
        pub const Y_MEM1 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a401));

        /// The memory that stores Y
        pub const Y_MEM2 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a402));

        /// The memory that stores Y
        pub const Y_MEM3 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a403));

        /// The memory that stores Y
        pub const Y_MEM4 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a404));

        /// The memory that stores Y
        pub const Y_MEM5 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a405));

        /// The memory that stores Y
        pub const Y_MEM6 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a406));

        /// The memory that stores Y
        pub const Y_MEM7 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a407));

        /// The memory that stores Y
        pub const Y_MEM8 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a408));

        /// The memory that stores Y
        pub const Y_MEM9 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a409));

        /// The memory that stores Y
        pub const Y_MEM10 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a40a));

        /// The memory that stores Y
        pub const Y_MEM11 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a40b));

        /// The memory that stores Y
        pub const Y_MEM12 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a40c));

        /// The memory that stores Y
        pub const Y_MEM13 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a40d));

        /// The memory that stores Y
        pub const Y_MEM14 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a40e));

        /// The memory that stores Y
        pub const Y_MEM15 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a40f));

        /// The memory that stores Y
        pub const Y_MEM16 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a410));

        /// The memory that stores Y
        pub const Y_MEM17 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a411));

        /// The memory that stores Y
        pub const Y_MEM18 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a412));

        /// The memory that stores Y
        pub const Y_MEM19 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a413));

        /// The memory that stores Y
        pub const Y_MEM20 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a414));

        /// The memory that stores Y
        pub const Y_MEM21 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a415));

        /// The memory that stores Y
        pub const Y_MEM22 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a416));

        /// The memory that stores Y
        pub const Y_MEM23 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a417));

        /// The memory that stores Y
        pub const Y_MEM24 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a418));

        /// The memory that stores Y
        pub const Y_MEM25 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a419));

        /// The memory that stores Y
        pub const Y_MEM26 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a41a));

        /// The memory that stores Y
        pub const Y_MEM27 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a41b));

        /// The memory that stores Y
        pub const Y_MEM28 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a41c));

        /// The memory that stores Y
        pub const Y_MEM29 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a41d));

        /// The memory that stores Y
        pub const Y_MEM30 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a41e));

        /// The memory that stores Y
        pub const Y_MEM31 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a41f));

        /// The memory that stores Y
        pub const Y_MEM32 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a420));

        /// The memory that stores Y
        pub const Y_MEM33 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a421));

        /// The memory that stores Y
        pub const Y_MEM34 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a422));

        /// The memory that stores Y
        pub const Y_MEM35 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a423));

        /// The memory that stores Y
        pub const Y_MEM36 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a424));

        /// The memory that stores Y
        pub const Y_MEM37 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a425));

        /// The memory that stores Y
        pub const Y_MEM38 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a426));

        /// The memory that stores Y
        pub const Y_MEM39 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a427));

        /// The memory that stores Y
        pub const Y_MEM40 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a428));

        /// The memory that stores Y
        pub const Y_MEM41 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a429));

        /// The memory that stores Y
        pub const Y_MEM42 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a42a));

        /// The memory that stores Y
        pub const Y_MEM43 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a42b));

        /// The memory that stores Y
        pub const Y_MEM44 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a42c));

        /// The memory that stores Y
        pub const Y_MEM45 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a42d));

        /// The memory that stores Y
        pub const Y_MEM46 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a42e));

        /// The memory that stores Y
        pub const Y_MEM47 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a42f));

        /// The memory that stores Y
        pub const Y_MEM48 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a430));

        /// The memory that stores Y
        pub const Y_MEM49 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a431));

        /// The memory that stores Y
        pub const Y_MEM50 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a432));

        /// The memory that stores Y
        pub const Y_MEM51 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a433));

        /// The memory that stores Y
        pub const Y_MEM52 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a434));

        /// The memory that stores Y
        pub const Y_MEM53 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a435));

        /// The memory that stores Y
        pub const Y_MEM54 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a436));

        /// The memory that stores Y
        pub const Y_MEM55 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a437));

        /// The memory that stores Y
        pub const Y_MEM56 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a438));

        /// The memory that stores Y
        pub const Y_MEM57 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a439));

        /// The memory that stores Y
        pub const Y_MEM58 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a43a));

        /// The memory that stores Y
        pub const Y_MEM59 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a43b));

        /// The memory that stores Y
        pub const Y_MEM60 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a43c));

        /// The memory that stores Y
        pub const Y_MEM61 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a43d));

        /// The memory that stores Y
        pub const Y_MEM62 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a43e));

        /// The memory that stores Y
        pub const Y_MEM63 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a43f));

        /// The memory that stores Y
        pub const Y_MEM64 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a440));

        /// The memory that stores Y
        pub const Y_MEM65 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a441));

        /// The memory that stores Y
        pub const Y_MEM66 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a442));

        /// The memory that stores Y
        pub const Y_MEM67 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a443));

        /// The memory that stores Y
        pub const Y_MEM68 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a444));

        /// The memory that stores Y
        pub const Y_MEM69 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a445));

        /// The memory that stores Y
        pub const Y_MEM70 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a446));

        /// The memory that stores Y
        pub const Y_MEM71 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a447));

        /// The memory that stores Y
        pub const Y_MEM72 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a448));

        /// The memory that stores Y
        pub const Y_MEM73 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a449));

        /// The memory that stores Y
        pub const Y_MEM74 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a44a));

        /// The memory that stores Y
        pub const Y_MEM75 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a44b));

        /// The memory that stores Y
        pub const Y_MEM76 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a44c));

        /// The memory that stores Y
        pub const Y_MEM77 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a44d));

        /// The memory that stores Y
        pub const Y_MEM78 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a44e));

        /// The memory that stores Y
        pub const Y_MEM79 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a44f));

        /// The memory that stores Y
        pub const Y_MEM80 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a450));

        /// The memory that stores Y
        pub const Y_MEM81 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a451));

        /// The memory that stores Y
        pub const Y_MEM82 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a452));

        /// The memory that stores Y
        pub const Y_MEM83 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a453));

        /// The memory that stores Y
        pub const Y_MEM84 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a454));

        /// The memory that stores Y
        pub const Y_MEM85 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a455));

        /// The memory that stores Y
        pub const Y_MEM86 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a456));

        /// The memory that stores Y
        pub const Y_MEM87 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a457));

        /// The memory that stores Y
        pub const Y_MEM88 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a458));

        /// The memory that stores Y
        pub const Y_MEM89 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a459));

        /// The memory that stores Y
        pub const Y_MEM90 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a45a));

        /// The memory that stores Y
        pub const Y_MEM91 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a45b));

        /// The memory that stores Y
        pub const Y_MEM92 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a45c));

        /// The memory that stores Y
        pub const Y_MEM93 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a45d));

        /// The memory that stores Y
        pub const Y_MEM94 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a45e));

        /// The memory that stores Y
        pub const Y_MEM95 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a45f));

        /// The memory that stores Y
        pub const Y_MEM96 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a460));

        /// The memory that stores Y
        pub const Y_MEM97 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a461));

        /// The memory that stores Y
        pub const Y_MEM98 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a462));

        /// The memory that stores Y
        pub const Y_MEM99 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a463));

        /// The memory that stores Y
        pub const Y_MEM100 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a464));

        /// The memory that stores Y
        pub const Y_MEM101 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a465));

        /// The memory that stores Y
        pub const Y_MEM102 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a466));

        /// The memory that stores Y
        pub const Y_MEM103 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a467));

        /// The memory that stores Y
        pub const Y_MEM104 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a468));

        /// The memory that stores Y
        pub const Y_MEM105 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a469));

        /// The memory that stores Y
        pub const Y_MEM106 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a46a));

        /// The memory that stores Y
        pub const Y_MEM107 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a46b));

        /// The memory that stores Y
        pub const Y_MEM108 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a46c));

        /// The memory that stores Y
        pub const Y_MEM109 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a46d));

        /// The memory that stores Y
        pub const Y_MEM110 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a46e));

        /// The memory that stores Y
        pub const Y_MEM111 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a46f));

        /// The memory that stores Y
        pub const Y_MEM112 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a470));

        /// The memory that stores Y
        pub const Y_MEM113 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a471));

        /// The memory that stores Y
        pub const Y_MEM114 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a472));

        /// The memory that stores Y
        pub const Y_MEM115 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a473));

        /// The memory that stores Y
        pub const Y_MEM116 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a474));

        /// The memory that stores Y
        pub const Y_MEM117 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a475));

        /// The memory that stores Y
        pub const Y_MEM118 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a476));

        /// The memory that stores Y
        pub const Y_MEM119 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a477));

        /// The memory that stores Y
        pub const Y_MEM120 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a478));

        /// The memory that stores Y
        pub const Y_MEM121 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a479));

        /// The memory that stores Y
        pub const Y_MEM122 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a47a));

        /// The memory that stores Y
        pub const Y_MEM123 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a47b));

        /// The memory that stores Y
        pub const Y_MEM124 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a47c));

        /// The memory that stores Y
        pub const Y_MEM125 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a47d));

        /// The memory that stores Y
        pub const Y_MEM126 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a47e));

        /// The memory that stores Y
        pub const Y_MEM127 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a47f));

        /// The memory that stores Y
        pub const Y_MEM128 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a480));

        /// The memory that stores Y
        pub const Y_MEM129 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a481));

        /// The memory that stores Y
        pub const Y_MEM130 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a482));

        /// The memory that stores Y
        pub const Y_MEM131 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a483));

        /// The memory that stores Y
        pub const Y_MEM132 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a484));

        /// The memory that stores Y
        pub const Y_MEM133 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a485));

        /// The memory that stores Y
        pub const Y_MEM134 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a486));

        /// The memory that stores Y
        pub const Y_MEM135 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a487));

        /// The memory that stores Y
        pub const Y_MEM136 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a488));

        /// The memory that stores Y
        pub const Y_MEM137 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a489));

        /// The memory that stores Y
        pub const Y_MEM138 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a48a));

        /// The memory that stores Y
        pub const Y_MEM139 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a48b));

        /// The memory that stores Y
        pub const Y_MEM140 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a48c));

        /// The memory that stores Y
        pub const Y_MEM141 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a48d));

        /// The memory that stores Y
        pub const Y_MEM142 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a48e));

        /// The memory that stores Y
        pub const Y_MEM143 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a48f));

        /// The memory that stores Y
        pub const Y_MEM144 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a490));

        /// The memory that stores Y
        pub const Y_MEM145 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a491));

        /// The memory that stores Y
        pub const Y_MEM146 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a492));

        /// The memory that stores Y
        pub const Y_MEM147 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a493));

        /// The memory that stores Y
        pub const Y_MEM148 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a494));

        /// The memory that stores Y
        pub const Y_MEM149 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a495));

        /// The memory that stores Y
        pub const Y_MEM150 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a496));

        /// The memory that stores Y
        pub const Y_MEM151 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a497));

        /// The memory that stores Y
        pub const Y_MEM152 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a498));

        /// The memory that stores Y
        pub const Y_MEM153 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a499));

        /// The memory that stores Y
        pub const Y_MEM154 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a49a));

        /// The memory that stores Y
        pub const Y_MEM155 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a49b));

        /// The memory that stores Y
        pub const Y_MEM156 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a49c));

        /// The memory that stores Y
        pub const Y_MEM157 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a49d));

        /// The memory that stores Y
        pub const Y_MEM158 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a49e));

        /// The memory that stores Y
        pub const Y_MEM159 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a49f));

        /// The memory that stores Y
        pub const Y_MEM160 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a4a0));

        /// The memory that stores Y
        pub const Y_MEM161 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a4a1));

        /// The memory that stores Y
        pub const Y_MEM162 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a4a2));

        /// The memory that stores Y
        pub const Y_MEM163 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a4a3));

        /// The memory that stores Y
        pub const Y_MEM164 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a4a4));

        /// The memory that stores Y
        pub const Y_MEM165 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a4a5));

        /// The memory that stores Y
        pub const Y_MEM166 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a4a6));

        /// The memory that stores Y
        pub const Y_MEM167 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a4a7));

        /// The memory that stores Y
        pub const Y_MEM168 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a4a8));

        /// The memory that stores Y
        pub const Y_MEM169 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a4a9));

        /// The memory that stores Y
        pub const Y_MEM170 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a4aa));

        /// The memory that stores Y
        pub const Y_MEM171 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a4ab));

        /// The memory that stores Y
        pub const Y_MEM172 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a4ac));

        /// The memory that stores Y
        pub const Y_MEM173 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a4ad));

        /// The memory that stores Y
        pub const Y_MEM174 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a4ae));

        /// The memory that stores Y
        pub const Y_MEM175 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a4af));

        /// The memory that stores Y
        pub const Y_MEM176 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a4b0));

        /// The memory that stores Y
        pub const Y_MEM177 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a4b1));

        /// The memory that stores Y
        pub const Y_MEM178 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a4b2));

        /// The memory that stores Y
        pub const Y_MEM179 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a4b3));

        /// The memory that stores Y
        pub const Y_MEM180 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a4b4));

        /// The memory that stores Y
        pub const Y_MEM181 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a4b5));

        /// The memory that stores Y
        pub const Y_MEM182 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a4b6));

        /// The memory that stores Y
        pub const Y_MEM183 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a4b7));

        /// The memory that stores Y
        pub const Y_MEM184 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a4b8));

        /// The memory that stores Y
        pub const Y_MEM185 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a4b9));

        /// The memory that stores Y
        pub const Y_MEM186 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a4ba));

        /// The memory that stores Y
        pub const Y_MEM187 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a4bb));

        /// The memory that stores Y
        pub const Y_MEM188 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a4bc));

        /// The memory that stores Y
        pub const Y_MEM189 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a4bd));

        /// The memory that stores Y
        pub const Y_MEM190 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a4be));

        /// The memory that stores Y
        pub const Y_MEM191 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a4bf));

        /// The memory that stores Y
        pub const Y_MEM192 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a4c0));

        /// The memory that stores Y
        pub const Y_MEM193 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a4c1));

        /// The memory that stores Y
        pub const Y_MEM194 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a4c2));

        /// The memory that stores Y
        pub const Y_MEM195 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a4c3));

        /// The memory that stores Y
        pub const Y_MEM196 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a4c4));

        /// The memory that stores Y
        pub const Y_MEM197 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a4c5));

        /// The memory that stores Y
        pub const Y_MEM198 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a4c6));

        /// The memory that stores Y
        pub const Y_MEM199 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a4c7));

        /// The memory that stores Y
        pub const Y_MEM200 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a4c8));

        /// The memory that stores Y
        pub const Y_MEM201 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a4c9));

        /// The memory that stores Y
        pub const Y_MEM202 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a4ca));

        /// The memory that stores Y
        pub const Y_MEM203 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a4cb));

        /// The memory that stores Y
        pub const Y_MEM204 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a4cc));

        /// The memory that stores Y
        pub const Y_MEM205 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a4cd));

        /// The memory that stores Y
        pub const Y_MEM206 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a4ce));

        /// The memory that stores Y
        pub const Y_MEM207 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a4cf));

        /// The memory that stores Y
        pub const Y_MEM208 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a4d0));

        /// The memory that stores Y
        pub const Y_MEM209 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a4d1));

        /// The memory that stores Y
        pub const Y_MEM210 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a4d2));

        /// The memory that stores Y
        pub const Y_MEM211 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a4d3));

        /// The memory that stores Y
        pub const Y_MEM212 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a4d4));

        /// The memory that stores Y
        pub const Y_MEM213 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a4d5));

        /// The memory that stores Y
        pub const Y_MEM214 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a4d6));

        /// The memory that stores Y
        pub const Y_MEM215 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a4d7));

        /// The memory that stores Y
        pub const Y_MEM216 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a4d8));

        /// The memory that stores Y
        pub const Y_MEM217 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a4d9));

        /// The memory that stores Y
        pub const Y_MEM218 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a4da));

        /// The memory that stores Y
        pub const Y_MEM219 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a4db));

        /// The memory that stores Y
        pub const Y_MEM220 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a4dc));

        /// The memory that stores Y
        pub const Y_MEM221 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a4dd));

        /// The memory that stores Y
        pub const Y_MEM222 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a4de));

        /// The memory that stores Y
        pub const Y_MEM223 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a4df));

        /// The memory that stores Y
        pub const Y_MEM224 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a4e0));

        /// The memory that stores Y
        pub const Y_MEM225 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a4e1));

        /// The memory that stores Y
        pub const Y_MEM226 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a4e2));

        /// The memory that stores Y
        pub const Y_MEM227 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a4e3));

        /// The memory that stores Y
        pub const Y_MEM228 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a4e4));

        /// The memory that stores Y
        pub const Y_MEM229 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a4e5));

        /// The memory that stores Y
        pub const Y_MEM230 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a4e6));

        /// The memory that stores Y
        pub const Y_MEM231 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a4e7));

        /// The memory that stores Y
        pub const Y_MEM232 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a4e8));

        /// The memory that stores Y
        pub const Y_MEM233 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a4e9));

        /// The memory that stores Y
        pub const Y_MEM234 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a4ea));

        /// The memory that stores Y
        pub const Y_MEM235 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a4eb));

        /// The memory that stores Y
        pub const Y_MEM236 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a4ec));

        /// The memory that stores Y
        pub const Y_MEM237 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a4ed));

        /// The memory that stores Y
        pub const Y_MEM238 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a4ee));

        /// The memory that stores Y
        pub const Y_MEM239 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a4ef));

        /// The memory that stores Y
        pub const Y_MEM240 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a4f0));

        /// The memory that stores Y
        pub const Y_MEM241 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a4f1));

        /// The memory that stores Y
        pub const Y_MEM242 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a4f2));

        /// The memory that stores Y
        pub const Y_MEM243 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a4f3));

        /// The memory that stores Y
        pub const Y_MEM244 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a4f4));

        /// The memory that stores Y
        pub const Y_MEM245 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a4f5));

        /// The memory that stores Y
        pub const Y_MEM246 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a4f6));

        /// The memory that stores Y
        pub const Y_MEM247 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a4f7));

        /// The memory that stores Y
        pub const Y_MEM248 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a4f8));

        /// The memory that stores Y
        pub const Y_MEM249 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a4f9));

        /// The memory that stores Y
        pub const Y_MEM250 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a4fa));

        /// The memory that stores Y
        pub const Y_MEM251 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a4fb));

        /// The memory that stores Y
        pub const Y_MEM252 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a4fc));

        /// The memory that stores Y
        pub const Y_MEM253 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a4fd));

        /// The memory that stores Y
        pub const Y_MEM254 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a4fe));

        /// The memory that stores Y
        pub const Y_MEM255 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a4ff));

        /// The memory that stores Y
        pub const Y_MEM256 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a500));

        /// The memory that stores Y
        pub const Y_MEM257 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a501));

        /// The memory that stores Y
        pub const Y_MEM258 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a502));

        /// The memory that stores Y
        pub const Y_MEM259 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a503));

        /// The memory that stores Y
        pub const Y_MEM260 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a504));

        /// The memory that stores Y
        pub const Y_MEM261 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a505));

        /// The memory that stores Y
        pub const Y_MEM262 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a506));

        /// The memory that stores Y
        pub const Y_MEM263 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a507));

        /// The memory that stores Y
        pub const Y_MEM264 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a508));

        /// The memory that stores Y
        pub const Y_MEM265 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a509));

        /// The memory that stores Y
        pub const Y_MEM266 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a50a));

        /// The memory that stores Y
        pub const Y_MEM267 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a50b));

        /// The memory that stores Y
        pub const Y_MEM268 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a50c));

        /// The memory that stores Y
        pub const Y_MEM269 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a50d));

        /// The memory that stores Y
        pub const Y_MEM270 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a50e));

        /// The memory that stores Y
        pub const Y_MEM271 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a50f));

        /// The memory that stores Y
        pub const Y_MEM272 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a510));

        /// The memory that stores Y
        pub const Y_MEM273 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a511));

        /// The memory that stores Y
        pub const Y_MEM274 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a512));

        /// The memory that stores Y
        pub const Y_MEM275 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a513));

        /// The memory that stores Y
        pub const Y_MEM276 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a514));

        /// The memory that stores Y
        pub const Y_MEM277 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a515));

        /// The memory that stores Y
        pub const Y_MEM278 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a516));

        /// The memory that stores Y
        pub const Y_MEM279 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a517));

        /// The memory that stores Y
        pub const Y_MEM280 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a518));

        /// The memory that stores Y
        pub const Y_MEM281 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a519));

        /// The memory that stores Y
        pub const Y_MEM282 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a51a));

        /// The memory that stores Y
        pub const Y_MEM283 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a51b));

        /// The memory that stores Y
        pub const Y_MEM284 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a51c));

        /// The memory that stores Y
        pub const Y_MEM285 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a51d));

        /// The memory that stores Y
        pub const Y_MEM286 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a51e));

        /// The memory that stores Y
        pub const Y_MEM287 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a51f));

        /// The memory that stores Y
        pub const Y_MEM288 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a520));

        /// The memory that stores Y
        pub const Y_MEM289 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a521));

        /// The memory that stores Y
        pub const Y_MEM290 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a522));

        /// The memory that stores Y
        pub const Y_MEM291 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a523));

        /// The memory that stores Y
        pub const Y_MEM292 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a524));

        /// The memory that stores Y
        pub const Y_MEM293 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a525));

        /// The memory that stores Y
        pub const Y_MEM294 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a526));

        /// The memory that stores Y
        pub const Y_MEM295 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a527));

        /// The memory that stores Y
        pub const Y_MEM296 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a528));

        /// The memory that stores Y
        pub const Y_MEM297 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a529));

        /// The memory that stores Y
        pub const Y_MEM298 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a52a));

        /// The memory that stores Y
        pub const Y_MEM299 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a52b));

        /// The memory that stores Y
        pub const Y_MEM300 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a52c));

        /// The memory that stores Y
        pub const Y_MEM301 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a52d));

        /// The memory that stores Y
        pub const Y_MEM302 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a52e));

        /// The memory that stores Y
        pub const Y_MEM303 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a52f));

        /// The memory that stores Y
        pub const Y_MEM304 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a530));

        /// The memory that stores Y
        pub const Y_MEM305 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a531));

        /// The memory that stores Y
        pub const Y_MEM306 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a532));

        /// The memory that stores Y
        pub const Y_MEM307 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a533));

        /// The memory that stores Y
        pub const Y_MEM308 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a534));

        /// The memory that stores Y
        pub const Y_MEM309 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a535));

        /// The memory that stores Y
        pub const Y_MEM310 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a536));

        /// The memory that stores Y
        pub const Y_MEM311 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a537));

        /// The memory that stores Y
        pub const Y_MEM312 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a538));

        /// The memory that stores Y
        pub const Y_MEM313 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a539));

        /// The memory that stores Y
        pub const Y_MEM314 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a53a));

        /// The memory that stores Y
        pub const Y_MEM315 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a53b));

        /// The memory that stores Y
        pub const Y_MEM316 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a53c));

        /// The memory that stores Y
        pub const Y_MEM317 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a53d));

        /// The memory that stores Y
        pub const Y_MEM318 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a53e));

        /// The memory that stores Y
        pub const Y_MEM319 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a53f));

        /// The memory that stores Y
        pub const Y_MEM320 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a540));

        /// The memory that stores Y
        pub const Y_MEM321 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a541));

        /// The memory that stores Y
        pub const Y_MEM322 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a542));

        /// The memory that stores Y
        pub const Y_MEM323 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a543));

        /// The memory that stores Y
        pub const Y_MEM324 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a544));

        /// The memory that stores Y
        pub const Y_MEM325 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a545));

        /// The memory that stores Y
        pub const Y_MEM326 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a546));

        /// The memory that stores Y
        pub const Y_MEM327 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a547));

        /// The memory that stores Y
        pub const Y_MEM328 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a548));

        /// The memory that stores Y
        pub const Y_MEM329 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a549));

        /// The memory that stores Y
        pub const Y_MEM330 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a54a));

        /// The memory that stores Y
        pub const Y_MEM331 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a54b));

        /// The memory that stores Y
        pub const Y_MEM332 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a54c));

        /// The memory that stores Y
        pub const Y_MEM333 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a54d));

        /// The memory that stores Y
        pub const Y_MEM334 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a54e));

        /// The memory that stores Y
        pub const Y_MEM335 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a54f));

        /// The memory that stores Y
        pub const Y_MEM336 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a550));

        /// The memory that stores Y
        pub const Y_MEM337 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a551));

        /// The memory that stores Y
        pub const Y_MEM338 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a552));

        /// The memory that stores Y
        pub const Y_MEM339 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a553));

        /// The memory that stores Y
        pub const Y_MEM340 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a554));

        /// The memory that stores Y
        pub const Y_MEM341 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a555));

        /// The memory that stores Y
        pub const Y_MEM342 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a556));

        /// The memory that stores Y
        pub const Y_MEM343 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a557));

        /// The memory that stores Y
        pub const Y_MEM344 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a558));

        /// The memory that stores Y
        pub const Y_MEM345 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a559));

        /// The memory that stores Y
        pub const Y_MEM346 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a55a));

        /// The memory that stores Y
        pub const Y_MEM347 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a55b));

        /// The memory that stores Y
        pub const Y_MEM348 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a55c));

        /// The memory that stores Y
        pub const Y_MEM349 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a55d));

        /// The memory that stores Y
        pub const Y_MEM350 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a55e));

        /// The memory that stores Y
        pub const Y_MEM351 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a55f));

        /// The memory that stores Y
        pub const Y_MEM352 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a560));

        /// The memory that stores Y
        pub const Y_MEM353 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a561));

        /// The memory that stores Y
        pub const Y_MEM354 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a562));

        /// The memory that stores Y
        pub const Y_MEM355 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a563));

        /// The memory that stores Y
        pub const Y_MEM356 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a564));

        /// The memory that stores Y
        pub const Y_MEM357 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a565));

        /// The memory that stores Y
        pub const Y_MEM358 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a566));

        /// The memory that stores Y
        pub const Y_MEM359 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a567));

        /// The memory that stores Y
        pub const Y_MEM360 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a568));

        /// The memory that stores Y
        pub const Y_MEM361 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a569));

        /// The memory that stores Y
        pub const Y_MEM362 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a56a));

        /// The memory that stores Y
        pub const Y_MEM363 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a56b));

        /// The memory that stores Y
        pub const Y_MEM364 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a56c));

        /// The memory that stores Y
        pub const Y_MEM365 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a56d));

        /// The memory that stores Y
        pub const Y_MEM366 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a56e));

        /// The memory that stores Y
        pub const Y_MEM367 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a56f));

        /// The memory that stores Y
        pub const Y_MEM368 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a570));

        /// The memory that stores Y
        pub const Y_MEM369 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a571));

        /// The memory that stores Y
        pub const Y_MEM370 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a572));

        /// The memory that stores Y
        pub const Y_MEM371 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a573));

        /// The memory that stores Y
        pub const Y_MEM372 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a574));

        /// The memory that stores Y
        pub const Y_MEM373 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a575));

        /// The memory that stores Y
        pub const Y_MEM374 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a576));

        /// The memory that stores Y
        pub const Y_MEM375 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a577));

        /// The memory that stores Y
        pub const Y_MEM376 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a578));

        /// The memory that stores Y
        pub const Y_MEM377 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a579));

        /// The memory that stores Y
        pub const Y_MEM378 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a57a));

        /// The memory that stores Y
        pub const Y_MEM379 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a57b));

        /// The memory that stores Y
        pub const Y_MEM380 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a57c));

        /// The memory that stores Y
        pub const Y_MEM381 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a57d));

        /// The memory that stores Y
        pub const Y_MEM382 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a57e));

        /// The memory that stores Y
        pub const Y_MEM383 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a57f));

        /// The memory that stores X
        pub const X_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a600));

        /// The memory that stores X
        pub const X_MEM1 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a601));

        /// The memory that stores X
        pub const X_MEM2 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a602));

        /// The memory that stores X
        pub const X_MEM3 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a603));

        /// The memory that stores X
        pub const X_MEM4 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a604));

        /// The memory that stores X
        pub const X_MEM5 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a605));

        /// The memory that stores X
        pub const X_MEM6 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a606));

        /// The memory that stores X
        pub const X_MEM7 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a607));

        /// The memory that stores X
        pub const X_MEM8 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a608));

        /// The memory that stores X
        pub const X_MEM9 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a609));

        /// The memory that stores X
        pub const X_MEM10 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a60a));

        /// The memory that stores X
        pub const X_MEM11 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a60b));

        /// The memory that stores X
        pub const X_MEM12 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a60c));

        /// The memory that stores X
        pub const X_MEM13 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a60d));

        /// The memory that stores X
        pub const X_MEM14 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a60e));

        /// The memory that stores X
        pub const X_MEM15 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a60f));

        /// The memory that stores X
        pub const X_MEM16 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a610));

        /// The memory that stores X
        pub const X_MEM17 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a611));

        /// The memory that stores X
        pub const X_MEM18 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a612));

        /// The memory that stores X
        pub const X_MEM19 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a613));

        /// The memory that stores X
        pub const X_MEM20 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a614));

        /// The memory that stores X
        pub const X_MEM21 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a615));

        /// The memory that stores X
        pub const X_MEM22 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a616));

        /// The memory that stores X
        pub const X_MEM23 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a617));

        /// The memory that stores X
        pub const X_MEM24 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a618));

        /// The memory that stores X
        pub const X_MEM25 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a619));

        /// The memory that stores X
        pub const X_MEM26 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a61a));

        /// The memory that stores X
        pub const X_MEM27 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a61b));

        /// The memory that stores X
        pub const X_MEM28 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a61c));

        /// The memory that stores X
        pub const X_MEM29 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a61d));

        /// The memory that stores X
        pub const X_MEM30 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a61e));

        /// The memory that stores X
        pub const X_MEM31 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a61f));

        /// The memory that stores X
        pub const X_MEM32 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a620));

        /// The memory that stores X
        pub const X_MEM33 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a621));

        /// The memory that stores X
        pub const X_MEM34 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a622));

        /// The memory that stores X
        pub const X_MEM35 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a623));

        /// The memory that stores X
        pub const X_MEM36 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a624));

        /// The memory that stores X
        pub const X_MEM37 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a625));

        /// The memory that stores X
        pub const X_MEM38 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a626));

        /// The memory that stores X
        pub const X_MEM39 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a627));

        /// The memory that stores X
        pub const X_MEM40 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a628));

        /// The memory that stores X
        pub const X_MEM41 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a629));

        /// The memory that stores X
        pub const X_MEM42 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a62a));

        /// The memory that stores X
        pub const X_MEM43 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a62b));

        /// The memory that stores X
        pub const X_MEM44 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a62c));

        /// The memory that stores X
        pub const X_MEM45 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a62d));

        /// The memory that stores X
        pub const X_MEM46 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a62e));

        /// The memory that stores X
        pub const X_MEM47 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a62f));

        /// The memory that stores X
        pub const X_MEM48 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a630));

        /// The memory that stores X
        pub const X_MEM49 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a631));

        /// The memory that stores X
        pub const X_MEM50 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a632));

        /// The memory that stores X
        pub const X_MEM51 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a633));

        /// The memory that stores X
        pub const X_MEM52 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a634));

        /// The memory that stores X
        pub const X_MEM53 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a635));

        /// The memory that stores X
        pub const X_MEM54 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a636));

        /// The memory that stores X
        pub const X_MEM55 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a637));

        /// The memory that stores X
        pub const X_MEM56 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a638));

        /// The memory that stores X
        pub const X_MEM57 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a639));

        /// The memory that stores X
        pub const X_MEM58 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a63a));

        /// The memory that stores X
        pub const X_MEM59 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a63b));

        /// The memory that stores X
        pub const X_MEM60 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a63c));

        /// The memory that stores X
        pub const X_MEM61 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a63d));

        /// The memory that stores X
        pub const X_MEM62 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a63e));

        /// The memory that stores X
        pub const X_MEM63 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a63f));

        /// The memory that stores X
        pub const X_MEM64 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a640));

        /// The memory that stores X
        pub const X_MEM65 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a641));

        /// The memory that stores X
        pub const X_MEM66 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a642));

        /// The memory that stores X
        pub const X_MEM67 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a643));

        /// The memory that stores X
        pub const X_MEM68 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a644));

        /// The memory that stores X
        pub const X_MEM69 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a645));

        /// The memory that stores X
        pub const X_MEM70 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a646));

        /// The memory that stores X
        pub const X_MEM71 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a647));

        /// The memory that stores X
        pub const X_MEM72 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a648));

        /// The memory that stores X
        pub const X_MEM73 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a649));

        /// The memory that stores X
        pub const X_MEM74 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a64a));

        /// The memory that stores X
        pub const X_MEM75 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a64b));

        /// The memory that stores X
        pub const X_MEM76 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a64c));

        /// The memory that stores X
        pub const X_MEM77 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a64d));

        /// The memory that stores X
        pub const X_MEM78 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a64e));

        /// The memory that stores X
        pub const X_MEM79 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a64f));

        /// The memory that stores X
        pub const X_MEM80 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a650));

        /// The memory that stores X
        pub const X_MEM81 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a651));

        /// The memory that stores X
        pub const X_MEM82 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a652));

        /// The memory that stores X
        pub const X_MEM83 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a653));

        /// The memory that stores X
        pub const X_MEM84 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a654));

        /// The memory that stores X
        pub const X_MEM85 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a655));

        /// The memory that stores X
        pub const X_MEM86 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a656));

        /// The memory that stores X
        pub const X_MEM87 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a657));

        /// The memory that stores X
        pub const X_MEM88 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a658));

        /// The memory that stores X
        pub const X_MEM89 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a659));

        /// The memory that stores X
        pub const X_MEM90 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a65a));

        /// The memory that stores X
        pub const X_MEM91 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a65b));

        /// The memory that stores X
        pub const X_MEM92 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a65c));

        /// The memory that stores X
        pub const X_MEM93 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a65d));

        /// The memory that stores X
        pub const X_MEM94 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a65e));

        /// The memory that stores X
        pub const X_MEM95 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a65f));

        /// The memory that stores X
        pub const X_MEM96 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a660));

        /// The memory that stores X
        pub const X_MEM97 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a661));

        /// The memory that stores X
        pub const X_MEM98 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a662));

        /// The memory that stores X
        pub const X_MEM99 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a663));

        /// The memory that stores X
        pub const X_MEM100 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a664));

        /// The memory that stores X
        pub const X_MEM101 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a665));

        /// The memory that stores X
        pub const X_MEM102 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a666));

        /// The memory that stores X
        pub const X_MEM103 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a667));

        /// The memory that stores X
        pub const X_MEM104 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a668));

        /// The memory that stores X
        pub const X_MEM105 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a669));

        /// The memory that stores X
        pub const X_MEM106 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a66a));

        /// The memory that stores X
        pub const X_MEM107 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a66b));

        /// The memory that stores X
        pub const X_MEM108 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a66c));

        /// The memory that stores X
        pub const X_MEM109 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a66d));

        /// The memory that stores X
        pub const X_MEM110 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a66e));

        /// The memory that stores X
        pub const X_MEM111 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a66f));

        /// The memory that stores X
        pub const X_MEM112 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a670));

        /// The memory that stores X
        pub const X_MEM113 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a671));

        /// The memory that stores X
        pub const X_MEM114 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a672));

        /// The memory that stores X
        pub const X_MEM115 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a673));

        /// The memory that stores X
        pub const X_MEM116 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a674));

        /// The memory that stores X
        pub const X_MEM117 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a675));

        /// The memory that stores X
        pub const X_MEM118 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a676));

        /// The memory that stores X
        pub const X_MEM119 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a677));

        /// The memory that stores X
        pub const X_MEM120 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a678));

        /// The memory that stores X
        pub const X_MEM121 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a679));

        /// The memory that stores X
        pub const X_MEM122 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a67a));

        /// The memory that stores X
        pub const X_MEM123 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a67b));

        /// The memory that stores X
        pub const X_MEM124 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a67c));

        /// The memory that stores X
        pub const X_MEM125 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a67d));

        /// The memory that stores X
        pub const X_MEM126 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a67e));

        /// The memory that stores X
        pub const X_MEM127 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a67f));

        /// The memory that stores X
        pub const X_MEM128 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a680));

        /// The memory that stores X
        pub const X_MEM129 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a681));

        /// The memory that stores X
        pub const X_MEM130 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a682));

        /// The memory that stores X
        pub const X_MEM131 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a683));

        /// The memory that stores X
        pub const X_MEM132 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a684));

        /// The memory that stores X
        pub const X_MEM133 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a685));

        /// The memory that stores X
        pub const X_MEM134 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a686));

        /// The memory that stores X
        pub const X_MEM135 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a687));

        /// The memory that stores X
        pub const X_MEM136 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a688));

        /// The memory that stores X
        pub const X_MEM137 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a689));

        /// The memory that stores X
        pub const X_MEM138 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a68a));

        /// The memory that stores X
        pub const X_MEM139 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a68b));

        /// The memory that stores X
        pub const X_MEM140 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a68c));

        /// The memory that stores X
        pub const X_MEM141 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a68d));

        /// The memory that stores X
        pub const X_MEM142 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a68e));

        /// The memory that stores X
        pub const X_MEM143 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a68f));

        /// The memory that stores X
        pub const X_MEM144 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a690));

        /// The memory that stores X
        pub const X_MEM145 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a691));

        /// The memory that stores X
        pub const X_MEM146 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a692));

        /// The memory that stores X
        pub const X_MEM147 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a693));

        /// The memory that stores X
        pub const X_MEM148 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a694));

        /// The memory that stores X
        pub const X_MEM149 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a695));

        /// The memory that stores X
        pub const X_MEM150 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a696));

        /// The memory that stores X
        pub const X_MEM151 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a697));

        /// The memory that stores X
        pub const X_MEM152 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a698));

        /// The memory that stores X
        pub const X_MEM153 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a699));

        /// The memory that stores X
        pub const X_MEM154 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a69a));

        /// The memory that stores X
        pub const X_MEM155 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a69b));

        /// The memory that stores X
        pub const X_MEM156 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a69c));

        /// The memory that stores X
        pub const X_MEM157 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a69d));

        /// The memory that stores X
        pub const X_MEM158 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a69e));

        /// The memory that stores X
        pub const X_MEM159 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a69f));

        /// The memory that stores X
        pub const X_MEM160 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a6a0));

        /// The memory that stores X
        pub const X_MEM161 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a6a1));

        /// The memory that stores X
        pub const X_MEM162 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a6a2));

        /// The memory that stores X
        pub const X_MEM163 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a6a3));

        /// The memory that stores X
        pub const X_MEM164 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a6a4));

        /// The memory that stores X
        pub const X_MEM165 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a6a5));

        /// The memory that stores X
        pub const X_MEM166 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a6a6));

        /// The memory that stores X
        pub const X_MEM167 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a6a7));

        /// The memory that stores X
        pub const X_MEM168 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a6a8));

        /// The memory that stores X
        pub const X_MEM169 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a6a9));

        /// The memory that stores X
        pub const X_MEM170 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a6aa));

        /// The memory that stores X
        pub const X_MEM171 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a6ab));

        /// The memory that stores X
        pub const X_MEM172 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a6ac));

        /// The memory that stores X
        pub const X_MEM173 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a6ad));

        /// The memory that stores X
        pub const X_MEM174 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a6ae));

        /// The memory that stores X
        pub const X_MEM175 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a6af));

        /// The memory that stores X
        pub const X_MEM176 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a6b0));

        /// The memory that stores X
        pub const X_MEM177 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a6b1));

        /// The memory that stores X
        pub const X_MEM178 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a6b2));

        /// The memory that stores X
        pub const X_MEM179 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a6b3));

        /// The memory that stores X
        pub const X_MEM180 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a6b4));

        /// The memory that stores X
        pub const X_MEM181 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a6b5));

        /// The memory that stores X
        pub const X_MEM182 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a6b6));

        /// The memory that stores X
        pub const X_MEM183 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a6b7));

        /// The memory that stores X
        pub const X_MEM184 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a6b8));

        /// The memory that stores X
        pub const X_MEM185 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a6b9));

        /// The memory that stores X
        pub const X_MEM186 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a6ba));

        /// The memory that stores X
        pub const X_MEM187 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a6bb));

        /// The memory that stores X
        pub const X_MEM188 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a6bc));

        /// The memory that stores X
        pub const X_MEM189 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a6bd));

        /// The memory that stores X
        pub const X_MEM190 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a6be));

        /// The memory that stores X
        pub const X_MEM191 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a6bf));

        /// The memory that stores X
        pub const X_MEM192 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a6c0));

        /// The memory that stores X
        pub const X_MEM193 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a6c1));

        /// The memory that stores X
        pub const X_MEM194 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a6c2));

        /// The memory that stores X
        pub const X_MEM195 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a6c3));

        /// The memory that stores X
        pub const X_MEM196 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a6c4));

        /// The memory that stores X
        pub const X_MEM197 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a6c5));

        /// The memory that stores X
        pub const X_MEM198 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a6c6));

        /// The memory that stores X
        pub const X_MEM199 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a6c7));

        /// The memory that stores X
        pub const X_MEM200 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a6c8));

        /// The memory that stores X
        pub const X_MEM201 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a6c9));

        /// The memory that stores X
        pub const X_MEM202 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a6ca));

        /// The memory that stores X
        pub const X_MEM203 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a6cb));

        /// The memory that stores X
        pub const X_MEM204 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a6cc));

        /// The memory that stores X
        pub const X_MEM205 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a6cd));

        /// The memory that stores X
        pub const X_MEM206 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a6ce));

        /// The memory that stores X
        pub const X_MEM207 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a6cf));

        /// The memory that stores X
        pub const X_MEM208 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a6d0));

        /// The memory that stores X
        pub const X_MEM209 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a6d1));

        /// The memory that stores X
        pub const X_MEM210 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a6d2));

        /// The memory that stores X
        pub const X_MEM211 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a6d3));

        /// The memory that stores X
        pub const X_MEM212 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a6d4));

        /// The memory that stores X
        pub const X_MEM213 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a6d5));

        /// The memory that stores X
        pub const X_MEM214 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a6d6));

        /// The memory that stores X
        pub const X_MEM215 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a6d7));

        /// The memory that stores X
        pub const X_MEM216 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a6d8));

        /// The memory that stores X
        pub const X_MEM217 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a6d9));

        /// The memory that stores X
        pub const X_MEM218 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a6da));

        /// The memory that stores X
        pub const X_MEM219 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a6db));

        /// The memory that stores X
        pub const X_MEM220 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a6dc));

        /// The memory that stores X
        pub const X_MEM221 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a6dd));

        /// The memory that stores X
        pub const X_MEM222 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a6de));

        /// The memory that stores X
        pub const X_MEM223 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a6df));

        /// The memory that stores X
        pub const X_MEM224 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a6e0));

        /// The memory that stores X
        pub const X_MEM225 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a6e1));

        /// The memory that stores X
        pub const X_MEM226 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a6e2));

        /// The memory that stores X
        pub const X_MEM227 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a6e3));

        /// The memory that stores X
        pub const X_MEM228 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a6e4));

        /// The memory that stores X
        pub const X_MEM229 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a6e5));

        /// The memory that stores X
        pub const X_MEM230 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a6e6));

        /// The memory that stores X
        pub const X_MEM231 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a6e7));

        /// The memory that stores X
        pub const X_MEM232 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a6e8));

        /// The memory that stores X
        pub const X_MEM233 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a6e9));

        /// The memory that stores X
        pub const X_MEM234 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a6ea));

        /// The memory that stores X
        pub const X_MEM235 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a6eb));

        /// The memory that stores X
        pub const X_MEM236 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a6ec));

        /// The memory that stores X
        pub const X_MEM237 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a6ed));

        /// The memory that stores X
        pub const X_MEM238 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a6ee));

        /// The memory that stores X
        pub const X_MEM239 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a6ef));

        /// The memory that stores X
        pub const X_MEM240 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a6f0));

        /// The memory that stores X
        pub const X_MEM241 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a6f1));

        /// The memory that stores X
        pub const X_MEM242 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a6f2));

        /// The memory that stores X
        pub const X_MEM243 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a6f3));

        /// The memory that stores X
        pub const X_MEM244 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a6f4));

        /// The memory that stores X
        pub const X_MEM245 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a6f5));

        /// The memory that stores X
        pub const X_MEM246 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a6f6));

        /// The memory that stores X
        pub const X_MEM247 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a6f7));

        /// The memory that stores X
        pub const X_MEM248 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a6f8));

        /// The memory that stores X
        pub const X_MEM249 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a6f9));

        /// The memory that stores X
        pub const X_MEM250 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a6fa));

        /// The memory that stores X
        pub const X_MEM251 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a6fb));

        /// The memory that stores X
        pub const X_MEM252 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a6fc));

        /// The memory that stores X
        pub const X_MEM253 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a6fd));

        /// The memory that stores X
        pub const X_MEM254 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a6fe));

        /// The memory that stores X
        pub const X_MEM255 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a6ff));

        /// The memory that stores X
        pub const X_MEM256 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a700));

        /// The memory that stores X
        pub const X_MEM257 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a701));

        /// The memory that stores X
        pub const X_MEM258 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a702));

        /// The memory that stores X
        pub const X_MEM259 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a703));

        /// The memory that stores X
        pub const X_MEM260 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a704));

        /// The memory that stores X
        pub const X_MEM261 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a705));

        /// The memory that stores X
        pub const X_MEM262 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a706));

        /// The memory that stores X
        pub const X_MEM263 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a707));

        /// The memory that stores X
        pub const X_MEM264 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a708));

        /// The memory that stores X
        pub const X_MEM265 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a709));

        /// The memory that stores X
        pub const X_MEM266 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a70a));

        /// The memory that stores X
        pub const X_MEM267 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a70b));

        /// The memory that stores X
        pub const X_MEM268 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a70c));

        /// The memory that stores X
        pub const X_MEM269 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a70d));

        /// The memory that stores X
        pub const X_MEM270 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a70e));

        /// The memory that stores X
        pub const X_MEM271 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a70f));

        /// The memory that stores X
        pub const X_MEM272 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a710));

        /// The memory that stores X
        pub const X_MEM273 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a711));

        /// The memory that stores X
        pub const X_MEM274 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a712));

        /// The memory that stores X
        pub const X_MEM275 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a713));

        /// The memory that stores X
        pub const X_MEM276 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a714));

        /// The memory that stores X
        pub const X_MEM277 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a715));

        /// The memory that stores X
        pub const X_MEM278 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a716));

        /// The memory that stores X
        pub const X_MEM279 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a717));

        /// The memory that stores X
        pub const X_MEM280 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a718));

        /// The memory that stores X
        pub const X_MEM281 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a719));

        /// The memory that stores X
        pub const X_MEM282 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a71a));

        /// The memory that stores X
        pub const X_MEM283 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a71b));

        /// The memory that stores X
        pub const X_MEM284 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a71c));

        /// The memory that stores X
        pub const X_MEM285 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a71d));

        /// The memory that stores X
        pub const X_MEM286 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a71e));

        /// The memory that stores X
        pub const X_MEM287 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a71f));

        /// The memory that stores X
        pub const X_MEM288 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a720));

        /// The memory that stores X
        pub const X_MEM289 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a721));

        /// The memory that stores X
        pub const X_MEM290 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a722));

        /// The memory that stores X
        pub const X_MEM291 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a723));

        /// The memory that stores X
        pub const X_MEM292 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a724));

        /// The memory that stores X
        pub const X_MEM293 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a725));

        /// The memory that stores X
        pub const X_MEM294 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a726));

        /// The memory that stores X
        pub const X_MEM295 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a727));

        /// The memory that stores X
        pub const X_MEM296 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a728));

        /// The memory that stores X
        pub const X_MEM297 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a729));

        /// The memory that stores X
        pub const X_MEM298 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a72a));

        /// The memory that stores X
        pub const X_MEM299 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a72b));

        /// The memory that stores X
        pub const X_MEM300 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a72c));

        /// The memory that stores X
        pub const X_MEM301 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a72d));

        /// The memory that stores X
        pub const X_MEM302 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a72e));

        /// The memory that stores X
        pub const X_MEM303 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a72f));

        /// The memory that stores X
        pub const X_MEM304 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a730));

        /// The memory that stores X
        pub const X_MEM305 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a731));

        /// The memory that stores X
        pub const X_MEM306 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a732));

        /// The memory that stores X
        pub const X_MEM307 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a733));

        /// The memory that stores X
        pub const X_MEM308 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a734));

        /// The memory that stores X
        pub const X_MEM309 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a735));

        /// The memory that stores X
        pub const X_MEM310 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a736));

        /// The memory that stores X
        pub const X_MEM311 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a737));

        /// The memory that stores X
        pub const X_MEM312 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a738));

        /// The memory that stores X
        pub const X_MEM313 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a739));

        /// The memory that stores X
        pub const X_MEM314 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a73a));

        /// The memory that stores X
        pub const X_MEM315 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a73b));

        /// The memory that stores X
        pub const X_MEM316 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a73c));

        /// The memory that stores X
        pub const X_MEM317 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a73d));

        /// The memory that stores X
        pub const X_MEM318 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a73e));

        /// The memory that stores X
        pub const X_MEM319 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a73f));

        /// The memory that stores X
        pub const X_MEM320 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a740));

        /// The memory that stores X
        pub const X_MEM321 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a741));

        /// The memory that stores X
        pub const X_MEM322 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a742));

        /// The memory that stores X
        pub const X_MEM323 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a743));

        /// The memory that stores X
        pub const X_MEM324 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a744));

        /// The memory that stores X
        pub const X_MEM325 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a745));

        /// The memory that stores X
        pub const X_MEM326 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a746));

        /// The memory that stores X
        pub const X_MEM327 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a747));

        /// The memory that stores X
        pub const X_MEM328 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a748));

        /// The memory that stores X
        pub const X_MEM329 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a749));

        /// The memory that stores X
        pub const X_MEM330 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a74a));

        /// The memory that stores X
        pub const X_MEM331 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a74b));

        /// The memory that stores X
        pub const X_MEM332 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a74c));

        /// The memory that stores X
        pub const X_MEM333 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a74d));

        /// The memory that stores X
        pub const X_MEM334 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a74e));

        /// The memory that stores X
        pub const X_MEM335 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a74f));

        /// The memory that stores X
        pub const X_MEM336 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a750));

        /// The memory that stores X
        pub const X_MEM337 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a751));

        /// The memory that stores X
        pub const X_MEM338 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a752));

        /// The memory that stores X
        pub const X_MEM339 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a753));

        /// The memory that stores X
        pub const X_MEM340 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a754));

        /// The memory that stores X
        pub const X_MEM341 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a755));

        /// The memory that stores X
        pub const X_MEM342 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a756));

        /// The memory that stores X
        pub const X_MEM343 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a757));

        /// The memory that stores X
        pub const X_MEM344 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a758));

        /// The memory that stores X
        pub const X_MEM345 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a759));

        /// The memory that stores X
        pub const X_MEM346 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a75a));

        /// The memory that stores X
        pub const X_MEM347 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a75b));

        /// The memory that stores X
        pub const X_MEM348 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a75c));

        /// The memory that stores X
        pub const X_MEM349 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a75d));

        /// The memory that stores X
        pub const X_MEM350 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a75e));

        /// The memory that stores X
        pub const X_MEM351 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a75f));

        /// The memory that stores X
        pub const X_MEM352 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a760));

        /// The memory that stores X
        pub const X_MEM353 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a761));

        /// The memory that stores X
        pub const X_MEM354 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a762));

        /// The memory that stores X
        pub const X_MEM355 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a763));

        /// The memory that stores X
        pub const X_MEM356 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a764));

        /// The memory that stores X
        pub const X_MEM357 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a765));

        /// The memory that stores X
        pub const X_MEM358 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a766));

        /// The memory that stores X
        pub const X_MEM359 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a767));

        /// The memory that stores X
        pub const X_MEM360 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a768));

        /// The memory that stores X
        pub const X_MEM361 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a769));

        /// The memory that stores X
        pub const X_MEM362 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a76a));

        /// The memory that stores X
        pub const X_MEM363 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a76b));

        /// The memory that stores X
        pub const X_MEM364 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a76c));

        /// The memory that stores X
        pub const X_MEM365 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a76d));

        /// The memory that stores X
        pub const X_MEM366 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a76e));

        /// The memory that stores X
        pub const X_MEM367 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a76f));

        /// The memory that stores X
        pub const X_MEM368 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a770));

        /// The memory that stores X
        pub const X_MEM369 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a771));

        /// The memory that stores X
        pub const X_MEM370 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a772));

        /// The memory that stores X
        pub const X_MEM371 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a773));

        /// The memory that stores X
        pub const X_MEM372 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a774));

        /// The memory that stores X
        pub const X_MEM373 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a775));

        /// The memory that stores X
        pub const X_MEM374 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a776));

        /// The memory that stores X
        pub const X_MEM375 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a777));

        /// The memory that stores X
        pub const X_MEM376 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a778));

        /// The memory that stores X
        pub const X_MEM377 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a779));

        /// The memory that stores X
        pub const X_MEM378 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a77a));

        /// The memory that stores X
        pub const X_MEM379 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a77b));

        /// The memory that stores X
        pub const X_MEM380 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a77c));

        /// The memory that stores X
        pub const X_MEM381 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a77d));

        /// The memory that stores X
        pub const X_MEM382 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a77e));

        /// The memory that stores X
        pub const X_MEM383 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008a77f));

        /// RSA M_prime register
        pub const M_PRIME = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Those bits stores m'
          M_PRIME: u32,

        }), @ptrFromInt(0x6008a800));

        /// RSA mode register
        pub const MODE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:6] rsa mode (rsa length).
          MODE: u7,

          /// [7:31] 
          res0: u25,

        }), @ptrFromInt(0x6008a804));

        /// RSA query clean register
        pub const QUERY_CLEAN = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] query clean
          QUERY_CLEAN: u1,

          /// [1:31] 
          res0: u31,

        }), @ptrFromInt(0x6008a808));

        /// RSA modular exponentiation trigger register.
        pub const SET_START_MODEXP = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] start modular exponentiation
          SET_START_MODEXP: u1,

          /// [1:31] 
          res0: u31,

        }), @ptrFromInt(0x6008a80c));

        /// RSA modular multiplication trigger register.
        pub const SET_START_MODMULT = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] start modular multiplication
          SET_START_MODMULT: u1,

          /// [1:31] 
          res0: u31,

        }), @ptrFromInt(0x6008a810));

        /// RSA normal multiplication trigger register.
        pub const SET_START_MULT = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] start multiplicaiton
          SET_START_MULT: u1,

          /// [1:31] 
          res0: u31,

        }), @ptrFromInt(0x6008a814));

        /// RSA query idle register
        pub const QUERY_IDLE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] query rsa idle. 1'b0: busy, 1'b1: idle
          QUERY_IDLE: u1,

          /// [1:31] 
          res0: u31,

        }), @ptrFromInt(0x6008a818));

        /// RSA interrupt clear register
        pub const INT_CLR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] set this bit to clear RSA interrupt.
          CLEAR_INTERRUPT: u1,

          /// [1:31] 
          res0: u31,

        }), @ptrFromInt(0x6008a81c));

        /// RSA constant time option register
        pub const CONSTANT_TIME = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Configure this bit to 0 for acceleration. 0: with acceleration, 1: without acceleration(defalut).
          CONSTANT_TIME: u1,

          /// [1:31] 
          res0: u31,

        }), @ptrFromInt(0x6008a820));

        /// RSA search option
        pub const SEARCH_ENABLE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Configure this bit to 1 for acceleration. 1: with acceleration, 0: without acceleration(default). This option should be used together with RSA_SEARCH_POS.
          SEARCH_ENABLE: u1,

          /// [1:31] 
          res0: u31,

        }), @ptrFromInt(0x6008a824));

        /// RSA search position configure register
        pub const SEARCH_POS = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:11] Configure this field to set search position. This field should be used together with RSA_SEARCH_ENABLE. The field is only meaningful when RSA_SEARCH_ENABLE is high.
          SEARCH_POS: u12,

          /// [12:31] 
          res0: u20,

        }), @ptrFromInt(0x6008a828));

        /// RSA interrupt enable register
        pub const INT_ENA = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Set this bit to enable interrupt that occurs when rsa calculation is done. 1'b0: disable, 1'b1: enable(default).
          INT_ENA: u1,

          /// [1:31] 
          res0: u31,

        }), @ptrFromInt(0x6008a82c));

        /// RSA version control register
        pub const DATE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:29] rsa version information
          DATE: u30,

          /// [30:31] 
          res0: u2,

        }), @ptrFromInt(0x6008a830));

      };

      /// SHA (Secure Hash Algorithm) Accelerator
      pub const SHA = struct {

        /// Initial configuration register.
        pub const MODE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:2] Sha mode.
          MODE: u3,

          /// [3:31] 
          res0: u29,

        }), @ptrFromInt(0x60089000));

        /// SHA 512/t configuration register 0.
        pub const T_STRING = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Sha t_string (used if and only if mode == SHA_512/t).
          T_STRING: u32,

        }), @ptrFromInt(0x60089004));

        /// SHA 512/t configuration register 1.
        pub const T_LENGTH = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] Sha t_length (used if and only if mode == SHA_512/t).
          T_LENGTH: u6,

          /// [6:31] 
          res0: u26,

        }), @ptrFromInt(0x60089008));

        /// DMA configuration register 0.
        pub const DMA_BLOCK_NUM = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] Dma-sha block number.
          DMA_BLOCK_NUM: u6,

          /// [6:31] 
          res0: u26,

        }), @ptrFromInt(0x6008900c));

        /// Typical SHA configuration register 0.
        pub const START = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] 
          res0: u1,

          /// [1:31] Reserved.
          START: u31,

        }), @ptrFromInt(0x60089010));

        /// Typical SHA configuration register 1.
        pub const CONTINUE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] 
          res0: u1,

          /// [1:31] Reserved.
          CONTINUE: u31,

        }), @ptrFromInt(0x60089014));

        /// Busy register.
        pub const BUSY = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Sha busy state. 1'b0: idle. 1'b1: busy.
          STATE: u1,

          /// [1:31] 
          res0: u31,

        }), @ptrFromInt(0x60089018));

        /// DMA configuration register 1.
        pub const DMA_START = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Start dma-sha.
          DMA_START: u1,

          /// [1:31] 
          res0: u31,

        }), @ptrFromInt(0x6008901c));

        /// DMA configuration register 2.
        pub const DMA_CONTINUE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Continue dma-sha.
          DMA_CONTINUE: u1,

          /// [1:31] 
          res0: u31,

        }), @ptrFromInt(0x60089020));

        /// Interrupt clear register.
        pub const CLEAR_IRQ = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Clear sha interrupt.
          CLEAR_INTERRUPT: u1,

          /// [1:31] 
          res0: u31,

        }), @ptrFromInt(0x60089024));

        /// Interrupt enable register.
        pub const IRQ_ENA = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Sha interrupt enable register. 1'b0: disable(default). 1'b1: enable.
          INTERRUPT_ENA: u1,

          /// [1:31] 
          res0: u31,

        }), @ptrFromInt(0x60089028));

        /// Date register.
        pub const DATE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:29] Sha date information/ sha version information.
          DATE: u30,

          /// [30:31] 
          res0: u2,

        }), @ptrFromInt(0x6008902c));

        /// Sha H memory which contains intermediate hash or finial hash.
        pub const H_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x60089040));

        /// Sha H memory which contains intermediate hash or finial hash.
        pub const H_MEM1 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x60089041));

        /// Sha H memory which contains intermediate hash or finial hash.
        pub const H_MEM2 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x60089042));

        /// Sha H memory which contains intermediate hash or finial hash.
        pub const H_MEM3 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x60089043));

        /// Sha H memory which contains intermediate hash or finial hash.
        pub const H_MEM4 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x60089044));

        /// Sha H memory which contains intermediate hash or finial hash.
        pub const H_MEM5 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x60089045));

        /// Sha H memory which contains intermediate hash or finial hash.
        pub const H_MEM6 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x60089046));

        /// Sha H memory which contains intermediate hash or finial hash.
        pub const H_MEM7 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x60089047));

        /// Sha H memory which contains intermediate hash or finial hash.
        pub const H_MEM8 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x60089048));

        /// Sha H memory which contains intermediate hash or finial hash.
        pub const H_MEM9 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x60089049));

        /// Sha H memory which contains intermediate hash or finial hash.
        pub const H_MEM10 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008904a));

        /// Sha H memory which contains intermediate hash or finial hash.
        pub const H_MEM11 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008904b));

        /// Sha H memory which contains intermediate hash or finial hash.
        pub const H_MEM12 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008904c));

        /// Sha H memory which contains intermediate hash or finial hash.
        pub const H_MEM13 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008904d));

        /// Sha H memory which contains intermediate hash or finial hash.
        pub const H_MEM14 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008904e));

        /// Sha H memory which contains intermediate hash or finial hash.
        pub const H_MEM15 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008904f));

        /// Sha H memory which contains intermediate hash or finial hash.
        pub const H_MEM16 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x60089050));

        /// Sha H memory which contains intermediate hash or finial hash.
        pub const H_MEM17 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x60089051));

        /// Sha H memory which contains intermediate hash or finial hash.
        pub const H_MEM18 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x60089052));

        /// Sha H memory which contains intermediate hash or finial hash.
        pub const H_MEM19 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x60089053));

        /// Sha H memory which contains intermediate hash or finial hash.
        pub const H_MEM20 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x60089054));

        /// Sha H memory which contains intermediate hash or finial hash.
        pub const H_MEM21 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x60089055));

        /// Sha H memory which contains intermediate hash or finial hash.
        pub const H_MEM22 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x60089056));

        /// Sha H memory which contains intermediate hash or finial hash.
        pub const H_MEM23 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x60089057));

        /// Sha H memory which contains intermediate hash or finial hash.
        pub const H_MEM24 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x60089058));

        /// Sha H memory which contains intermediate hash or finial hash.
        pub const H_MEM25 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x60089059));

        /// Sha H memory which contains intermediate hash or finial hash.
        pub const H_MEM26 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008905a));

        /// Sha H memory which contains intermediate hash or finial hash.
        pub const H_MEM27 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008905b));

        /// Sha H memory which contains intermediate hash or finial hash.
        pub const H_MEM28 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008905c));

        /// Sha H memory which contains intermediate hash or finial hash.
        pub const H_MEM29 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008905d));

        /// Sha H memory which contains intermediate hash or finial hash.
        pub const H_MEM30 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008905e));

        /// Sha H memory which contains intermediate hash or finial hash.
        pub const H_MEM31 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008905f));

        /// Sha H memory which contains intermediate hash or finial hash.
        pub const H_MEM32 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x60089060));

        /// Sha H memory which contains intermediate hash or finial hash.
        pub const H_MEM33 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x60089061));

        /// Sha H memory which contains intermediate hash or finial hash.
        pub const H_MEM34 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x60089062));

        /// Sha H memory which contains intermediate hash or finial hash.
        pub const H_MEM35 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x60089063));

        /// Sha H memory which contains intermediate hash or finial hash.
        pub const H_MEM36 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x60089064));

        /// Sha H memory which contains intermediate hash or finial hash.
        pub const H_MEM37 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x60089065));

        /// Sha H memory which contains intermediate hash or finial hash.
        pub const H_MEM38 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x60089066));

        /// Sha H memory which contains intermediate hash or finial hash.
        pub const H_MEM39 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x60089067));

        /// Sha H memory which contains intermediate hash or finial hash.
        pub const H_MEM40 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x60089068));

        /// Sha H memory which contains intermediate hash or finial hash.
        pub const H_MEM41 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x60089069));

        /// Sha H memory which contains intermediate hash or finial hash.
        pub const H_MEM42 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008906a));

        /// Sha H memory which contains intermediate hash or finial hash.
        pub const H_MEM43 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008906b));

        /// Sha H memory which contains intermediate hash or finial hash.
        pub const H_MEM44 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008906c));

        /// Sha H memory which contains intermediate hash or finial hash.
        pub const H_MEM45 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008906d));

        /// Sha H memory which contains intermediate hash or finial hash.
        pub const H_MEM46 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008906e));

        /// Sha H memory which contains intermediate hash or finial hash.
        pub const H_MEM47 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008906f));

        /// Sha H memory which contains intermediate hash or finial hash.
        pub const H_MEM48 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x60089070));

        /// Sha H memory which contains intermediate hash or finial hash.
        pub const H_MEM49 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x60089071));

        /// Sha H memory which contains intermediate hash or finial hash.
        pub const H_MEM50 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x60089072));

        /// Sha H memory which contains intermediate hash or finial hash.
        pub const H_MEM51 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x60089073));

        /// Sha H memory which contains intermediate hash or finial hash.
        pub const H_MEM52 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x60089074));

        /// Sha H memory which contains intermediate hash or finial hash.
        pub const H_MEM53 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x60089075));

        /// Sha H memory which contains intermediate hash or finial hash.
        pub const H_MEM54 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x60089076));

        /// Sha H memory which contains intermediate hash or finial hash.
        pub const H_MEM55 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x60089077));

        /// Sha H memory which contains intermediate hash or finial hash.
        pub const H_MEM56 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x60089078));

        /// Sha H memory which contains intermediate hash or finial hash.
        pub const H_MEM57 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x60089079));

        /// Sha H memory which contains intermediate hash or finial hash.
        pub const H_MEM58 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008907a));

        /// Sha H memory which contains intermediate hash or finial hash.
        pub const H_MEM59 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008907b));

        /// Sha H memory which contains intermediate hash or finial hash.
        pub const H_MEM60 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008907c));

        /// Sha H memory which contains intermediate hash or finial hash.
        pub const H_MEM61 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008907d));

        /// Sha H memory which contains intermediate hash or finial hash.
        pub const H_MEM62 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008907e));

        /// Sha H memory which contains intermediate hash or finial hash.
        pub const H_MEM63 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008907f));

        /// Sha M memory which contains message.
        pub const M_MEM0 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x60089080));

        /// Sha M memory which contains message.
        pub const M_MEM1 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x60089081));

        /// Sha M memory which contains message.
        pub const M_MEM2 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x60089082));

        /// Sha M memory which contains message.
        pub const M_MEM3 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x60089083));

        /// Sha M memory which contains message.
        pub const M_MEM4 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x60089084));

        /// Sha M memory which contains message.
        pub const M_MEM5 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x60089085));

        /// Sha M memory which contains message.
        pub const M_MEM6 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x60089086));

        /// Sha M memory which contains message.
        pub const M_MEM7 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x60089087));

        /// Sha M memory which contains message.
        pub const M_MEM8 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x60089088));

        /// Sha M memory which contains message.
        pub const M_MEM9 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x60089089));

        /// Sha M memory which contains message.
        pub const M_MEM10 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008908a));

        /// Sha M memory which contains message.
        pub const M_MEM11 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008908b));

        /// Sha M memory which contains message.
        pub const M_MEM12 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008908c));

        /// Sha M memory which contains message.
        pub const M_MEM13 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008908d));

        /// Sha M memory which contains message.
        pub const M_MEM14 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008908e));

        /// Sha M memory which contains message.
        pub const M_MEM15 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008908f));

        /// Sha M memory which contains message.
        pub const M_MEM16 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x60089090));

        /// Sha M memory which contains message.
        pub const M_MEM17 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x60089091));

        /// Sha M memory which contains message.
        pub const M_MEM18 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x60089092));

        /// Sha M memory which contains message.
        pub const M_MEM19 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x60089093));

        /// Sha M memory which contains message.
        pub const M_MEM20 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x60089094));

        /// Sha M memory which contains message.
        pub const M_MEM21 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x60089095));

        /// Sha M memory which contains message.
        pub const M_MEM22 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x60089096));

        /// Sha M memory which contains message.
        pub const M_MEM23 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x60089097));

        /// Sha M memory which contains message.
        pub const M_MEM24 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x60089098));

        /// Sha M memory which contains message.
        pub const M_MEM25 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x60089099));

        /// Sha M memory which contains message.
        pub const M_MEM26 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008909a));

        /// Sha M memory which contains message.
        pub const M_MEM27 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008909b));

        /// Sha M memory which contains message.
        pub const M_MEM28 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008909c));

        /// Sha M memory which contains message.
        pub const M_MEM29 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008909d));

        /// Sha M memory which contains message.
        pub const M_MEM30 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008909e));

        /// Sha M memory which contains message.
        pub const M_MEM31 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x6008909f));

        /// Sha M memory which contains message.
        pub const M_MEM32 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x600890a0));

        /// Sha M memory which contains message.
        pub const M_MEM33 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x600890a1));

        /// Sha M memory which contains message.
        pub const M_MEM34 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x600890a2));

        /// Sha M memory which contains message.
        pub const M_MEM35 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x600890a3));

        /// Sha M memory which contains message.
        pub const M_MEM36 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x600890a4));

        /// Sha M memory which contains message.
        pub const M_MEM37 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x600890a5));

        /// Sha M memory which contains message.
        pub const M_MEM38 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x600890a6));

        /// Sha M memory which contains message.
        pub const M_MEM39 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x600890a7));

        /// Sha M memory which contains message.
        pub const M_MEM40 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x600890a8));

        /// Sha M memory which contains message.
        pub const M_MEM41 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x600890a9));

        /// Sha M memory which contains message.
        pub const M_MEM42 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x600890aa));

        /// Sha M memory which contains message.
        pub const M_MEM43 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x600890ab));

        /// Sha M memory which contains message.
        pub const M_MEM44 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x600890ac));

        /// Sha M memory which contains message.
        pub const M_MEM45 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x600890ad));

        /// Sha M memory which contains message.
        pub const M_MEM46 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x600890ae));

        /// Sha M memory which contains message.
        pub const M_MEM47 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x600890af));

        /// Sha M memory which contains message.
        pub const M_MEM48 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x600890b0));

        /// Sha M memory which contains message.
        pub const M_MEM49 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x600890b1));

        /// Sha M memory which contains message.
        pub const M_MEM50 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x600890b2));

        /// Sha M memory which contains message.
        pub const M_MEM51 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x600890b3));

        /// Sha M memory which contains message.
        pub const M_MEM52 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x600890b4));

        /// Sha M memory which contains message.
        pub const M_MEM53 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x600890b5));

        /// Sha M memory which contains message.
        pub const M_MEM54 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x600890b6));

        /// Sha M memory which contains message.
        pub const M_MEM55 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x600890b7));

        /// Sha M memory which contains message.
        pub const M_MEM56 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x600890b8));

        /// Sha M memory which contains message.
        pub const M_MEM57 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x600890b9));

        /// Sha M memory which contains message.
        pub const M_MEM58 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x600890ba));

        /// Sha M memory which contains message.
        pub const M_MEM59 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x600890bb));

        /// Sha M memory which contains message.
        pub const M_MEM60 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x600890bc));

        /// Sha M memory which contains message.
        pub const M_MEM61 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x600890bd));

        /// Sha M memory which contains message.
        pub const M_MEM62 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x600890be));

        /// Sha M memory which contains message.
        pub const M_MEM63 = @as(*volatile mmio.Mmio(packed struct(u8) {

          /// [0:7] 
          raw: u8,

        }), @ptrFromInt(0x600890bf));

      };

      /// SLCHOST Peripheral
      pub const SLCHOST = struct {

        /// *******Description***********
        pub const FUNC2_0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:23] 
          res0: u24,

          /// [24:24] *******Description***********
          SLC_FUNC2_INT: u1,

          /// [25:31] 
          res1: u7,

        }), @ptrFromInt(0x60017010));

        /// *******Description***********
        pub const FUNC2_1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] *******Description***********
          SLC_FUNC2_INT_EN: u1,

          /// [1:31] 
          res0: u31,

        }), @ptrFromInt(0x60017014));

        /// *******Description***********
        pub const FUNC2_2 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] *******Description***********
          SLC_FUNC1_MDSTAT: u1,

          /// [1:31] 
          res0: u31,

        }), @ptrFromInt(0x60017020));

        /// *******Description***********
        pub const GPIO_STATUS0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] *******Description***********
          GPIO_SDIO_INT0: u32,

        }), @ptrFromInt(0x60017034));

        /// *******Description***********
        pub const GPIO_STATUS1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] *******Description***********
          GPIO_SDIO_INT1: u32,

        }), @ptrFromInt(0x60017038));

        /// *******Description***********
        pub const GPIO_IN0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] *******Description***********
          GPIO_SDIO_IN0: u32,

        }), @ptrFromInt(0x6001703c));

        /// *******Description***********
        pub const GPIO_IN1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] *******Description***********
          GPIO_SDIO_IN1: u32,

        }), @ptrFromInt(0x60017040));

        /// *******Description***********
        pub const SLC0HOST_TOKEN_RDATA = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:11] *******Description***********
          SLC0_TOKEN0: u12,

          /// [12:12] *******Description***********
          SLC0_RX_PF_VALID: u1,

          /// [13:15] 
          res0: u3,

          /// [16:27] *******Description***********
          HOSTSLCHOST_SLC0_TOKEN1: u12,

          /// [28:31] *******Description***********
          SLC0_RX_PF_EOF: u4,

        }), @ptrFromInt(0x60017044));

        /// *******Description***********
        pub const SLC0_HOST_PF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] *******Description***********
          SLC0_PF_DATA: u32,

        }), @ptrFromInt(0x60017048));

        /// *******Description***********
        pub const SLC1_HOST_PF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] *******Description***********
          SLC1_PF_DATA: u32,

        }), @ptrFromInt(0x6001704c));

        /// *******Description***********
        pub const SLC0HOST_INT_RAW = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] *******Description***********
          SLC0_TOHOST_BIT0_INT_RAW: u1,

          /// [1:1] *******Description***********
          SLC0_TOHOST_BIT1_INT_RAW: u1,

          /// [2:2] *******Description***********
          SLC0_TOHOST_BIT2_INT_RAW: u1,

          /// [3:3] *******Description***********
          SLC0_TOHOST_BIT3_INT_RAW: u1,

          /// [4:4] *******Description***********
          SLC0_TOHOST_BIT4_INT_RAW: u1,

          /// [5:5] *******Description***********
          SLC0_TOHOST_BIT5_INT_RAW: u1,

          /// [6:6] *******Description***********
          SLC0_TOHOST_BIT6_INT_RAW: u1,

          /// [7:7] *******Description***********
          SLC0_TOHOST_BIT7_INT_RAW: u1,

          /// [8:8] *******Description***********
          SLC0_TOKEN0_1TO0_INT_RAW: u1,

          /// [9:9] *******Description***********
          SLC0_TOKEN1_1TO0_INT_RAW: u1,

          /// [10:10] *******Description***********
          SLC0_TOKEN0_0TO1_INT_RAW: u1,

          /// [11:11] *******Description***********
          SLC0_TOKEN1_0TO1_INT_RAW: u1,

          /// [12:12] *******Description***********
          SLC0HOST_RX_SOF_INT_RAW: u1,

          /// [13:13] *******Description***********
          SLC0HOST_RX_EOF_INT_RAW: u1,

          /// [14:14] *******Description***********
          SLC0HOST_RX_START_INT_RAW: u1,

          /// [15:15] *******Description***********
          SLC0HOST_TX_START_INT_RAW: u1,

          /// [16:16] *******Description***********
          SLC0_RX_UDF_INT_RAW: u1,

          /// [17:17] *******Description***********
          SLC0_TX_OVF_INT_RAW: u1,

          /// [18:18] *******Description***********
          SLC0_RX_PF_VALID_INT_RAW: u1,

          /// [19:19] *******Description***********
          SLC0_EXT_BIT0_INT_RAW: u1,

          /// [20:20] *******Description***********
          SLC0_EXT_BIT1_INT_RAW: u1,

          /// [21:21] *******Description***********
          SLC0_EXT_BIT2_INT_RAW: u1,

          /// [22:22] *******Description***********
          SLC0_EXT_BIT3_INT_RAW: u1,

          /// [23:23] *******Description***********
          SLC0_RX_NEW_PACKET_INT_RAW: u1,

          /// [24:24] *******Description***********
          SLC0_HOST_RD_RETRY_INT_RAW: u1,

          /// [25:25] *******Description***********
          GPIO_SDIO_INT_RAW: u1,

          /// [26:31] 
          res0: u6,

        }), @ptrFromInt(0x60017050));

        /// *******Description***********
        pub const SLC1HOST_INT_RAW = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] *******Description***********
          SLC1_TOHOST_BIT0_INT_RAW: u1,

          /// [1:1] *******Description***********
          SLC1_TOHOST_BIT1_INT_RAW: u1,

          /// [2:2] *******Description***********
          SLC1_TOHOST_BIT2_INT_RAW: u1,

          /// [3:3] *******Description***********
          SLC1_TOHOST_BIT3_INT_RAW: u1,

          /// [4:4] *******Description***********
          SLC1_TOHOST_BIT4_INT_RAW: u1,

          /// [5:5] *******Description***********
          SLC1_TOHOST_BIT5_INT_RAW: u1,

          /// [6:6] *******Description***********
          SLC1_TOHOST_BIT6_INT_RAW: u1,

          /// [7:7] *******Description***********
          SLC1_TOHOST_BIT7_INT_RAW: u1,

          /// [8:8] *******Description***********
          SLC1_TOKEN0_1TO0_INT_RAW: u1,

          /// [9:9] *******Description***********
          SLC1_TOKEN1_1TO0_INT_RAW: u1,

          /// [10:10] *******Description***********
          SLC1_TOKEN0_0TO1_INT_RAW: u1,

          /// [11:11] *******Description***********
          SLC1_TOKEN1_0TO1_INT_RAW: u1,

          /// [12:12] *******Description***********
          SLC1HOST_RX_SOF_INT_RAW: u1,

          /// [13:13] *******Description***********
          SLC1HOST_RX_EOF_INT_RAW: u1,

          /// [14:14] *******Description***********
          SLC1HOST_RX_START_INT_RAW: u1,

          /// [15:15] *******Description***********
          SLC1HOST_TX_START_INT_RAW: u1,

          /// [16:16] *******Description***********
          SLC1_RX_UDF_INT_RAW: u1,

          /// [17:17] *******Description***********
          SLC1_TX_OVF_INT_RAW: u1,

          /// [18:18] *******Description***********
          SLC1_RX_PF_VALID_INT_RAW: u1,

          /// [19:19] *******Description***********
          SLC1_EXT_BIT0_INT_RAW: u1,

          /// [20:20] *******Description***********
          SLC1_EXT_BIT1_INT_RAW: u1,

          /// [21:21] *******Description***********
          SLC1_EXT_BIT2_INT_RAW: u1,

          /// [22:22] *******Description***********
          SLC1_EXT_BIT3_INT_RAW: u1,

          /// [23:23] *******Description***********
          SLC1_WIFI_RX_NEW_PACKET_INT_RAW: u1,

          /// [24:24] *******Description***********
          SLC1_HOST_RD_RETRY_INT_RAW: u1,

          /// [25:25] *******Description***********
          SLC1_BT_RX_NEW_PACKET_INT_RAW: u1,

          /// [26:31] 
          res0: u6,

        }), @ptrFromInt(0x60017054));

        /// *******Description***********
        pub const SLC0HOST_INT_ST = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] *******Description***********
          SLC0_TOHOST_BIT0_INT_ST: u1,

          /// [1:1] *******Description***********
          SLC0_TOHOST_BIT1_INT_ST: u1,

          /// [2:2] *******Description***********
          SLC0_TOHOST_BIT2_INT_ST: u1,

          /// [3:3] *******Description***********
          SLC0_TOHOST_BIT3_INT_ST: u1,

          /// [4:4] *******Description***********
          SLC0_TOHOST_BIT4_INT_ST: u1,

          /// [5:5] *******Description***********
          SLC0_TOHOST_BIT5_INT_ST: u1,

          /// [6:6] *******Description***********
          SLC0_TOHOST_BIT6_INT_ST: u1,

          /// [7:7] *******Description***********
          SLC0_TOHOST_BIT7_INT_ST: u1,

          /// [8:8] *******Description***********
          SLC0_TOKEN0_1TO0_INT_ST: u1,

          /// [9:9] *******Description***********
          SLC0_TOKEN1_1TO0_INT_ST: u1,

          /// [10:10] *******Description***********
          SLC0_TOKEN0_0TO1_INT_ST: u1,

          /// [11:11] *******Description***********
          SLC0_TOKEN1_0TO1_INT_ST: u1,

          /// [12:12] *******Description***********
          SLC0HOST_RX_SOF_INT_ST: u1,

          /// [13:13] *******Description***********
          SLC0HOST_RX_EOF_INT_ST: u1,

          /// [14:14] *******Description***********
          SLC0HOST_RX_START_INT_ST: u1,

          /// [15:15] *******Description***********
          SLC0HOST_TX_START_INT_ST: u1,

          /// [16:16] *******Description***********
          SLC0_RX_UDF_INT_ST: u1,

          /// [17:17] *******Description***********
          SLC0_TX_OVF_INT_ST: u1,

          /// [18:18] *******Description***********
          SLC0_RX_PF_VALID_INT_ST: u1,

          /// [19:19] *******Description***********
          SLC0_EXT_BIT0_INT_ST: u1,

          /// [20:20] *******Description***********
          SLC0_EXT_BIT1_INT_ST: u1,

          /// [21:21] *******Description***********
          SLC0_EXT_BIT2_INT_ST: u1,

          /// [22:22] *******Description***********
          SLC0_EXT_BIT3_INT_ST: u1,

          /// [23:23] *******Description***********
          SLC0_RX_NEW_PACKET_INT_ST: u1,

          /// [24:24] *******Description***********
          SLC0_HOST_RD_RETRY_INT_ST: u1,

          /// [25:25] *******Description***********
          GPIO_SDIO_INT_ST: u1,

          /// [26:31] 
          res0: u6,

        }), @ptrFromInt(0x60017058));

        /// *******Description***********
        pub const SLC1HOST_INT_ST = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] *******Description***********
          SLC1_TOHOST_BIT0_INT_ST: u1,

          /// [1:1] *******Description***********
          SLC1_TOHOST_BIT1_INT_ST: u1,

          /// [2:2] *******Description***********
          SLC1_TOHOST_BIT2_INT_ST: u1,

          /// [3:3] *******Description***********
          SLC1_TOHOST_BIT3_INT_ST: u1,

          /// [4:4] *******Description***********
          SLC1_TOHOST_BIT4_INT_ST: u1,

          /// [5:5] *******Description***********
          SLC1_TOHOST_BIT5_INT_ST: u1,

          /// [6:6] *******Description***********
          SLC1_TOHOST_BIT6_INT_ST: u1,

          /// [7:7] *******Description***********
          SLC1_TOHOST_BIT7_INT_ST: u1,

          /// [8:8] *******Description***********
          SLC1_TOKEN0_1TO0_INT_ST: u1,

          /// [9:9] *******Description***********
          SLC1_TOKEN1_1TO0_INT_ST: u1,

          /// [10:10] *******Description***********
          SLC1_TOKEN0_0TO1_INT_ST: u1,

          /// [11:11] *******Description***********
          SLC1_TOKEN1_0TO1_INT_ST: u1,

          /// [12:12] *******Description***********
          SLC1HOST_RX_SOF_INT_ST: u1,

          /// [13:13] *******Description***********
          SLC1HOST_RX_EOF_INT_ST: u1,

          /// [14:14] *******Description***********
          SLC1HOST_RX_START_INT_ST: u1,

          /// [15:15] *******Description***********
          SLC1HOST_TX_START_INT_ST: u1,

          /// [16:16] *******Description***********
          SLC1_RX_UDF_INT_ST: u1,

          /// [17:17] *******Description***********
          SLC1_TX_OVF_INT_ST: u1,

          /// [18:18] *******Description***********
          SLC1_RX_PF_VALID_INT_ST: u1,

          /// [19:19] *******Description***********
          SLC1_EXT_BIT0_INT_ST: u1,

          /// [20:20] *******Description***********
          SLC1_EXT_BIT1_INT_ST: u1,

          /// [21:21] *******Description***********
          SLC1_EXT_BIT2_INT_ST: u1,

          /// [22:22] *******Description***********
          SLC1_EXT_BIT3_INT_ST: u1,

          /// [23:23] *******Description***********
          SLC1_WIFI_RX_NEW_PACKET_INT_ST: u1,

          /// [24:24] *******Description***********
          SLC1_HOST_RD_RETRY_INT_ST: u1,

          /// [25:25] *******Description***********
          SLC1_BT_RX_NEW_PACKET_INT_ST: u1,

          /// [26:31] 
          res0: u6,

        }), @ptrFromInt(0x6001705c));

        /// *******Description***********
        pub const PKT_LEN = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:19] *******Description***********
          HOSTSLCHOST_SLC0_LEN: u20,

          /// [20:31] *******Description***********
          HOSTSLCHOST_SLC0_LEN_CHECK: u12,

        }), @ptrFromInt(0x60017060));

        /// *******Description***********
        pub const STATE_W0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] *******Description***********
          SLCHOST_STATE0: u8,

          /// [8:15] *******Description***********
          SLCHOST_STATE1: u8,

          /// [16:23] *******Description***********
          SLCHOST_STATE2: u8,

          /// [24:31] *******Description***********
          SLCHOST_STATE3: u8,

        }), @ptrFromInt(0x60017064));

        /// *******Description***********
        pub const STATE_W1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] *******Description***********
          SLCHOST_STATE4: u8,

          /// [8:15] *******Description***********
          SLCHOST_STATE5: u8,

          /// [16:23] *******Description***********
          SLCHOST_STATE6: u8,

          /// [24:31] *******Description***********
          SLCHOST_STATE7: u8,

        }), @ptrFromInt(0x60017068));

        /// *******Description***********
        pub const CONF_W0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] *******Description***********
          SLCHOST_CONF0: u8,

          /// [8:15] *******Description***********
          SLCHOST_CONF1: u8,

          /// [16:23] *******Description***********
          SLCHOST_CONF2: u8,

          /// [24:31] *******Description***********
          SLCHOST_CONF3: u8,

        }), @ptrFromInt(0x6001706c));

        /// *******Description***********
        pub const CONF_W1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] *******Description***********
          SLCHOST_CONF4: u8,

          /// [8:15] *******Description***********
          SLCHOST_CONF5: u8,

          /// [16:23] *******Description***********
          SLCHOST_CONF6: u8,

          /// [24:31] *******Description***********
          SLCHOST_CONF7: u8,

        }), @ptrFromInt(0x60017070));

        /// *******Description***********
        pub const CONF_W2 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] *******Description***********
          SLCHOST_CONF8: u8,

          /// [8:15] *******Description***********
          SLCHOST_CONF9: u8,

          /// [16:23] *******Description***********
          SLCHOST_CONF10: u8,

          /// [24:31] *******Description***********
          SLCHOST_CONF11: u8,

        }), @ptrFromInt(0x60017074));

        /// *******Description***********
        pub const CONF_W3 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] *******Description***********
          SLCHOST_CONF12: u8,

          /// [8:15] *******Description***********
          SLCHOST_CONF13: u8,

          /// [16:23] *******Description***********
          SLCHOST_CONF14: u8,

          /// [24:31] *******Description***********
          SLCHOST_CONF15: u8,

        }), @ptrFromInt(0x60017078));

        /// *******Description***********
        pub const CONF_W4 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] *******Description***********
          SLCHOST_CONF16: u8,

          /// [8:15] *******Description***********
          SLCHOST_CONF17: u8,

          /// [16:23] *******Description***********
          SLCHOST_CONF18: u8,

          /// [24:31] *******Description***********
          SLCHOST_CONF19: u8,

        }), @ptrFromInt(0x6001707c));

        /// *******Description***********
        pub const CONF_W5 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] *******Description***********
          SLCHOST_CONF20: u8,

          /// [8:15] *******Description***********
          SLCHOST_CONF21: u8,

          /// [16:23] *******Description***********
          SLCHOST_CONF22: u8,

          /// [24:31] *******Description***********
          SLCHOST_CONF23: u8,

        }), @ptrFromInt(0x60017080));

        /// *******Description***********
        pub const WIN_CMD = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:15] *******Description***********
          SLCHOST_WIN_CMD: u16,

          /// [16:31] 
          res0: u16,

        }), @ptrFromInt(0x60017084));

        /// *******Description***********
        pub const CONF_W6 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] *******Description***********
          SLCHOST_CONF24: u8,

          /// [8:15] *******Description***********
          SLCHOST_CONF25: u8,

          /// [16:23] *******Description***********
          SLCHOST_CONF26: u8,

          /// [24:31] *******Description***********
          SLCHOST_CONF27: u8,

        }), @ptrFromInt(0x60017088));

        /// *******Description***********
        pub const CONF_W7 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] *******Description***********
          SLCHOST_CONF28: u8,

          /// [8:15] *******Description***********
          SLCHOST_CONF29: u8,

          /// [16:23] *******Description***********
          SLCHOST_CONF30: u8,

          /// [24:31] *******Description***********
          SLCHOST_CONF31: u8,

        }), @ptrFromInt(0x6001708c));

        /// *******Description***********
        pub const PKT_LEN0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:19] *******Description***********
          HOSTSLCHOST_SLC0_LEN0: u20,

          /// [20:31] *******Description***********
          HOSTSLCHOST_SLC0_LEN0_CHECK: u12,

        }), @ptrFromInt(0x60017090));

        /// *******Description***********
        pub const PKT_LEN1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:19] *******Description***********
          HOSTSLCHOST_SLC0_LEN1: u20,

          /// [20:31] *******Description***********
          HOSTSLCHOST_SLC0_LEN1_CHECK: u12,

        }), @ptrFromInt(0x60017094));

        /// *******Description***********
        pub const PKT_LEN2 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:19] *******Description***********
          HOSTSLCHOST_SLC0_LEN2: u20,

          /// [20:31] *******Description***********
          HOSTSLCHOST_SLC0_LEN2_CHECK: u12,

        }), @ptrFromInt(0x60017098));

        /// *******Description***********
        pub const CONF_W8 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] *******Description***********
          SLCHOST_CONF32: u8,

          /// [8:15] *******Description***********
          SLCHOST_CONF33: u8,

          /// [16:23] *******Description***********
          SLCHOST_CONF34: u8,

          /// [24:31] *******Description***********
          SLCHOST_CONF35: u8,

        }), @ptrFromInt(0x6001709c));

        /// *******Description***********
        pub const CONF_W9 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] *******Description***********
          SLCHOST_CONF36: u8,

          /// [8:15] *******Description***********
          SLCHOST_CONF37: u8,

          /// [16:23] *******Description***********
          SLCHOST_CONF38: u8,

          /// [24:31] *******Description***********
          SLCHOST_CONF39: u8,

        }), @ptrFromInt(0x600170a0));

        /// *******Description***********
        pub const CONF_W10 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] *******Description***********
          SLCHOST_CONF40: u8,

          /// [8:15] *******Description***********
          SLCHOST_CONF41: u8,

          /// [16:23] *******Description***********
          SLCHOST_CONF42: u8,

          /// [24:31] *******Description***********
          SLCHOST_CONF43: u8,

        }), @ptrFromInt(0x600170a4));

        /// *******Description***********
        pub const CONF_W11 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] *******Description***********
          SLCHOST_CONF44: u8,

          /// [8:15] *******Description***********
          SLCHOST_CONF45: u8,

          /// [16:23] *******Description***********
          SLCHOST_CONF46: u8,

          /// [24:31] *******Description***********
          SLCHOST_CONF47: u8,

        }), @ptrFromInt(0x600170a8));

        /// *******Description***********
        pub const CONF_W12 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] *******Description***********
          SLCHOST_CONF48: u8,

          /// [8:15] *******Description***********
          SLCHOST_CONF49: u8,

          /// [16:23] *******Description***********
          SLCHOST_CONF50: u8,

          /// [24:31] *******Description***********
          SLCHOST_CONF51: u8,

        }), @ptrFromInt(0x600170ac));

        /// *******Description***********
        pub const CONF_W13 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] *******Description***********
          SLCHOST_CONF52: u8,

          /// [8:15] *******Description***********
          SLCHOST_CONF53: u8,

          /// [16:23] *******Description***********
          SLCHOST_CONF54: u8,

          /// [24:31] *******Description***********
          SLCHOST_CONF55: u8,

        }), @ptrFromInt(0x600170b0));

        /// *******Description***********
        pub const CONF_W14 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] *******Description***********
          SLCHOST_CONF56: u8,

          /// [8:15] *******Description***********
          SLCHOST_CONF57: u8,

          /// [16:23] *******Description***********
          SLCHOST_CONF58: u8,

          /// [24:31] *******Description***********
          SLCHOST_CONF59: u8,

        }), @ptrFromInt(0x600170b4));

        /// *******Description***********
        pub const CONF_W15 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] *******Description***********
          SLCHOST_CONF60: u8,

          /// [8:15] *******Description***********
          SLCHOST_CONF61: u8,

          /// [16:23] *******Description***********
          SLCHOST_CONF62: u8,

          /// [24:31] *******Description***********
          SLCHOST_CONF63: u8,

        }), @ptrFromInt(0x600170b8));

        /// *******Description***********
        pub const CHECK_SUM0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] *******Description***********
          SLCHOST_CHECK_SUM0: u32,

        }), @ptrFromInt(0x600170bc));

        /// *******Description***********
        pub const CHECK_SUM1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] *******Description***********
          SLCHOST_CHECK_SUM1: u32,

        }), @ptrFromInt(0x600170c0));

        /// *******Description***********
        pub const SLC1HOST_TOKEN_RDATA = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:11] *******Description***********
          SLC1_TOKEN0: u12,

          /// [12:12] *******Description***********
          SLC1_RX_PF_VALID: u1,

          /// [13:15] 
          res0: u3,

          /// [16:27] *******Description***********
          HOSTSLCHOST_SLC1_TOKEN1: u12,

          /// [28:31] *******Description***********
          SLC1_RX_PF_EOF: u4,

        }), @ptrFromInt(0x600170c4));

        /// *******Description***********
        pub const SLC0HOST_TOKEN_WDATA = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:11] *******Description***********
          SLC0HOST_TOKEN0_WD: u12,

          /// [12:15] 
          res0: u4,

          /// [16:27] *******Description***********
          SLC0HOST_TOKEN1_WD: u12,

          /// [28:31] 
          res1: u4,

        }), @ptrFromInt(0x600170c8));

        /// *******Description***********
        pub const SLC1HOST_TOKEN_WDATA = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:11] *******Description***********
          SLC1HOST_TOKEN0_WD: u12,

          /// [12:15] 
          res0: u4,

          /// [16:27] *******Description***********
          SLC1HOST_TOKEN1_WD: u12,

          /// [28:31] 
          res1: u4,

        }), @ptrFromInt(0x600170cc));

        /// *******Description***********
        pub const TOKEN_CON = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] *******Description***********
          SLC0HOST_TOKEN0_DEC: u1,

          /// [1:1] *******Description***********
          SLC0HOST_TOKEN1_DEC: u1,

          /// [2:2] *******Description***********
          SLC0HOST_TOKEN0_WR: u1,

          /// [3:3] *******Description***********
          SLC0HOST_TOKEN1_WR: u1,

          /// [4:4] *******Description***********
          SLC1HOST_TOKEN0_DEC: u1,

          /// [5:5] *******Description***********
          SLC1HOST_TOKEN1_DEC: u1,

          /// [6:6] *******Description***********
          SLC1HOST_TOKEN0_WR: u1,

          /// [7:7] *******Description***********
          SLC1HOST_TOKEN1_WR: u1,

          /// [8:8] *******Description***********
          SLC0HOST_LEN_WR: u1,

          /// [9:31] 
          res0: u23,

        }), @ptrFromInt(0x600170d0));

        /// *******Description***********
        pub const SLC0HOST_INT_CLR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] *******Description***********
          SLC0_TOHOST_BIT0_INT_CLR: u1,

          /// [1:1] *******Description***********
          SLC0_TOHOST_BIT1_INT_CLR: u1,

          /// [2:2] *******Description***********
          SLC0_TOHOST_BIT2_INT_CLR: u1,

          /// [3:3] *******Description***********
          SLC0_TOHOST_BIT3_INT_CLR: u1,

          /// [4:4] *******Description***********
          SLC0_TOHOST_BIT4_INT_CLR: u1,

          /// [5:5] *******Description***********
          SLC0_TOHOST_BIT5_INT_CLR: u1,

          /// [6:6] *******Description***********
          SLC0_TOHOST_BIT6_INT_CLR: u1,

          /// [7:7] *******Description***********
          SLC0_TOHOST_BIT7_INT_CLR: u1,

          /// [8:8] *******Description***********
          SLC0_TOKEN0_1TO0_INT_CLR: u1,

          /// [9:9] *******Description***********
          SLC0_TOKEN1_1TO0_INT_CLR: u1,

          /// [10:10] *******Description***********
          SLC0_TOKEN0_0TO1_INT_CLR: u1,

          /// [11:11] *******Description***********
          SLC0_TOKEN1_0TO1_INT_CLR: u1,

          /// [12:12] *******Description***********
          SLC0HOST_RX_SOF_INT_CLR: u1,

          /// [13:13] *******Description***********
          SLC0HOST_RX_EOF_INT_CLR: u1,

          /// [14:14] *******Description***********
          SLC0HOST_RX_START_INT_CLR: u1,

          /// [15:15] *******Description***********
          SLC0HOST_TX_START_INT_CLR: u1,

          /// [16:16] *******Description***********
          SLC0_RX_UDF_INT_CLR: u1,

          /// [17:17] *******Description***********
          SLC0_TX_OVF_INT_CLR: u1,

          /// [18:18] *******Description***********
          SLC0_RX_PF_VALID_INT_CLR: u1,

          /// [19:19] *******Description***********
          SLC0_EXT_BIT0_INT_CLR: u1,

          /// [20:20] *******Description***********
          SLC0_EXT_BIT1_INT_CLR: u1,

          /// [21:21] *******Description***********
          SLC0_EXT_BIT2_INT_CLR: u1,

          /// [22:22] *******Description***********
          SLC0_EXT_BIT3_INT_CLR: u1,

          /// [23:23] *******Description***********
          SLC0_RX_NEW_PACKET_INT_CLR: u1,

          /// [24:24] *******Description***********
          SLC0_HOST_RD_RETRY_INT_CLR: u1,

          /// [25:25] *******Description***********
          GPIO_SDIO_INT_CLR: u1,

          /// [26:31] 
          res0: u6,

        }), @ptrFromInt(0x600170d4));

        /// *******Description***********
        pub const SLC1HOST_INT_CLR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] *******Description***********
          SLC1_TOHOST_BIT0_INT_CLR: u1,

          /// [1:1] *******Description***********
          SLC1_TOHOST_BIT1_INT_CLR: u1,

          /// [2:2] *******Description***********
          SLC1_TOHOST_BIT2_INT_CLR: u1,

          /// [3:3] *******Description***********
          SLC1_TOHOST_BIT3_INT_CLR: u1,

          /// [4:4] *******Description***********
          SLC1_TOHOST_BIT4_INT_CLR: u1,

          /// [5:5] *******Description***********
          SLC1_TOHOST_BIT5_INT_CLR: u1,

          /// [6:6] *******Description***********
          SLC1_TOHOST_BIT6_INT_CLR: u1,

          /// [7:7] *******Description***********
          SLC1_TOHOST_BIT7_INT_CLR: u1,

          /// [8:8] *******Description***********
          SLC1_TOKEN0_1TO0_INT_CLR: u1,

          /// [9:9] *******Description***********
          SLC1_TOKEN1_1TO0_INT_CLR: u1,

          /// [10:10] *******Description***********
          SLC1_TOKEN0_0TO1_INT_CLR: u1,

          /// [11:11] *******Description***********
          SLC1_TOKEN1_0TO1_INT_CLR: u1,

          /// [12:12] *******Description***********
          SLC1HOST_RX_SOF_INT_CLR: u1,

          /// [13:13] *******Description***********
          SLC1HOST_RX_EOF_INT_CLR: u1,

          /// [14:14] *******Description***********
          SLC1HOST_RX_START_INT_CLR: u1,

          /// [15:15] *******Description***********
          SLC1HOST_TX_START_INT_CLR: u1,

          /// [16:16] *******Description***********
          SLC1_RX_UDF_INT_CLR: u1,

          /// [17:17] *******Description***********
          SLC1_TX_OVF_INT_CLR: u1,

          /// [18:18] *******Description***********
          SLC1_RX_PF_VALID_INT_CLR: u1,

          /// [19:19] *******Description***********
          SLC1_EXT_BIT0_INT_CLR: u1,

          /// [20:20] *******Description***********
          SLC1_EXT_BIT1_INT_CLR: u1,

          /// [21:21] *******Description***********
          SLC1_EXT_BIT2_INT_CLR: u1,

          /// [22:22] *******Description***********
          SLC1_EXT_BIT3_INT_CLR: u1,

          /// [23:23] *******Description***********
          SLC1_WIFI_RX_NEW_PACKET_INT_CLR: u1,

          /// [24:24] *******Description***********
          SLC1_HOST_RD_RETRY_INT_CLR: u1,

          /// [25:25] *******Description***********
          SLC1_BT_RX_NEW_PACKET_INT_CLR: u1,

          /// [26:31] 
          res0: u6,

        }), @ptrFromInt(0x600170d8));

        /// *******Description***********
        pub const SLC0HOST_FUNC1_INT_ENA = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] *******Description***********
          FN1_SLC0_TOHOST_BIT0_INT_ENA: u1,

          /// [1:1] *******Description***********
          FN1_SLC0_TOHOST_BIT1_INT_ENA: u1,

          /// [2:2] *******Description***********
          FN1_SLC0_TOHOST_BIT2_INT_ENA: u1,

          /// [3:3] *******Description***********
          FN1_SLC0_TOHOST_BIT3_INT_ENA: u1,

          /// [4:4] *******Description***********
          FN1_SLC0_TOHOST_BIT4_INT_ENA: u1,

          /// [5:5] *******Description***********
          FN1_SLC0_TOHOST_BIT5_INT_ENA: u1,

          /// [6:6] *******Description***********
          FN1_SLC0_TOHOST_BIT6_INT_ENA: u1,

          /// [7:7] *******Description***********
          FN1_SLC0_TOHOST_BIT7_INT_ENA: u1,

          /// [8:8] *******Description***********
          FN1_SLC0_TOKEN0_1TO0_INT_ENA: u1,

          /// [9:9] *******Description***********
          FN1_SLC0_TOKEN1_1TO0_INT_ENA: u1,

          /// [10:10] *******Description***********
          FN1_SLC0_TOKEN0_0TO1_INT_ENA: u1,

          /// [11:11] *******Description***********
          FN1_SLC0_TOKEN1_0TO1_INT_ENA: u1,

          /// [12:12] *******Description***********
          FN1_SLC0HOST_RX_SOF_INT_ENA: u1,

          /// [13:13] *******Description***********
          FN1_SLC0HOST_RX_EOF_INT_ENA: u1,

          /// [14:14] *******Description***********
          FN1_SLC0HOST_RX_START_INT_ENA: u1,

          /// [15:15] *******Description***********
          FN1_SLC0HOST_TX_START_INT_ENA: u1,

          /// [16:16] *******Description***********
          FN1_SLC0_RX_UDF_INT_ENA: u1,

          /// [17:17] *******Description***********
          FN1_SLC0_TX_OVF_INT_ENA: u1,

          /// [18:18] *******Description***********
          FN1_SLC0_RX_PF_VALID_INT_ENA: u1,

          /// [19:19] *******Description***********
          FN1_SLC0_EXT_BIT0_INT_ENA: u1,

          /// [20:20] *******Description***********
          FN1_SLC0_EXT_BIT1_INT_ENA: u1,

          /// [21:21] *******Description***********
          FN1_SLC0_EXT_BIT2_INT_ENA: u1,

          /// [22:22] *******Description***********
          FN1_SLC0_EXT_BIT3_INT_ENA: u1,

          /// [23:23] *******Description***********
          FN1_SLC0_RX_NEW_PACKET_INT_ENA: u1,

          /// [24:24] *******Description***********
          FN1_SLC0_HOST_RD_RETRY_INT_ENA: u1,

          /// [25:25] *******Description***********
          FN1_GPIO_SDIO_INT_ENA: u1,

          /// [26:31] 
          res0: u6,

        }), @ptrFromInt(0x600170dc));

        /// *******Description***********
        pub const SLC1HOST_FUNC1_INT_ENA = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] *******Description***********
          FN1_SLC1_TOHOST_BIT0_INT_ENA: u1,

          /// [1:1] *******Description***********
          FN1_SLC1_TOHOST_BIT1_INT_ENA: u1,

          /// [2:2] *******Description***********
          FN1_SLC1_TOHOST_BIT2_INT_ENA: u1,

          /// [3:3] *******Description***********
          FN1_SLC1_TOHOST_BIT3_INT_ENA: u1,

          /// [4:4] *******Description***********
          FN1_SLC1_TOHOST_BIT4_INT_ENA: u1,

          /// [5:5] *******Description***********
          FN1_SLC1_TOHOST_BIT5_INT_ENA: u1,

          /// [6:6] *******Description***********
          FN1_SLC1_TOHOST_BIT6_INT_ENA: u1,

          /// [7:7] *******Description***********
          FN1_SLC1_TOHOST_BIT7_INT_ENA: u1,

          /// [8:8] *******Description***********
          FN1_SLC1_TOKEN0_1TO0_INT_ENA: u1,

          /// [9:9] *******Description***********
          FN1_SLC1_TOKEN1_1TO0_INT_ENA: u1,

          /// [10:10] *******Description***********
          FN1_SLC1_TOKEN0_0TO1_INT_ENA: u1,

          /// [11:11] *******Description***********
          FN1_SLC1_TOKEN1_0TO1_INT_ENA: u1,

          /// [12:12] *******Description***********
          FN1_SLC1HOST_RX_SOF_INT_ENA: u1,

          /// [13:13] *******Description***********
          FN1_SLC1HOST_RX_EOF_INT_ENA: u1,

          /// [14:14] *******Description***********
          FN1_SLC1HOST_RX_START_INT_ENA: u1,

          /// [15:15] *******Description***********
          FN1_SLC1HOST_TX_START_INT_ENA: u1,

          /// [16:16] *******Description***********
          FN1_SLC1_RX_UDF_INT_ENA: u1,

          /// [17:17] *******Description***********
          FN1_SLC1_TX_OVF_INT_ENA: u1,

          /// [18:18] *******Description***********
          FN1_SLC1_RX_PF_VALID_INT_ENA: u1,

          /// [19:19] *******Description***********
          FN1_SLC1_EXT_BIT0_INT_ENA: u1,

          /// [20:20] *******Description***********
          FN1_SLC1_EXT_BIT1_INT_ENA: u1,

          /// [21:21] *******Description***********
          FN1_SLC1_EXT_BIT2_INT_ENA: u1,

          /// [22:22] *******Description***********
          FN1_SLC1_EXT_BIT3_INT_ENA: u1,

          /// [23:23] *******Description***********
          FN1_SLC1_WIFI_RX_NEW_PACKET_INT_ENA: u1,

          /// [24:24] *******Description***********
          FN1_SLC1_HOST_RD_RETRY_INT_ENA: u1,

          /// [25:25] *******Description***********
          FN1_SLC1_BT_RX_NEW_PACKET_INT_ENA: u1,

          /// [26:31] 
          res0: u6,

        }), @ptrFromInt(0x600170e0));

        /// *******Description***********
        pub const SLC0HOST_FUNC2_INT_ENA = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] *******Description***********
          FN2_SLC0_TOHOST_BIT0_INT_ENA: u1,

          /// [1:1] *******Description***********
          FN2_SLC0_TOHOST_BIT1_INT_ENA: u1,

          /// [2:2] *******Description***********
          FN2_SLC0_TOHOST_BIT2_INT_ENA: u1,

          /// [3:3] *******Description***********
          FN2_SLC0_TOHOST_BIT3_INT_ENA: u1,

          /// [4:4] *******Description***********
          FN2_SLC0_TOHOST_BIT4_INT_ENA: u1,

          /// [5:5] *******Description***********
          FN2_SLC0_TOHOST_BIT5_INT_ENA: u1,

          /// [6:6] *******Description***********
          FN2_SLC0_TOHOST_BIT6_INT_ENA: u1,

          /// [7:7] *******Description***********
          FN2_SLC0_TOHOST_BIT7_INT_ENA: u1,

          /// [8:8] *******Description***********
          FN2_SLC0_TOKEN0_1TO0_INT_ENA: u1,

          /// [9:9] *******Description***********
          FN2_SLC0_TOKEN1_1TO0_INT_ENA: u1,

          /// [10:10] *******Description***********
          FN2_SLC0_TOKEN0_0TO1_INT_ENA: u1,

          /// [11:11] *******Description***********
          FN2_SLC0_TOKEN1_0TO1_INT_ENA: u1,

          /// [12:12] *******Description***********
          FN2_SLC0HOST_RX_SOF_INT_ENA: u1,

          /// [13:13] *******Description***********
          FN2_SLC0HOST_RX_EOF_INT_ENA: u1,

          /// [14:14] *******Description***********
          FN2_SLC0HOST_RX_START_INT_ENA: u1,

          /// [15:15] *******Description***********
          FN2_SLC0HOST_TX_START_INT_ENA: u1,

          /// [16:16] *******Description***********
          FN2_SLC0_RX_UDF_INT_ENA: u1,

          /// [17:17] *******Description***********
          FN2_SLC0_TX_OVF_INT_ENA: u1,

          /// [18:18] *******Description***********
          FN2_SLC0_RX_PF_VALID_INT_ENA: u1,

          /// [19:19] *******Description***********
          FN2_SLC0_EXT_BIT0_INT_ENA: u1,

          /// [20:20] *******Description***********
          FN2_SLC0_EXT_BIT1_INT_ENA: u1,

          /// [21:21] *******Description***********
          FN2_SLC0_EXT_BIT2_INT_ENA: u1,

          /// [22:22] *******Description***********
          FN2_SLC0_EXT_BIT3_INT_ENA: u1,

          /// [23:23] *******Description***********
          FN2_SLC0_RX_NEW_PACKET_INT_ENA: u1,

          /// [24:24] *******Description***********
          FN2_SLC0_HOST_RD_RETRY_INT_ENA: u1,

          /// [25:25] *******Description***********
          FN2_GPIO_SDIO_INT_ENA: u1,

          /// [26:31] 
          res0: u6,

        }), @ptrFromInt(0x600170e4));

        /// *******Description***********
        pub const SLC1HOST_FUNC2_INT_ENA = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] *******Description***********
          FN2_SLC1_TOHOST_BIT0_INT_ENA: u1,

          /// [1:1] *******Description***********
          FN2_SLC1_TOHOST_BIT1_INT_ENA: u1,

          /// [2:2] *******Description***********
          FN2_SLC1_TOHOST_BIT2_INT_ENA: u1,

          /// [3:3] *******Description***********
          FN2_SLC1_TOHOST_BIT3_INT_ENA: u1,

          /// [4:4] *******Description***********
          FN2_SLC1_TOHOST_BIT4_INT_ENA: u1,

          /// [5:5] *******Description***********
          FN2_SLC1_TOHOST_BIT5_INT_ENA: u1,

          /// [6:6] *******Description***********
          FN2_SLC1_TOHOST_BIT6_INT_ENA: u1,

          /// [7:7] *******Description***********
          FN2_SLC1_TOHOST_BIT7_INT_ENA: u1,

          /// [8:8] *******Description***********
          FN2_SLC1_TOKEN0_1TO0_INT_ENA: u1,

          /// [9:9] *******Description***********
          FN2_SLC1_TOKEN1_1TO0_INT_ENA: u1,

          /// [10:10] *******Description***********
          FN2_SLC1_TOKEN0_0TO1_INT_ENA: u1,

          /// [11:11] *******Description***********
          FN2_SLC1_TOKEN1_0TO1_INT_ENA: u1,

          /// [12:12] *******Description***********
          FN2_SLC1HOST_RX_SOF_INT_ENA: u1,

          /// [13:13] *******Description***********
          FN2_SLC1HOST_RX_EOF_INT_ENA: u1,

          /// [14:14] *******Description***********
          FN2_SLC1HOST_RX_START_INT_ENA: u1,

          /// [15:15] *******Description***********
          FN2_SLC1HOST_TX_START_INT_ENA: u1,

          /// [16:16] *******Description***********
          FN2_SLC1_RX_UDF_INT_ENA: u1,

          /// [17:17] *******Description***********
          FN2_SLC1_TX_OVF_INT_ENA: u1,

          /// [18:18] *******Description***********
          FN2_SLC1_RX_PF_VALID_INT_ENA: u1,

          /// [19:19] *******Description***********
          FN2_SLC1_EXT_BIT0_INT_ENA: u1,

          /// [20:20] *******Description***********
          FN2_SLC1_EXT_BIT1_INT_ENA: u1,

          /// [21:21] *******Description***********
          FN2_SLC1_EXT_BIT2_INT_ENA: u1,

          /// [22:22] *******Description***********
          FN2_SLC1_EXT_BIT3_INT_ENA: u1,

          /// [23:23] *******Description***********
          FN2_SLC1_WIFI_RX_NEW_PACKET_INT_ENA: u1,

          /// [24:24] *******Description***********
          FN2_SLC1_HOST_RD_RETRY_INT_ENA: u1,

          /// [25:25] *******Description***********
          FN2_SLC1_BT_RX_NEW_PACKET_INT_ENA: u1,

          /// [26:31] 
          res0: u6,

        }), @ptrFromInt(0x600170e8));

        /// *******Description***********
        pub const SLC0HOST_INT_ENA = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] *******Description***********
          SLC0_TOHOST_BIT0_INT_ENA: u1,

          /// [1:1] *******Description***********
          SLC0_TOHOST_BIT1_INT_ENA: u1,

          /// [2:2] *******Description***********
          SLC0_TOHOST_BIT2_INT_ENA: u1,

          /// [3:3] *******Description***********
          SLC0_TOHOST_BIT3_INT_ENA: u1,

          /// [4:4] *******Description***********
          SLC0_TOHOST_BIT4_INT_ENA: u1,

          /// [5:5] *******Description***********
          SLC0_TOHOST_BIT5_INT_ENA: u1,

          /// [6:6] *******Description***********
          SLC0_TOHOST_BIT6_INT_ENA: u1,

          /// [7:7] *******Description***********
          SLC0_TOHOST_BIT7_INT_ENA: u1,

          /// [8:8] *******Description***********
          SLC0_TOKEN0_1TO0_INT_ENA: u1,

          /// [9:9] *******Description***********
          SLC0_TOKEN1_1TO0_INT_ENA: u1,

          /// [10:10] *******Description***********
          SLC0_TOKEN0_0TO1_INT_ENA: u1,

          /// [11:11] *******Description***********
          SLC0_TOKEN1_0TO1_INT_ENA: u1,

          /// [12:12] *******Description***********
          SLC0HOST_RX_SOF_INT_ENA: u1,

          /// [13:13] *******Description***********
          SLC0HOST_RX_EOF_INT_ENA: u1,

          /// [14:14] *******Description***********
          SLC0HOST_RX_START_INT_ENA: u1,

          /// [15:15] *******Description***********
          SLC0HOST_TX_START_INT_ENA: u1,

          /// [16:16] *******Description***********
          SLC0_RX_UDF_INT_ENA: u1,

          /// [17:17] *******Description***********
          SLC0_TX_OVF_INT_ENA: u1,

          /// [18:18] *******Description***********
          SLC0_RX_PF_VALID_INT_ENA: u1,

          /// [19:19] *******Description***********
          SLC0_EXT_BIT0_INT_ENA: u1,

          /// [20:20] *******Description***********
          SLC0_EXT_BIT1_INT_ENA: u1,

          /// [21:21] *******Description***********
          SLC0_EXT_BIT2_INT_ENA: u1,

          /// [22:22] *******Description***********
          SLC0_EXT_BIT3_INT_ENA: u1,

          /// [23:23] *******Description***********
          SLC0_RX_NEW_PACKET_INT_ENA: u1,

          /// [24:24] *******Description***********
          SLC0_HOST_RD_RETRY_INT_ENA: u1,

          /// [25:25] *******Description***********
          GPIO_SDIO_INT_ENA: u1,

          /// [26:31] 
          res0: u6,

        }), @ptrFromInt(0x600170ec));

        /// *******Description***********
        pub const SLC1HOST_INT_ENA = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] *******Description***********
          SLC1_TOHOST_BIT0_INT_ENA: u1,

          /// [1:1] *******Description***********
          SLC1_TOHOST_BIT1_INT_ENA: u1,

          /// [2:2] *******Description***********
          SLC1_TOHOST_BIT2_INT_ENA: u1,

          /// [3:3] *******Description***********
          SLC1_TOHOST_BIT3_INT_ENA: u1,

          /// [4:4] *******Description***********
          SLC1_TOHOST_BIT4_INT_ENA: u1,

          /// [5:5] *******Description***********
          SLC1_TOHOST_BIT5_INT_ENA: u1,

          /// [6:6] *******Description***********
          SLC1_TOHOST_BIT6_INT_ENA: u1,

          /// [7:7] *******Description***********
          SLC1_TOHOST_BIT7_INT_ENA: u1,

          /// [8:8] *******Description***********
          SLC1_TOKEN0_1TO0_INT_ENA: u1,

          /// [9:9] *******Description***********
          SLC1_TOKEN1_1TO0_INT_ENA: u1,

          /// [10:10] *******Description***********
          SLC1_TOKEN0_0TO1_INT_ENA: u1,

          /// [11:11] *******Description***********
          SLC1_TOKEN1_0TO1_INT_ENA: u1,

          /// [12:12] *******Description***********
          SLC1HOST_RX_SOF_INT_ENA: u1,

          /// [13:13] *******Description***********
          SLC1HOST_RX_EOF_INT_ENA: u1,

          /// [14:14] *******Description***********
          SLC1HOST_RX_START_INT_ENA: u1,

          /// [15:15] *******Description***********
          SLC1HOST_TX_START_INT_ENA: u1,

          /// [16:16] *******Description***********
          SLC1_RX_UDF_INT_ENA: u1,

          /// [17:17] *******Description***********
          SLC1_TX_OVF_INT_ENA: u1,

          /// [18:18] *******Description***********
          SLC1_RX_PF_VALID_INT_ENA: u1,

          /// [19:19] *******Description***********
          SLC1_EXT_BIT0_INT_ENA: u1,

          /// [20:20] *******Description***********
          SLC1_EXT_BIT1_INT_ENA: u1,

          /// [21:21] *******Description***********
          SLC1_EXT_BIT2_INT_ENA: u1,

          /// [22:22] *******Description***********
          SLC1_EXT_BIT3_INT_ENA: u1,

          /// [23:23] *******Description***********
          SLC1_WIFI_RX_NEW_PACKET_INT_ENA: u1,

          /// [24:24] *******Description***********
          SLC1_HOST_RD_RETRY_INT_ENA: u1,

          /// [25:25] *******Description***********
          SLC1_BT_RX_NEW_PACKET_INT_ENA: u1,

          /// [26:31] 
          res0: u6,

        }), @ptrFromInt(0x600170f0));

        /// *******Description***********
        pub const SLC0HOST_RX_INFOR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:19] *******Description***********
          SLC0HOST_RX_INFOR: u20,

          /// [20:31] 
          res0: u12,

        }), @ptrFromInt(0x600170f4));

        /// *******Description***********
        pub const SLC1HOST_RX_INFOR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:19] *******Description***********
          SLC1HOST_RX_INFOR: u20,

          /// [20:31] 
          res0: u12,

        }), @ptrFromInt(0x600170f8));

        /// *******Description***********
        pub const SLC0HOST_LEN_WD = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] *******Description***********
          SLC0HOST_LEN_WD: u32,

        }), @ptrFromInt(0x600170fc));

        /// *******Description***********
        pub const SLC_APBWIN_WDATA = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] *******Description***********
          SLC_APBWIN_WDATA: u32,

        }), @ptrFromInt(0x60017100));

        /// *******Description***********
        pub const SLC_APBWIN_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:27] *******Description***********
          SLC_APBWIN_ADDR: u28,

          /// [28:28] *******Description***********
          SLC_APBWIN_WR: u1,

          /// [29:29] *******Description***********
          SLC_APBWIN_START: u1,

          /// [30:31] 
          res0: u2,

        }), @ptrFromInt(0x60017104));

        /// *******Description***********
        pub const SLC_APBWIN_RDATA = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] *******Description***********
          SLC_APBWIN_RDATA: u32,

        }), @ptrFromInt(0x60017108));

        /// *******Description***********
        pub const RDCLR0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:8] *******Description***********
          SLCHOST_SLC0_BIT7_CLRADDR: u9,

          /// [9:17] *******Description***********
          SLCHOST_SLC0_BIT6_CLRADDR: u9,

          /// [18:31] 
          res0: u14,

        }), @ptrFromInt(0x6001710c));

        /// *******Description***********
        pub const RDCLR1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:8] *******Description***********
          SLCHOST_SLC1_BIT7_CLRADDR: u9,

          /// [9:17] *******Description***********
          SLCHOST_SLC1_BIT6_CLRADDR: u9,

          /// [18:31] 
          res0: u14,

        }), @ptrFromInt(0x60017110));

        /// *******Description***********
        pub const SLC0HOST_INT_ENA1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] *******Description***********
          SLC0_TOHOST_BIT0_INT_ENA1: u1,

          /// [1:1] *******Description***********
          SLC0_TOHOST_BIT1_INT_ENA1: u1,

          /// [2:2] *******Description***********
          SLC0_TOHOST_BIT2_INT_ENA1: u1,

          /// [3:3] *******Description***********
          SLC0_TOHOST_BIT3_INT_ENA1: u1,

          /// [4:4] *******Description***********
          SLC0_TOHOST_BIT4_INT_ENA1: u1,

          /// [5:5] *******Description***********
          SLC0_TOHOST_BIT5_INT_ENA1: u1,

          /// [6:6] *******Description***********
          SLC0_TOHOST_BIT6_INT_ENA1: u1,

          /// [7:7] *******Description***********
          SLC0_TOHOST_BIT7_INT_ENA1: u1,

          /// [8:8] *******Description***********
          SLC0_TOKEN0_1TO0_INT_ENA1: u1,

          /// [9:9] *******Description***********
          SLC0_TOKEN1_1TO0_INT_ENA1: u1,

          /// [10:10] *******Description***********
          SLC0_TOKEN0_0TO1_INT_ENA1: u1,

          /// [11:11] *******Description***********
          SLC0_TOKEN1_0TO1_INT_ENA1: u1,

          /// [12:12] *******Description***********
          SLC0HOST_RX_SOF_INT_ENA1: u1,

          /// [13:13] *******Description***********
          SLC0HOST_RX_EOF_INT_ENA1: u1,

          /// [14:14] *******Description***********
          SLC0HOST_RX_START_INT_ENA1: u1,

          /// [15:15] *******Description***********
          SLC0HOST_TX_START_INT_ENA1: u1,

          /// [16:16] *******Description***********
          SLC0_RX_UDF_INT_ENA1: u1,

          /// [17:17] *******Description***********
          SLC0_TX_OVF_INT_ENA1: u1,

          /// [18:18] *******Description***********
          SLC0_RX_PF_VALID_INT_ENA1: u1,

          /// [19:19] *******Description***********
          SLC0_EXT_BIT0_INT_ENA1: u1,

          /// [20:20] *******Description***********
          SLC0_EXT_BIT1_INT_ENA1: u1,

          /// [21:21] *******Description***********
          SLC0_EXT_BIT2_INT_ENA1: u1,

          /// [22:22] *******Description***********
          SLC0_EXT_BIT3_INT_ENA1: u1,

          /// [23:23] *******Description***********
          SLC0_RX_NEW_PACKET_INT_ENA1: u1,

          /// [24:24] *******Description***********
          SLC0_HOST_RD_RETRY_INT_ENA1: u1,

          /// [25:25] *******Description***********
          GPIO_SDIO_INT_ENA1: u1,

          /// [26:31] 
          res0: u6,

        }), @ptrFromInt(0x60017114));

        /// *******Description***********
        pub const SLC1HOST_INT_ENA1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] *******Description***********
          SLC1_TOHOST_BIT0_INT_ENA1: u1,

          /// [1:1] *******Description***********
          SLC1_TOHOST_BIT1_INT_ENA1: u1,

          /// [2:2] *******Description***********
          SLC1_TOHOST_BIT2_INT_ENA1: u1,

          /// [3:3] *******Description***********
          SLC1_TOHOST_BIT3_INT_ENA1: u1,

          /// [4:4] *******Description***********
          SLC1_TOHOST_BIT4_INT_ENA1: u1,

          /// [5:5] *******Description***********
          SLC1_TOHOST_BIT5_INT_ENA1: u1,

          /// [6:6] *******Description***********
          SLC1_TOHOST_BIT6_INT_ENA1: u1,

          /// [7:7] *******Description***********
          SLC1_TOHOST_BIT7_INT_ENA1: u1,

          /// [8:8] *******Description***********
          SLC1_TOKEN0_1TO0_INT_ENA1: u1,

          /// [9:9] *******Description***********
          SLC1_TOKEN1_1TO0_INT_ENA1: u1,

          /// [10:10] *******Description***********
          SLC1_TOKEN0_0TO1_INT_ENA1: u1,

          /// [11:11] *******Description***********
          SLC1_TOKEN1_0TO1_INT_ENA1: u1,

          /// [12:12] *******Description***********
          SLC1HOST_RX_SOF_INT_ENA1: u1,

          /// [13:13] *******Description***********
          SLC1HOST_RX_EOF_INT_ENA1: u1,

          /// [14:14] *******Description***********
          SLC1HOST_RX_START_INT_ENA1: u1,

          /// [15:15] *******Description***********
          SLC1HOST_TX_START_INT_ENA1: u1,

          /// [16:16] *******Description***********
          SLC1_RX_UDF_INT_ENA1: u1,

          /// [17:17] *******Description***********
          SLC1_TX_OVF_INT_ENA1: u1,

          /// [18:18] *******Description***********
          SLC1_RX_PF_VALID_INT_ENA1: u1,

          /// [19:19] *******Description***********
          SLC1_EXT_BIT0_INT_ENA1: u1,

          /// [20:20] *******Description***********
          SLC1_EXT_BIT1_INT_ENA1: u1,

          /// [21:21] *******Description***********
          SLC1_EXT_BIT2_INT_ENA1: u1,

          /// [22:22] *******Description***********
          SLC1_EXT_BIT3_INT_ENA1: u1,

          /// [23:23] *******Description***********
          SLC1_WIFI_RX_NEW_PACKET_INT_ENA1: u1,

          /// [24:24] *******Description***********
          SLC1_HOST_RD_RETRY_INT_ENA1: u1,

          /// [25:25] *******Description***********
          SLC1_BT_RX_NEW_PACKET_INT_ENA1: u1,

          /// [26:31] 
          res0: u6,

        }), @ptrFromInt(0x60017118));

        /// *******Description***********
        pub const SLCHOSTDATE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] *******Description***********
          SLCHOST_DATE: u32,

        }), @ptrFromInt(0x60017178));

        /// *******Description***********
        pub const SLCHOSTID = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] *******Description***********
          SLCHOST_ID: u32,

        }), @ptrFromInt(0x6001717c));

        /// *******Description***********
        pub const CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:4] *******Description***********
          FRC_SDIO11: u5,

          /// [5:9] *******Description***********
          FRC_SDIO20: u5,

          /// [10:14] *******Description***********
          FRC_NEG_SAMP: u5,

          /// [15:19] *******Description***********
          FRC_POS_SAMP: u5,

          /// [20:24] *******Description***********
          FRC_QUICK_IN: u5,

          /// [25:25] *******Description***********
          SDIO20_INT_DELAY: u1,

          /// [26:26] *******Description***********
          SDIO_PAD_PULLUP: u1,

          /// [27:27] *******Description***********
          HSPEED_CON_EN: u1,

          /// [28:31] 
          res0: u4,

        }), @ptrFromInt(0x600171f0));

        /// *******Description***********
        pub const INF_ST = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:4] *******Description***********
          SDIO20_MODE: u5,

          /// [5:9] *******Description***********
          SDIO_NEG_SAMP: u5,

          /// [10:14] *******Description***********
          SDIO_QUICK_IN: u5,

          /// [15:15] dll is controlled by software
          DLL_ON_SW: u1,

          /// [16:16] Software dll on
          DLL_ON: u1,

          /// [17:17] dll clock mode is controlled by software
          CLK_MODE_SW: u1,

          /// [18:19] Software set clock mode
          CLK_MODE: u2,

          /// [20:31] 
          res0: u12,

        }), @ptrFromInt(0x600171f4));

      };

      /// SOC_ETM Peripheral
      pub const SOC_ETM = struct {

        /// channel enable register
        pub const CH_ENA_AD0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] ch0 enable
          CH_ENA0: u1,

          /// [1:1] ch1 enable
          CH_ENA1: u1,

          /// [2:2] ch2 enable
          CH_ENA2: u1,

          /// [3:3] ch3 enable
          CH_ENA3: u1,

          /// [4:4] ch4 enable
          CH_ENA4: u1,

          /// [5:5] ch5 enable
          CH_ENA5: u1,

          /// [6:6] ch6 enable
          CH_ENA6: u1,

          /// [7:7] ch7 enable
          CH_ENA7: u1,

          /// [8:8] ch8 enable
          CH_ENA8: u1,

          /// [9:9] ch9 enable
          CH_ENA9: u1,

          /// [10:10] ch10 enable
          CH_ENA10: u1,

          /// [11:11] ch11 enable
          CH_ENA11: u1,

          /// [12:12] ch12 enable
          CH_ENA12: u1,

          /// [13:13] ch13 enable
          CH_ENA13: u1,

          /// [14:14] ch14 enable
          CH_ENA14: u1,

          /// [15:15] ch15 enable
          CH_ENA15: u1,

          /// [16:16] ch16 enable
          CH_ENA16: u1,

          /// [17:17] ch17 enable
          CH_ENA17: u1,

          /// [18:18] ch18 enable
          CH_ENA18: u1,

          /// [19:19] ch19 enable
          CH_ENA19: u1,

          /// [20:20] ch20 enable
          CH_ENA20: u1,

          /// [21:21] ch21 enable
          CH_ENA21: u1,

          /// [22:22] ch22 enable
          CH_ENA22: u1,

          /// [23:23] ch23 enable
          CH_ENA23: u1,

          /// [24:24] ch24 enable
          CH_ENA24: u1,

          /// [25:25] ch25 enable
          CH_ENA25: u1,

          /// [26:26] ch26 enable
          CH_ENA26: u1,

          /// [27:27] ch27 enable
          CH_ENA27: u1,

          /// [28:28] ch28 enable
          CH_ENA28: u1,

          /// [29:29] ch29 enable
          CH_ENA29: u1,

          /// [30:30] ch30 enable
          CH_ENA30: u1,

          /// [31:31] ch31 enable
          CH_ENA31: u1,

        }), @ptrFromInt(0x60013000));

        /// channel enable set register
        pub const CH_ENA_AD0_SET = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] ch0 set
          CH_SET0: u1,

          /// [1:1] ch1 set
          CH_SET1: u1,

          /// [2:2] ch2 set
          CH_SET2: u1,

          /// [3:3] ch3 set
          CH_SET3: u1,

          /// [4:4] ch4 set
          CH_SET4: u1,

          /// [5:5] ch5 set
          CH_SET5: u1,

          /// [6:6] ch6 set
          CH_SET6: u1,

          /// [7:7] ch7 set
          CH_SET7: u1,

          /// [8:8] ch8 set
          CH_SET8: u1,

          /// [9:9] ch9 set
          CH_SET9: u1,

          /// [10:10] ch10 set
          CH_SET10: u1,

          /// [11:11] ch11 set
          CH_SET11: u1,

          /// [12:12] ch12 set
          CH_SET12: u1,

          /// [13:13] ch13 set
          CH_SET13: u1,

          /// [14:14] ch14 set
          CH_SET14: u1,

          /// [15:15] ch15 set
          CH_SET15: u1,

          /// [16:16] ch16 set
          CH_SET16: u1,

          /// [17:17] ch17 set
          CH_SET17: u1,

          /// [18:18] ch18 set
          CH_SET18: u1,

          /// [19:19] ch19 set
          CH_SET19: u1,

          /// [20:20] ch20 set
          CH_SET20: u1,

          /// [21:21] ch21 set
          CH_SET21: u1,

          /// [22:22] ch22 set
          CH_SET22: u1,

          /// [23:23] ch23 set
          CH_SET23: u1,

          /// [24:24] ch24 set
          CH_SET24: u1,

          /// [25:25] ch25 set
          CH_SET25: u1,

          /// [26:26] ch26 set
          CH_SET26: u1,

          /// [27:27] ch27 set
          CH_SET27: u1,

          /// [28:28] ch28 set
          CH_SET28: u1,

          /// [29:29] ch29 set
          CH_SET29: u1,

          /// [30:30] ch30 set
          CH_SET30: u1,

          /// [31:31] ch31 set
          CH_SET31: u1,

        }), @ptrFromInt(0x60013004));

        /// channel enable clear register
        pub const CH_ENA_AD0_CLR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] ch0 clear
          CH_CLR0: u1,

          /// [1:1] ch1 clear
          CH_CLR1: u1,

          /// [2:2] ch2 clear
          CH_CLR2: u1,

          /// [3:3] ch3 clear
          CH_CLR3: u1,

          /// [4:4] ch4 clear
          CH_CLR4: u1,

          /// [5:5] ch5 clear
          CH_CLR5: u1,

          /// [6:6] ch6 clear
          CH_CLR6: u1,

          /// [7:7] ch7 clear
          CH_CLR7: u1,

          /// [8:8] ch8 clear
          CH_CLR8: u1,

          /// [9:9] ch9 clear
          CH_CLR9: u1,

          /// [10:10] ch10 clear
          CH_CLR10: u1,

          /// [11:11] ch11 clear
          CH_CLR11: u1,

          /// [12:12] ch12 clear
          CH_CLR12: u1,

          /// [13:13] ch13 clear
          CH_CLR13: u1,

          /// [14:14] ch14 clear
          CH_CLR14: u1,

          /// [15:15] ch15 clear
          CH_CLR15: u1,

          /// [16:16] ch16 clear
          CH_CLR16: u1,

          /// [17:17] ch17 clear
          CH_CLR17: u1,

          /// [18:18] ch18 clear
          CH_CLR18: u1,

          /// [19:19] ch19 clear
          CH_CLR19: u1,

          /// [20:20] ch20 clear
          CH_CLR20: u1,

          /// [21:21] ch21 clear
          CH_CLR21: u1,

          /// [22:22] ch22 clear
          CH_CLR22: u1,

          /// [23:23] ch23 clear
          CH_CLR23: u1,

          /// [24:24] ch24 clear
          CH_CLR24: u1,

          /// [25:25] ch25 clear
          CH_CLR25: u1,

          /// [26:26] ch26 clear
          CH_CLR26: u1,

          /// [27:27] ch27 clear
          CH_CLR27: u1,

          /// [28:28] ch28 clear
          CH_CLR28: u1,

          /// [29:29] ch29 clear
          CH_CLR29: u1,

          /// [30:30] ch30 clear
          CH_CLR30: u1,

          /// [31:31] ch31 clear
          CH_CLR31: u1,

        }), @ptrFromInt(0x60013008));

        /// channel enable register
        pub const CH_ENA_AD1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] ch32 enable
          CH_ENA32: u1,

          /// [1:1] ch33 enable
          CH_ENA33: u1,

          /// [2:2] ch34 enable
          CH_ENA34: u1,

          /// [3:3] ch35 enable
          CH_ENA35: u1,

          /// [4:4] ch36 enable
          CH_ENA36: u1,

          /// [5:5] ch37 enable
          CH_ENA37: u1,

          /// [6:6] ch38 enable
          CH_ENA38: u1,

          /// [7:7] ch39 enable
          CH_ENA39: u1,

          /// [8:8] ch40 enable
          CH_ENA40: u1,

          /// [9:9] ch41 enable
          CH_ENA41: u1,

          /// [10:10] ch42 enable
          CH_ENA42: u1,

          /// [11:11] ch43 enable
          CH_ENA43: u1,

          /// [12:12] ch44 enable
          CH_ENA44: u1,

          /// [13:13] ch45 enable
          CH_ENA45: u1,

          /// [14:14] ch46 enable
          CH_ENA46: u1,

          /// [15:15] ch47 enable
          CH_ENA47: u1,

          /// [16:16] ch48 enable
          CH_ENA48: u1,

          /// [17:17] ch49 enable
          CH_ENA49: u1,

          /// [18:31] 
          res0: u14,

        }), @ptrFromInt(0x6001300c));

        /// channel enable set register
        pub const CH_ENA_AD1_SET = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] ch32 set
          CH_SET32: u1,

          /// [1:1] ch33 set
          CH_SET33: u1,

          /// [2:2] ch34 set
          CH_SET34: u1,

          /// [3:3] ch35 set
          CH_SET35: u1,

          /// [4:4] ch36 set
          CH_SET36: u1,

          /// [5:5] ch37 set
          CH_SET37: u1,

          /// [6:6] ch38 set
          CH_SET38: u1,

          /// [7:7] ch39 set
          CH_SET39: u1,

          /// [8:8] ch40 set
          CH_SET40: u1,

          /// [9:9] ch41 set
          CH_SET41: u1,

          /// [10:10] ch42 set
          CH_SET42: u1,

          /// [11:11] ch43 set
          CH_SET43: u1,

          /// [12:12] ch44 set
          CH_SET44: u1,

          /// [13:13] ch45 set
          CH_SET45: u1,

          /// [14:14] ch46 set
          CH_SET46: u1,

          /// [15:15] ch47 set
          CH_SET47: u1,

          /// [16:16] ch48 set
          CH_SET48: u1,

          /// [17:17] ch49 set
          CH_SET49: u1,

          /// [18:31] 
          res0: u14,

        }), @ptrFromInt(0x60013010));

        /// channel enable clear register
        pub const CH_ENA_AD1_CLR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] ch32 clear
          CH_CLR32: u1,

          /// [1:1] ch33 clear
          CH_CLR33: u1,

          /// [2:2] ch34 clear
          CH_CLR34: u1,

          /// [3:3] ch35 clear
          CH_CLR35: u1,

          /// [4:4] ch36 clear
          CH_CLR36: u1,

          /// [5:5] ch37 clear
          CH_CLR37: u1,

          /// [6:6] ch38 clear
          CH_CLR38: u1,

          /// [7:7] ch39 clear
          CH_CLR39: u1,

          /// [8:8] ch40 clear
          CH_CLR40: u1,

          /// [9:9] ch41 clear
          CH_CLR41: u1,

          /// [10:10] ch42 clear
          CH_CLR42: u1,

          /// [11:11] ch43 clear
          CH_CLR43: u1,

          /// [12:12] ch44 clear
          CH_CLR44: u1,

          /// [13:13] ch45 clear
          CH_CLR45: u1,

          /// [14:14] ch46 clear
          CH_CLR46: u1,

          /// [15:15] ch47 clear
          CH_CLR47: u1,

          /// [16:16] ch48 clear
          CH_CLR48: u1,

          /// [17:17] ch49 clear
          CH_CLR49: u1,

          /// [18:31] 
          res0: u14,

        }), @ptrFromInt(0x60013014));

        /// channel0 event id register
        pub const CH0_EVT_ID = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] ch0_evt_id
          CH0_EVT_ID: u8,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x60013018));

        /// channel0 task id register
        pub const CH0_TASK_ID = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] ch0_task_id
          CH0_TASK_ID: u8,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x6001301c));

        /// channel1 event id register
        pub const CH1_EVT_ID = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] ch1_evt_id
          CH1_EVT_ID: u8,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x60013020));

        /// channel1 task id register
        pub const CH1_TASK_ID = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] ch1_task_id
          CH1_TASK_ID: u8,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x60013024));

        /// channel2 event id register
        pub const CH2_EVT_ID = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] ch2_evt_id
          CH2_EVT_ID: u8,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x60013028));

        /// channel2 task id register
        pub const CH2_TASK_ID = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] ch2_task_id
          CH2_TASK_ID: u8,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x6001302c));

        /// channel3 event id register
        pub const CH3_EVT_ID = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] ch3_evt_id
          CH3_EVT_ID: u8,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x60013030));

        /// channel3 task id register
        pub const CH3_TASK_ID = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] ch3_task_id
          CH3_TASK_ID: u8,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x60013034));

        /// channel4 event id register
        pub const CH4_EVT_ID = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] ch4_evt_id
          CH4_EVT_ID: u8,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x60013038));

        /// channel4 task id register
        pub const CH4_TASK_ID = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] ch4_task_id
          CH4_TASK_ID: u8,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x6001303c));

        /// channel5 event id register
        pub const CH5_EVT_ID = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] ch5_evt_id
          CH5_EVT_ID: u8,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x60013040));

        /// channel5 task id register
        pub const CH5_TASK_ID = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] ch5_task_id
          CH5_TASK_ID: u8,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x60013044));

        /// channel6 event id register
        pub const CH6_EVT_ID = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] ch6_evt_id
          CH6_EVT_ID: u8,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x60013048));

        /// channel6 task id register
        pub const CH6_TASK_ID = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] ch6_task_id
          CH6_TASK_ID: u8,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x6001304c));

        /// channel7 event id register
        pub const CH7_EVT_ID = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] ch7_evt_id
          CH7_EVT_ID: u8,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x60013050));

        /// channel7 task id register
        pub const CH7_TASK_ID = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] ch7_task_id
          CH7_TASK_ID: u8,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x60013054));

        /// channel8 event id register
        pub const CH8_EVT_ID = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] ch8_evt_id
          CH8_EVT_ID: u8,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x60013058));

        /// channel8 task id register
        pub const CH8_TASK_ID = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] ch8_task_id
          CH8_TASK_ID: u8,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x6001305c));

        /// channel9 event id register
        pub const CH9_EVT_ID = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] ch9_evt_id
          CH9_EVT_ID: u8,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x60013060));

        /// channel9 task id register
        pub const CH9_TASK_ID = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] ch9_task_id
          CH9_TASK_ID: u8,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x60013064));

        /// channel10 event id register
        pub const CH10_EVT_ID = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] ch10_evt_id
          CH10_EVT_ID: u8,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x60013068));

        /// channel10 task id register
        pub const CH10_TASK_ID = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] ch10_task_id
          CH10_TASK_ID: u8,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x6001306c));

        /// channel11 event id register
        pub const CH11_EVT_ID = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] ch11_evt_id
          CH11_EVT_ID: u8,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x60013070));

        /// channel11 task id register
        pub const CH11_TASK_ID = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] ch11_task_id
          CH11_TASK_ID: u8,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x60013074));

        /// channel12 event id register
        pub const CH12_EVT_ID = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] ch12_evt_id
          CH12_EVT_ID: u8,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x60013078));

        /// channel12 task id register
        pub const CH12_TASK_ID = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] ch12_task_id
          CH12_TASK_ID: u8,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x6001307c));

        /// channel13 event id register
        pub const CH13_EVT_ID = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] ch13_evt_id
          CH13_EVT_ID: u8,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x60013080));

        /// channel13 task id register
        pub const CH13_TASK_ID = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] ch13_task_id
          CH13_TASK_ID: u8,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x60013084));

        /// channel14 event id register
        pub const CH14_EVT_ID = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] ch14_evt_id
          CH14_EVT_ID: u8,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x60013088));

        /// channel14 task id register
        pub const CH14_TASK_ID = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] ch14_task_id
          CH14_TASK_ID: u8,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x6001308c));

        /// channel15 event id register
        pub const CH15_EVT_ID = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] ch15_evt_id
          CH15_EVT_ID: u8,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x60013090));

        /// channel15 task id register
        pub const CH15_TASK_ID = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] ch15_task_id
          CH15_TASK_ID: u8,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x60013094));

        /// channel16 event id register
        pub const CH16_EVT_ID = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] ch16_evt_id
          CH16_EVT_ID: u8,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x60013098));

        /// channel16 task id register
        pub const CH16_TASK_ID = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] ch16_task_id
          CH16_TASK_ID: u8,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x6001309c));

        /// channel17 event id register
        pub const CH17_EVT_ID = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] ch17_evt_id
          CH17_EVT_ID: u8,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x600130a0));

        /// channel17 task id register
        pub const CH17_TASK_ID = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] ch17_task_id
          CH17_TASK_ID: u8,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x600130a4));

        /// channel18 event id register
        pub const CH18_EVT_ID = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] ch18_evt_id
          CH18_EVT_ID: u8,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x600130a8));

        /// channel18 task id register
        pub const CH18_TASK_ID = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] ch18_task_id
          CH18_TASK_ID: u8,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x600130ac));

        /// channel19 event id register
        pub const CH19_EVT_ID = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] ch19_evt_id
          CH19_EVT_ID: u8,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x600130b0));

        /// channel19 task id register
        pub const CH19_TASK_ID = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] ch19_task_id
          CH19_TASK_ID: u8,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x600130b4));

        /// channel20 event id register
        pub const CH20_EVT_ID = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] ch20_evt_id
          CH20_EVT_ID: u8,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x600130b8));

        /// channel20 task id register
        pub const CH20_TASK_ID = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] ch20_task_id
          CH20_TASK_ID: u8,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x600130bc));

        /// channel21 event id register
        pub const CH21_EVT_ID = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] ch21_evt_id
          CH21_EVT_ID: u8,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x600130c0));

        /// channel21 task id register
        pub const CH21_TASK_ID = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] ch21_task_id
          CH21_TASK_ID: u8,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x600130c4));

        /// channel22 event id register
        pub const CH22_EVT_ID = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] ch22_evt_id
          CH22_EVT_ID: u8,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x600130c8));

        /// channel22 task id register
        pub const CH22_TASK_ID = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] ch22_task_id
          CH22_TASK_ID: u8,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x600130cc));

        /// channel23 event id register
        pub const CH23_EVT_ID = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] ch23_evt_id
          CH23_EVT_ID: u8,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x600130d0));

        /// channel23 task id register
        pub const CH23_TASK_ID = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] ch23_task_id
          CH23_TASK_ID: u8,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x600130d4));

        /// channel24 event id register
        pub const CH24_EVT_ID = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] ch24_evt_id
          CH24_EVT_ID: u8,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x600130d8));

        /// channel24 task id register
        pub const CH24_TASK_ID = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] ch24_task_id
          CH24_TASK_ID: u8,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x600130dc));

        /// channel25 event id register
        pub const CH25_EVT_ID = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] ch25_evt_id
          CH25_EVT_ID: u8,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x600130e0));

        /// channel25 task id register
        pub const CH25_TASK_ID = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] ch25_task_id
          CH25_TASK_ID: u8,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x600130e4));

        /// channel26 event id register
        pub const CH26_EVT_ID = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] ch26_evt_id
          CH26_EVT_ID: u8,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x600130e8));

        /// channel26 task id register
        pub const CH26_TASK_ID = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] ch26_task_id
          CH26_TASK_ID: u8,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x600130ec));

        /// channel27 event id register
        pub const CH27_EVT_ID = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] ch27_evt_id
          CH27_EVT_ID: u8,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x600130f0));

        /// channel27 task id register
        pub const CH27_TASK_ID = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] ch27_task_id
          CH27_TASK_ID: u8,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x600130f4));

        /// channel28 event id register
        pub const CH28_EVT_ID = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] ch28_evt_id
          CH28_EVT_ID: u8,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x600130f8));

        /// channel28 task id register
        pub const CH28_TASK_ID = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] ch28_task_id
          CH28_TASK_ID: u8,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x600130fc));

        /// channel29 event id register
        pub const CH29_EVT_ID = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] ch29_evt_id
          CH29_EVT_ID: u8,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x60013100));

        /// channel29 task id register
        pub const CH29_TASK_ID = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] ch29_task_id
          CH29_TASK_ID: u8,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x60013104));

        /// channel30 event id register
        pub const CH30_EVT_ID = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] ch30_evt_id
          CH30_EVT_ID: u8,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x60013108));

        /// channel30 task id register
        pub const CH30_TASK_ID = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] ch30_task_id
          CH30_TASK_ID: u8,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x6001310c));

        /// channel31 event id register
        pub const CH31_EVT_ID = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] ch31_evt_id
          CH31_EVT_ID: u8,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x60013110));

        /// channel31 task id register
        pub const CH31_TASK_ID = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] ch31_task_id
          CH31_TASK_ID: u8,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x60013114));

        /// channel32 event id register
        pub const CH32_EVT_ID = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] ch32_evt_id
          CH32_EVT_ID: u8,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x60013118));

        /// channel32 task id register
        pub const CH32_TASK_ID = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] ch32_task_id
          CH32_TASK_ID: u8,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x6001311c));

        /// channel33 event id register
        pub const CH33_EVT_ID = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] ch33_evt_id
          CH33_EVT_ID: u8,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x60013120));

        /// channel33 task id register
        pub const CH33_TASK_ID = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] ch33_task_id
          CH33_TASK_ID: u8,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x60013124));

        /// channel34 event id register
        pub const CH34_EVT_ID = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] ch34_evt_id
          CH34_EVT_ID: u8,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x60013128));

        /// channel34 task id register
        pub const CH34_TASK_ID = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] ch34_task_id
          CH34_TASK_ID: u8,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x6001312c));

        /// channel35 event id register
        pub const CH35_EVT_ID = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] ch35_evt_id
          CH35_EVT_ID: u8,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x60013130));

        /// channel35 task id register
        pub const CH35_TASK_ID = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] ch35_task_id
          CH35_TASK_ID: u8,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x60013134));

        /// channel36 event id register
        pub const CH36_EVT_ID = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] ch36_evt_id
          CH36_EVT_ID: u8,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x60013138));

        /// channel36 task id register
        pub const CH36_TASK_ID = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] ch36_task_id
          CH36_TASK_ID: u8,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x6001313c));

        /// channel37 event id register
        pub const CH37_EVT_ID = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] ch37_evt_id
          CH37_EVT_ID: u8,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x60013140));

        /// channel37 task id register
        pub const CH37_TASK_ID = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] ch37_task_id
          CH37_TASK_ID: u8,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x60013144));

        /// channel38 event id register
        pub const CH38_EVT_ID = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] ch38_evt_id
          CH38_EVT_ID: u8,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x60013148));

        /// channel38 task id register
        pub const CH38_TASK_ID = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] ch38_task_id
          CH38_TASK_ID: u8,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x6001314c));

        /// channel39 event id register
        pub const CH39_EVT_ID = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] ch39_evt_id
          CH39_EVT_ID: u8,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x60013150));

        /// channel39 task id register
        pub const CH39_TASK_ID = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] ch39_task_id
          CH39_TASK_ID: u8,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x60013154));

        /// channel40 event id register
        pub const CH40_EVT_ID = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] ch40_evt_id
          CH40_EVT_ID: u8,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x60013158));

        /// channel40 task id register
        pub const CH40_TASK_ID = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] ch40_task_id
          CH40_TASK_ID: u8,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x6001315c));

        /// channel41 event id register
        pub const CH41_EVT_ID = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] ch41_evt_id
          CH41_EVT_ID: u8,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x60013160));

        /// channel41 task id register
        pub const CH41_TASK_ID = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] ch41_task_id
          CH41_TASK_ID: u8,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x60013164));

        /// channel42 event id register
        pub const CH42_EVT_ID = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] ch42_evt_id
          CH42_EVT_ID: u8,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x60013168));

        /// channel42 task id register
        pub const CH42_TASK_ID = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] ch42_task_id
          CH42_TASK_ID: u8,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x6001316c));

        /// channel43 event id register
        pub const CH43_EVT_ID = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] ch43_evt_id
          CH43_EVT_ID: u8,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x60013170));

        /// channel43 task id register
        pub const CH43_TASK_ID = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] ch43_task_id
          CH43_TASK_ID: u8,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x60013174));

        /// channel44 event id register
        pub const CH44_EVT_ID = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] ch44_evt_id
          CH44_EVT_ID: u8,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x60013178));

        /// channel44 task id register
        pub const CH44_TASK_ID = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] ch44_task_id
          CH44_TASK_ID: u8,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x6001317c));

        /// channel45 event id register
        pub const CH45_EVT_ID = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] ch45_evt_id
          CH45_EVT_ID: u8,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x60013180));

        /// channel45 task id register
        pub const CH45_TASK_ID = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] ch45_task_id
          CH45_TASK_ID: u8,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x60013184));

        /// channel46 event id register
        pub const CH46_EVT_ID = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] ch46_evt_id
          CH46_EVT_ID: u8,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x60013188));

        /// channel46 task id register
        pub const CH46_TASK_ID = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] ch46_task_id
          CH46_TASK_ID: u8,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x6001318c));

        /// channel47 event id register
        pub const CH47_EVT_ID = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] ch47_evt_id
          CH47_EVT_ID: u8,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x60013190));

        /// channel47 task id register
        pub const CH47_TASK_ID = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] ch47_task_id
          CH47_TASK_ID: u8,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x60013194));

        /// channel48 event id register
        pub const CH48_EVT_ID = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] ch48_evt_id
          CH48_EVT_ID: u8,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x60013198));

        /// channel48 task id register
        pub const CH48_TASK_ID = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] ch48_task_id
          CH48_TASK_ID: u8,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x6001319c));

        /// channel49 event id register
        pub const CH49_EVT_ID = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] ch49_evt_id
          CH49_EVT_ID: u8,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x600131a0));

        /// channel49 task id register
        pub const CH49_TASK_ID = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] ch49_task_id
          CH49_TASK_ID: u8,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x600131a4));

        /// etm clock enable register
        pub const CLK_EN = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] clock enable
          CLK_EN: u1,

          /// [1:31] 
          res0: u31,

        }), @ptrFromInt(0x600131a8));

        /// etm date register
        pub const DATE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:27] date
          DATE: u28,

          /// [28:31] 
          res0: u4,

        }), @ptrFromInt(0x600131ac));

      };

      /// SPI (Serial Peripheral Interface) Controller 0
      pub const SPI0 = struct {

        /// SPI0 FSM status register
        pub const SPI_MEM_CMD = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:3] The current status of SPI0 master FSM: spi0_mst_st. 0: idle state, 1:SPI0_GRANT , 2: program/erase suspend state, 3: SPI0 read data state, 4: wait cache/EDMA sent data is stored in SPI0 TX FIFO, 5: SPI0 write data state.
          SPI_MEM_MST_ST: u4,

          /// [4:7] The current status of SPI0 slave FSM: mspi_st. 0: idle state, 1: preparation state, 2: send command state, 3: send address state, 4: wait state, 5: read data state, 6:write data state, 7: done state, 8: read data end state.
          SPI_MEM_SLV_ST: u4,

          /// [8:17] 
          res0: u10,

          /// [18:18] SPI0 USR_CMD start bit, only used when SPI_MEM_AXI_REQ_EN is cleared.An operation will be triggered when the bit is set. The bit will be cleared once the operation done.1: enable 0: disable.
          SPI_MEM_USR: u1,

          /// [19:31] 
          res1: u13,

        }), @ptrFromInt(0x60002000));

        /// SPI0 control register.
        pub const SPI_MEM_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] In the dummy phase of an MSPI write data transfer when accesses to flash, the level of SPI_DQS is output by the MSPI controller.
          SPI_MEM_WDUMMY_DQS_ALWAYS_OUT: u1,

          /// [1:1] In the dummy phase of an MSPI write data transfer when accesses to flash, the level of SPI_IO[7:0] is output by the MSPI controller.
          SPI_MEM_WDUMMY_ALWAYS_OUT: u1,

          /// [2:2] In an MSPI read data transfer when accesses to flash, the level of SPI_IO[7:0] is output by the MSPI controller in the first half part of dummy phase. It is used to mask invalid SPI_DQS in the half part of dummy phase.
          SPI_MEM_FDUMMY_RIN: u1,

          /// [3:3] In an MSPI write data transfer when accesses to flash, the level of SPI_IO[7:0] is output by the MSPI controller in the second half part of dummy phase. It is used to pre-drive flash.
          SPI_MEM_FDUMMY_WOUT: u1,

          /// [4:4] Apply 8 signals during write-data phase 1:enable 0: disable
          SPI_MEM_FDOUT_OCT: u1,

          /// [5:5] Apply 8 signals during read-data phase 1:enable 0: disable
          SPI_MEM_FDIN_OCT: u1,

          /// [6:6] Apply 8 signals during address phase 1:enable 0: disable
          SPI_MEM_FADDR_OCT: u1,

          /// [7:7] 
          res0: u1,

          /// [8:8] Apply 4 signals during command phase 1:enable 0: disable
          SPI_MEM_FCMD_QUAD: u1,

          /// [9:9] Apply 8 signals during command phase 1:enable 0: disable
          SPI_MEM_FCMD_OCT: u1,

          /// [10:12] 
          res1: u3,

          /// [13:13] This bit enable the bits: SPI_MEM_FREAD_QIO, SPI_MEM_FREAD_DIO, SPI_MEM_FREAD_QOUT and SPI_MEM_FREAD_DOUT. 1: enable 0: disable.
          SPI_MEM_FASTRD_MODE: u1,

          /// [14:14] In the read operations, read-data phase apply 2 signals. 1: enable 0: disable.
          SPI_MEM_FREAD_DUAL: u1,

          /// [15:17] 
          res2: u3,

          /// [18:18] The bit is used to set MISO line polarity, 1: high 0, low
          SPI_MEM_Q_POL: u1,

          /// [19:19] The bit is used to set MOSI line polarity, 1: high 0, low
          SPI_MEM_D_POL: u1,

          /// [20:20] In the read operations read-data phase apply 4 signals. 1: enable 0: disable.
          SPI_MEM_FREAD_QUAD: u1,

          /// [21:21] Write protect signal output when SPI is idle.1: output high, 0: output low.
          SPI_MEM_WP: u1,

          /// [22:22] 
          res3: u1,

          /// [23:23] In the read operations address phase and read-data phase apply 2 signals. 1: enable 0: disable.
          SPI_MEM_FREAD_DIO: u1,

          /// [24:24] In the read operations address phase and read-data phase apply 4 signals. 1: enable 0: disable.
          SPI_MEM_FREAD_QIO: u1,

          /// [25:29] 
          res4: u5,

          /// [30:30] When accesses to flash, 1: the IE signals of pads connected to SPI_DQS are always 1. 0: Others.
          SPI_MEM_DQS_IE_ALWAYS_ON: u1,

          /// [31:31] When accesses to flash, 1: the IE signals of pads connected to SPI_IO[7:0] are always 1. 0: Others.
          SPI_MEM_DATA_IE_ALWAYS_ON: u1,

        }), @ptrFromInt(0x60002008));

        /// SPI0 control1 register.
        pub const SPI_MEM_CTRL1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:1] SPI clock mode bits. 0: SPI clock is off when CS inactive 1: SPI clock is delayed one cycle after CS inactive 2: SPI clock is delayed two cycles after CS inactive 3: SPI clock is alwasy on.
          SPI_MEM_CLK_MODE: u2,

          /// [2:20] 
          res0: u19,

          /// [21:21] 1: MSPI supports ARSIZE 0~3. When ARSIZE =0~2, MSPI read address is 4*n and reply the real AXI read data back. 0: When ARSIZE 0~1, MSPI reply SLV_ERR.
          SPI_AR_SIZE0_1_SUPPORT_EN: u1,

          /// [22:22] 1: MSPI supports AWSIZE 0~3. 0: When AWSIZE 0~1, MSPI reply SLV_ERR.
          SPI_AW_SIZE0_1_SUPPORT_EN: u1,

          /// [23:23] 1: Reply AXI read data to AXI bus when one AXI read beat data is available. 0: Reply AXI read data to AXI bus when all the read data is available.
          SPI_AXI_RDATA_BACK_FAST: u1,

          /// [24:24] 1: RRESP is SLV_ERR when there is a ECC error in AXI read data. 0: RRESP is OKAY when there is a ECC error in AXI read data. The ECC error information is recorded in SPI_MEM_ECC_ERR_ADDR_REG.
          SPI_MEM_RRESP_ECC_ERR_EN: u1,

          /// [25:25] Set this bit to enable AXI Read Splice-transfer.
          SPI_MEM_AR_SPLICE_EN: u1,

          /// [26:26] Set this bit to enable AXI Write Splice-transfer.
          SPI_MEM_AW_SPLICE_EN: u1,

          /// [27:27] When SPI_MEM_DUAL_RAM_EN is 0 and SPI_MEM_RAM0_EN is 1, only EXT_RAM0 will be accessed. When SPI_MEM_DUAL_RAM_EN is 0 and SPI_MEM_RAM0_EN is 0, only EXT_RAM1 will be accessed. When SPI_MEM_DUAL_RAM_EN is 1,EXT_RAM0 and EXT_RAM1 will be accessed at the same time.
          SPI_MEM_RAM0_EN: u1,

          /// [28:28] Set this bit to enable DUAL-RAM mode, EXT_RAM0 and EXT_RAM1 will be accessed at the same time.
          SPI_MEM_DUAL_RAM_EN: u1,

          /// [29:29] Set this bit to write data faster, do not wait write data has been stored in tx_bus_fifo_l2. It will wait 4*T_clk_ctrl to insure the write data has been stored intx_bus_fifo_l2.
          SPI_MEM_FAST_WRITE_EN: u1,

          /// [30:30] The synchronous reset signal for SPI0 RX AFIFO and all the AES_MSPI SYNC FIFO to receive signals from AXI.Set this bit to reset these FIFO.
          SPI_MEM_RXFIFO_RST: u1,

          /// [31:31] The synchronous reset signal for SPI0 TX AFIFO and all the AES_MSPI SYNC FIFO to send signals to AXI. Set this bit to reset these FIFO.
          SPI_MEM_TXFIFO_RST: u1,

        }), @ptrFromInt(0x6000200c));

        /// SPI0 control2 register.
        pub const SPI_MEM_CTRL2 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:4] (cycles-1) of prepare phase by SPI Bus clock, this bits are combined with SPI_MEM_CS_SETUP bit.
          SPI_MEM_CS_SETUP_TIME: u5,

          /// [5:9] SPI CS signal is delayed to inactive by SPI bus clock, this bits are combined with SPI_MEM_CS_HOLD bit.
          SPI_MEM_CS_HOLD_TIME: u5,

          /// [10:12] SPI_MEM_CS_HOLD_TIME + SPI_MEM_ECC_CS_HOLD_TIME is the SPI0 CS hold cycle in ECC mode when accessed flash.
          SPI_MEM_ECC_CS_HOLD_TIME: u3,

          /// [13:13] 1: SPI0 and SPI1 skip page corner when accesses flash. 0: Not skip page corner when accesses flash.
          SPI_MEM_ECC_SKIP_PAGE_CORNER: u1,

          /// [14:14] Set this bit to enable SPI0 and SPI1 ECC 16 bytes data with 2 ECC bytes mode when accesses flash.
          SPI_MEM_ECC_16TO18_BYTE_EN: u1,

          /// [15:23] 
          res0: u9,

          /// [24:24] Set this bit to enable SPI0 split one AXI read flash transfer into two SPI transfers when one transfer will cross flash or EXT_RAM page corner, valid no matter whether there is an ECC region or not.
          SPI_MEM_SPLIT_TRANS_EN: u1,

          /// [25:30] These bits are used to set the minimum CS high time tSHSL between SPI burst transfer when accesses to flash. tSHSL is (SPI_MEM_CS_HOLD_DELAY[5:0] + 1) MSPI core clock cycles.
          SPI_MEM_CS_HOLD_DELAY: u6,

          /// [31:31] The spi0_mst_st and spi0_slv_st will be reset.
          SPI_MEM_SYNC_RESET: u1,

        }), @ptrFromInt(0x60002010));

        /// SPI clock division control register.
        pub const SPI_MEM_CLOCK = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] In the master mode it must be equal to spi_mem_clkcnt_N.
          SPI_MEM_CLKCNT_L: u8,

          /// [8:15] In the master mode it must be floor((spi_mem_clkcnt_N+1)/2-1).
          SPI_MEM_CLKCNT_H: u8,

          /// [16:23] In the master mode it is the divider of spi_mem_clk. So spi_mem_clk frequency is system/(spi_mem_clkcnt_N+1)
          SPI_MEM_CLKCNT_N: u8,

          /// [24:30] 
          res0: u7,

          /// [31:31] 1: 1-division mode, the frequency of SPI bus clock equals to that of MSPI module clock.
          SPI_MEM_CLK_EQU_SYSCLK: u1,

        }), @ptrFromInt(0x60002014));

        /// SPI0 user register.
        pub const SPI_MEM_USER = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] 
          res0: u6,

          /// [6:6] spi cs keep low when spi is indonephase. 1: enable 0: disable.
          SPI_MEM_CS_HOLD: u1,

          /// [7:7] spi cs is enable when spi is inpreparephase. 1: enable 0: disable.
          SPI_MEM_CS_SETUP: u1,

          /// [8:8] 
          res1: u1,

          /// [9:9] The bit combined with SPI_MEM_CK_IDLE_EDGE bit to control SPI clock mode 0~3.
          SPI_MEM_CK_OUT_EDGE: u1,

          /// [10:25] 
          res2: u16,

          /// [26:26] spi clock is disable in dummy phase when the bit is enable.
          SPI_MEM_USR_DUMMY_IDLE: u1,

          /// [27:28] 
          res3: u2,

          /// [29:29] This bit enable the dummy phase of an operation.
          SPI_MEM_USR_DUMMY: u1,

          /// [30:31] 
          res4: u2,

        }), @ptrFromInt(0x60002018));

        /// SPI0 user1 register.
        pub const SPI_MEM_USER1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] The length in spi_mem_clk cycles of dummy phase. The register value shall be (cycle_num-1).
          SPI_MEM_USR_DUMMY_CYCLELEN: u6,

          /// [6:8] SPI0 USR_CMD read or write data byte length -1
          SPI_MEM_USR_DBYTELEN: u3,

          /// [9:25] 
          res0: u17,

          /// [26:31] The length in bits of address phase. The register value shall be (bit_num-1).
          SPI_MEM_USR_ADDR_BITLEN: u6,

        }), @ptrFromInt(0x6000201c));

        /// SPI0 user2 register.
        pub const SPI_MEM_USER2 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:15] The value ofcommand.
          SPI_MEM_USR_COMMAND_VALUE: u16,

          /// [16:27] 
          res0: u12,

          /// [28:31] The length in bits of command phase. The register value shall be (bit_num-1)
          SPI_MEM_USR_COMMAND_BITLEN: u4,

        }), @ptrFromInt(0x60002020));

        /// SPI0 read control register.
        pub const SPI_MEM_RD_STATUS = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:15] 
          res0: u16,

          /// [16:23] Mode bits in the flash fast read modeit is combined with spi_mem_fastrd_mode bit.
          SPI_MEM_WB_MODE: u8,

          /// [24:31] 
          res1: u8,

        }), @ptrFromInt(0x6000202c));

        /// SPI0 misc register
        pub const SPI_MEM_MISC = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:6] 
          res0: u7,

          /// [7:7] For SPI0,flash is connected to SUBPINs.
          SPI_MEM_FSUB_PIN: u1,

          /// [8:8] For SPI0,sram is connected to SUBPINs.
          SPI_MEM_SSUB_PIN: u1,

          /// [9:9] 1: SPI_CLK line is high when idle 0: spi clk line is low when idle
          SPI_MEM_CK_IDLE_EDGE: u1,

          /// [10:10] SPI_CS line keep low when the bit is set.
          SPI_MEM_CS_KEEP_ACTIVE: u1,

          /// [11:31] 
          res1: u21,

        }), @ptrFromInt(0x60002034));

        /// SPI0 bit mode control register.
        pub const SPI_MEM_CACHE_FCTRL = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] For SPI0, AXI master access enable, 1: enable, 0:disable.
          SPI_MEM_AXI_REQ_EN: u1,

          /// [1:1] For SPI0,cacheread flash with 4 bytes address, 1: enable, 0:disable.
          SPI_MEM_CACHE_USR_ADDR_4BYTE: u1,

          /// [2:2] For SPI0,cacheread flash for user define command, 1: enable, 0:disable.
          SPI_MEM_CACHE_FLASH_USR_CMD: u1,

          /// [3:3] For SPI0 flash, din phase apply 2 signals. 1: enable 0: disable. The bit is the same with spi_mem_fread_dio.
          SPI_MEM_FDIN_DUAL: u1,

          /// [4:4] For SPI0 flash, dout phase apply 2 signals. 1: enable 0: disable. The bit is the same with spi_mem_fread_dio.
          SPI_MEM_FDOUT_DUAL: u1,

          /// [5:5] For SPI0 flash, address phase apply 2 signals. 1: enable 0: disable.The bit is the same with spi_mem_fread_dio.
          SPI_MEM_FADDR_DUAL: u1,

          /// [6:6] For SPI0 flash, din phase apply 4 signals. 1: enable 0: disable.The bit is the same with spi_mem_fread_qio.
          SPI_MEM_FDIN_QUAD: u1,

          /// [7:7] For SPI0 flash, dout phase apply 4 signals. 1: enable 0: disable.The bit is the same with spi_mem_fread_qio.
          SPI_MEM_FDOUT_QUAD: u1,

          /// [8:8] For SPI0 flash, address phase apply 4 signals. 1: enable 0: disable.The bit is the same with spi_mem_fread_qio.
          SPI_MEM_FADDR_QUAD: u1,

          /// [9:29] 
          res0: u21,

          /// [30:30] Set this bit to check AXI read/write the same address region.
          SPI_SAME_AW_AR_ADDR_CHK_EN: u1,

          /// [31:31] Set this bit to close AXI read/write transfer to MSPI, which means that only SLV_ERR will be replied to BRESP/RRESP.
          SPI_CLOSE_AXI_INF_EN: u1,

        }), @ptrFromInt(0x6000203c));

        /// SPI0 external RAM control register
        pub const SPI_MEM_CACHE_SCTRL = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] For SPI0, In the external RAM mode, cache read flash with 4 bytes command, 1: enable, 0:disable.
          SPI_MEM_CACHE_USR_SADDR_4BYTE: u1,

          /// [1:1] For SPI0, In the external RAM mode, spi dual I/O mode enable, 1: enable, 0:disable
          SPI_MEM_USR_SRAM_DIO: u1,

          /// [2:2] For SPI0, In the external RAM mode, spi quad I/O mode enable, 1: enable, 0:disable
          SPI_MEM_USR_SRAM_QIO: u1,

          /// [3:3] For SPI0, In the external RAM mode, it is the enable bit of dummy phase for write operations.
          SPI_MEM_USR_WR_SRAM_DUMMY: u1,

          /// [4:4] For SPI0, In the external RAM mode, it is the enable bit of dummy phase for read operations.
          SPI_MEM_USR_RD_SRAM_DUMMY: u1,

          /// [5:5] For SPI0, In the external RAM mode cache read external RAM for user define command.
          SPI_MEM_CACHE_SRAM_USR_RCMD: u1,

          /// [6:11] For SPI0, In the external RAM mode, it is the length in bits of read dummy phase. The register value shall be (bit_num-1).
          SPI_MEM_SRAM_RDUMMY_CYCLELEN: u6,

          /// [12:13] 
          res0: u2,

          /// [14:19] For SPI0, In the external RAM mode, it is the length in bits of address phase. The register value shall be (bit_num-1).
          SPI_MEM_SRAM_ADDR_BITLEN: u6,

          /// [20:20] For SPI0, In the external RAM mode cache write sram for user define command
          SPI_MEM_CACHE_SRAM_USR_WCMD: u1,

          /// [21:21] reserved
          SPI_MEM_SRAM_OCT: u1,

          /// [22:27] For SPI0, In the external RAM mode, it is the length in bits of write dummy phase. The register value shall be (bit_num-1).
          SPI_MEM_SRAM_WDUMMY_CYCLELEN: u6,

          /// [28:31] 
          res1: u4,

        }), @ptrFromInt(0x60002040));

        /// SPI0 external RAM mode control register
        pub const SPI_MEM_SRAM_CMD = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:1] SPI clock mode bits. 0: SPI clock is off when CS inactive 1: SPI clock is delayed one cycle after CS inactive 2: SPI clock is delayed two cycles after CS inactive 3: SPI clock is always on.
          SPI_MEM_SCLK_MODE: u2,

          /// [2:9] Mode bits in the external RAM fast read modeit is combined with spi_mem_fastrd_mode bit.
          SPI_MEM_SWB_MODE: u8,

          /// [10:10] For SPI0 external RAM , din phase apply 2 signals. 1: enable 0: disable. The bit is the same with spi_mem_usr_sram_dio.
          SPI_MEM_SDIN_DUAL: u1,

          /// [11:11] For SPI0 external RAM , dout phase apply 2 signals. 1: enable 0: disable. The bit is the same with spi_mem_usr_sram_dio.
          SPI_MEM_SDOUT_DUAL: u1,

          /// [12:12] For SPI0 external RAM , address phase apply 2 signals. 1: enable 0: disable. The bit is the same with spi_mem_usr_sram_dio.
          SPI_MEM_SADDR_DUAL: u1,

          /// [13:13] 
          res0: u1,

          /// [14:14] For SPI0 external RAM , din phase apply 4 signals. 1: enable 0: disable. The bit is the same with spi_mem_usr_sram_qio.
          SPI_MEM_SDIN_QUAD: u1,

          /// [15:15] For SPI0 external RAM , dout phase apply 4 signals. 1: enable 0: disable. The bit is the same with spi_mem_usr_sram_qio.
          SPI_MEM_SDOUT_QUAD: u1,

          /// [16:16] For SPI0 external RAM , address phase apply 4 signals. 1: enable 0: disable. The bit is the same with spi_mem_usr_sram_qio.
          SPI_MEM_SADDR_QUAD: u1,

          /// [17:17] For SPI0 external RAM , cmd phase apply 4 signals. 1: enable 0: disable. The bit is the same with spi_mem_usr_sram_qio.
          SPI_MEM_SCMD_QUAD: u1,

          /// [18:18] For SPI0 external RAM , din phase apply 8 signals. 1: enable 0: disable.
          SPI_MEM_SDIN_OCT: u1,

          /// [19:19] For SPI0 external RAM , dout phase apply 8 signals. 1: enable 0: disable.
          SPI_MEM_SDOUT_OCT: u1,

          /// [20:20] For SPI0 external RAM , address phase apply 4 signals. 1: enable 0: disable.
          SPI_MEM_SADDR_OCT: u1,

          /// [21:21] For SPI0 external RAM , cmd phase apply 8 signals. 1: enable 0: disable.
          SPI_MEM_SCMD_OCT: u1,

          /// [22:22] In the dummy phase of a MSPI read data transfer when accesses to external RAM, the signal level of SPI bus is output by the MSPI controller.
          SPI_MEM_SDUMMY_RIN: u1,

          /// [23:23] In the dummy phase of a MSPI write data transfer when accesses to external RAM, the signal level of SPI bus is output by the MSPI controller.
          SPI_MEM_SDUMMY_WOUT: u1,

          /// [24:24] In the dummy phase of an MSPI write data transfer when accesses to external RAM, the level of SPI_DQS is output by the MSPI controller.
          SPI_SMEM_WDUMMY_DQS_ALWAYS_OUT: u1,

          /// [25:25] In the dummy phase of an MSPI write data transfer when accesses to external RAM, the level of SPI_IO[7:0] is output by the MSPI controller.
          SPI_SMEM_WDUMMY_ALWAYS_OUT: u1,

          /// [26:29] 
          res1: u4,

          /// [30:30] When accesses to external RAM, 1: the IE signals of pads connected to SPI_DQS are always 1. 0: Others.
          SPI_SMEM_DQS_IE_ALWAYS_ON: u1,

          /// [31:31] When accesses to external RAM, 1: the IE signals of pads connected to SPI_IO[7:0] are always 1. 0: Others.
          SPI_SMEM_DATA_IE_ALWAYS_ON: u1,

        }), @ptrFromInt(0x60002044));

        /// SPI0 external RAM DDR read command control register
        pub const SPI_MEM_SRAM_DRD_CMD = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:15] For SPI0,When cache mode is enable it is the read command value of command phase for sram.
          SPI_MEM_CACHE_SRAM_USR_RD_CMD_VALUE: u16,

          /// [16:27] 
          res0: u12,

          /// [28:31] For SPI0,When cache mode is enable it is the length in bits of command phase for sram. The register value shall be (bit_num-1).
          SPI_MEM_CACHE_SRAM_USR_RD_CMD_BITLEN: u4,

        }), @ptrFromInt(0x60002048));

        /// SPI0 external RAM DDR write command control register
        pub const SPI_MEM_SRAM_DWR_CMD = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:15] For SPI0,When cache mode is enable it is the write command value of command phase for sram.
          SPI_MEM_CACHE_SRAM_USR_WR_CMD_VALUE: u16,

          /// [16:27] 
          res0: u12,

          /// [28:31] For SPI0,When cache mode is enable it is the in bits of command phasefor sram. The register value shall be (bit_num-1).
          SPI_MEM_CACHE_SRAM_USR_WR_CMD_BITLEN: u4,

        }), @ptrFromInt(0x6000204c));

        /// SPI0 external RAM clock control register
        pub const SPI_MEM_SRAM_CLK = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] For SPI0 external RAMinterface, it must be equal to spi_mem_clkcnt_N.
          SPI_MEM_SCLKCNT_L: u8,

          /// [8:15] For SPI0 external RAMinterface, it must be floor((spi_mem_clkcnt_N+1)/2-1).
          SPI_MEM_SCLKCNT_H: u8,

          /// [16:23] For SPI0 external RAMinterface, it is the divider of spi_mem_clk. So spi_mem_clk frequency is system/(spi_mem_clkcnt_N+1)
          SPI_MEM_SCLKCNT_N: u8,

          /// [24:30] 
          res0: u7,

          /// [31:31] For SPI0 external RAMinterface, 1: spi_mem_clk is eqaul to system 0: spi_mem_clk is divided from system clock.
          SPI_MEM_SCLK_EQU_SYSCLK: u1,

        }), @ptrFromInt(0x60002050));

        /// SPI0 FSM status register
        pub const SPI_MEM_FSM = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:6] 
          res0: u7,

          /// [7:11] The lock delay time of SPI0/1 arbiter by spi0_slv_st, after PER is sent by SPI1.
          SPI_MEM_LOCK_DELAY_TIME: u5,

          /// [12:31] 
          res1: u20,

        }), @ptrFromInt(0x60002054));

        /// SPI0 interrupt enable register
        pub const SPI_MEM_INT_ENA = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:2] 
          res0: u3,

          /// [3:3] The enable bit for SPI_MEM_SLV_ST_END_INT interrupt.
          SPI_MEM_SLV_ST_END_INT_ENA: u1,

          /// [4:4] The enable bit for SPI_MEM_MST_ST_END_INT interrupt.
          SPI_MEM_MST_ST_END_INT_ENA: u1,

          /// [5:5] The enable bit for SPI_MEM_ECC_ERR_INT interrupt.
          SPI_MEM_ECC_ERR_INT_ENA: u1,

          /// [6:6] The enable bit for SPI_MEM_PMS_REJECT_INT interrupt.
          SPI_MEM_PMS_REJECT_INT_ENA: u1,

          /// [7:7] The enable bit for SPI_MEM_AXI_RADDR_ERR_INT interrupt.
          SPI_MEM_AXI_RADDR_ERR_INT_ENA: u1,

          /// [8:8] The enable bit for SPI_MEM_AXI_WR_FALSH_ERR_INT interrupt.
          SPI_MEM_AXI_WR_FLASH_ERR_INT_ENA: u1,

          /// [9:9] The enable bit for SPI_MEM_AXI_WADDR_ERR_INT interrupt.
          SPI_MEM_AXI_WADDR_ERR_INT__ENA: u1,

          /// [10:31] 
          res1: u22,

        }), @ptrFromInt(0x600020c0));

        /// SPI0 interrupt clear register
        pub const SPI_MEM_INT_CLR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:2] 
          res0: u3,

          /// [3:3] The clear bit for SPI_MEM_SLV_ST_END_INT interrupt.
          SPI_MEM_SLV_ST_END_INT_CLR: u1,

          /// [4:4] The clear bit for SPI_MEM_MST_ST_END_INT interrupt.
          SPI_MEM_MST_ST_END_INT_CLR: u1,

          /// [5:5] The clear bit for SPI_MEM_ECC_ERR_INT interrupt.
          SPI_MEM_ECC_ERR_INT_CLR: u1,

          /// [6:6] The clear bit for SPI_MEM_PMS_REJECT_INT interrupt.
          SPI_MEM_PMS_REJECT_INT_CLR: u1,

          /// [7:7] The clear bit for SPI_MEM_AXI_RADDR_ERR_INT interrupt.
          SPI_MEM_AXI_RADDR_ERR_INT_CLR: u1,

          /// [8:8] The clear bit for SPI_MEM_AXI_WR_FALSH_ERR_INT interrupt.
          SPI_MEM_AXI_WR_FLASH_ERR_INT_CLR: u1,

          /// [9:9] The clear bit for SPI_MEM_AXI_WADDR_ERR_INT interrupt.
          SPI_MEM_AXI_WADDR_ERR_INT_CLR: u1,

          /// [10:31] 
          res1: u22,

        }), @ptrFromInt(0x600020c4));

        /// SPI0 interrupt raw register
        pub const SPI_MEM_INT_RAW = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:2] 
          res0: u3,

          /// [3:3] The raw bit for SPI_MEM_SLV_ST_END_INT interrupt. 1: Triggered when spi0_slv_st is changed from non idle state to idle state. It means that SPI_CS raises high. 0: Others
          SPI_MEM_SLV_ST_END_INT_RAW: u1,

          /// [4:4] The raw bit for SPI_MEM_MST_ST_END_INT interrupt. 1: Triggered when spi0_mst_st is changed from non idle state to idle state. 0: Others.
          SPI_MEM_MST_ST_END_INT_RAW: u1,

          /// [5:5] The raw bit for SPI_MEM_ECC_ERR_INT interrupt. When SPI_FMEM_ECC_ERR_INT_EN is set andSPI_SMEM_ECC_ERR_INT_EN is cleared, this bit is triggered when the error times of SPI0/1 ECC read flash are equal or bigger than SPI_MEM_ECC_ERR_INT_NUM. When SPI_FMEM_ECC_ERR_INT_EN is cleared andSPI_SMEM_ECC_ERR_INT_EN is set, this bit is triggered when the error times of SPI0/1 ECC read external RAM are equal or bigger than SPI_MEM_ECC_ERR_INT_NUM. When SPI_FMEM_ECC_ERR_INT_EN andSPI_SMEM_ECC_ERR_INT_EN are set, this bit is triggered when the total error times of SPI0/1 ECC read external RAM and flash are equal or bigger than SPI_MEM_ECC_ERR_INT_NUM. When SPI_FMEM_ECC_ERR_INT_EN andSPI_SMEM_ECC_ERR_INT_EN are cleared, this bit will not be triggered.
          SPI_MEM_ECC_ERR_INT_RAW: u1,

          /// [6:6] The raw bit for SPI_MEM_PMS_REJECT_INT interrupt. 1: Triggered when SPI1 access is rejected. 0: Others.
          SPI_MEM_PMS_REJECT_INT_RAW: u1,

          /// [7:7] The raw bit for SPI_MEM_AXI_RADDR_ERR_INT interrupt. 1: Triggered when AXI read address is invalid by compared to MMU configuration. 0: Others.
          SPI_MEM_AXI_RADDR_ERR_INT_RAW: u1,

          /// [8:8] The raw bit for SPI_MEM_AXI_WR_FALSH_ERR_INT interrupt. 1: Triggered when AXI write flash request is received. 0: Others.
          SPI_MEM_AXI_WR_FLASH_ERR_INT_RAW: u1,

          /// [9:9] The raw bit for SPI_MEM_AXI_WADDR_ERR_INT interrupt. 1: Triggered when AXI write address is invalid by compared to MMU configuration. 0: Others.
          SPI_MEM_AXI_WADDR_ERR_INT_RAW: u1,

          /// [10:31] 
          res1: u22,

        }), @ptrFromInt(0x600020c8));

        /// SPI0 interrupt status register
        pub const SPI_MEM_INT_ST = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:2] 
          res0: u3,

          /// [3:3] The status bit for SPI_MEM_SLV_ST_END_INT interrupt.
          SPI_MEM_SLV_ST_END_INT_ST: u1,

          /// [4:4] The status bit for SPI_MEM_MST_ST_END_INT interrupt.
          SPI_MEM_MST_ST_END_INT_ST: u1,

          /// [5:5] The status bit for SPI_MEM_ECC_ERR_INT interrupt.
          SPI_MEM_ECC_ERR_INT_ST: u1,

          /// [6:6] The status bit for SPI_MEM_PMS_REJECT_INT interrupt.
          SPI_MEM_PMS_REJECT_INT_ST: u1,

          /// [7:7] The enable bit for SPI_MEM_AXI_RADDR_ERR_INT interrupt.
          SPI_MEM_AXI_RADDR_ERR_INT_ST: u1,

          /// [8:8] The enable bit for SPI_MEM_AXI_WR_FALSH_ERR_INT interrupt.
          SPI_MEM_AXI_WR_FLASH_ERR_INT_ST: u1,

          /// [9:9] The enable bit for SPI_MEM_AXI_WADDR_ERR_INT interrupt.
          SPI_MEM_AXI_WADDR_ERR_INT_ST: u1,

          /// [10:31] 
          res1: u22,

        }), @ptrFromInt(0x600020cc));

        /// SPI0 flash DDR mode control register
        pub const SPI_MEM_DDR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] 1: in DDR mode,0 in SDR mode
          SPI_FMEM_DDR_EN: u1,

          /// [1:1] Set the bit to enable variable dummy cycle in spi DDR mode.
          SPI_FMEM_VAR_DUMMY: u1,

          /// [2:2] Set the bit to reorder rx data of the word in spi DDR mode.
          SPI_FMEM_DDR_RDAT_SWP: u1,

          /// [3:3] Set the bit to reorder tx data of the word in spi DDR mode.
          SPI_FMEM_DDR_WDAT_SWP: u1,

          /// [4:4] the bit is used to disable dual edge in command phase when DDR mode.
          SPI_FMEM_DDR_CMD_DIS: u1,

          /// [5:11] It is the minimum output data length in the panda device.
          SPI_FMEM_OUTMINBYTELEN: u7,

          /// [12:12] Set this bit to mask the first or the last byte in SPI0 ECC DDR write mode, when accesses to flash.
          SPI_FMEM_TX_DDR_MSK_EN: u1,

          /// [13:13] Set this bit to mask the first or the last byte in SPI0 ECC DDR read mode, when accesses to flash.
          SPI_FMEM_RX_DDR_MSK_EN: u1,

          /// [14:20] The delay number of data strobe which from memory based on SPI clock.
          SPI_FMEM_USR_DDR_DQS_THD: u7,

          /// [21:21] 1: Do not need the input of SPI_DQS signal, SPI0 starts to receive data when spi0_slv_st is in SPI_MEM_DIN state. It is used when there is no SPI_DQS signal or SPI_DQS signal is not stable. 0: SPI0 starts to store data at the positive and negative edge of SPI_DQS.
          SPI_FMEM_DDR_DQS_LOOP: u1,

          /// [22:23] 
          res0: u2,

          /// [24:24] Set this bit to enable the differential SPI_CLK#.
          SPI_FMEM_CLK_DIFF_EN: u1,

          /// [25:25] 
          res1: u1,

          /// [26:26] Set this bit to enable the input of SPI_DQS signal in SPI phases of CMD and ADDR.
          SPI_FMEM_DQS_CA_IN: u1,

          /// [27:27] Set this bit to enable the vary dummy function in SPI HyperBus mode, when SPI0 accesses flash or SPI1 accesses flash or sram.
          SPI_FMEM_HYPERBUS_DUMMY_2X: u1,

          /// [28:28] Set this bit to invert SPI_DIFF when accesses to flash. .
          SPI_FMEM_CLK_DIFF_INV: u1,

          /// [29:29] Set this bit to enable octa_ram address out when accesses to flash, which means ADDR_OUT[31:0] = {spi_usr_addr_value[25:4], 6'd0, spi_usr_addr_value[3:1], 1'b0}.
          SPI_FMEM_OCTA_RAM_ADDR: u1,

          /// [30:30] Set this bit to enable HyperRAM address out when accesses to flash, which means ADDR_OUT[31:0] = {spi_usr_addr_value[19:4], 13'd0, spi_usr_addr_value[3:1]}.
          SPI_FMEM_HYPERBUS_CA: u1,

          /// [31:31] 
          res2: u1,

        }), @ptrFromInt(0x600020d4));

        /// SPI0 external RAM DDR mode control register
        pub const SPI_SMEM_DDR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] 1: in DDR mode,0 in SDR mode
          EN: u1,

          /// [1:1] Set the bit to enable variable dummy cycle in spi DDR mode.
          SPI_SMEM_VAR_DUMMY: u1,

          /// [2:2] Set the bit to reorder rx data of the word in spi DDR mode.
          RDAT_SWP: u1,

          /// [3:3] Set the bit to reorder tx data of the word in spi DDR mode.
          WDAT_SWP: u1,

          /// [4:4] the bit is used to disable dual edge in command phase when DDR mode.
          CMD_DIS: u1,

          /// [5:11] It is the minimum output data length in the DDR psram.
          SPI_SMEM_OUTMINBYTELEN: u7,

          /// [12:12] Set this bit to mask the first or the last byte in SPI0 ECC DDR write mode, when accesses to external RAM.
          SPI_SMEM_TX_DDR_MSK_EN: u1,

          /// [13:13] Set this bit to mask the first or the last byte in SPI0 ECC DDR read mode, when accesses to external RAM.
          SPI_SMEM_RX_DDR_MSK_EN: u1,

          /// [14:20] The delay number of data strobe which from memory based on SPI clock.
          SPI_SMEM_USR_DDR_DQS_THD: u7,

          /// [21:21] 1: Do not need the input of SPI_DQS signal, SPI0 starts to receive data when spi0_slv_st is in SPI_MEM_DIN state. It is used when there is no SPI_DQS signal or SPI_DQS signal is not stable. 0: SPI0 starts to store data at the positive and negative edge of SPI_DQS.
          DQS_LOOP: u1,

          /// [22:23] 
          res0: u2,

          /// [24:24] Set this bit to enable the differential SPI_CLK#.
          SPI_SMEM_CLK_DIFF_EN: u1,

          /// [25:25] 
          res1: u1,

          /// [26:26] Set this bit to enable the input of SPI_DQS signal in SPI phases of CMD and ADDR.
          SPI_SMEM_DQS_CA_IN: u1,

          /// [27:27] Set this bit to enable the vary dummy function in SPI HyperBus mode, when SPI0 accesses flash or SPI1 accesses flash or sram.
          SPI_SMEM_HYPERBUS_DUMMY_2X: u1,

          /// [28:28] Set this bit to invert SPI_DIFF when accesses to external RAM. .
          SPI_SMEM_CLK_DIFF_INV: u1,

          /// [29:29] Set this bit to enable octa_ram address out when accesses to external RAM, which means ADDR_OUT[31:0] = {spi_usr_addr_value[25:4], 6'd0, spi_usr_addr_value[3:1], 1'b0}.
          SPI_SMEM_OCTA_RAM_ADDR: u1,

          /// [30:30] Set this bit to enable HyperRAM address out when accesses to external RAM, which means ADDR_OUT[31:0] = {spi_usr_addr_value[19:4], 13'd0, spi_usr_addr_value[3:1]}.
          SPI_SMEM_HYPERBUS_CA: u1,

          /// [31:31] 
          res2: u1,

        }), @ptrFromInt(0x600020d8));

        /// MSPI flash ACE section %s attribute register
        pub const SPI_FMEM_PMS0_ATTR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] 1: SPI1 flash ACE section %s read accessible. 0: Not allowed.
          SPI_FMEM_PMS_RD_ATTR: u1,

          /// [1:1] 1: SPI1 flash ACE section %s write accessible. 0: Not allowed.
          SPI_FMEM_PMS_WR_ATTR: u1,

          /// [2:2] SPI1 flash ACE section %s ECC mode, 1: enable ECC mode. 0: Disable it. The flash ACE section %s is configured by registers SPI_FMEM_PMS%s_ADDR_REG and SPI_FMEM_PMS%s_SIZE_REG.
          SPI_FMEM_PMS_ECC: u1,

          /// [3:31] 
          res0: u29,

        }), @ptrFromInt(0x60002100));

        /// MSPI flash ACE section %s attribute register
        pub const SPI_FMEM_PMS1_ATTR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] 1: SPI1 flash ACE section %s read accessible. 0: Not allowed.
          SPI_FMEM_PMS_RD_ATTR: u1,

          /// [1:1] 1: SPI1 flash ACE section %s write accessible. 0: Not allowed.
          SPI_FMEM_PMS_WR_ATTR: u1,

          /// [2:2] SPI1 flash ACE section %s ECC mode, 1: enable ECC mode. 0: Disable it. The flash ACE section %s is configured by registers SPI_FMEM_PMS%s_ADDR_REG and SPI_FMEM_PMS%s_SIZE_REG.
          SPI_FMEM_PMS_ECC: u1,

          /// [3:31] 
          res0: u29,

        }), @ptrFromInt(0x60002104));

        /// MSPI flash ACE section %s attribute register
        pub const SPI_FMEM_PMS2_ATTR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] 1: SPI1 flash ACE section %s read accessible. 0: Not allowed.
          SPI_FMEM_PMS_RD_ATTR: u1,

          /// [1:1] 1: SPI1 flash ACE section %s write accessible. 0: Not allowed.
          SPI_FMEM_PMS_WR_ATTR: u1,

          /// [2:2] SPI1 flash ACE section %s ECC mode, 1: enable ECC mode. 0: Disable it. The flash ACE section %s is configured by registers SPI_FMEM_PMS%s_ADDR_REG and SPI_FMEM_PMS%s_SIZE_REG.
          SPI_FMEM_PMS_ECC: u1,

          /// [3:31] 
          res0: u29,

        }), @ptrFromInt(0x60002108));

        /// MSPI flash ACE section %s attribute register
        pub const SPI_FMEM_PMS3_ATTR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] 1: SPI1 flash ACE section %s read accessible. 0: Not allowed.
          SPI_FMEM_PMS_RD_ATTR: u1,

          /// [1:1] 1: SPI1 flash ACE section %s write accessible. 0: Not allowed.
          SPI_FMEM_PMS_WR_ATTR: u1,

          /// [2:2] SPI1 flash ACE section %s ECC mode, 1: enable ECC mode. 0: Disable it. The flash ACE section %s is configured by registers SPI_FMEM_PMS%s_ADDR_REG and SPI_FMEM_PMS%s_SIZE_REG.
          SPI_FMEM_PMS_ECC: u1,

          /// [3:31] 
          res0: u29,

        }), @ptrFromInt(0x6000210c));

        /// SPI1 flash ACE section %s start address register
        pub const SPI_FMEM_PMS0_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:25] SPI1 flash ACE section %s start address value
          S: u26,

          /// [26:31] 
          res0: u6,

        }), @ptrFromInt(0x60002110));

        /// SPI1 flash ACE section %s start address register
        pub const SPI_FMEM_PMS1_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:25] SPI1 flash ACE section %s start address value
          S: u26,

          /// [26:31] 
          res0: u6,

        }), @ptrFromInt(0x60002114));

        /// SPI1 flash ACE section %s start address register
        pub const SPI_FMEM_PMS2_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:25] SPI1 flash ACE section %s start address value
          S: u26,

          /// [26:31] 
          res0: u6,

        }), @ptrFromInt(0x60002118));

        /// SPI1 flash ACE section %s start address register
        pub const SPI_FMEM_PMS3_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:25] SPI1 flash ACE section %s start address value
          S: u26,

          /// [26:31] 
          res0: u6,

        }), @ptrFromInt(0x6000211c));

        /// SPI1 flash ACE section %s start address register
        pub const SPI_FMEM_PMS0_SIZE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:13] SPI1 flash ACE section %s address region is (SPI_FMEM_PMS%s_ADDR_S, SPI_FMEM_PMS%s_ADDR_S + SPI_FMEM_PMS%s_SIZE)
          SPI_FMEM_PMS_SIZE: u14,

          /// [14:31] 
          res0: u18,

        }), @ptrFromInt(0x60002120));

        /// SPI1 flash ACE section %s start address register
        pub const SPI_FMEM_PMS1_SIZE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:13] SPI1 flash ACE section %s address region is (SPI_FMEM_PMS%s_ADDR_S, SPI_FMEM_PMS%s_ADDR_S + SPI_FMEM_PMS%s_SIZE)
          SPI_FMEM_PMS_SIZE: u14,

          /// [14:31] 
          res0: u18,

        }), @ptrFromInt(0x60002124));

        /// SPI1 flash ACE section %s start address register
        pub const SPI_FMEM_PMS2_SIZE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:13] SPI1 flash ACE section %s address region is (SPI_FMEM_PMS%s_ADDR_S, SPI_FMEM_PMS%s_ADDR_S + SPI_FMEM_PMS%s_SIZE)
          SPI_FMEM_PMS_SIZE: u14,

          /// [14:31] 
          res0: u18,

        }), @ptrFromInt(0x60002128));

        /// SPI1 flash ACE section %s start address register
        pub const SPI_FMEM_PMS3_SIZE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:13] SPI1 flash ACE section %s address region is (SPI_FMEM_PMS%s_ADDR_S, SPI_FMEM_PMS%s_ADDR_S + SPI_FMEM_PMS%s_SIZE)
          SPI_FMEM_PMS_SIZE: u14,

          /// [14:31] 
          res0: u18,

        }), @ptrFromInt(0x6000212c));

        /// SPI1 flash ACE section %s start address register
        pub const SPI_SMEM_PMS0_ATTR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] 1: SPI1 external RAM ACE section %s read accessible. 0: Not allowed.
          SPI_SMEM_PMS_RD_ATTR: u1,

          /// [1:1] 1: SPI1 external RAM ACE section %s write accessible. 0: Not allowed.
          SPI_SMEM_PMS_WR_ATTR: u1,

          /// [2:2] SPI1 external RAM ACE section %s ECC mode, 1: enable ECC mode. 0: Disable it. The external RAM ACE section %s is configured by registers SPI_SMEM_PMS%s_ADDR_REG and SPI_SMEM_PMS%s_SIZE_REG.
          SPI_SMEM_PMS_ECC: u1,

          /// [3:31] 
          res0: u29,

        }), @ptrFromInt(0x60002130));

        /// SPI1 flash ACE section %s start address register
        pub const SPI_SMEM_PMS1_ATTR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] 1: SPI1 external RAM ACE section %s read accessible. 0: Not allowed.
          SPI_SMEM_PMS_RD_ATTR: u1,

          /// [1:1] 1: SPI1 external RAM ACE section %s write accessible. 0: Not allowed.
          SPI_SMEM_PMS_WR_ATTR: u1,

          /// [2:2] SPI1 external RAM ACE section %s ECC mode, 1: enable ECC mode. 0: Disable it. The external RAM ACE section %s is configured by registers SPI_SMEM_PMS%s_ADDR_REG and SPI_SMEM_PMS%s_SIZE_REG.
          SPI_SMEM_PMS_ECC: u1,

          /// [3:31] 
          res0: u29,

        }), @ptrFromInt(0x60002134));

        /// SPI1 flash ACE section %s start address register
        pub const SPI_SMEM_PMS2_ATTR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] 1: SPI1 external RAM ACE section %s read accessible. 0: Not allowed.
          SPI_SMEM_PMS_RD_ATTR: u1,

          /// [1:1] 1: SPI1 external RAM ACE section %s write accessible. 0: Not allowed.
          SPI_SMEM_PMS_WR_ATTR: u1,

          /// [2:2] SPI1 external RAM ACE section %s ECC mode, 1: enable ECC mode. 0: Disable it. The external RAM ACE section %s is configured by registers SPI_SMEM_PMS%s_ADDR_REG and SPI_SMEM_PMS%s_SIZE_REG.
          SPI_SMEM_PMS_ECC: u1,

          /// [3:31] 
          res0: u29,

        }), @ptrFromInt(0x60002138));

        /// SPI1 flash ACE section %s start address register
        pub const SPI_SMEM_PMS3_ATTR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] 1: SPI1 external RAM ACE section %s read accessible. 0: Not allowed.
          SPI_SMEM_PMS_RD_ATTR: u1,

          /// [1:1] 1: SPI1 external RAM ACE section %s write accessible. 0: Not allowed.
          SPI_SMEM_PMS_WR_ATTR: u1,

          /// [2:2] SPI1 external RAM ACE section %s ECC mode, 1: enable ECC mode. 0: Disable it. The external RAM ACE section %s is configured by registers SPI_SMEM_PMS%s_ADDR_REG and SPI_SMEM_PMS%s_SIZE_REG.
          SPI_SMEM_PMS_ECC: u1,

          /// [3:31] 
          res0: u29,

        }), @ptrFromInt(0x6000213c));

        /// SPI1 external RAM ACE section %s start address register
        pub const SPI_SMEM_PMS0_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:25] SPI1 external RAM ACE section %s start address value
          S: u26,

          /// [26:31] 
          res0: u6,

        }), @ptrFromInt(0x60002140));

        /// SPI1 external RAM ACE section %s start address register
        pub const SPI_SMEM_PMS1_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:25] SPI1 external RAM ACE section %s start address value
          S: u26,

          /// [26:31] 
          res0: u6,

        }), @ptrFromInt(0x60002144));

        /// SPI1 external RAM ACE section %s start address register
        pub const SPI_SMEM_PMS2_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:25] SPI1 external RAM ACE section %s start address value
          S: u26,

          /// [26:31] 
          res0: u6,

        }), @ptrFromInt(0x60002148));

        /// SPI1 external RAM ACE section %s start address register
        pub const SPI_SMEM_PMS3_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:25] SPI1 external RAM ACE section %s start address value
          S: u26,

          /// [26:31] 
          res0: u6,

        }), @ptrFromInt(0x6000214c));

        /// SPI1 external RAM ACE section %s start address register
        pub const SPI_SMEM_PMS0_SIZE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:13] SPI1 external RAM ACE section %s address region is (SPI_SMEM_PMS%s_ADDR_S, SPI_SMEM_PMS%s_ADDR_S + SPI_SMEM_PMS%s_SIZE)
          SPI_SMEM_PMS_SIZE: u14,

          /// [14:31] 
          res0: u18,

        }), @ptrFromInt(0x60002150));

        /// SPI1 external RAM ACE section %s start address register
        pub const SPI_SMEM_PMS1_SIZE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:13] SPI1 external RAM ACE section %s address region is (SPI_SMEM_PMS%s_ADDR_S, SPI_SMEM_PMS%s_ADDR_S + SPI_SMEM_PMS%s_SIZE)
          SPI_SMEM_PMS_SIZE: u14,

          /// [14:31] 
          res0: u18,

        }), @ptrFromInt(0x60002154));

        /// SPI1 external RAM ACE section %s start address register
        pub const SPI_SMEM_PMS2_SIZE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:13] SPI1 external RAM ACE section %s address region is (SPI_SMEM_PMS%s_ADDR_S, SPI_SMEM_PMS%s_ADDR_S + SPI_SMEM_PMS%s_SIZE)
          SPI_SMEM_PMS_SIZE: u14,

          /// [14:31] 
          res0: u18,

        }), @ptrFromInt(0x60002158));

        /// SPI1 external RAM ACE section %s start address register
        pub const SPI_SMEM_PMS3_SIZE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:13] SPI1 external RAM ACE section %s address region is (SPI_SMEM_PMS%s_ADDR_S, SPI_SMEM_PMS%s_ADDR_S + SPI_SMEM_PMS%s_SIZE)
          SPI_SMEM_PMS_SIZE: u14,

          /// [14:31] 
          res0: u18,

        }), @ptrFromInt(0x6000215c));

        /// SPI1 access reject register
        pub const SPI_MEM_PMS_REJECT = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:25] This bits show the first SPI1 access error address. It is cleared by whenSPI_MEM_PMS_REJECT_INT_CLR bit is set.
          SPI_MEM_REJECT_ADDR: u26,

          /// [26:26] Set this bit to enable SPI0/1 transfer permission control function.
          SPI_MEM_PM_EN: u1,

          /// [27:27] 
          res0: u1,

          /// [28:28] 1: SPI1 write access error. 0: No write access error. It is cleared by whenSPI_MEM_PMS_REJECT_INT_CLR bit is set.
          SPI_MEM_PMS_LD: u1,

          /// [29:29] 1: SPI1 read access error. 0: No read access error. It is cleared by whenSPI_MEM_PMS_REJECT_INT_CLR bit is set.
          SPI_MEM_PMS_ST: u1,

          /// [30:30] 1: SPI1 access is rejected because of address miss. 0: No address miss error. It is cleared by whenSPI_MEM_PMS_REJECT_INT_CLR bit is set.
          SPI_MEM_PMS_MULTI_HIT: u1,

          /// [31:31] 1: SPI1 access is rejected because of address multi-hit. 0: No address multi-hit error. It is cleared by whenSPI_MEM_PMS_REJECT_INT_CLR bit is set.
          SPI_MEM_PMS_IVD: u1,

        }), @ptrFromInt(0x60002164));

        /// MSPI ECC control register
        pub const SPI_MEM_ECC_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:10] 
          res0: u11,

          /// [11:16] Set the error times of MSPI ECC read to generate MSPI SPI_MEM_ECC_ERR_INT interrupt.
          SPI_FMEM_ECC_ERR_INT_NUM: u6,

          /// [17:17] Set this bit to calculate the error times of MSPI ECC read when accesses to flash.
          SPI_FMEM_ECC_ERR_INT_EN: u1,

          /// [18:19] Set the page size of the flash accessed by MSPI. 0: 256 bytes. 1: 512 bytes. 2: 1024 bytes. 3: 2048 bytes.
          SPI_FMEM_PAGE_SIZE: u2,

          /// [20:20] Set this bit to enable MSPI ECC address conversion, no matter MSPI accesses to the ECC region or non-ECC region of flash. If there is no ECC region in flash, this bit should be 0. Otherwise, this bit should be 1.
          SPI_FMEM_ECC_ADDR_EN: u1,

          /// [21:21] Set this bit to enable ECC address convert in SPI0/1 USR_CMD transfer.
          SPI_MEM_USR_ECC_ADDR_EN: u1,

          /// [22:23] 
          res1: u2,

          /// [24:24] 1: The error information in SPI_MEM_ECC_ERR_BITS and SPI_MEM_ECC_ERR_ADDR is updated when there is an ECC error. 0: SPI_MEM_ECC_ERR_BITS and SPI_MEM_ECC_ERR_ADDR record the first ECC error information.
          SPI_MEM_ECC_CONTINUE_RECORD_ERR_EN: u1,

          /// [25:31] Records the first ECC error bit number in the 16 bytes(From 0~127, corresponding to byte 0 bit 0 to byte 15 bit 7)
          SPI_MEM_ECC_ERR_BITS: u7,

        }), @ptrFromInt(0x60002168));

        /// MSPI ECC error address register
        pub const SPI_MEM_ECC_ERR_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:25] This bits show the first MSPI ECC error address. It is cleared by whenSPI_MEM_ECC_ERR_INT_CLR bit is set.
          SPI_MEM_ECC_ERR_ADDR: u26,

          /// [26:31] This bits show the error times of MSPI ECC read. It is cleared by whenSPI_MEM_ECC_ERR_INT_CLR bit is set.
          SPI_MEM_ECC_ERR_CNT: u6,

        }), @ptrFromInt(0x6000216c));

        /// SPI0 AXI request error address.
        pub const SPI_MEM_AXI_ERR_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:25] This bits show the first AXI write/read invalid error or AXI write flash error address. It is cleared by when SPI_MEM_AXI_WADDR_ERR_INT_CLR, SPI_MEM_AXI_WR_FLASH_ERR_IN_CLR or SPI_MEM_AXI_RADDR_ERR_IN_CLR bit is set.
          SPI_MEM_AXI_ERR_ADDR: u26,

          /// [26:26] The empty status of all AFIFO and SYNC_FIFO in MSPI module. 1: All AXI transfers and SPI0 transfers are done. 0: Others.
          SPI_MEM_ALL_FIFO_EMPTY: u1,

          /// [27:27] 1: RDATA_AFIFO is empty. 0: At least one AXI read transfer is pending.
          SPI_RDATA_AFIFO_REMPTY: u1,

          /// [28:28] 1: AXI_RADDR_CTL_AFIFO is empty. 0: At least one AXI read transfer is pending.
          SPI_RADDR_AFIFO_REMPTY: u1,

          /// [29:29] 1: WDATA_AFIFO is empty. 0: At least one AXI write transfer is pending.
          SPI_WDATA_AFIFO_REMPTY: u1,

          /// [30:30] 1: WBLEN_AFIFO is empty. 0: At least one AXI write transfer is pending.
          SPI_WBLEN_AFIFO_REMPTY: u1,

          /// [31:31] This bit is set when WADDR_AFIFO, WBLEN_AFIFO, WDATA_AFIFO, AXI_RADDR_CTL_AFIFO and RDATA_AFIFO are empty and spi0_mst_st is IDLE.
          SPI_ALL_AXI_TRANS_AFIFO_EMPTY: u1,

        }), @ptrFromInt(0x60002170));

        /// MSPI ECC control register
        pub const SPI_SMEM_ECC_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:16] 
          res0: u17,

          /// [17:17] Set this bit to calculate the error times of MSPI ECC read when accesses to external RAM.
          SPI_SMEM_ECC_ERR_INT_EN: u1,

          /// [18:19] Set the page size of the external RAM accessed by MSPI. 0: 256 bytes. 1: 512 bytes. 2: 1024 bytes. 3: 2048 bytes.
          SPI_SMEM_PAGE_SIZE: u2,

          /// [20:20] Set this bit to enable MSPI ECC address conversion, no matter MSPI accesses to the ECC region or non-ECC region of external RAM. If there is no ECC region in external RAM, this bit should be 0. Otherwise, this bit should be 1.
          SPI_SMEM_ECC_ADDR_EN: u1,

          /// [21:31] 
          res1: u11,

        }), @ptrFromInt(0x60002174));

        /// SPI0 flash timing calibration register
        pub const SPI_MEM_TIMING_CALI = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] The bit is used to enable timing adjust clock for all reading operations.
          SPI_MEM_TIMING_CLK_ENA: u1,

          /// [1:1] The bit is used to enable timing auto-calibration for all reading operations.
          SPI_MEM_TIMING_CALI: u1,

          /// [2:4] add extra dummy spi clock cycle length for spi clock calibration.
          SPI_MEM_EXTRA_DUMMY_CYCLELEN: u3,

          /// [5:5] Set this bit to enable DLL for timing calibration in DDR mode when accessed to flash.
          SPI_MEM_DLL_TIMING_CALI: u1,

          /// [6:6] Set this bit to update delay mode, delay num and extra dummy in MSPI.
          UPDATE: u1,

          /// [7:31] 
          res0: u25,

        }), @ptrFromInt(0x60002180));

        /// MSPI flash input timing delay mode control register
        pub const SPI_MEM_DIN_MODE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:2] the input signals are delayed by system clock cycles, 0: input without delayed, 1: input with the posedge of clk_apb,2 input with the negedge of clk_apb,3: input with the posedge of clk_160, 4 input with the negedge of clk_160, 5: input with the spi_clk high edge,6: input with the spi_clk low edge
          SPI_MEM_DIN0_MODE: u3,

          /// [3:5] the input signals are delayed by system clock cycles, 0: input without delayed, 1: input with the posedge of clk_apb,2 input with the negedge of clk_apb,3: input with the posedge of clk_160, 4 input with the negedge of clk_160, 5: input with the spi_clk high edge,6: input with the spi_clk low edge
          SPI_MEM_DIN1_MODE: u3,

          /// [6:8] the input signals are delayed by system clock cycles, 0: input without delayed, 1: input with the posedge of clk_apb,2 input with the negedge of clk_apb,3: input with the posedge of clk_160, 4 input with the negedge of clk_160, 5: input with the spi_clk high edge,6: input with the spi_clk low edge
          SPI_MEM_DIN2_MODE: u3,

          /// [9:11] the input signals are delayed by system clock cycles, 0: input without delayed, 1: input with the posedge of clk_apb,2 input with the negedge of clk_apb,3: input with the posedge of clk_160, 4 input with the negedge of clk_160, 5: input with the spi_clk high edge,6: input with the spi_clk low edge
          SPI_MEM_DIN3_MODE: u3,

          /// [12:14] the input signals are delayed by system clock cycles, 0: input without delayed, 1: input with the posedge of clk_apb,2 input with the negedge of clk_apb, 3: input with the spi_clk
          SPI_MEM_DIN4_MODE: u3,

          /// [15:17] the input signals are delayed by system clock cycles, 0: input without delayed, 1: input with the posedge of clk_apb,2 input with the negedge of clk_apb, 3: input with the spi_clk
          SPI_MEM_DIN5_MODE: u3,

          /// [18:20] the input signals are delayed by system clock cycles, 0: input without delayed, 1: input with the posedge of clk_apb,2 input with the negedge of clk_apb, 3: input with the spi_clk
          SPI_MEM_DIN6_MODE: u3,

          /// [21:23] the input signals are delayed by system clock cycles, 0: input without delayed, 1: input with the posedge of clk_apb,2 input with the negedge of clk_apb, 3: input with the spi_clk
          SPI_MEM_DIN7_MODE: u3,

          /// [24:26] the input signals are delayed by system clock cycles, 0: input without delayed, 1: input with the posedge of clk_apb,2 input with the negedge of clk_apb, 3: input with the spi_clk
          SPI_MEM_DINS_MODE: u3,

          /// [27:31] 
          res0: u5,

        }), @ptrFromInt(0x60002184));

        /// MSPI flash input timing delay number control register
        pub const SPI_MEM_DIN_NUM = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:1] the input signals are delayed by system clock cycles, 0: delayed by 1 cycle, 1: delayed by 2 cycles,...
          SPI_MEM_DIN0_NUM: u2,

          /// [2:3] the input signals are delayed by system clock cycles, 0: delayed by 1 cycle, 1: delayed by 2 cycles,...
          SPI_MEM_DIN1_NUM: u2,

          /// [4:5] the input signals are delayed by system clock cycles, 0: delayed by 1 cycle, 1: delayed by 2 cycles,...
          SPI_MEM_DIN2_NUM: u2,

          /// [6:7] the input signals are delayed by system clock cycles, 0: delayed by 1 cycle, 1: delayed by 2 cycles,...
          SPI_MEM_DIN3_NUM: u2,

          /// [8:9] the input signals are delayed by system clock cycles, 0: delayed by 1 cycle, 1: delayed by 2 cycles,...
          SPI_MEM_DIN4_NUM: u2,

          /// [10:11] the input signals are delayed by system clock cycles, 0: delayed by 1 cycle, 1: delayed by 2 cycles,...
          SPI_MEM_DIN5_NUM: u2,

          /// [12:13] the input signals are delayed by system clock cycles, 0: delayed by 1 cycle, 1: delayed by 2 cycles,...
          SPI_MEM_DIN6_NUM: u2,

          /// [14:15] the input signals are delayed by system clock cycles, 0: delayed by 1 cycle, 1: delayed by 2 cycles,...
          SPI_MEM_DIN7_NUM: u2,

          /// [16:17] the input signals are delayed by system clock cycles, 0: delayed by 1 cycle, 1: delayed by 2 cycles,...
          SPI_MEM_DINS_NUM: u2,

          /// [18:31] 
          res0: u14,

        }), @ptrFromInt(0x60002188));

        /// MSPI flash output timing adjustment control register
        pub const SPI_MEM_DOUT_MODE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] the output signals are delayed by system clock cycles, 0: output without delayed, 1: output with the posedge of clk_apb,2 output with the negedge of clk_apb, 3: output with the posedge of clk_160,4 output with the negedge of clk_160,5: output with the spi_clk high edge ,6: output with the spi_clk low edge
          SPI_MEM_DOUT0_MODE: u1,

          /// [1:1] the output signals are delayed by system clock cycles, 0: output without delayed, 1: output with the posedge of clk_apb,2 output with the negedge of clk_apb, 3: output with the posedge of clk_160,4 output with the negedge of clk_160,5: output with the spi_clk high edge ,6: output with the spi_clk low edge
          SPI_MEM_DOUT1_MODE: u1,

          /// [2:2] the output signals are delayed by system clock cycles, 0: output without delayed, 1: output with the posedge of clk_apb,2 output with the negedge of clk_apb, 3: output with the posedge of clk_160,4 output with the negedge of clk_160,5: output with the spi_clk high edge ,6: output with the spi_clk low edge
          SPI_MEM_DOUT2_MODE: u1,

          /// [3:3] the output signals are delayed by system clock cycles, 0: output without delayed, 1: output with the posedge of clk_apb,2 output with the negedge of clk_apb, 3: output with the posedge of clk_160,4 output with the negedge of clk_160,5: output with the spi_clk high edge ,6: output with the spi_clk low edge
          SPI_MEM_DOUT3_MODE: u1,

          /// [4:4] the output signals are delayed by system clock cycles, 0: output without delayed, 1: output with the posedge of clk_apb,2 output with the negedge of clk_apb, 3: output with the spi_clk
          SPI_MEM_DOUT4_MODE: u1,

          /// [5:5] the output signals are delayed by system clock cycles, 0: output without delayed, 1: output with the posedge of clk_apb,2 output with the negedge of clk_apb, 3: output with the spi_clk
          SPI_MEM_DOUT5_MODE: u1,

          /// [6:6] the output signals are delayed by system clock cycles, 0: output without delayed, 1: output with the posedge of clk_apb,2 output with the negedge of clk_apb, 3: output with the spi_clk
          SPI_MEM_DOUT6_MODE: u1,

          /// [7:7] the output signals are delayed by system clock cycles, 0: output without delayed, 1: output with the posedge of clk_apb,2 output with the negedge of clk_apb, 3: output with the spi_clk
          SPI_MEM_DOUT7_MODE: u1,

          /// [8:8] the output signals are delayed by system clock cycles, 0: output without delayed, 1: output with the posedge of clk_apb,2 output with the negedge of clk_apb, 3: output with the spi_clk
          SPI_MEM_DOUTS_MODE: u1,

          /// [9:31] 
          res0: u23,

        }), @ptrFromInt(0x6000218c));

        /// MSPI external RAM timing calibration register
        pub const SPI_SMEM_TIMING_CALI = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] For sram, the bit is used to enable timing adjust clock for all reading operations.
          SPI_SMEM_TIMING_CLK_ENA: u1,

          /// [1:1] For sram, the bit is used to enable timing auto-calibration for all reading operations.
          SPI_SMEM_TIMING_CALI: u1,

          /// [2:4] For sram, add extra dummy spi clock cycle length for spi clock calibration.
          SPI_SMEM_EXTRA_DUMMY_CYCLELEN: u3,

          /// [5:5] Set this bit to enable DLL for timing calibration in DDR mode when accessed to EXT_RAM.
          SPI_SMEM_DLL_TIMING_CALI: u1,

          /// [6:31] 
          res0: u26,

        }), @ptrFromInt(0x60002190));

        /// MSPI external RAM input timing delay mode control register
        pub const SPI_SMEM_DIN_MODE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:2] the input signals are delayed by system clock cycles, 0: input without delayed, 1: input with the posedge of clk_apb,2 input with the negedge of clk_apb,3: input with the posedge of clk_160, 4 input with the negedge of clk_160, 5: input with the spi_clk high edge,6: input with the spi_clk low edge
          SPI_SMEM_DIN0_MODE: u3,

          /// [3:5] the input signals are delayed by system clock cycles, 0: input without delayed, 1: input with the posedge of clk_apb,2 input with the negedge of clk_apb,3: input with the posedge of clk_160, 4 input with the negedge of clk_160, 5: input with the spi_clk high edge,6: input with the spi_clk low edge
          SPI_SMEM_DIN1_MODE: u3,

          /// [6:8] the input signals are delayed by system clock cycles, 0: input without delayed, 1: input with the posedge of clk_apb,2 input with the negedge of clk_apb,3: input with the posedge of clk_160, 4 input with the negedge of clk_160, 5: input with the spi_clk high edge,6: input with the spi_clk low edge
          SPI_SMEM_DIN2_MODE: u3,

          /// [9:11] the input signals are delayed by system clock cycles, 0: input without delayed, 1: input with the posedge of clk_apb,2 input with the negedge of clk_apb,3: input with the posedge of clk_160, 4 input with the negedge of clk_160, 5: input with the spi_clk high edge,6: input with the spi_clk low edge
          SPI_SMEM_DIN3_MODE: u3,

          /// [12:14] the input signals are delayed by system clock cycles, 0: input without delayed, 1: input with the posedge of clk_apb,2 input with the negedge of clk_apb,3: input with the posedge of clk_160, 4 input with the negedge of clk_160, 5: input with the spi_clk high edge,6: input with the spi_clk low edge
          SPI_SMEM_DIN4_MODE: u3,

          /// [15:17] the input signals are delayed by system clock cycles, 0: input without delayed, 1: input with the posedge of clk_apb,2 input with the negedge of clk_apb,3: input with the posedge of clk_160, 4 input with the negedge of clk_160, 5: input with the spi_clk high edge,6: input with the spi_clk low edge
          SPI_SMEM_DIN5_MODE: u3,

          /// [18:20] the input signals are delayed by system clock cycles, 0: input without delayed, 1: input with the posedge of clk_apb,2 input with the negedge of clk_apb,3: input with the posedge of clk_160, 4 input with the negedge of clk_160, 5: input with the spi_clk high edge,6: input with the spi_clk low edge
          SPI_SMEM_DIN6_MODE: u3,

          /// [21:23] the input signals are delayed by system clock cycles, 0: input without delayed, 1: input with the posedge of clk_apb,2 input with the negedge of clk_apb,3: input with the posedge of clk_160, 4 input with the negedge of clk_160, 5: input with the spi_clk high edge,6: input with the spi_clk low edge
          SPI_SMEM_DIN7_MODE: u3,

          /// [24:26] the input signals are delayed by system clock cycles, 0: input without delayed, 1: input with the posedge of clk_apb,2 input with the negedge of clk_apb,3: input with the posedge of clk_160, 4 input with the negedge of clk_160, 5: input with the spi_clk high edge,6: input with the spi_clk low edge
          SPI_SMEM_DINS_MODE: u3,

          /// [27:31] 
          res0: u5,

        }), @ptrFromInt(0x60002194));

        /// MSPI external RAM input timing delay number control register
        pub const SPI_SMEM_DIN_NUM = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:1] the input signals are delayed by system clock cycles, 0: delayed by 1 cycle, 1: delayed by 2 cycles,...
          SPI_SMEM_DIN0_NUM: u2,

          /// [2:3] the input signals are delayed by system clock cycles, 0: delayed by 1 cycle, 1: delayed by 2 cycles,...
          SPI_SMEM_DIN1_NUM: u2,

          /// [4:5] the input signals are delayed by system clock cycles, 0: delayed by 1 cycle, 1: delayed by 2 cycles,...
          SPI_SMEM_DIN2_NUM: u2,

          /// [6:7] the input signals are delayed by system clock cycles, 0: delayed by 1 cycle, 1: delayed by 2 cycles,...
          SPI_SMEM_DIN3_NUM: u2,

          /// [8:9] the input signals are delayed by system clock cycles, 0: delayed by 1 cycle, 1: delayed by 2 cycles,...
          SPI_SMEM_DIN4_NUM: u2,

          /// [10:11] the input signals are delayed by system clock cycles, 0: delayed by 1 cycle, 1: delayed by 2 cycles,...
          SPI_SMEM_DIN5_NUM: u2,

          /// [12:13] the input signals are delayed by system clock cycles, 0: delayed by 1 cycle, 1: delayed by 2 cycles,...
          SPI_SMEM_DIN6_NUM: u2,

          /// [14:15] the input signals are delayed by system clock cycles, 0: delayed by 1 cycle, 1: delayed by 2 cycles,...
          SPI_SMEM_DIN7_NUM: u2,

          /// [16:17] the input signals are delayed by system clock cycles, 0: input without delayed, 1: input with the posedge of clk_apb,2 input with the negedge of clk_apb,3: input with the posedge of clk_160, 4 input with the negedge of clk_160, 5: input with the spi_clk high edge,6: input with the spi_clk low edge
          SPI_SMEM_DINS_NUM: u2,

          /// [18:31] 
          res0: u14,

        }), @ptrFromInt(0x60002198));

        /// MSPI external RAM output timing adjustment control register
        pub const SPI_SMEM_DOUT_MODE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] the output signals are delayed by system clock cycles, 0: output without delayed, 1: output with the posedge of clk_apb,2 output with the negedge of clk_apb, 3: output with the posedge of clk_160,4 output with the negedge of clk_160,5: output with the spi_clk high edge ,6: output with the spi_clk low edge
          SPI_SMEM_DOUT0_MODE: u1,

          /// [1:1] the output signals are delayed by system clock cycles, 0: output without delayed, 1: output with the posedge of clk_apb,2 output with the negedge of clk_apb, 3: output with the posedge of clk_160,4 output with the negedge of clk_160,5: output with the spi_clk high edge ,6: output with the spi_clk low edge
          SPI_SMEM_DOUT1_MODE: u1,

          /// [2:2] the output signals are delayed by system clock cycles, 0: output without delayed, 1: output with the posedge of clk_apb,2 output with the negedge of clk_apb, 3: output with the posedge of clk_160,4 output with the negedge of clk_160,5: output with the spi_clk high edge ,6: output with the spi_clk low edge
          SPI_SMEM_DOUT2_MODE: u1,

          /// [3:3] the output signals are delayed by system clock cycles, 0: output without delayed, 1: output with the posedge of clk_apb,2 output with the negedge of clk_apb, 3: output with the posedge of clk_160,4 output with the negedge of clk_160,5: output with the spi_clk high edge ,6: output with the spi_clk low edge
          SPI_SMEM_DOUT3_MODE: u1,

          /// [4:4] the output signals are delayed by system clock cycles, 0: output without delayed, 1: output with the posedge of clk_apb,2 output with the negedge of clk_apb, 3: output with the posedge of clk_160,4 output with the negedge of clk_160,5: output with the spi_clk high edge ,6: output with the spi_clk low edge
          SPI_SMEM_DOUT4_MODE: u1,

          /// [5:5] the output signals are delayed by system clock cycles, 0: output without delayed, 1: output with the posedge of clk_apb,2 output with the negedge of clk_apb, 3: output with the posedge of clk_160,4 output with the negedge of clk_160,5: output with the spi_clk high edge ,6: output with the spi_clk low edge
          SPI_SMEM_DOUT5_MODE: u1,

          /// [6:6] the output signals are delayed by system clock cycles, 0: output without delayed, 1: output with the posedge of clk_apb,2 output with the negedge of clk_apb, 3: output with the posedge of clk_160,4 output with the negedge of clk_160,5: output with the spi_clk high edge ,6: output with the spi_clk low edge
          SPI_SMEM_DOUT6_MODE: u1,

          /// [7:7] the output signals are delayed by system clock cycles, 0: output without delayed, 1: output with the posedge of clk_apb,2 output with the negedge of clk_apb, 3: output with the posedge of clk_160,4 output with the negedge of clk_160,5: output with the spi_clk high edge ,6: output with the spi_clk low edge
          SPI_SMEM_DOUT7_MODE: u1,

          /// [8:8] the output signals are delayed by system clock cycles, 0: output without delayed, 1: output with the posedge of clk_apb,2 output with the negedge of clk_apb, 3: output with the posedge of clk_160,4 output with the negedge of clk_160,5: output with the spi_clk high edge ,6: output with the spi_clk low edge
          SPI_SMEM_DOUTS_MODE: u1,

          /// [9:31] 
          res0: u23,

        }), @ptrFromInt(0x6000219c));

        /// MSPI external RAM ECC and SPI CS timing control register
        pub const SPI_SMEM_AC = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] For SPI0 and SPI1, spi cs is enable when spi is in prepare phase. 1: enable 0: disable.
          SPI_SMEM_CS_SETUP: u1,

          /// [1:1] For SPI0 and SPI1, spi cs keep low when spi is in done phase. 1: enable 0: disable.
          SPI_SMEM_CS_HOLD: u1,

          /// [2:6] For spi0, (cycles-1) of prepare phase by spi clock this bits are combined with spi_mem_cs_setup bit.
          SPI_SMEM_CS_SETUP_TIME: u5,

          /// [7:11] For SPI0 and SPI1, spi cs signal is delayed to inactive by spi clock this bits are combined with spi_mem_cs_hold bit.
          SPI_SMEM_CS_HOLD_TIME: u5,

          /// [12:14] SPI_SMEM_CS_HOLD_TIME + SPI_SMEM_ECC_CS_HOLD_TIME is the SPI0 and SPI1 CS hold cycles in ECC mode when accessed external RAM.
          SPI_SMEM_ECC_CS_HOLD_TIME: u3,

          /// [15:15] 1: SPI0 skips page corner when accesses external RAM. 0: Not skip page corner when accesses external RAM.
          SPI_SMEM_ECC_SKIP_PAGE_CORNER: u1,

          /// [16:16] Set this bit to enable SPI0 and SPI1 ECC 16 bytes data with 2 ECC bytes mode when accesses external RAM.
          SPI_SMEM_ECC_16TO18_BYTE_EN: u1,

          /// [17:24] 
          res0: u8,

          /// [25:30] These bits are used to set the minimum CS high time tSHSL between SPI burst transfer when accesses to external RAM. tSHSL is (SPI_SMEM_CS_HOLD_DELAY[5:0] + 1) MSPI core clock cycles.
          SPI_SMEM_CS_HOLD_DELAY: u6,

          /// [31:31] Set this bit to enable SPI0 split one AXI accesses EXT_RAM transfer into two SPI transfers when one transfer will cross flash/EXT_RAM page corner, valid no matter whether there is an ECC region or not.
          SPI_SMEM_SPLIT_TRANS_EN: u1,

        }), @ptrFromInt(0x600021a0));

        /// SPI0 clock gate register
        pub const SPI_MEM_CLOCK_GATE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Register clock gate enable signal. 1: Enable. 0: Disable.
          SPI_CLK_EN: u1,

          /// [1:31] 
          res0: u31,

        }), @ptrFromInt(0x60002200));

        /// The base address of the memory that stores plaintext in Manual Encryption
        pub const SPI_MEM_XTS_PLAIN_BASE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] This field is only used to generate include file in c case. This field is useless. Please do not use this field.
          SPI_XTS_PLAIN: u32,

        }), @ptrFromInt(0x60002300));

        /// Manual Encryption Line-Size register
        pub const SPI_MEM_XTS_LINESIZE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:1] This bits stores the line-size parameter which will be used in manual encryption calculation. It decides how many bytes will be encrypted one time. 0: 16-bytes, 1: 32-bytes, 2: 64-bytes, 3:reserved.
          SPI_XTS_LINESIZE: u2,

          /// [2:31] 
          res0: u30,

        }), @ptrFromInt(0x60002340));

        /// Manual Encryption destination register
        pub const SPI_MEM_XTS_DESTINATION = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] This bit stores the destination parameter which will be used in manual encryption calculation. 0: flash(default), 1: psram(reserved). Only default value can be used.
          SPI_XTS_DESTINATION: u1,

          /// [1:31] 
          res0: u31,

        }), @ptrFromInt(0x60002344));

        /// Manual Encryption physical address register
        pub const SPI_MEM_XTS_PHYSICAL_ADDRESS = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:25] This bits stores the physical-address parameter which will be used in manual encryption calculation. This value should aligned with byte number decided by line-size parameter.
          SPI_XTS_PHYSICAL_ADDRESS: u26,

          /// [26:31] 
          res0: u6,

        }), @ptrFromInt(0x60002348));

        /// Manual Encryption physical address register
        pub const SPI_MEM_XTS_TRIGGER = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Set this bit to trigger the process of manual encryption calculation. This action should only be asserted when manual encryption status is 0. After this action, manual encryption status becomes 1. After calculation is done, manual encryption status becomes 2.
          SPI_XTS_TRIGGER: u1,

          /// [1:31] 
          res0: u31,

        }), @ptrFromInt(0x6000234c));

        /// Manual Encryption physical address register
        pub const SPI_MEM_XTS_RELEASE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Set this bit to release encrypted result to mspi. This action should only be asserted when manual encryption status is 2. After this action, manual encryption status will become 3.
          SPI_XTS_RELEASE: u1,

          /// [1:31] 
          res0: u31,

        }), @ptrFromInt(0x60002350));

        /// Manual Encryption physical address register
        pub const SPI_MEM_XTS_DESTROY = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Set this bit to destroy encrypted result. This action should be asserted only when manual encryption status is 3. After this action, manual encryption status will become 0.
          SPI_XTS_DESTROY: u1,

          /// [1:31] 
          res0: u31,

        }), @ptrFromInt(0x60002354));

        /// Manual Encryption physical address register
        pub const SPI_MEM_XTS_STATE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:1] This bits stores the status of manual encryption. 0: idle, 1: busy of encryption calculation, 2: encryption calculation is done but the encrypted result is invisible to mspi, 3: the encrypted result is visible to mspi.
          SPI_XTS_STATE: u2,

          /// [2:31] 
          res0: u30,

        }), @ptrFromInt(0x60002358));

        /// Manual Encryption version register
        pub const SPI_MEM_XTS_DATE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:29] This bits stores the last modified-time of manual encryption feature.
          SPI_XTS_DATE: u30,

          /// [30:31] 
          res0: u2,

        }), @ptrFromInt(0x6000235c));

        /// MSPI-MMU item content register
        pub const SPI_MEM_MMU_ITEM_CONTENT = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] MSPI-MMU item content
          SPI_MMU_ITEM_CONTENT: u32,

        }), @ptrFromInt(0x6000237c));

        /// MSPI-MMU item index register
        pub const SPI_MEM_MMU_ITEM_INDEX = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] MSPI-MMU item index
          SPI_MMU_ITEM_INDEX: u32,

        }), @ptrFromInt(0x60002380));

        /// MSPI MMU power control register
        pub const SPI_MEM_MMU_POWER_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Set this bit to enable mmu-memory clock force on
          SPI_MMU_MEM_FORCE_ON: u1,

          /// [1:1] Set this bit to force mmu-memory powerdown
          SPI_MMU_MEM_FORCE_PD: u1,

          /// [2:2] Set this bit to force mmu-memory powerup, in this case, the power should also be controlled by rtc.
          SPI_MMU_MEM_FORCE_PU: u1,

          /// [3:4] 0: Max page size , 1: Max page size/2 , 2: Max page size/4, 3: Max page size/8
          SPI_MMU_PAGE_SIZE: u2,

          /// [5:15] 
          res0: u11,

          /// [16:29] MMU PSRAM aux control register
          SPI_MEM_AUX_CTRL: u14,

          /// [30:30] ECO register enable bit
          SPI_MEM_RDN_ENA: u1,

          /// [31:31] MSPI module clock domain and AXI clock domain ECO register result register
          SPI_MEM_RDN_RESULT: u1,

        }), @ptrFromInt(0x60002384));

        /// SPI memory cryption DPA register
        pub const SPI_MEM_DPA_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:2] Set the security level of spi mem cryption. 0: Shut off cryption DPA funtion. 1-7: The bigger the number is, the more secure the cryption is. (Note that the performance of cryption will decrease together with this number increasing)
          SPI_CRYPT_SECURITY_LEVEL: u3,

          /// [3:3] Only available when SPI_CRYPT_SECURITY_LEVEL is not 0. 1: Enable DPA in the calculation that using key 1 or key 2. 0: Enable DPA only in the calculation that using key 1.
          SPI_CRYPT_CALC_D_DPA_EN: u1,

          /// [4:4] 1: MSPI XTS DPA clock gate is controlled by SPI_CRYPT_CALC_D_DPA_EN and SPI_CRYPT_SECURITY_LEVEL. 0: Controlled by efuse bits.
          SPI_CRYPT_DPA_SELECT_REGISTER: u1,

          /// [5:31] 
          res0: u27,

        }), @ptrFromInt(0x60002388));

        /// MSPI ECO high register
        pub const SPI_MEM_REGISTERRND_ECO_HIGH = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] ECO high register
          SPI_MEM_REGISTERRND_ECO_HIGH: u32,

        }), @ptrFromInt(0x600023f0));

        /// MSPI ECO low register
        pub const SPI_MEM_REGISTERRND_ECO_LOW = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] ECO low register
          SPI_MEM_REGISTERRND_ECO_LOW: u32,

        }), @ptrFromInt(0x600023f4));

        /// SPI0 version control register
        pub const SPI_MEM_DATE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:27] SPI0 register version.
          SPI_MEM_DATE: u28,

          /// [28:31] 
          res0: u4,

        }), @ptrFromInt(0x600023fc));

      };

      /// SPI (Serial Peripheral Interface) Controller 1
      pub const SPI1 = struct {

        /// SPI1 memory command register
        pub const SPI_MEM_CMD = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:3] The current status of SPI1 master FSM.
          SPI_MEM_MST_ST: u4,

          /// [4:7] The current status of SPI1 slave FSM: mspi_st. 0: idle state, 1: preparation state, 2: send command state, 3: send address state, 4: wait state, 5: read data state, 6:write data state, 7: done state, 8: read data end state.
          SPI_MEM_SLV_ST: u4,

          /// [8:16] 
          res0: u9,

          /// [17:17] In user mode, it is set to indicate that program/erase operation will be triggered. The bit is combined with spi_mem_usr bit. The bit will be cleared once the operation done.1: enable 0: disable.
          SPI_MEM_FLASH_PE: u1,

          /// [18:18] User define command enable.An operation will be triggered when the bit is set. The bit will be cleared once the operation done.1: enable 0: disable.
          SPI_MEM_USR: u1,

          /// [19:19] Drive Flash into high performance mode.The bit will be cleared once the operation done.1: enable 0: disable.
          SPI_MEM_FLASH_HPM: u1,

          /// [20:20] This bit combined with reg_resandres bit releases Flash from the power-down state or high performance mode and obtains the devices ID. The bit will be cleared once the operation done.1: enable 0: disable.
          SPI_MEM_FLASH_RES: u1,

          /// [21:21] Drive Flash into power down.An operation will be triggered when the bit is set. The bit will be cleared once the operation done.1: enable 0: disable.
          SPI_MEM_FLASH_DP: u1,

          /// [22:22] Chip erase enable. Chip erase operation will be triggered when the bit is set. The bit will be cleared once the operation done.1: enable 0: disable.
          SPI_MEM_FLASH_CE: u1,

          /// [23:23] Block erase enable(32KB) .Block erase operation will be triggered when the bit is set. The bit will be cleared once the operation done.1: enable 0: disable.
          SPI_MEM_FLASH_BE: u1,

          /// [24:24] Sector erase enable(4KB). Sector erase operation will be triggered when the bit is set. The bit will be cleared once the operation done.1: enable 0: disable.
          SPI_MEM_FLASH_SE: u1,

          /// [25:25] Page program enable(1 byte ~256 bytes data to be programmed). Page program operationwill be triggered when the bit is set. The bit will be cleared once the operation done .1: enable 0: disable.
          SPI_MEM_FLASH_PP: u1,

          /// [26:26] Write status register enable. Write status operationwill be triggered when the bit is set. The bit will be cleared once the operation done.1: enable 0: disable.
          SPI_MEM_FLASH_WRSR: u1,

          /// [27:27] Read status register-1.Read status operation will be triggered when the bit is set. The bit will be cleared once the operation done.1: enable 0: disable.
          SPI_MEM_FLASH_RDSR: u1,

          /// [28:28] Read JEDEC ID . Read ID command will be sent when the bit is set. The bit will be cleared once the operation done. 1: enable 0: disable.
          SPI_MEM_FLASH_RDID: u1,

          /// [29:29] Write flash disable. Write disable command will be sent when the bit is set. The bit will be cleared once the operation done. 1: enable 0: disable.
          SPI_MEM_FLASH_WRDI: u1,

          /// [30:30] Write flash enable.Write enable command will be sent when the bit is set. The bit will be cleared once the operation done. 1: enable 0: disable.
          SPI_MEM_FLASH_WREN: u1,

          /// [31:31] Read flash enable. Read flash operation will be triggered when the bit is set. The bit will be cleared once the operation done. 1: enable 0: disable.
          SPI_MEM_FLASH_READ: u1,

        }), @ptrFromInt(0x60003000));

        /// SPI1 address register
        pub const SPI_MEM_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] In user mode, it is the memory address. other then the bit0-bit23 is the memory address, the bit24-bit31 are the byte length of a transfer.
          SPI_MEM_USR_ADDR_VALUE: u32,

        }), @ptrFromInt(0x60003004));

        /// SPI1 control register.
        pub const SPI_MEM_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:1] 
          res0: u2,

          /// [2:2] In the dummy phase of a MSPI read data transfer when accesses to flash, the signal level of SPI bus is output by the MSPI controller.
          SPI_MEM_FDUMMY_RIN: u1,

          /// [3:3] In the dummy phase of a MSPI write data transfer when accesses to flash, the signal level of SPI bus is output by the MSPI controller.
          SPI_MEM_FDUMMY_WOUT: u1,

          /// [4:4] Apply 8 signals during write-data phase 1:enable 0: disable
          SPI_MEM_FDOUT_OCT: u1,

          /// [5:5] Apply 8 signals during read-data phase 1:enable 0: disable
          SPI_MEM_FDIN_OCT: u1,

          /// [6:6] Apply 8 signals during address phase 1:enable 0: disable
          SPI_MEM_FADDR_OCT: u1,

          /// [7:7] 
          res1: u1,

          /// [8:8] Apply 4 signals during command phase 1:enable 0: disable
          SPI_MEM_FCMD_QUAD: u1,

          /// [9:9] Apply 8 signals during command phase 1:enable 0: disable
          SPI_MEM_FCMD_OCT: u1,

          /// [10:10] For SPI1,initialize crc32 module before writing encrypted data to flash. Active low.
          SPI_MEM_FCS_CRC_EN: u1,

          /// [11:11] For SPI1,enable crc32 when writing encrypted data to flash. 1: enable 0:disable
          SPI_MEM_TX_CRC_EN: u1,

          /// [12:12] 
          res2: u1,

          /// [13:13] This bit enable the bits: spi_mem_fread_qio, spi_mem_fread_dio, spi_mem_fread_qout and spi_mem_fread_dout. 1: enable 0: disable.
          SPI_MEM_FASTRD_MODE: u1,

          /// [14:14] In the read operations, read-data phase apply 2 signals. 1: enable 0: disable.
          SPI_MEM_FREAD_DUAL: u1,

          /// [15:15] The Device ID is read out to SPI_MEM_RD_STATUS register,this bit combine with spi_mem_flash_res bit. 1: enable 0: disable.
          SPI_MEM_RESANDRES: u1,

          /// [16:17] 
          res3: u2,

          /// [18:18] The bit is used to set MISO line polarity, 1: high 0, low
          SPI_MEM_Q_POL: u1,

          /// [19:19] The bit is used to set MOSI line polarity, 1: high 0, low
          SPI_MEM_D_POL: u1,

          /// [20:20] In the read operations read-data phase apply 4 signals. 1: enable 0: disable.
          SPI_MEM_FREAD_QUAD: u1,

          /// [21:21] Write protect signal output when SPI is idle.1: output high, 0: output low.
          SPI_MEM_WP: u1,

          /// [22:22] two bytes data will be written to status register when it is set. 1: enable 0: disable.
          SPI_MEM_WRSR_2B: u1,

          /// [23:23] In the read operations address phase and read-data phase apply 2 signals. 1: enable 0: disable.
          SPI_MEM_FREAD_DIO: u1,

          /// [24:24] In the read operations address phase and read-data phase apply 4 signals. 1: enable 0: disable.
          SPI_MEM_FREAD_QIO: u1,

          /// [25:31] 
          res4: u7,

        }), @ptrFromInt(0x60003008));

        /// SPI1 control1 register.
        pub const SPI_MEM_CTRL1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:1] SPI clock mode bits. 0: SPI clock is off when CS inactive 1: SPI clock is delayed one cycle after CS inactive 2: SPI clock is delayed two cycles after CS inactive 3: SPI clock is alwasy on.
          SPI_MEM_CLK_MODE: u2,

          /// [2:11] After RES/DP/HPM command is sent, SPI1 waits (SPI_MEM_CS_HOLD_DELAY_RES[9:0] * 512) SPI_CLK cycles.
          SPI_MEM_CS_HOLD_DLY_RES: u10,

          /// [12:31] 
          res0: u20,

        }), @ptrFromInt(0x6000300c));

        /// SPI1 control2 register.
        pub const SPI_MEM_CTRL2 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:30] 
          res0: u31,

          /// [31:31] The FSM will be reset.
          SPI_MEM_SYNC_RESET: u1,

        }), @ptrFromInt(0x60003010));

        /// SPI1 clock division control register.
        pub const SPI_MEM_CLOCK = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] In the master mode it must be equal to spi_mem_clkcnt_N.
          SPI_MEM_CLKCNT_L: u8,

          /// [8:15] In the master mode it must be floor((spi_mem_clkcnt_N+1)/2-1).
          SPI_MEM_CLKCNT_H: u8,

          /// [16:23] In the master mode it is the divider of spi_mem_clk. So spi_mem_clk frequency is system/(spi_mem_clkcnt_N+1)
          SPI_MEM_CLKCNT_N: u8,

          /// [24:30] 
          res0: u7,

          /// [31:31] reserved
          SPI_MEM_CLK_EQU_SYSCLK: u1,

        }), @ptrFromInt(0x60003014));

        /// SPI1 user register.
        pub const SPI_MEM_USER = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:8] 
          res0: u9,

          /// [9:9] the bit combined with spi_mem_mosi_delay_mode bits to set mosi signal delay mode.
          SPI_MEM_CK_OUT_EDGE: u1,

          /// [10:11] 
          res1: u2,

          /// [12:12] In the write operations read-data phase apply 2 signals
          SPI_MEM_FWRITE_DUAL: u1,

          /// [13:13] In the write operations read-data phase apply 4 signals
          SPI_MEM_FWRITE_QUAD: u1,

          /// [14:14] In the write operations address phase and read-data phase apply 2 signals.
          SPI_MEM_FWRITE_DIO: u1,

          /// [15:15] In the write operations address phase and read-data phase apply 4 signals.
          SPI_MEM_FWRITE_QIO: u1,

          /// [16:23] 
          res2: u8,

          /// [24:24] read-data phase only access to high-part of the buffer spi_mem_w8~spi_mem_w15. 1: enable 0: disable.
          SPI_MEM_USR_MISO_HIGHPART: u1,

          /// [25:25] write-data phase only access to high-part of the buffer spi_mem_w8~spi_mem_w15. 1: enable 0: disable.
          SPI_MEM_USR_MOSI_HIGHPART: u1,

          /// [26:26] SPI clock is disable in dummy phase when the bit is enable.
          SPI_MEM_USR_DUMMY_IDLE: u1,

          /// [27:27] This bit enable the write-data phase of an operation.
          SPI_MEM_USR_MOSI: u1,

          /// [28:28] This bit enable the read-data phase of an operation.
          SPI_MEM_USR_MISO: u1,

          /// [29:29] This bit enable the dummy phase of an operation.
          SPI_MEM_USR_DUMMY: u1,

          /// [30:30] This bit enable the address phase of an operation.
          SPI_MEM_USR_ADDR: u1,

          /// [31:31] This bit enable the command phase of an operation.
          SPI_MEM_USR_COMMAND: u1,

        }), @ptrFromInt(0x60003018));

        /// SPI1 user1 register.
        pub const SPI_MEM_USER1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] The length in spi_mem_clk cycles of dummy phase. The register value shall be (cycle_num-1).
          SPI_MEM_USR_DUMMY_CYCLELEN: u6,

          /// [6:25] 
          res0: u20,

          /// [26:31] The length in bits of address phase. The register value shall be (bit_num-1).
          SPI_MEM_USR_ADDR_BITLEN: u6,

        }), @ptrFromInt(0x6000301c));

        /// SPI1 user2 register.
        pub const SPI_MEM_USER2 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:15] The value ofcommand.
          SPI_MEM_USR_COMMAND_VALUE: u16,

          /// [16:27] 
          res0: u12,

          /// [28:31] The length in bits of command phase. The register value shall be (bit_num-1)
          SPI_MEM_USR_COMMAND_BITLEN: u4,

        }), @ptrFromInt(0x60003020));

        /// SPI1 send data bit length control register.
        pub const SPI_MEM_MOSI_DLEN = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:9] The length in bits of write-data. The register value shall be (bit_num-1).
          SPI_MEM_USR_MOSI_DBITLEN: u10,

          /// [10:31] 
          res0: u22,

        }), @ptrFromInt(0x60003024));

        /// SPI1 receive data bit length control register.
        pub const SPI_MEM_MISO_DLEN = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:9] The length in bits ofread-data. The register value shall be (bit_num-1).
          SPI_MEM_USR_MISO_DBITLEN: u10,

          /// [10:31] 
          res0: u22,

        }), @ptrFromInt(0x60003028));

        /// SPI1 status register.
        pub const SPI_MEM_RD_STATUS = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:15] The value is stored when set spi_mem_flash_rdsr bit and spi_mem_flash_res bit.
          SPI_MEM_STATUS: u16,

          /// [16:23] Mode bits in the flash fast read modeit is combined with spi_mem_fastrd_mode bit.
          SPI_MEM_WB_MODE: u8,

          /// [24:31] 
          res0: u8,

        }), @ptrFromInt(0x6000302c));

        /// SPI1 misc register
        pub const SPI_MEM_MISC = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] SPI_CS0 pin enable, 1: disable SPI_CS0, 0: SPI_CS0 pin is active to select SPI device, such as flash, external RAM and so on.
          SPI_MEM_CS0_DIS: u1,

          /// [1:1] SPI_CS1 pin enable, 1: disable SPI_CS1, 0: SPI_CS1 pin is active to select SPI device, such as flash, external RAM and so on.
          SPI_MEM_CS1_DIS: u1,

          /// [2:8] 
          res0: u7,

          /// [9:9] 1: spi clk line is high when idle 0: spi clk line is low when idle
          SPI_MEM_CK_IDLE_EDGE: u1,

          /// [10:10] spi cs line keep low when the bit is set.
          SPI_MEM_CS_KEEP_ACTIVE: u1,

          /// [11:31] 
          res1: u21,

        }), @ptrFromInt(0x60003034));

        /// SPI1 TX CRC data register.
        pub const SPI_MEM_TX_CRC = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] For SPI1, the value of crc32.
          DATA: u32,

        }), @ptrFromInt(0x60003038));

        /// SPI1 bit mode control register.
        pub const SPI_MEM_CACHE_FCTRL = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] 
          res0: u1,

          /// [1:1] For SPI1,cacheread flash with 4 bytes address, 1: enable, 0:disable.
          SPI_MEM_CACHE_USR_ADDR_4BYTE: u1,

          /// [2:2] 
          res1: u1,

          /// [3:3] For SPI1, din phase apply 2 signals. 1: enable 0: disable. The bit is the same with spi_mem_fread_dio.
          SPI_MEM_FDIN_DUAL: u1,

          /// [4:4] For SPI1, dout phase apply 2 signals. 1: enable 0: disable. The bit is the same with spi_mem_fread_dio.
          SPI_MEM_FDOUT_DUAL: u1,

          /// [5:5] For SPI1, address phase apply 2 signals. 1: enable 0: disable.The bit is the same with spi_mem_fread_dio.
          SPI_MEM_FADDR_DUAL: u1,

          /// [6:6] For SPI1, din phase apply 4 signals. 1: enable 0: disable.The bit is the same with spi_mem_fread_qio.
          SPI_MEM_FDIN_QUAD: u1,

          /// [7:7] For SPI1, dout phase apply 4 signals. 1: enable 0: disable.The bit is the same with spi_mem_fread_qio.
          SPI_MEM_FDOUT_QUAD: u1,

          /// [8:8] For SPI1, address phase apply 4 signals. 1: enable 0: disable.The bit is the same with spi_mem_fread_qio.
          SPI_MEM_FADDR_QUAD: u1,

          /// [9:31] 
          res2: u23,

        }), @ptrFromInt(0x6000303c));

        /// SPI1 memory data buffer0
        pub const SPI_MEM_W0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] data buffer
          SPI_MEM_BUF0: u32,

        }), @ptrFromInt(0x60003058));

        /// SPI1 memory data buffer1
        pub const SPI_MEM_W1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] data buffer
          SPI_MEM_BUF1: u32,

        }), @ptrFromInt(0x6000305c));

        /// SPI1 memory data buffer2
        pub const SPI_MEM_W2 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] data buffer
          SPI_MEM_BUF2: u32,

        }), @ptrFromInt(0x60003060));

        /// SPI1 memory data buffer3
        pub const SPI_MEM_W3 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] data buffer
          SPI_MEM_BUF3: u32,

        }), @ptrFromInt(0x60003064));

        /// SPI1 memory data buffer4
        pub const SPI_MEM_W4 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] data buffer
          SPI_MEM_BUF4: u32,

        }), @ptrFromInt(0x60003068));

        /// SPI1 memory data buffer5
        pub const SPI_MEM_W5 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] data buffer
          SPI_MEM_BUF5: u32,

        }), @ptrFromInt(0x6000306c));

        /// SPI1 memory data buffer6
        pub const SPI_MEM_W6 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] data buffer
          SPI_MEM_BUF6: u32,

        }), @ptrFromInt(0x60003070));

        /// SPI1 memory data buffer7
        pub const SPI_MEM_W7 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] data buffer
          SPI_MEM_BUF7: u32,

        }), @ptrFromInt(0x60003074));

        /// SPI1 memory data buffer8
        pub const SPI_MEM_W8 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] data buffer
          SPI_MEM_BUF8: u32,

        }), @ptrFromInt(0x60003078));

        /// SPI1 memory data buffer9
        pub const SPI_MEM_W9 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] data buffer
          SPI_MEM_BUF9: u32,

        }), @ptrFromInt(0x6000307c));

        /// SPI1 memory data buffer10
        pub const SPI_MEM_W10 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] data buffer
          SPI_MEM_BUF10: u32,

        }), @ptrFromInt(0x60003080));

        /// SPI1 memory data buffer11
        pub const SPI_MEM_W11 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] data buffer
          SPI_MEM_BUF11: u32,

        }), @ptrFromInt(0x60003084));

        /// SPI1 memory data buffer12
        pub const SPI_MEM_W12 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] data buffer
          SPI_MEM_BUF12: u32,

        }), @ptrFromInt(0x60003088));

        /// SPI1 memory data buffer13
        pub const SPI_MEM_W13 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] data buffer
          SPI_MEM_BUF13: u32,

        }), @ptrFromInt(0x6000308c));

        /// SPI1 memory data buffer14
        pub const SPI_MEM_W14 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] data buffer
          SPI_MEM_BUF14: u32,

        }), @ptrFromInt(0x60003090));

        /// SPI1 memory data buffer15
        pub const SPI_MEM_W15 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] data buffer
          SPI_MEM_BUF15: u32,

        }), @ptrFromInt(0x60003094));

        /// SPI1 wait idle control register
        pub const SPI_MEM_FLASH_WAITI_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] 1: The hardware will wait idle after SE/PP/WRSR automatically, and hardware auto Suspend/Resume can be enabled. 0: The functions of hardware wait idle and auto Suspend/Resume are not supported.
          SPI_MEM_WAITI_EN: u1,

          /// [1:1] The dummy phase enable when wait flash idle (RDSR)
          SPI_MEM_WAITI_DUMMY: u1,

          /// [2:2] 1: Outputaddress 0 in RDSR or read SUS command transfer. 0: Do not send out address in RDSR or read SUS command transfer.
          SPI_MEM_WAITI_ADDR_EN: u1,

          /// [3:4] When SPI_MEM_WAITI_ADDR_EN is set, thecycle length of sent out address is (SPI_MEM_WAITI_ADDR_CYCLELEN[1:0] + 1) SPIbus clock cycles. It is not active when SPI_MEM_WAITI_ADDR_EN is cleared.
          SPI_MEM_WAITI_ADDR_CYCLELEN: u2,

          /// [5:8] 
          res0: u4,

          /// [9:9] 1:The wait idle command bit length is 16. 0: The wait idle command bit length is 8.
          SPI_MEM_WAITI_CMD_2B: u1,

          /// [10:15] The dummy cycle length when wait flash idle(RDSR).
          SPI_MEM_WAITI_DUMMY_CYCLELEN: u6,

          /// [16:31] The command value to wait flash idle(RDSR).
          SPI_MEM_WAITI_CMD: u16,

        }), @ptrFromInt(0x60003098));

        /// SPI1 flash suspend control register
        pub const SPI_MEM_FLASH_SUS_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] program erase resume bit, program erase suspend operation will be triggered when the bit is set. The bit will be cleared once the operation done.1: enable 0: disable.
          SPI_MEM_FLASH_PER: u1,

          /// [1:1] program erase suspend bit, program erase suspend operation will be triggered when the bit is set. The bit will be cleared once the operation done.1: enable 0: disable.
          SPI_MEM_FLASH_PES: u1,

          /// [2:2] 1: SPI1 waits (SPI_MEM_CS_HOLD_DELAY_RES[9:0] * 4 or *128) SPI_CLK cycles after program erase resume command is sent. 0: SPI1 does not wait after program erase resume command is sent.
          SPI_MEM_FLASH_PER_WAIT_EN: u1,

          /// [3:3] 1: SPI1 waits (SPI_MEM_CS_HOLD_DELAY_RES[9:0] * 4 or *128) SPI_CLK cycles after program erase suspend command is sent. 0: SPI1 does not wait after program erase suspend command is sent.
          SPI_MEM_FLASH_PES_WAIT_EN: u1,

          /// [4:4] Set this bit to enable PES end triggers PER transfer option. If this bit is 0, application should send PER after PES is done.
          SPI_MEM_PES_PER_EN: u1,

          /// [5:5] Set this bit to enable Auto-suspending function.
          SPI_MEM_FLASH_PES_EN: u1,

          /// [6:21] The mask value when check SUS/SUS1/SUS2 status bit. If the read status value is status_in[15:0](only status_in[7:0] is valid when only one byte of data is read out, status_in[15:0] is valid when two bytes of data are read out), SUS/SUS1/SUS2 = status_in[15:0]^ SPI_MEM_PESR_END_MSK[15:0].
          SPI_MEM_PESR_END_MSK: u16,

          /// [22:22] 1: Read two bytes when check flash SUS/SUS1/SUS2 status bit. 0:Read one byte when check flash SUS/SUS1/SUS2 status bit
          SPI_FMEM_RD_SUS_2B: u1,

          /// [23:23] 1: Both WIP and SUS/SUS1/SUS2 bits should be checked to insure the resume status of flash. 0: Only need to check WIP is 0.
          SPI_MEM_PER_END_EN: u1,

          /// [24:24] 1: Both WIP and SUS/SUS1/SUS2 bits should be checked to insure the suspend status of flash. 0: Only need to check WIP is 0.
          SPI_MEM_PES_END_EN: u1,

          /// [25:31] When SPI1 checks SUS/SUS1/SUS2 bits fail for SPI_MEM_SUS_TIMEOUT_CNT[6:0] times, it will be treated as check pass.
          SPI_MEM_SUS_TIMEOUT_CNT: u7,

        }), @ptrFromInt(0x6000309c));

        /// SPI1 flash suspend command register
        pub const SPI_MEM_FLASH_SUS_CMD = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:15] Program/Erase suspend command.
          SPI_MEM_FLASH_PES_COMMAND: u16,

          /// [16:31] Flash SUS/SUS1/SUS2 status bit read command. The command should be sent when SUS/SUS1/SUS2 bit should be checked to insure the suspend or resume status of flash.
          SPI_MEM_WAIT_PESR_COMMAND: u16,

        }), @ptrFromInt(0x600030a0));

        /// SPI1 flash suspend status register
        pub const SPI_MEM_SUS_STATUS = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] The status of flash suspend, only used in SPI1.
          SPI_MEM_FLASH_SUS: u1,

          /// [1:1] 1: SPI1 sends out SPI_MEM_WAIT_PESR_COMMAND[15:0] to check SUS/SUS1/SUS2 bit. 0: SPI1 sends out SPI_MEM_WAIT_PESR_COMMAND[7:0] to check SUS/SUS1/SUS2 bit.
          SPI_MEM_WAIT_PESR_CMD_2B: u1,

          /// [2:2] 1: SPI1 waits (SPI_MEM_CS_HOLD_DELAY_RES[9:0] * 128) SPI_CLK cycles after HPM command is sent. 0: SPI1 waits (SPI_MEM_CS_HOLD_DELAY_RES[9:0] * 4) SPI_CLK cycles after HPM command is sent.
          SPI_MEM_FLASH_HPM_DLY_128: u1,

          /// [3:3] 1: SPI1 waits (SPI_MEM_CS_HOLD_DELAY_RES[9:0] * 128) SPI_CLK cycles after RES command is sent. 0: SPI1 waits (SPI_MEM_CS_HOLD_DELAY_RES[9:0] * 4) SPI_CLK cycles after RES command is sent.
          SPI_MEM_FLASH_RES_DLY_128: u1,

          /// [4:4] 1: SPI1 waits (SPI_MEM_CS_HOLD_DELAY_RES[9:0] * 128) SPI_CLK cycles after DP command is sent. 0: SPI1 waits (SPI_MEM_CS_HOLD_DELAY_RES[9:0] * 4) SPI_CLK cycles after DP command is sent.
          SPI_MEM_FLASH_DP_DLY_128: u1,

          /// [5:5] Valid when SPI_MEM_FLASH_PER_WAIT_EN is 1. 1: SPI1 waits (SPI_MEM_CS_HOLD_DELAY_RES[9:0] * 128) SPI_CLK cycles after PER command is sent. 0: SPI1 waits (SPI_MEM_CS_HOLD_DELAY_RES[9:0] * 4) SPI_CLK cycles after PER command is sent.
          SPI_MEM_FLASH_PER_DLY_128: u1,

          /// [6:6] Valid when SPI_MEM_FLASH_PES_WAIT_EN is 1. 1: SPI1 waits (SPI_MEM_CS_HOLD_DELAY_RES[9:0] * 128) SPI_CLK cycles after PES command is sent. 0: SPI1 waits (SPI_MEM_CS_HOLD_DELAY_RES[9:0] * 4) SPI_CLK cycles after PES command is sent.
          SPI_MEM_FLASH_PES_DLY_128: u1,

          /// [7:7] 1: Enable SPI0 lock SPI0/1 arbiter option. 0: Disable it.
          SPI_MEM_SPI0_LOCK_EN: u1,

          /// [8:14] 
          res0: u7,

          /// [15:15] 1: The bit length of Program/Erase Suspend/Resume command is 16. 0: The bit length of Program/Erase Suspend/Resume command is 8.
          SPI_MEM_FLASH_PESR_CMD_2B: u1,

          /// [16:31] Program/Erase resume command.
          SPI_MEM_FLASH_PER_COMMAND: u16,

        }), @ptrFromInt(0x600030a4));

        /// SPI1 interrupt enable register
        pub const SPI_MEM_INT_ENA = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] The enable bit for SPI_MEM_PER_END_INT interrupt.
          SPI_MEM_PER_END_INT_ENA: u1,

          /// [1:1] The enable bit for SPI_MEM_PES_END_INT interrupt.
          SPI_MEM_PES_END_INT_ENA: u1,

          /// [2:2] The enable bit for SPI_MEM_WPE_END_INT interrupt.
          SPI_MEM_WPE_END_INT_ENA: u1,

          /// [3:3] The enable bit for SPI_MEM_SLV_ST_END_INT interrupt.
          SPI_MEM_SLV_ST_END_INT_ENA: u1,

          /// [4:4] The enable bit for SPI_MEM_MST_ST_END_INT interrupt.
          SPI_MEM_MST_ST_END_INT_ENA: u1,

          /// [5:9] 
          res0: u5,

          /// [10:10] The enable bit for SPI_MEM_BROWN_OUT_INT interrupt.
          SPI_MEM_BROWN_OUT_INT_ENA: u1,

          /// [11:31] 
          res1: u21,

        }), @ptrFromInt(0x600030c0));

        /// SPI1 interrupt clear register
        pub const SPI_MEM_INT_CLR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] The clear bit for SPI_MEM_PER_END_INT interrupt.
          SPI_MEM_PER_END_INT_CLR: u1,

          /// [1:1] The clear bit for SPI_MEM_PES_END_INT interrupt.
          SPI_MEM_PES_END_INT_CLR: u1,

          /// [2:2] The clear bit for SPI_MEM_WPE_END_INT interrupt.
          SPI_MEM_WPE_END_INT_CLR: u1,

          /// [3:3] The clear bit for SPI_MEM_SLV_ST_END_INT interrupt.
          SPI_MEM_SLV_ST_END_INT_CLR: u1,

          /// [4:4] The clear bit for SPI_MEM_MST_ST_END_INT interrupt.
          SPI_MEM_MST_ST_END_INT_CLR: u1,

          /// [5:9] 
          res0: u5,

          /// [10:10] The status bit for SPI_MEM_BROWN_OUT_INT interrupt.
          SPI_MEM_BROWN_OUT_INT_CLR: u1,

          /// [11:31] 
          res1: u21,

        }), @ptrFromInt(0x600030c4));

        /// SPI1 interrupt raw register
        pub const SPI_MEM_INT_RAW = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] The raw bit for SPI_MEM_PER_END_INT interrupt. 1: Triggered when Auto Resume command (0x7A) is sent and flash is resumed successfully. 0: Others.
          SPI_MEM_PER_END_INT_RAW: u1,

          /// [1:1] The raw bit for SPI_MEM_PES_END_INT interrupt.1: Triggered when Auto Suspend command (0x75) is sent and flash is suspended successfully. 0: Others.
          SPI_MEM_PES_END_INT_RAW: u1,

          /// [2:2] The raw bit for SPI_MEM_WPE_END_INT interrupt. 1: Triggered when WRSR/PP/SE/BE/CE is sent and flash is already idle. 0: Others.
          SPI_MEM_WPE_END_INT_RAW: u1,

          /// [3:3] The raw bit for SPI_MEM_SLV_ST_END_INT interrupt. 1: Triggered when spi1_slv_st is changed from non idle state to idle state. It means that SPI_CS raises high. 0: Others
          SPI_MEM_SLV_ST_END_INT_RAW: u1,

          /// [4:4] The raw bit for SPI_MEM_MST_ST_END_INT interrupt. 1: Triggered when spi1_mst_st is changed from non idle state to idle state. 0: Others.
          SPI_MEM_MST_ST_END_INT_RAW: u1,

          /// [5:9] 
          res0: u5,

          /// [10:10] The raw bit for SPI_MEM_BROWN_OUT_INT interrupt. 1: Triggered condition is that chip is loosing power and RTC module sends out brown out close flash request to SPI1. After SPI1 sends out suspend command to flash, this interrupt is triggered and MSPI returns to idle state. 0: Others.
          SPI_MEM_BROWN_OUT_INT_RAW: u1,

          /// [11:31] 
          res1: u21,

        }), @ptrFromInt(0x600030c8));

        /// SPI1 interrupt status register
        pub const SPI_MEM_INT_ST = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] The status bit for SPI_MEM_PER_END_INT interrupt.
          SPI_MEM_PER_END_INT_ST: u1,

          /// [1:1] The status bit for SPI_MEM_PES_END_INT interrupt.
          SPI_MEM_PES_END_INT_ST: u1,

          /// [2:2] The status bit for SPI_MEM_WPE_END_INT interrupt.
          SPI_MEM_WPE_END_INT_ST: u1,

          /// [3:3] The status bit for SPI_MEM_SLV_ST_END_INT interrupt.
          SPI_MEM_SLV_ST_END_INT_ST: u1,

          /// [4:4] The status bit for SPI_MEM_MST_ST_END_INT interrupt.
          SPI_MEM_MST_ST_END_INT_ST: u1,

          /// [5:9] 
          res0: u5,

          /// [10:10] The status bit for SPI_MEM_BROWN_OUT_INT interrupt.
          SPI_MEM_BROWN_OUT_INT_ST: u1,

          /// [11:31] 
          res1: u21,

        }), @ptrFromInt(0x600030cc));

        /// SPI1 DDR control register
        pub const SPI_MEM_DDR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] 1: in ddr mode,0 in sdr mode
          SPI_FMEM_DDR_EN: u1,

          /// [1:1] Set the bit to enable variable dummy cycle in spi ddr mode.
          SPI_FMEM_VAR_DUMMY: u1,

          /// [2:2] Set the bit to reorder rx data of the word in spi ddr mode.
          SPI_FMEM_DDR_RDAT_SWP: u1,

          /// [3:3] Set the bit to reorder tx data of the word in spi ddr mode.
          SPI_FMEM_DDR_WDAT_SWP: u1,

          /// [4:4] the bit is used to disable dual edge in command phase when ddr mode.
          SPI_FMEM_DDR_CMD_DIS: u1,

          /// [5:11] It is the minimum output data length in the panda device.
          SPI_FMEM_OUTMINBYTELEN: u7,

          /// [12:13] 
          res0: u2,

          /// [14:20] The delay number of data strobe which from memory based on SPI clock.
          SPI_FMEM_USR_DDR_DQS_THD: u7,

          /// [21:21] 1: Do not need the input of SPI_DQS signal, SPI0 starts to receive data when spi0_slv_st is in SPI_MEM_DIN state. It is used when there is no SPI_DQS signal or SPI_DQS signal is not stable. 0: SPI0 starts to store data at the positive and negative edge of SPI_DQS.
          SPI_FMEM_DDR_DQS_LOOP: u1,

          /// [22:23] 
          res1: u2,

          /// [24:24] Set this bit to enable the differential SPI_CLK#.
          SPI_FMEM_CLK_DIFF_EN: u1,

          /// [25:25] 
          res2: u1,

          /// [26:26] Set this bit to enable the input of SPI_DQS signal in SPI phases of CMD and ADDR.
          SPI_FMEM_DQS_CA_IN: u1,

          /// [27:27] Set this bit to enable the vary dummy function in SPI HyperBus mode, when SPI0 accesses flash or SPI1 accesses flash or sram.
          SPI_FMEM_HYPERBUS_DUMMY_2X: u1,

          /// [28:28] Set this bit to invert SPI_DIFF when accesses to flash. .
          SPI_FMEM_CLK_DIFF_INV: u1,

          /// [29:29] Set this bit to enable octa_ram address out when accesses to flash, which means ADDR_OUT[31:0] = {spi_usr_addr_value[25:4], 6'd0, spi_usr_addr_value[3:1], 1'b0}.
          SPI_FMEM_OCTA_RAM_ADDR: u1,

          /// [30:30] Set this bit to enable HyperRAM address out when accesses to flash, which means ADDR_OUT[31:0] = {spi_usr_addr_value[19:4], 13'd0, spi_usr_addr_value[3:1]}.
          SPI_FMEM_HYPERBUS_CA: u1,

          /// [31:31] 
          res3: u1,

        }), @ptrFromInt(0x600030d4));

        /// SPI1 timing control register
        pub const SPI_MEM_TIMING_CALI = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] 
          res0: u1,

          /// [1:1] The bit is used to enable timing auto-calibration for all reading operations.
          SPI_MEM_TIMING_CALI: u1,

          /// [2:4] add extra dummy spi clock cycle length for spi clock calibration.
          SPI_MEM_EXTRA_DUMMY_CYCLELEN: u3,

          /// [5:31] 
          res1: u27,

        }), @ptrFromInt(0x60003180));

        /// SPI1 clk_gate register
        pub const SPI_MEM_CLOCK_GATE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Register clock gate enable signal. 1: Enable. 0: Disable.
          SPI_MEM_CLK_EN: u1,

          /// [1:31] 
          res0: u31,

        }), @ptrFromInt(0x60003200));

        /// Version control register
        pub const SPI_MEM_DATE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:27] Version control register
          SPI_MEM_DATE: u28,

          /// [28:31] 
          res0: u4,

        }), @ptrFromInt(0x600033fc));

      };

      /// SPI (Serial Peripheral Interface) Controller 2
      pub const SPI2 = struct {

        /// Command control register
        pub const CMD = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:17] Define the APB cycles ofSPI_CONF state. Can be configured in CONF state.
          CONF_BITLEN: u18,

          /// [18:22] 
          res0: u5,

          /// [23:23] Set this bit to synchronize SPI registers from APB clock domain into SPI module clock domain, which is only used in SPI master mode.
          UPDATE: u1,

          /// [24:24] User define command enable.An operation will be triggered when the bit is set. The bit will be cleared once the operation done.1: enable 0: disable. Can not be changed by CONF_buf.
          USR: u1,

          /// [25:31] 
          res1: u7,

        }), @ptrFromInt(0x60081000));

        /// Address value register
        pub const ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Address to slave. Can be configured in CONF state.
          USR_ADDR_VALUE: u32,

        }), @ptrFromInt(0x60081004));

        /// SPI control register
        pub const CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:2] 
          res0: u3,

          /// [3:3] 0: In the dummy phase, the FSPI bus signals are not output. 1: In the dummy phase, the FSPI bus signals are output. Can be configured in CONF state.
          DUMMY_OUT: u1,

          /// [4:4] 
          res1: u1,

          /// [5:5] Apply 2 signals during addr phase 1:enable 0: disable. Can be configured in CONF state.
          FADDR_DUAL: u1,

          /// [6:6] Apply 4 signals during addr phase 1:enable 0: disable. Can be configured in CONF state.
          FADDR_QUAD: u1,

          /// [7:7] Apply 8 signals during addr phase 1:enable 0: disable. Can be configured in CONF state.
          FADDR_OCT: u1,

          /// [8:8] Apply 2 signals during command phase 1:enable 0: disable. Can be configured in CONF state.
          FCMD_DUAL: u1,

          /// [9:9] Apply 4 signals during command phase 1:enable 0: disable. Can be configured in CONF state.
          FCMD_QUAD: u1,

          /// [10:10] Apply 8 signals during command phase 1:enable 0: disable. Can be configured in CONF state.
          FCMD_OCT: u1,

          /// [11:13] 
          res2: u3,

          /// [14:14] In the read operations, read-data phase apply 2 signals. 1: enable 0: disable. Can be configured in CONF state.
          FREAD_DUAL: u1,

          /// [15:15] In the read operations read-data phase apply 4 signals. 1: enable 0: disable.Can be configured in CONF state.
          FREAD_QUAD: u1,

          /// [16:16] In the read operations read-data phase apply 8 signals. 1: enable 0: disable.Can be configured in CONF state.
          FREAD_OCT: u1,

          /// [17:17] 
          res3: u1,

          /// [18:18] The bit is used to set MISO line polarity, 1: high 0, low. Can be configured in CONF state.
          Q_POL: u1,

          /// [19:19] The bit is used to set MOSI line polarity, 1: high 0, low. Can be configured in CONF state.
          D_POL: u1,

          /// [20:20] SPI_HOLD output value when SPI is idle. 1: output high, 0: output low. Can be configured in CONF state.
          HOLD_POL: u1,

          /// [21:21] Write protect signal output when SPI is idle.1: output high, 0: output low.Can be configured in CONF state.
          WP_POL: u1,

          /// [22:22] 
          res4: u1,

          /// [23:24] In read-data (MISO) phase 1: LSB first 0: MSB first. Can be configured in CONF state.
          RD_BIT_ORDER: u2,

          /// [25:26] In command address write-data (MOSI) phases 1: LSB firs 0: MSB first. Can be configured in CONF state.
          WR_BIT_ORDER: u2,

          /// [27:31] 
          res5: u5,

        }), @ptrFromInt(0x60081008));

        /// SPI clock control register
        pub const CLOCK = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] In the master mode it must be equal to spi_clkcnt_N. In the slave mode it must be 0. Can be configured in CONF state.
          CLKCNT_L: u6,

          /// [6:11] In the master mode it must be floor((spi_clkcnt_N+1)/2-1). In the slave mode it must be 0. Can be configured in CONF state.
          CLKCNT_H: u6,

          /// [12:17] In the master mode it is the divider of spi_clk. So spi_clk frequency is system/(spi_clkdiv_pre+1)/(spi_clkcnt_N+1). Can be configured in CONF state.
          CLKCNT_N: u6,

          /// [18:21] In the master mode it is pre-divider of spi_clk.Can be configured in CONF state.
          CLKDIV_PRE: u4,

          /// [22:30] 
          res0: u9,

          /// [31:31] In the master mode 1: spi_clk is eqaul to system 0: spi_clk is divided from system clock. Can be configured in CONF state.
          CLK_EQU_SYSCLK: u1,

        }), @ptrFromInt(0x6008100c));

        /// SPI USER control register
        pub const USER = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Set the bit to enable full duplex communication. 1: enable 0: disable. Can be configured in CONF state.
          DOUTDIN: u1,

          /// [1:2] 
          res0: u2,

          /// [3:3] Both for master mode and slave mode. 1: spi controller is in QPI mode. 0: others. Can be configured in CONF state.
          QPI_MODE: u1,

          /// [4:4] Just for master mode. 1: spi controller is in OPI mode (all in 8-b-m). 0: others. Can be configured in CONF state.
          OPI_MODE: u1,

          /// [5:5] In the slave mode, this bit can be used to change the polarity of tsck. 0: tsck = spi_ck_i. 1:tsck = !spi_ck_i.
          TSCK_I_EDGE: u1,

          /// [6:6] spi cs keep low when spi is indonephase. 1: enable 0: disable. Can be configured in CONF state.
          CS_HOLD: u1,

          /// [7:7] spi cs is enable when spi is inpreparephase. 1: enable 0: disable. Can be configured in CONF state.
          CS_SETUP: u1,

          /// [8:8] In the slave mode, this bit can be used to change the polarity of rsck. 0: rsck = !spi_ck_i. 1:rsck = spi_ck_i.
          RSCK_I_EDGE: u1,

          /// [9:9] the bit combined with spi_mosi_delay_mode bits to set mosi signal delay mode. Can be configured in CONF state.
          CK_OUT_EDGE: u1,

          /// [10:11] 
          res1: u2,

          /// [12:12] In the write operations read-data phase apply 2 signals. Can be configured in CONF state.
          FWRITE_DUAL: u1,

          /// [13:13] In the write operations read-data phase apply 4 signals. Can be configured in CONF state.
          FWRITE_QUAD: u1,

          /// [14:14] In the write operations read-data phase apply 8 signals. Can be configured in CONF state.
          FWRITE_OCT: u1,

          /// [15:15] 1: Enable the DMA CONF phase of next seg-trans operation, which means seg-trans will continue. 0: The seg-trans will end after the current SPI seg-trans or this is not seg-trans mode. Can be configured in CONF state.
          USR_CONF_NXT: u1,

          /// [16:16] 
          res2: u1,

          /// [17:17] Set the bit to enable 3-line half duplex communication mosi and miso signals share the same pin. 1: enable 0: disable. Can be configured in CONF state.
          SIO: u1,

          /// [18:23] 
          res3: u6,

          /// [24:24] read-data phase only access to high-part of the buffer spi_w8~spi_w15. 1: enable 0: disable. Can be configured in CONF state.
          USR_MISO_HIGHPART: u1,

          /// [25:25] write-data phase only access to high-part of the buffer spi_w8~spi_w15. 1: enable 0: disable.Can be configured in CONF state.
          USR_MOSI_HIGHPART: u1,

          /// [26:26] spi clock is disable in dummy phase when the bit is enable. Can be configured in CONF state.
          USR_DUMMY_IDLE: u1,

          /// [27:27] This bit enable the write-data phase of an operation. Can be configured in CONF state.
          USR_MOSI: u1,

          /// [28:28] This bit enable the read-data phase of an operation. Can be configured in CONF state.
          USR_MISO: u1,

          /// [29:29] This bit enable the dummy phase of an operation. Can be configured in CONF state.
          USR_DUMMY: u1,

          /// [30:30] This bit enable the address phase of an operation. Can be configured in CONF state.
          USR_ADDR: u1,

          /// [31:31] This bit enable the command phase of an operation. Can be configured in CONF state.
          USR_COMMAND: u1,

        }), @ptrFromInt(0x60081010));

        /// SPI USER control register 1
        pub const USER1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] The length in spi_clk cycles of dummy phase. The register value shall be (cycle_num-1). Can be configured in CONF state.
          USR_DUMMY_CYCLELEN: u8,

          /// [8:15] 
          res0: u8,

          /// [16:16] 1: SPI transfer is ended when SPI RX AFIFO wfull error is valid in GP-SPI master FD/HD-mode. 0: SPI transfer is not ended when SPI RX AFIFO wfull error is valid in GP-SPI master FD/HD-mode.
          MST_WFULL_ERR_END_EN: u1,

          /// [17:21] (cycles+1) of prepare phase by spi clock this bits are combined with spi_cs_setup bit. Can be configured in CONF state.
          CS_SETUP_TIME: u5,

          /// [22:26] delay cycles of cs pin by spi clock this bits are combined with spi_cs_hold bit. Can be configured in CONF state.
          CS_HOLD_TIME: u5,

          /// [27:31] The length in bits of address phase. The register value shall be (bit_num-1). Can be configured in CONF state.
          USR_ADDR_BITLEN: u5,

        }), @ptrFromInt(0x60081014));

        /// SPI USER control register 2
        pub const USER2 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:15] The value ofcommand. Can be configured in CONF state.
          USR_COMMAND_VALUE: u16,

          /// [16:26] 
          res0: u11,

          /// [27:27] 1: SPI transfer is ended when SPI TX AFIFO read empty error is valid in GP-SPI master FD/HD-mode. 0: SPI transfer is not ended when SPI TX AFIFO read empty error is valid in GP-SPI master FD/HD-mode.
          MST_REMPTY_ERR_END_EN: u1,

          /// [28:31] The length in bits of command phase. The register value shall be (bit_num-1). Can be configured in CONF state.
          USR_COMMAND_BITLEN: u4,

        }), @ptrFromInt(0x60081018));

        /// SPI data bit length control register
        pub const MS_DLEN = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:17] The value of these bits is the configured SPI transmission data bit length in master mode DMA controlled transfer or CPU controlled transfer. The value is also the configured bit length in slave mode DMA RX controlled transfer. The register value shall be (bit_num-1). Can be configured in CONF state.
          MS_DATA_BITLEN: u18,

          /// [18:31] 
          res0: u14,

        }), @ptrFromInt(0x6008101c));

        /// SPI misc register
        pub const MISC = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] SPI CS0 pin enable, 1: disable CS0, 0: spi_cs0 signal is from/to CS0 pin. Can be configured in CONF state.
          CS0_DIS: u1,

          /// [1:1] SPI CS1 pin enable, 1: disable CS1, 0: spi_cs1 signal is from/to CS1 pin. Can be configured in CONF state.
          CS1_DIS: u1,

          /// [2:2] SPI CS2 pin enable, 1: disable CS2, 0: spi_cs2 signal is from/to CS2 pin. Can be configured in CONF state.
          CS2_DIS: u1,

          /// [3:3] SPI CS3 pin enable, 1: disable CS3, 0: spi_cs3 signal is from/to CS3 pin. Can be configured in CONF state.
          CS3_DIS: u1,

          /// [4:4] SPI CS4 pin enable, 1: disable CS4, 0: spi_cs4 signal is from/to CS4 pin. Can be configured in CONF state.
          CS4_DIS: u1,

          /// [5:5] SPI CS5 pin enable, 1: disable CS5, 0: spi_cs5 signal is from/to CS5 pin. Can be configured in CONF state.
          CS5_DIS: u1,

          /// [6:6] 1: spi clk out disable,0: spi clk out enable. Can be configured in CONF state.
          CK_DIS: u1,

          /// [7:12] In the master mode the bits are the polarity of spi cs line, the value is equivalent to spi_cs ^ spi_master_cs_pol. Can be configured in CONF state.
          MASTER_CS_POL: u6,

          /// [13:15] 
          res0: u3,

          /// [16:16] 1: SPI master DTR mode is applied to SPI clk, data and spi_dqs.0: SPI master DTR mode isonly applied to spi_dqs. This bit should be used with bit 17/18/19.
          CLK_DATA_DTR_EN: u1,

          /// [17:17] 1: SPI clk and data of SPI_DOUT and SPI_DIN state are in DTR mode, including master 1/2/4/8-bm.0:SPI clk and data of SPI_DOUT and SPI_DIN state are in STR mode. Can be configured in CONF state.
          DATA_DTR_EN: u1,

          /// [18:18] 1: SPI clk and data of SPI_SEND_ADDR state are in DTR mode, including master 1/2/4/8-bm.0:SPI clk and data of SPI_SEND_ADDR state are in STR mode. Can be configured in CONF state.
          ADDR_DTR_EN: u1,

          /// [19:19] 1: SPI clk and data of SPI_SEND_CMD state are in DTR mode, including master 1/2/4/8-bm. 0:SPI clk and data of SPI_SEND_CMD state are in STR mode. Can be configured in CONF state.
          CMD_DTR_EN: u1,

          /// [20:22] 
          res1: u3,

          /// [23:23] spi slave input cs polarity select. 1: inv0: not change. Can be configured in CONF state.
          SLAVE_CS_POL: u1,

          /// [24:24] The default value of spi_dqs. Can be configured in CONF state.
          DQS_IDLE_EDGE: u1,

          /// [25:28] 
          res2: u4,

          /// [29:29] 1: spi clk line is high when idle 0: spi clk line is low when idle. Can be configured in CONF state.
          CK_IDLE_EDGE: u1,

          /// [30:30] spi cs line keep low when the bit is set. Can be configured in CONF state.
          CS_KEEP_ACTIVE: u1,

          /// [31:31] 1: SPI quad input swap enable, swap FSPID with FSPIQ, swap FSPIWP with FSPIHD. 0:spi quad input swap disable. Can be configured in CONF state.
          QUAD_DIN_PIN_SWAP: u1,

        }), @ptrFromInt(0x60081020));

        /// SPI input delay mode configuration
        pub const DIN_MODE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:1] the input signals are delayed by SPI module clock cycles, 0: input without delayed, 1: input with the posedge of clk_apb,2 input with the negedge of clk_apb, 3: input with the spi_clk. Can be configured in CONF state.
          DIN0_MODE: u2,

          /// [2:3] the input signals are delayed by SPI module clock cycles, 0: input without delayed, 1: input with the posedge of clk_apb,2 input with the negedge of clk_apb, 3: input with the spi_clk. Can be configured in CONF state.
          DIN1_MODE: u2,

          /// [4:5] the input signals are delayed by SPI module clock cycles, 0: input without delayed, 1: input with the posedge of clk_apb,2 input with the negedge of clk_apb, 3: input with the spi_clk. Can be configured in CONF state.
          DIN2_MODE: u2,

          /// [6:7] the input signals are delayed by SPI module clock cycles, 0: input without delayed, 1: input with the posedge of clk_apb,2 input with the negedge of clk_apb, 3: input with the spi_clk. Can be configured in CONF state.
          DIN3_MODE: u2,

          /// [8:9] the input signals are delayed by SPI module clock cycles, 0: input without delayed, 1: input with the posedge of clk_apb,2 input with the negedge of clk_apb, 3: input with the spi_clk. Can be configured in CONF state.
          DIN4_MODE: u2,

          /// [10:11] the input signals are delayed by SPI module clock cycles, 0: input without delayed, 1: input with the posedge of clk_apb,2 input with the negedge of clk_apb, 3: input with the spi_clk. Can be configured in CONF state.
          DIN5_MODE: u2,

          /// [12:13] the input signals are delayed by SPI module clock cycles, 0: input without delayed, 1: input with the posedge of clk_apb,2 input with the negedge of clk_apb, 3: input with the spi_clk. Can be configured in CONF state.
          DIN6_MODE: u2,

          /// [14:15] the input signals are delayed by SPI module clock cycles, 0: input without delayed, 1: input with the posedge of clk_apb,2 input with the negedge of clk_apb, 3: input with the spi_clk. Can be configured in CONF state.
          DIN7_MODE: u2,

          /// [16:16] 1:enable hclk in SPI input timing module.0: disable it. Can be configured in CONF state.
          TIMING_HCLK_ACTIVE: u1,

          /// [17:31] 
          res0: u15,

        }), @ptrFromInt(0x60081024));

        /// SPI input delay number configuration
        pub const DIN_NUM = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:1] the input signals are delayed by SPI module clock cycles, 0: delayed by 1 cycle, 1: delayed by 2 cycles,...Can be configured in CONF state.
          DIN0_NUM: u2,

          /// [2:3] the input signals are delayed by SPI module clock cycles, 0: delayed by 1 cycle, 1: delayed by 2 cycles,...Can be configured in CONF state.
          DIN1_NUM: u2,

          /// [4:5] the input signals are delayed by SPI module clock cycles, 0: delayed by 1 cycle, 1: delayed by 2 cycles,...Can be configured in CONF state.
          DIN2_NUM: u2,

          /// [6:7] the input signals are delayed by SPI module clock cycles, 0: delayed by 1 cycle, 1: delayed by 2 cycles,...Can be configured in CONF state.
          DIN3_NUM: u2,

          /// [8:9] the input signals are delayed by SPI module clock cycles, 0: delayed by 1 cycle, 1: delayed by 2 cycles,...Can be configured in CONF state.
          DIN4_NUM: u2,

          /// [10:11] the input signals are delayed by SPI module clock cycles, 0: delayed by 1 cycle, 1: delayed by 2 cycles,...Can be configured in CONF state.
          DIN5_NUM: u2,

          /// [12:13] the input signals are delayed by SPI module clock cycles, 0: delayed by 1 cycle, 1: delayed by 2 cycles,...Can be configured in CONF state.
          DIN6_NUM: u2,

          /// [14:15] the input signals are delayed by SPI module clock cycles, 0: delayed by 1 cycle, 1: delayed by 2 cycles,...Can be configured in CONF state.
          DIN7_NUM: u2,

          /// [16:31] 
          res0: u16,

        }), @ptrFromInt(0x60081028));

        /// SPI output delay mode configuration
        pub const DOUT_MODE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] The output signal 0 is delayed by the SPI module clock, 0: output without delayed, 1: output delay for a SPI module clock cycle at its negative edge. Can be configured in CONF state.
          DOUT0_MODE: u1,

          /// [1:1] The output signal 1 is delayed by the SPI module clock, 0: output without delayed, 1: output delay for a SPI module clock cycle at its negative edge. Can be configured in CONF state.
          DOUT1_MODE: u1,

          /// [2:2] The output signal 2 is delayed by the SPI module clock, 0: output without delayed, 1: output delay for a SPI module clock cycle at its negative edge. Can be configured in CONF state.
          DOUT2_MODE: u1,

          /// [3:3] The output signal 3 is delayed by the SPI module clock, 0: output without delayed, 1: output delay for a SPI module clock cycle at its negative edge. Can be configured in CONF state.
          DOUT3_MODE: u1,

          /// [4:4] The output signal 4 is delayed by the SPI module clock, 0: output without delayed, 1: output delay for a SPI module clock cycle at its negative edge. Can be configured in CONF state.
          DOUT4_MODE: u1,

          /// [5:5] The output signal 5 is delayed by the SPI module clock, 0: output without delayed, 1: output delay for a SPI module clock cycle at its negative edge. Can be configured in CONF state.
          DOUT5_MODE: u1,

          /// [6:6] The output signal 6 is delayed by the SPI module clock, 0: output without delayed, 1: output delay for a SPI module clock cycle at its negative edge. Can be configured in CONF state.
          DOUT6_MODE: u1,

          /// [7:7] The output signal 7 is delayed by the SPI module clock, 0: output without delayed, 1: output delay for a SPI module clock cycle at its negative edge. Can be configured in CONF state.
          DOUT7_MODE: u1,

          /// [8:8] The output signal SPI_DQS is delayed by the SPI module clock, 0: output without delayed, 1: output delay for a SPI module clock cycle at its negative edge. Can be configured in CONF state.
          D_DQS_MODE: u1,

          /// [9:31] 
          res0: u23,

        }), @ptrFromInt(0x6008102c));

        /// SPI DMA control register
        pub const DMA_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Records the status of DMA TX FIFO. 1: DMA TX FIFO is not ready for sending data. 0: DMA TX FIFO is ready for sending data.
          DMA_OUTFIFO_EMPTY: u1,

          /// [1:1] Records the status of DMA RX FIFO. 1: DMA RX FIFO is not ready for receiving data. 0: DMA RX FIFO is ready for receiving data.
          DMA_INFIFO_FULL: u1,

          /// [2:17] 
          res0: u16,

          /// [18:18] Enable dma segment transfer in spi dma half slave mode. 1: enable. 0: disable.
          DMA_SLV_SEG_TRANS_EN: u1,

          /// [19:19] 1: spi_dma_infifo_full_vld is cleared by spi slave cmd 5. 0: spi_dma_infifo_full_vld is cleared by spi_trans_done.
          SLV_RX_SEG_TRANS_CLR_EN: u1,

          /// [20:20] 1: spi_dma_outfifo_empty_vld is cleared by spi slave cmd 6. 0: spi_dma_outfifo_empty_vld is cleared by spi_trans_done.
          SLV_TX_SEG_TRANS_CLR_EN: u1,

          /// [21:21] 1: spi_dma_inlink_eof is set when the number of dma pushed data bytes is equal to the value of spi_slv/mst_dma_rd_bytelen[19:0] in spi dma transition.0: spi_dma_inlink_eof is set by spi_trans_done in non-seg-trans or spi_dma_seg_trans_done in seg-trans.
          RX_EOF_EN: u1,

          /// [22:26] 
          res1: u5,

          /// [27:27] Set this bit to enable SPI DMA controlled receive data mode.
          DMA_RX_ENA: u1,

          /// [28:28] Set this bit to enable SPI DMA controlled send data mode.
          DMA_TX_ENA: u1,

          /// [29:29] Set this bit to reset RX AFIFO, which is used to receive data in SPI master and slave mode transfer.
          RX_AFIFO_RST: u1,

          /// [30:30] Set this bit to reset BUF TX AFIFO, which is used send data out in SPI slave CPU controlled mode transfer and master mode transfer.
          BUF_AFIFO_RST: u1,

          /// [31:31] Set this bit to reset DMA TX AFIFO, which is used to send data out in SPI slave DMA controlled mode transfer.
          DMA_AFIFO_RST: u1,

        }), @ptrFromInt(0x60081030));

        /// SPI interrupt enable register
        pub const DMA_INT_ENA = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] The enable bit for SPI_DMA_INFIFO_FULL_ERR_INT interrupt.
          DMA_INFIFO_FULL_ERR_INT_ENA: u1,

          /// [1:1] The enable bit for SPI_DMA_OUTFIFO_EMPTY_ERR_INT interrupt.
          DMA_OUTFIFO_EMPTY_ERR_INT_ENA: u1,

          /// [2:2] The enable bit for SPI slave Ex_QPI interrupt.
          SLV_EX_QPI_INT_ENA: u1,

          /// [3:3] The enable bit for SPI slave En_QPI interrupt.
          SLV_EN_QPI_INT_ENA: u1,

          /// [4:4] The enable bit for SPI slave CMD7 interrupt.
          SLV_CMD7_INT_ENA: u1,

          /// [5:5] The enable bit for SPI slave CMD8 interrupt.
          SLV_CMD8_INT_ENA: u1,

          /// [6:6] The enable bit for SPI slave CMD9 interrupt.
          SLV_CMD9_INT_ENA: u1,

          /// [7:7] The enable bit for SPI slave CMDA interrupt.
          SLV_CMDA_INT_ENA: u1,

          /// [8:8] The enable bit for SPI_SLV_RD_DMA_DONE_INT interrupt.
          SLV_RD_DMA_DONE_INT_ENA: u1,

          /// [9:9] The enable bit for SPI_SLV_WR_DMA_DONE_INT interrupt.
          SLV_WR_DMA_DONE_INT_ENA: u1,

          /// [10:10] The enable bit for SPI_SLV_RD_BUF_DONE_INT interrupt.
          SLV_RD_BUF_DONE_INT_ENA: u1,

          /// [11:11] The enable bit for SPI_SLV_WR_BUF_DONE_INT interrupt.
          SLV_WR_BUF_DONE_INT_ENA: u1,

          /// [12:12] The enable bit for SPI_TRANS_DONE_INT interrupt.
          TRANS_DONE_INT_ENA: u1,

          /// [13:13] The enable bit for SPI_DMA_SEG_TRANS_DONE_INT interrupt.
          DMA_SEG_TRANS_DONE_INT_ENA: u1,

          /// [14:14] The enable bit for SPI_SEG_MAGIC_ERR_INT interrupt.
          SEG_MAGIC_ERR_INT_ENA: u1,

          /// [15:15] The enable bit for SPI_SLV_BUF_ADDR_ERR_INT interrupt.
          SLV_BUF_ADDR_ERR_INT_ENA: u1,

          /// [16:16] The enable bit for SPI_SLV_CMD_ERR_INT interrupt.
          SLV_CMD_ERR_INT_ENA: u1,

          /// [17:17] The enable bit for SPI_MST_RX_AFIFO_WFULL_ERR_INT interrupt.
          MST_RX_AFIFO_WFULL_ERR_INT_ENA: u1,

          /// [18:18] The enable bit for SPI_MST_TX_AFIFO_REMPTY_ERR_INT interrupt.
          MST_TX_AFIFO_REMPTY_ERR_INT_ENA: u1,

          /// [19:19] The enable bit for SPI_APP2_INT interrupt.
          APP2_INT_ENA: u1,

          /// [20:20] The enable bit for SPI_APP1_INT interrupt.
          APP1_INT_ENA: u1,

          /// [21:31] 
          res0: u11,

        }), @ptrFromInt(0x60081034));

        /// SPI interrupt clear register
        pub const DMA_INT_CLR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] The clear bit for SPI_DMA_INFIFO_FULL_ERR_INT interrupt.
          DMA_INFIFO_FULL_ERR_INT_CLR: u1,

          /// [1:1] The clear bit for SPI_DMA_OUTFIFO_EMPTY_ERR_INT interrupt.
          DMA_OUTFIFO_EMPTY_ERR_INT_CLR: u1,

          /// [2:2] The clear bit for SPI slave Ex_QPI interrupt.
          SLV_EX_QPI_INT_CLR: u1,

          /// [3:3] The clear bit for SPI slave En_QPI interrupt.
          SLV_EN_QPI_INT_CLR: u1,

          /// [4:4] The clear bit for SPI slave CMD7 interrupt.
          SLV_CMD7_INT_CLR: u1,

          /// [5:5] The clear bit for SPI slave CMD8 interrupt.
          SLV_CMD8_INT_CLR: u1,

          /// [6:6] The clear bit for SPI slave CMD9 interrupt.
          SLV_CMD9_INT_CLR: u1,

          /// [7:7] The clear bit for SPI slave CMDA interrupt.
          SLV_CMDA_INT_CLR: u1,

          /// [8:8] The clear bit for SPI_SLV_RD_DMA_DONE_INT interrupt.
          SLV_RD_DMA_DONE_INT_CLR: u1,

          /// [9:9] The clear bit for SPI_SLV_WR_DMA_DONE_INT interrupt.
          SLV_WR_DMA_DONE_INT_CLR: u1,

          /// [10:10] The clear bit for SPI_SLV_RD_BUF_DONE_INT interrupt.
          SLV_RD_BUF_DONE_INT_CLR: u1,

          /// [11:11] The clear bit for SPI_SLV_WR_BUF_DONE_INT interrupt.
          SLV_WR_BUF_DONE_INT_CLR: u1,

          /// [12:12] The clear bit for SPI_TRANS_DONE_INT interrupt.
          TRANS_DONE_INT_CLR: u1,

          /// [13:13] The clear bit for SPI_DMA_SEG_TRANS_DONE_INT interrupt.
          DMA_SEG_TRANS_DONE_INT_CLR: u1,

          /// [14:14] The clear bit for SPI_SEG_MAGIC_ERR_INT interrupt.
          SEG_MAGIC_ERR_INT_CLR: u1,

          /// [15:15] The clear bit for SPI_SLV_BUF_ADDR_ERR_INT interrupt.
          SLV_BUF_ADDR_ERR_INT_CLR: u1,

          /// [16:16] The clear bit for SPI_SLV_CMD_ERR_INT interrupt.
          SLV_CMD_ERR_INT_CLR: u1,

          /// [17:17] The clear bit for SPI_MST_RX_AFIFO_WFULL_ERR_INT interrupt.
          MST_RX_AFIFO_WFULL_ERR_INT_CLR: u1,

          /// [18:18] The clear bit for SPI_MST_TX_AFIFO_REMPTY_ERR_INT interrupt.
          MST_TX_AFIFO_REMPTY_ERR_INT_CLR: u1,

          /// [19:19] The clear bit for SPI_APP2_INT interrupt.
          APP2_INT_CLR: u1,

          /// [20:20] The clear bit for SPI_APP1_INT interrupt.
          APP1_INT_CLR: u1,

          /// [21:31] 
          res0: u11,

        }), @ptrFromInt(0x60081038));

        /// SPI interrupt raw register
        pub const DMA_INT_RAW = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] 1: The current data rate of DMA Rx is smaller than that of SPI, which will lose the receive data.0: Others.
          DMA_INFIFO_FULL_ERR_INT_RAW: u1,

          /// [1:1] 1: The current data rate of DMA TX is smaller than that of SPI. SPI will stop in master mode and send out all 0 in slave mode.0: Others.
          DMA_OUTFIFO_EMPTY_ERR_INT_RAW: u1,

          /// [2:2] The raw bit for SPI slave Ex_QPI interrupt. 1: SPI slave mode Ex_QPI transmission is ended. 0: Others.
          SLV_EX_QPI_INT_RAW: u1,

          /// [3:3] The raw bit for SPI slave En_QPI interrupt. 1: SPI slave mode En_QPI transmission is ended. 0: Others.
          SLV_EN_QPI_INT_RAW: u1,

          /// [4:4] The raw bit for SPI slave CMD7 interrupt. 1: SPI slave mode CMD7 transmission is ended. 0: Others.
          SLV_CMD7_INT_RAW: u1,

          /// [5:5] The raw bit for SPI slave CMD8 interrupt. 1: SPI slave mode CMD8 transmission is ended. 0: Others.
          SLV_CMD8_INT_RAW: u1,

          /// [6:6] The raw bit for SPI slave CMD9 interrupt. 1: SPI slave mode CMD9 transmission is ended. 0: Others.
          SLV_CMD9_INT_RAW: u1,

          /// [7:7] The raw bit for SPI slave CMDA interrupt. 1: SPI slave mode CMDA transmission is ended. 0: Others.
          SLV_CMDA_INT_RAW: u1,

          /// [8:8] The raw bit for SPI_SLV_RD_DMA_DONE_INT interrupt. 1: SPI slave mode Rd_DMA transmission is ended. 0: Others.
          SLV_RD_DMA_DONE_INT_RAW: u1,

          /// [9:9] The raw bit for SPI_SLV_WR_DMA_DONE_INT interrupt. 1: SPI slave mode Wr_DMA transmission is ended. 0: Others.
          SLV_WR_DMA_DONE_INT_RAW: u1,

          /// [10:10] The raw bit for SPI_SLV_RD_BUF_DONE_INT interrupt. 1: SPI slave mode Rd_BUF transmission is ended. 0: Others.
          SLV_RD_BUF_DONE_INT_RAW: u1,

          /// [11:11] The raw bit for SPI_SLV_WR_BUF_DONE_INT interrupt. 1: SPI slave mode Wr_BUF transmission is ended. 0: Others.
          SLV_WR_BUF_DONE_INT_RAW: u1,

          /// [12:12] The raw bit for SPI_TRANS_DONE_INT interrupt. 1: SPI master mode transmission is ended. 0: others.
          TRANS_DONE_INT_RAW: u1,

          /// [13:13] The raw bit for SPI_DMA_SEG_TRANS_DONE_INT interrupt. 1:spi master DMA full-duplex/half-duplex seg-conf-trans ends or slave half-duplex seg-trans ends. And data has been pushed to corresponding memory.0:seg-conf-trans or seg-trans is not ended or not occurred.
          DMA_SEG_TRANS_DONE_INT_RAW: u1,

          /// [14:14] The raw bit for SPI_SEG_MAGIC_ERR_INT interrupt. 1: The magic value in CONF buffer is error in the DMA seg-conf-trans. 0: others.
          SEG_MAGIC_ERR_INT_RAW: u1,

          /// [15:15] The raw bit for SPI_SLV_BUF_ADDR_ERR_INT interrupt. 1: The accessing data address of the current SPI slave mode CPU controlled FD, Wr_BUF or Rd_BUF transmission is bigger than 63. 0: Others.
          SLV_BUF_ADDR_ERR_INT_RAW: u1,

          /// [16:16] The raw bit for SPI_SLV_CMD_ERR_INT interrupt. 1: The slave command value in the current SPI slave HD mode transmission is not supported. 0: Others.
          SLV_CMD_ERR_INT_RAW: u1,

          /// [17:17] The raw bit for SPI_MST_RX_AFIFO_WFULL_ERR_INT interrupt. 1: There is a RX AFIFO write-full error when SPI inputs data in master mode. 0: Others.
          MST_RX_AFIFO_WFULL_ERR_INT_RAW: u1,

          /// [18:18] The raw bit for SPI_MST_TX_AFIFO_REMPTY_ERR_INT interrupt. 1: There is a TX BUF AFIFO read-empty error when SPI outputs data in master mode. 0: Others.
          MST_TX_AFIFO_REMPTY_ERR_INT_RAW: u1,

          /// [19:19] The raw bit for SPI_APP2_INT interrupt. The value is only controlled by software.
          APP2_INT_RAW: u1,

          /// [20:20] The raw bit for SPI_APP1_INT interrupt. The value is only controlled by software.
          APP1_INT_RAW: u1,

          /// [21:31] 
          res0: u11,

        }), @ptrFromInt(0x6008103c));

        /// SPI interrupt status register
        pub const DMA_INT_ST = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] The status bit for SPI_DMA_INFIFO_FULL_ERR_INT interrupt.
          DMA_INFIFO_FULL_ERR_INT_ST: u1,

          /// [1:1] The status bit for SPI_DMA_OUTFIFO_EMPTY_ERR_INT interrupt.
          DMA_OUTFIFO_EMPTY_ERR_INT_ST: u1,

          /// [2:2] The status bit for SPI slave Ex_QPI interrupt.
          SLV_EX_QPI_INT_ST: u1,

          /// [3:3] The status bit for SPI slave En_QPI interrupt.
          SLV_EN_QPI_INT_ST: u1,

          /// [4:4] The status bit for SPI slave CMD7 interrupt.
          SLV_CMD7_INT_ST: u1,

          /// [5:5] The status bit for SPI slave CMD8 interrupt.
          SLV_CMD8_INT_ST: u1,

          /// [6:6] The status bit for SPI slave CMD9 interrupt.
          SLV_CMD9_INT_ST: u1,

          /// [7:7] The status bit for SPI slave CMDA interrupt.
          SLV_CMDA_INT_ST: u1,

          /// [8:8] The status bit for SPI_SLV_RD_DMA_DONE_INT interrupt.
          SLV_RD_DMA_DONE_INT_ST: u1,

          /// [9:9] The status bit for SPI_SLV_WR_DMA_DONE_INT interrupt.
          SLV_WR_DMA_DONE_INT_ST: u1,

          /// [10:10] The status bit for SPI_SLV_RD_BUF_DONE_INT interrupt.
          SLV_RD_BUF_DONE_INT_ST: u1,

          /// [11:11] The status bit for SPI_SLV_WR_BUF_DONE_INT interrupt.
          SLV_WR_BUF_DONE_INT_ST: u1,

          /// [12:12] The status bit for SPI_TRANS_DONE_INT interrupt.
          TRANS_DONE_INT_ST: u1,

          /// [13:13] The status bit for SPI_DMA_SEG_TRANS_DONE_INT interrupt.
          DMA_SEG_TRANS_DONE_INT_ST: u1,

          /// [14:14] The status bit for SPI_SEG_MAGIC_ERR_INT interrupt.
          SEG_MAGIC_ERR_INT_ST: u1,

          /// [15:15] The status bit for SPI_SLV_BUF_ADDR_ERR_INT interrupt.
          SLV_BUF_ADDR_ERR_INT_ST: u1,

          /// [16:16] The status bit for SPI_SLV_CMD_ERR_INT interrupt.
          SLV_CMD_ERR_INT_ST: u1,

          /// [17:17] The status bit for SPI_MST_RX_AFIFO_WFULL_ERR_INT interrupt.
          MST_RX_AFIFO_WFULL_ERR_INT_ST: u1,

          /// [18:18] The status bit for SPI_MST_TX_AFIFO_REMPTY_ERR_INT interrupt.
          MST_TX_AFIFO_REMPTY_ERR_INT_ST: u1,

          /// [19:19] The status bit for SPI_APP2_INT interrupt.
          APP2_INT_ST: u1,

          /// [20:20] The status bit for SPI_APP1_INT interrupt.
          APP1_INT_ST: u1,

          /// [21:31] 
          res0: u11,

        }), @ptrFromInt(0x60081040));

        /// SPI interrupt software set register
        pub const DMA_INT_SET = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] The software set bit for SPI_DMA_INFIFO_FULL_ERR_INT interrupt.
          DMA_INFIFO_FULL_ERR_INT_SET: u1,

          /// [1:1] The software set bit for SPI_DMA_OUTFIFO_EMPTY_ERR_INT interrupt.
          DMA_OUTFIFO_EMPTY_ERR_INT_SET: u1,

          /// [2:2] The software set bit for SPI slave Ex_QPI interrupt.
          SLV_EX_QPI_INT_SET: u1,

          /// [3:3] The software set bit for SPI slave En_QPI interrupt.
          SLV_EN_QPI_INT_SET: u1,

          /// [4:4] The software set bit for SPI slave CMD7 interrupt.
          SLV_CMD7_INT_SET: u1,

          /// [5:5] The software set bit for SPI slave CMD8 interrupt.
          SLV_CMD8_INT_SET: u1,

          /// [6:6] The software set bit for SPI slave CMD9 interrupt.
          SLV_CMD9_INT_SET: u1,

          /// [7:7] The software set bit for SPI slave CMDA interrupt.
          SLV_CMDA_INT_SET: u1,

          /// [8:8] The software set bit for SPI_SLV_RD_DMA_DONE_INT interrupt.
          SLV_RD_DMA_DONE_INT_SET: u1,

          /// [9:9] The software set bit for SPI_SLV_WR_DMA_DONE_INT interrupt.
          SLV_WR_DMA_DONE_INT_SET: u1,

          /// [10:10] The software set bit for SPI_SLV_RD_BUF_DONE_INT interrupt.
          SLV_RD_BUF_DONE_INT_SET: u1,

          /// [11:11] The software set bit for SPI_SLV_WR_BUF_DONE_INT interrupt.
          SLV_WR_BUF_DONE_INT_SET: u1,

          /// [12:12] The software set bit for SPI_TRANS_DONE_INT interrupt.
          TRANS_DONE_INT_SET: u1,

          /// [13:13] The software set bit for SPI_DMA_SEG_TRANS_DONE_INT interrupt.
          DMA_SEG_TRANS_DONE_INT_SET: u1,

          /// [14:14] The software set bit for SPI_SEG_MAGIC_ERR_INT interrupt.
          SEG_MAGIC_ERR_INT_SET: u1,

          /// [15:15] The software set bit for SPI_SLV_BUF_ADDR_ERR_INT interrupt.
          SLV_BUF_ADDR_ERR_INT_SET: u1,

          /// [16:16] The software set bit for SPI_SLV_CMD_ERR_INT interrupt.
          SLV_CMD_ERR_INT_SET: u1,

          /// [17:17] The software set bit for SPI_MST_RX_AFIFO_WFULL_ERR_INT interrupt.
          MST_RX_AFIFO_WFULL_ERR_INT_SET: u1,

          /// [18:18] The software set bit for SPI_MST_TX_AFIFO_REMPTY_ERR_INT interrupt.
          MST_TX_AFIFO_REMPTY_ERR_INT_SET: u1,

          /// [19:19] The software set bit for SPI_APP2_INT interrupt.
          APP2_INT_SET: u1,

          /// [20:20] The software set bit for SPI_APP1_INT interrupt.
          APP1_INT_SET: u1,

          /// [21:31] 
          res0: u11,

        }), @ptrFromInt(0x60081044));

        /// SPI CPU-controlled buffer0
        pub const W0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] data buffer
          BUF0: u32,

        }), @ptrFromInt(0x60081098));

        /// SPI CPU-controlled buffer1
        pub const W1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] data buffer
          BUF1: u32,

        }), @ptrFromInt(0x6008109c));

        /// SPI CPU-controlled buffer2
        pub const W2 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] data buffer
          BUF2: u32,

        }), @ptrFromInt(0x600810a0));

        /// SPI CPU-controlled buffer3
        pub const W3 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] data buffer
          BUF3: u32,

        }), @ptrFromInt(0x600810a4));

        /// SPI CPU-controlled buffer4
        pub const W4 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] data buffer
          BUF4: u32,

        }), @ptrFromInt(0x600810a8));

        /// SPI CPU-controlled buffer5
        pub const W5 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] data buffer
          BUF5: u32,

        }), @ptrFromInt(0x600810ac));

        /// SPI CPU-controlled buffer6
        pub const W6 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] data buffer
          BUF6: u32,

        }), @ptrFromInt(0x600810b0));

        /// SPI CPU-controlled buffer7
        pub const W7 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] data buffer
          BUF7: u32,

        }), @ptrFromInt(0x600810b4));

        /// SPI CPU-controlled buffer8
        pub const W8 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] data buffer
          BUF8: u32,

        }), @ptrFromInt(0x600810b8));

        /// SPI CPU-controlled buffer9
        pub const W9 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] data buffer
          BUF9: u32,

        }), @ptrFromInt(0x600810bc));

        /// SPI CPU-controlled buffer10
        pub const W10 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] data buffer
          BUF10: u32,

        }), @ptrFromInt(0x600810c0));

        /// SPI CPU-controlled buffer11
        pub const W11 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] data buffer
          BUF11: u32,

        }), @ptrFromInt(0x600810c4));

        /// SPI CPU-controlled buffer12
        pub const W12 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] data buffer
          BUF12: u32,

        }), @ptrFromInt(0x600810c8));

        /// SPI CPU-controlled buffer13
        pub const W13 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] data buffer
          BUF13: u32,

        }), @ptrFromInt(0x600810cc));

        /// SPI CPU-controlled buffer14
        pub const W14 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] data buffer
          BUF14: u32,

        }), @ptrFromInt(0x600810d0));

        /// SPI CPU-controlled buffer15
        pub const W15 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] data buffer
          BUF15: u32,

        }), @ptrFromInt(0x600810d4));

        /// SPI slave control register
        pub const SLAVE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:1] SPI clock mode bits. 0: SPI clock is off when CS inactive 1: SPI clock is delayed one cycle after CS inactive 2: SPI clock is delayed two cycles after CS inactive 3: SPI clock is alwasy on. Can be configured in CONF state.
          CLK_MODE: u2,

          /// [2:2] {CPOL, CPHA},1: support spi clk mode 1 and 3, first edge output data B[0]/B[7].0: support spi clk mode 0 and 2, first edge output data B[1]/B[6].
          CLK_MODE_13: u1,

          /// [3:3] It saves half a cycle when tsck is the same as rsck. 1: output data at rsck posedge 0: output data at tsck posedge
          RSCK_DATA_OUT: u1,

          /// [4:7] 
          res0: u4,

          /// [8:8] 1: SPI_SLV_DATA_BITLEN stores data bit length of master-read-slave data length in DMA controlled mode(Rd_DMA). 0: others
          SLV_RDDMA_BITLEN_EN: u1,

          /// [9:9] 1: SPI_SLV_DATA_BITLEN stores data bit length of master-write-to-slave data length in DMA controlled mode(Wr_DMA). 0: others
          SLV_WRDMA_BITLEN_EN: u1,

          /// [10:10] 1: SPI_SLV_DATA_BITLEN stores data bit length of master-read-slave data length in CPU controlled mode(Rd_BUF). 0: others
          SLV_RDBUF_BITLEN_EN: u1,

          /// [11:11] 1: SPI_SLV_DATA_BITLEN stores data bit length of master-write-to-slave data length in CPU controlled mode(Wr_BUF). 0: others
          SLV_WRBUF_BITLEN_EN: u1,

          /// [12:21] 
          res1: u10,

          /// [22:25] The magic value of BM table in master DMA seg-trans.
          DMA_SEG_MAGIC_VALUE: u4,

          /// [26:26] Set SPI work mode. 1: slave mode 0: master mode.
          MODE: u1,

          /// [27:27] Software reset enable, reset the spi clock line cs line and data lines. Can be configured in CONF state.
          SOFT_RESET: u1,

          /// [28:28] 1: Enable the DMA CONF phase of current seg-trans operation, which means seg-trans will start. 0: This is not seg-trans mode.
          USR_CONF: u1,

          /// [29:29] In master full-duplex mode, 1: GP-SPI will wait DMA TX data is ready before starting SPI transfer. 0: GP-SPI does not wait DMA TX data before starting SPI transfer.
          MST_FD_WAIT_DMA_TX_DATA: u1,

          /// [30:31] 
          res2: u2,

        }), @ptrFromInt(0x600810e0));

        /// SPI slave control register 1
        pub const SLAVE1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:17] The transferred data bit length in SPI slave FD and HD mode.
          SLV_DATA_BITLEN: u18,

          /// [18:25] In the slave mode it is the value of command.
          SLV_LAST_COMMAND: u8,

          /// [26:31] In the slave mode it is the value of address.
          SLV_LAST_ADDR: u6,

        }), @ptrFromInt(0x600810e4));

        /// SPI module clock and register clock control
        pub const CLK_GATE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Set this bit to enable clk gate
          CLK_EN: u1,

          /// [1:1] Set this bit to power on the SPI module clock.
          MST_CLK_ACTIVE: u1,

          /// [2:2] This bit is used to select SPI module clock source in master mode. 1: PLL_CLK_80M. 0: XTAL CLK.
          MST_CLK_SEL: u1,

          /// [3:31] 
          res0: u29,

        }), @ptrFromInt(0x600810e8));

        /// Version control
        pub const DATE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:27] SPI register version.
          DATE: u28,

          /// [28:31] 
          res0: u4,

        }), @ptrFromInt(0x600810f0));

      };

      /// System Timer
      pub const SYSTIMER = struct {

        /// Configure system timer clock
        pub const CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] systimer clock force on
          SYSTIMER_CLK_FO: u1,

          /// [1:1] enable systimer's etm task and event
          ETM_EN: u1,

          /// [2:21] 
          res0: u20,

          /// [22:22] target2 work enable
          TARGET2_WORK_EN: u1,

          /// [23:23] target1 work enable
          TARGET1_WORK_EN: u1,

          /// [24:24] target0 work enable
          TARGET0_WORK_EN: u1,

          /// [25:25] If timer unit1 is stalled when core1 stalled
          TIMER_UNIT1_CORE1_STALL_EN: u1,

          /// [26:26] If timer unit1 is stalled when core0 stalled
          TIMER_UNIT1_CORE0_STALL_EN: u1,

          /// [27:27] If timer unit0 is stalled when core1 stalled
          TIMER_UNIT0_CORE1_STALL_EN: u1,

          /// [28:28] If timer unit0 is stalled when core0 stalled
          TIMER_UNIT0_CORE0_STALL_EN: u1,

          /// [29:29] timer unit1 work enable
          TIMER_UNIT1_WORK_EN: u1,

          /// [30:30] timer unit0 work enable
          TIMER_UNIT0_WORK_EN: u1,

          /// [31:31] register file clk gating
          CLK_EN: u1,

        }), @ptrFromInt(0x6000a000));

        /// system timer unit0 value update register
        pub const UNIT0_OP = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:28] 
          res0: u29,

          /// [29:29] timer value is sync and valid
          TIMER_UNIT0_VALUE_VALID: u1,

          /// [30:30] update timer_unit0
          TIMER_UNIT0_UPDATE: u1,

          /// [31:31] 
          res1: u1,

        }), @ptrFromInt(0x6000a004));

        /// system timer unit1 value update register
        pub const UNIT1_OP = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:28] 
          res0: u29,

          /// [29:29] timer value is sync and valid
          TIMER_UNIT1_VALUE_VALID: u1,

          /// [30:30] update timer unit1
          TIMER_UNIT1_UPDATE: u1,

          /// [31:31] 
          res1: u1,

        }), @ptrFromInt(0x6000a008));

        /// system timer unit0 value high load register
        pub const UNIT0_LOAD_HI = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:19] timer unit0 load high 20 bits
          TIMER_UNIT0_LOAD_HI: u20,

          /// [20:31] 
          res0: u12,

        }), @ptrFromInt(0x6000a00c));

        /// system timer unit0 value low load register
        pub const UNIT0_LOAD_LO = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] timer unit0 load low 32 bits
          TIMER_UNIT0_LOAD_LO: u32,

        }), @ptrFromInt(0x6000a010));

        /// system timer unit1 value high load register
        pub const UNIT1_LOAD_HI = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:19] timer unit1 load high 20 bits
          TIMER_UNIT1_LOAD_HI: u20,

          /// [20:31] 
          res0: u12,

        }), @ptrFromInt(0x6000a014));

        /// system timer unit1 value low load register
        pub const UNIT1_LOAD_LO = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] timer unit1 load low 32 bits
          TIMER_UNIT1_LOAD_LO: u32,

        }), @ptrFromInt(0x6000a018));

        /// system timer comp0 value high register
        pub const TARGET0_HI = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:19] timer taget0 high 20 bits
          TIMER_TARGET0_HI: u20,

          /// [20:31] 
          res0: u12,

        }), @ptrFromInt(0x6000a01c));

        /// system timer comp0 value low register
        pub const TARGET0_LO = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] timer taget0 low 32 bits
          TIMER_TARGET0_LO: u32,

        }), @ptrFromInt(0x6000a020));

        /// system timer comp1 value high register
        pub const TARGET1_HI = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:19] timer taget1 high 20 bits
          TIMER_TARGET1_HI: u20,

          /// [20:31] 
          res0: u12,

        }), @ptrFromInt(0x6000a024));

        /// system timer comp1 value low register
        pub const TARGET1_LO = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] timer taget1 low 32 bits
          TIMER_TARGET1_LO: u32,

        }), @ptrFromInt(0x6000a028));

        /// system timer comp2 value high register
        pub const TARGET2_HI = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:19] timer taget2 high 20 bits
          TIMER_TARGET2_HI: u20,

          /// [20:31] 
          res0: u12,

        }), @ptrFromInt(0x6000a02c));

        /// system timer comp2 value low register
        pub const TARGET2_LO = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] timer taget2 low 32 bits
          TIMER_TARGET2_LO: u32,

        }), @ptrFromInt(0x6000a030));

        /// system timer comp0 target mode register
        pub const TARGET0_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:25] target0 period
          TARGET0_PERIOD: u26,

          /// [26:29] 
          res0: u4,

          /// [30:30] Set target0 to period mode
          TARGET0_PERIOD_MODE: u1,

          /// [31:31] select which unit to compare
          TARGET0_TIMER_UNIT_SEL: u1,

        }), @ptrFromInt(0x6000a034));

        /// system timer comp1 target mode register
        pub const TARGET1_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:25] target1 period
          TARGET1_PERIOD: u26,

          /// [26:29] 
          res0: u4,

          /// [30:30] Set target1 to period mode
          TARGET1_PERIOD_MODE: u1,

          /// [31:31] select which unit to compare
          TARGET1_TIMER_UNIT_SEL: u1,

        }), @ptrFromInt(0x6000a038));

        /// system timer comp2 target mode register
        pub const TARGET2_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:25] target2 period
          TARGET2_PERIOD: u26,

          /// [26:29] 
          res0: u4,

          /// [30:30] Set target2 to period mode
          TARGET2_PERIOD_MODE: u1,

          /// [31:31] select which unit to compare
          TARGET2_TIMER_UNIT_SEL: u1,

        }), @ptrFromInt(0x6000a03c));

        /// system timer unit0 value high register
        pub const UNIT0_VALUE_HI = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:19] timer read value high 20bits
          TIMER_UNIT0_VALUE_HI: u20,

          /// [20:31] 
          res0: u12,

        }), @ptrFromInt(0x6000a040));

        /// system timer unit0 value low register
        pub const UNIT0_VALUE_LO = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] timer read value low 32bits
          TIMER_UNIT0_VALUE_LO: u32,

        }), @ptrFromInt(0x6000a044));

        /// system timer unit1 value high register
        pub const UNIT1_VALUE_HI = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:19] timer read value high 20bits
          TIMER_UNIT1_VALUE_HI: u20,

          /// [20:31] 
          res0: u12,

        }), @ptrFromInt(0x6000a048));

        /// system timer unit1 value low register
        pub const UNIT1_VALUE_LO = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] timer read value low 32bits
          TIMER_UNIT1_VALUE_LO: u32,

        }), @ptrFromInt(0x6000a04c));

        /// system timer comp0 conf sync register
        pub const COMP0_LOAD = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] timer comp0 sync enable signal
          TIMER_COMP0_LOAD: u1,

          /// [1:31] 
          res0: u31,

        }), @ptrFromInt(0x6000a050));

        /// system timer comp1 conf sync register
        pub const COMP1_LOAD = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] timer comp1 sync enable signal
          TIMER_COMP1_LOAD: u1,

          /// [1:31] 
          res0: u31,

        }), @ptrFromInt(0x6000a054));

        /// system timer comp2 conf sync register
        pub const COMP2_LOAD = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] timer comp2 sync enable signal
          TIMER_COMP2_LOAD: u1,

          /// [1:31] 
          res0: u31,

        }), @ptrFromInt(0x6000a058));

        /// system timer unit0 conf sync register
        pub const UNIT0_LOAD = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] timer unit0 sync enable signal
          TIMER_UNIT0_LOAD: u1,

          /// [1:31] 
          res0: u31,

        }), @ptrFromInt(0x6000a05c));

        /// system timer unit1 conf sync register
        pub const UNIT1_LOAD = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] timer unit1 sync enable signal
          TIMER_UNIT1_LOAD: u1,

          /// [1:31] 
          res0: u31,

        }), @ptrFromInt(0x6000a060));

        /// systimer interrupt enable register
        pub const INT_ENA = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] interupt0 enable
          TARGET0_INT_ENA: u1,

          /// [1:1] interupt1 enable
          TARGET1_INT_ENA: u1,

          /// [2:2] interupt2 enable
          TARGET2_INT_ENA: u1,

          /// [3:31] 
          res0: u29,

        }), @ptrFromInt(0x6000a064));

        /// systimer interrupt raw register
        pub const INT_RAW = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] interupt0 raw
          TARGET0_INT_RAW: u1,

          /// [1:1] interupt1 raw
          TARGET1_INT_RAW: u1,

          /// [2:2] interupt2 raw
          TARGET2_INT_RAW: u1,

          /// [3:31] 
          res0: u29,

        }), @ptrFromInt(0x6000a068));

        /// systimer interrupt clear register
        pub const INT_CLR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] interupt0 clear
          TARGET0_INT_CLR: u1,

          /// [1:1] interupt1 clear
          TARGET1_INT_CLR: u1,

          /// [2:2] interupt2 clear
          TARGET2_INT_CLR: u1,

          /// [3:31] 
          res0: u29,

        }), @ptrFromInt(0x6000a06c));

        /// systimer interrupt status register
        pub const INT_ST = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] interupt0 status
          TARGET0_INT_ST: u1,

          /// [1:1] interupt1 status
          TARGET1_INT_ST: u1,

          /// [2:2] interupt2 status
          TARGET2_INT_ST: u1,

          /// [3:31] 
          res0: u29,

        }), @ptrFromInt(0x6000a070));

        /// system timer comp0 actual target value low register
        pub const REAL_TARGET0_LO = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] actual target value value low 32bits
          TARGET0_LO_RO: u32,

        }), @ptrFromInt(0x6000a074));

        /// system timer comp0 actual target value high register
        pub const REAL_TARGET0_HI = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:19] actual target value value high 20bits
          TARGET0_HI_RO: u20,

          /// [20:31] 
          res0: u12,

        }), @ptrFromInt(0x6000a078));

        /// system timer comp1 actual target value low register
        pub const REAL_TARGET1_LO = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] actual target value value low 32bits
          TARGET1_LO_RO: u32,

        }), @ptrFromInt(0x6000a07c));

        /// system timer comp1 actual target value high register
        pub const REAL_TARGET1_HI = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:19] actual target value value high 20bits
          TARGET1_HI_RO: u20,

          /// [20:31] 
          res0: u12,

        }), @ptrFromInt(0x6000a080));

        /// system timer comp2 actual target value low register
        pub const REAL_TARGET2_LO = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] actual target value value low 32bits
          TARGET2_LO_RO: u32,

        }), @ptrFromInt(0x6000a084));

        /// system timer comp2 actual target value high register
        pub const REAL_TARGET2_HI = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:19] actual target value value high 20bits
          TARGET2_HI_RO: u20,

          /// [20:31] 
          res0: u12,

        }), @ptrFromInt(0x6000a088));

        /// system timer version control register
        pub const DATE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] systimer register version
          DATE: u32,

        }), @ptrFromInt(0x6000a0fc));

      };

      /// TEE Peripheral
      pub const TEE = struct {

        /// Tee mode control register
        pub const M0_MODE_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:1] M0 security level mode: 2'd3: ree_mode2. 2'd2: ree_mode1. 2'd1: ree_mode0. 2'd0: tee_mode
          M0_MODE: u2,

          /// [2:31] 
          res0: u30,

        }), @ptrFromInt(0x60098000));

        /// Tee mode control register
        pub const M1_MODE_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:1] M1 security level mode: 2'd3: ree_mode2. 2'd2: ree_mode1. 2'd1: ree_mode0. 2'd0: tee_mode
          M1_MODE: u2,

          /// [2:31] 
          res0: u30,

        }), @ptrFromInt(0x60098004));

        /// Tee mode control register
        pub const M2_MODE_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:1] M2 security level mode: 2'd3: ree_mode2. 2'd2: ree_mode1. 2'd1: ree_mode0. 2'd0: tee_mode
          M2_MODE: u2,

          /// [2:31] 
          res0: u30,

        }), @ptrFromInt(0x60098008));

        /// Tee mode control register
        pub const M3_MODE_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:1] M3 security level mode: 2'd3: ree_mode2. 2'd2: ree_mode1. 2'd1: ree_mode0. 2'd0: tee_mode
          M3_MODE: u2,

          /// [2:31] 
          res0: u30,

        }), @ptrFromInt(0x6009800c));

        /// Tee mode control register
        pub const M4_MODE_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:1] M4 security level mode: 2'd3: ree_mode2. 2'd2: ree_mode1. 2'd1: ree_mode0. 2'd0: tee_mode
          M4_MODE: u2,

          /// [2:31] 
          res0: u30,

        }), @ptrFromInt(0x60098010));

        /// Tee mode control register
        pub const M5_MODE_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:1] M5 security level mode: 2'd3: ree_mode2. 2'd2: ree_mode1. 2'd1: ree_mode0. 2'd0: tee_mode
          M5_MODE: u2,

          /// [2:31] 
          res0: u30,

        }), @ptrFromInt(0x60098014));

        /// Tee mode control register
        pub const M6_MODE_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:1] M6 security level mode: 2'd3: ree_mode2. 2'd2: ree_mode1. 2'd1: ree_mode0. 2'd0: tee_mode
          M6_MODE: u2,

          /// [2:31] 
          res0: u30,

        }), @ptrFromInt(0x60098018));

        /// Tee mode control register
        pub const M7_MODE_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:1] M7 security level mode: 2'd3: ree_mode2. 2'd2: ree_mode1. 2'd1: ree_mode0. 2'd0: tee_mode
          M7_MODE: u2,

          /// [2:31] 
          res0: u30,

        }), @ptrFromInt(0x6009801c));

        /// Tee mode control register
        pub const M8_MODE_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:1] M8 security level mode: 2'd3: ree_mode2. 2'd2: ree_mode1. 2'd1: ree_mode0. 2'd0: tee_mode
          M8_MODE: u2,

          /// [2:31] 
          res0: u30,

        }), @ptrFromInt(0x60098020));

        /// Tee mode control register
        pub const M9_MODE_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:1] M9 security level mode: 2'd3: ree_mode2. 2'd2: ree_mode1. 2'd1: ree_mode0. 2'd0: tee_mode
          M9_MODE: u2,

          /// [2:31] 
          res0: u30,

        }), @ptrFromInt(0x60098024));

        /// Tee mode control register
        pub const M10_MODE_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:1] M10 security level mode: 2'd3: ree_mode2. 2'd2: ree_mode1. 2'd1: ree_mode0. 2'd0: tee_mode
          M10_MODE: u2,

          /// [2:31] 
          res0: u30,

        }), @ptrFromInt(0x60098028));

        /// Tee mode control register
        pub const M11_MODE_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:1] M11 security level mode: 2'd3: ree_mode2. 2'd2: ree_mode1. 2'd1: ree_mode0. 2'd0: tee_mode
          M11_MODE: u2,

          /// [2:31] 
          res0: u30,

        }), @ptrFromInt(0x6009802c));

        /// Tee mode control register
        pub const M12_MODE_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:1] M12 security level mode: 2'd3: ree_mode2. 2'd2: ree_mode1. 2'd1: ree_mode0. 2'd0: tee_mode
          M12_MODE: u2,

          /// [2:31] 
          res0: u30,

        }), @ptrFromInt(0x60098030));

        /// Tee mode control register
        pub const M13_MODE_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:1] M13 security level mode: 2'd3: ree_mode2. 2'd2: ree_mode1. 2'd1: ree_mode0. 2'd0: tee_mode
          M13_MODE: u2,

          /// [2:31] 
          res0: u30,

        }), @ptrFromInt(0x60098034));

        /// Tee mode control register
        pub const M14_MODE_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:1] M14 security level mode: 2'd3: ree_mode2. 2'd2: ree_mode1. 2'd1: ree_mode0. 2'd0: tee_mode
          M14_MODE: u2,

          /// [2:31] 
          res0: u30,

        }), @ptrFromInt(0x60098038));

        /// Tee mode control register
        pub const M15_MODE_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:1] M15 security level mode: 2'd3: ree_mode2. 2'd2: ree_mode1. 2'd1: ree_mode0. 2'd0: tee_mode
          M15_MODE: u2,

          /// [2:31] 
          res0: u30,

        }), @ptrFromInt(0x6009803c));

        /// Tee mode control register
        pub const M16_MODE_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:1] M16 security level mode: 2'd3: ree_mode2. 2'd2: ree_mode1. 2'd1: ree_mode0. 2'd0: tee_mode
          M16_MODE: u2,

          /// [2:31] 
          res0: u30,

        }), @ptrFromInt(0x60098040));

        /// Tee mode control register
        pub const M17_MODE_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:1] M17 security level mode: 2'd3: ree_mode2. 2'd2: ree_mode1. 2'd1: ree_mode0. 2'd0: tee_mode
          M17_MODE: u2,

          /// [2:31] 
          res0: u30,

        }), @ptrFromInt(0x60098044));

        /// Tee mode control register
        pub const M18_MODE_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:1] M18 security level mode: 2'd3: ree_mode2. 2'd2: ree_mode1. 2'd1: ree_mode0. 2'd0: tee_mode
          M18_MODE: u2,

          /// [2:31] 
          res0: u30,

        }), @ptrFromInt(0x60098048));

        /// Tee mode control register
        pub const M19_MODE_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:1] M19 security level mode: 2'd3: ree_mode2. 2'd2: ree_mode1. 2'd1: ree_mode0. 2'd0: tee_mode
          M19_MODE: u2,

          /// [2:31] 
          res0: u30,

        }), @ptrFromInt(0x6009804c));

        /// Tee mode control register
        pub const M20_MODE_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:1] M20 security level mode: 2'd3: ree_mode2. 2'd2: ree_mode1. 2'd1: ree_mode0. 2'd0: tee_mode
          M20_MODE: u2,

          /// [2:31] 
          res0: u30,

        }), @ptrFromInt(0x60098050));

        /// Tee mode control register
        pub const M21_MODE_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:1] M21 security level mode: 2'd3: ree_mode2. 2'd2: ree_mode1. 2'd1: ree_mode0. 2'd0: tee_mode
          M21_MODE: u2,

          /// [2:31] 
          res0: u30,

        }), @ptrFromInt(0x60098054));

        /// Tee mode control register
        pub const M22_MODE_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:1] M22 security level mode: 2'd3: ree_mode2. 2'd2: ree_mode1. 2'd1: ree_mode0. 2'd0: tee_mode
          M22_MODE: u2,

          /// [2:31] 
          res0: u30,

        }), @ptrFromInt(0x60098058));

        /// Tee mode control register
        pub const M23_MODE_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:1] M23 security level mode: 2'd3: ree_mode2. 2'd2: ree_mode1. 2'd1: ree_mode0. 2'd0: tee_mode
          M23_MODE: u2,

          /// [2:31] 
          res0: u30,

        }), @ptrFromInt(0x6009805c));

        /// Tee mode control register
        pub const M24_MODE_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:1] M24 security level mode: 2'd3: ree_mode2. 2'd2: ree_mode1. 2'd1: ree_mode0. 2'd0: tee_mode
          M24_MODE: u2,

          /// [2:31] 
          res0: u30,

        }), @ptrFromInt(0x60098060));

        /// Tee mode control register
        pub const M25_MODE_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:1] M25 security level mode: 2'd3: ree_mode2. 2'd2: ree_mode1. 2'd1: ree_mode0. 2'd0: tee_mode
          M25_MODE: u2,

          /// [2:31] 
          res0: u30,

        }), @ptrFromInt(0x60098064));

        /// Tee mode control register
        pub const M26_MODE_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:1] M26 security level mode: 2'd3: ree_mode2. 2'd2: ree_mode1. 2'd1: ree_mode0. 2'd0: tee_mode
          M26_MODE: u2,

          /// [2:31] 
          res0: u30,

        }), @ptrFromInt(0x60098068));

        /// Tee mode control register
        pub const M27_MODE_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:1] M27 security level mode: 2'd3: ree_mode2. 2'd2: ree_mode1. 2'd1: ree_mode0. 2'd0: tee_mode
          M27_MODE: u2,

          /// [2:31] 
          res0: u30,

        }), @ptrFromInt(0x6009806c));

        /// Tee mode control register
        pub const M28_MODE_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:1] M28 security level mode: 2'd3: ree_mode2. 2'd2: ree_mode1. 2'd1: ree_mode0. 2'd0: tee_mode
          M28_MODE: u2,

          /// [2:31] 
          res0: u30,

        }), @ptrFromInt(0x60098070));

        /// Tee mode control register
        pub const M29_MODE_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:1] M29 security level mode: 2'd3: ree_mode2. 2'd2: ree_mode1. 2'd1: ree_mode0. 2'd0: tee_mode
          M29_MODE: u2,

          /// [2:31] 
          res0: u30,

        }), @ptrFromInt(0x60098074));

        /// Tee mode control register
        pub const M30_MODE_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:1] M30 security level mode: 2'd3: ree_mode2. 2'd2: ree_mode1. 2'd1: ree_mode0. 2'd0: tee_mode
          M30_MODE: u2,

          /// [2:31] 
          res0: u30,

        }), @ptrFromInt(0x60098078));

        /// Tee mode control register
        pub const M31_MODE_CTRL = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:1] M31 security level mode: 2'd3: ree_mode2. 2'd2: ree_mode1. 2'd1: ree_mode0. 2'd0: tee_mode
          M31_MODE: u2,

          /// [2:31] 
          res0: u30,

        }), @ptrFromInt(0x6009807c));

        /// Clock gating register
        pub const CLOCK_GATE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] reg_clk_en
          CLK_EN: u1,

          /// [1:31] 
          res0: u31,

        }), @ptrFromInt(0x60098080));

        /// Version register
        pub const DATE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:27] reg_tee_date
          DATE: u28,

          /// [28:31] 
          res0: u4,

        }), @ptrFromInt(0x60098ffc));

      };

      /// Timer Group 0
      pub const TIMG0 = struct {

        /// Timer %s configuration register
        pub const T0CONFIG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:8] 
          res0: u9,

          /// [9:9] 1: Use XTAL_CLK as the source clock of timer group. 0: Use APB_CLK as the source clock of timer group.
          USE_XTAL: u1,

          /// [10:10] When set, the alarm is enabled. This bit is automatically cleared once analarm occurs.
          ALARM_EN: u1,

          /// [11:11] 
          res1: u1,

          /// [12:12] When set, Timer %s 's clock divider counter will be reset.
          DIVCNT_RST: u1,

          /// [13:28] Timer %s clock (T%s_clk) prescaler value.
          DIVIDER: u16,

          /// [29:29] When set, timer %s auto-reload at alarm is enabled.
          AUTORELOAD: u1,

          /// [30:30] When set, the timer %s time-base counter will increment every clock tick. Whencleared, the timer %s time-base counter will decrement.
          INCREASE: u1,

          /// [31:31] When set, the timer %s time-base counter is enabled.
          EN: u1,

        }), @ptrFromInt(0x60008000));

        /// Timer %s current value, low 32 bits
        pub const T0LO = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] After writing to TIMG_T%sUPDATE_REG, the low 32 bits of the time-base counterof timer %s can be read here.
          LO: u32,

        }), @ptrFromInt(0x60008004));

        /// Timer %s current value, high 22 bits
        pub const T0HI = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:21] After writing to TIMG_T%sUPDATE_REG, the high 22 bits of the time-base counterof timer %s can be read here.
          HI: u22,

          /// [22:31] 
          res0: u10,

        }), @ptrFromInt(0x60008008));

        /// Write to copy current timer value to TIMGn_T%s_(LO/HI)_REG
        pub const T0UPDATE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:30] 
          res0: u31,

          /// [31:31] After writing 0 or 1 to TIMG_T%sUPDATE_REG, the counter value is latched.
          UPDATE: u1,

        }), @ptrFromInt(0x6000800c));

        /// Timer %s alarm value, low 32 bits
        pub const T0ALARMLO = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Timer %s alarm trigger time-base counter value, low 32 bits.
          ALARM_LO: u32,

        }), @ptrFromInt(0x60008010));

        /// Timer %s alarm value, high bits
        pub const T0ALARMHI = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:21] Timer %s alarm trigger time-base counter value, high 22 bits.
          ALARM_HI: u22,

          /// [22:31] 
          res0: u10,

        }), @ptrFromInt(0x60008014));

        /// Timer %s reload value, low 32 bits
        pub const T0LOADLO = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Low 32 bits of the value that a reload will load onto timer %s time-baseCounter.
          LOAD_LO: u32,

        }), @ptrFromInt(0x60008018));

        /// Timer %s reload value, high 22 bits
        pub const T0LOADHI = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:21] High 22 bits of the value that a reload will load onto timer %s time-basecounter.
          LOAD_HI: u22,

          /// [22:31] 
          res0: u10,

        }), @ptrFromInt(0x6000801c));

        /// Write to reload timer from TIMG_T%s_(LOADLOLOADHI)_REG
        pub const T0LOAD = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Write any value to trigger a timer %s time-base counter reload.
          LOAD: u32,

        }), @ptrFromInt(0x60008020));

        /// Watchdog timer configuration register
        pub const WDTCONFIG0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:11] 
          res0: u12,

          /// [12:12] WDT reset CPU enable.
          WDT_APPCPU_RESET_EN: u1,

          /// [13:13] WDT reset CPU enable.
          WDT_PROCPU_RESET_EN: u1,

          /// [14:14] When set, Flash boot protection is enabled.
          WDT_FLASHBOOT_MOD_EN: u1,

          /// [15:17] System reset signal length selection. 0: 100 ns, 1: 200 ns,2: 300 ns, 3: 400 ns, 4: 500 ns, 5: 800 ns, 6: 1.6 us, 7: 3.2 us.
          WDT_SYS_RESET_LENGTH: u3,

          /// [18:20] CPU reset signal length selection. 0: 100 ns, 1: 200 ns,2: 300 ns, 3: 400 ns, 4: 500 ns, 5: 800 ns, 6: 1.6 us, 7: 3.2 us.
          WDT_CPU_RESET_LENGTH: u3,

          /// [21:21] choose WDT clock:0-apb_clk, 1-xtal_clk.
          WDT_USE_XTAL: u1,

          /// [22:22] update the WDT configuration registers
          WDT_CONF_UPDATE_EN: u1,

          /// [23:24] Stage 3 configuration. 0: off, 1: interrupt, 2: reset CPU, 3: reset system.
          WDT_STG3: u2,

          /// [25:26] Stage 2 configuration. 0: off, 1: interrupt, 2: reset CPU, 3: reset system.
          WDT_STG2: u2,

          /// [27:28] Stage 1 configuration. 0: off, 1: interrupt, 2: reset CPU, 3: reset system.
          WDT_STG1: u2,

          /// [29:30] Stage 0 configuration. 0: off, 1: interrupt, 2: reset CPU, 3: reset system.
          WDT_STG0: u2,

          /// [31:31] When set, MWDT is enabled.
          WDT_EN: u1,

        }), @ptrFromInt(0x60008048));

        /// Watchdog timer prescaler register
        pub const WDTCONFIG1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] When set, WDT 's clock divider counter will be reset.
          WDT_DIVCNT_RST: u1,

          /// [1:15] 
          res0: u15,

          /// [16:31] MWDT clock prescaler value. MWDT clock period = 12.5 ns *TIMG_WDT_CLK_PRESCALE.
          WDT_CLK_PRESCALE: u16,

        }), @ptrFromInt(0x6000804c));

        /// Watchdog timer stage 0 timeout value
        pub const WDTCONFIG2 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Stage 0 timeout value, in MWDT clock cycles.
          WDT_STG0_HOLD: u32,

        }), @ptrFromInt(0x60008050));

        /// Watchdog timer stage 1 timeout value
        pub const WDTCONFIG3 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Stage 1 timeout value, in MWDT clock cycles.
          WDT_STG1_HOLD: u32,

        }), @ptrFromInt(0x60008054));

        /// Watchdog timer stage 2 timeout value
        pub const WDTCONFIG4 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Stage 2 timeout value, in MWDT clock cycles.
          WDT_STG2_HOLD: u32,

        }), @ptrFromInt(0x60008058));

        /// Watchdog timer stage 3 timeout value
        pub const WDTCONFIG5 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Stage 3 timeout value, in MWDT clock cycles.
          WDT_STG3_HOLD: u32,

        }), @ptrFromInt(0x6000805c));

        /// Write to feed the watchdog timer
        pub const WDTFEED = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Write any value to feed the MWDT. (WO)
          WDT_FEED: u32,

        }), @ptrFromInt(0x60008060));

        /// Watchdog write protect register
        pub const WDTWPROTECT = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] If the register contains a different value than its reset value, writeprotection is enabled.
          WDT_WKEY: u32,

        }), @ptrFromInt(0x60008064));

        /// RTC calibration configure register
        pub const RTCCALICFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:11] 
          res0: u12,

          /// [12:12] 0: one-shot frequency calculation,1: periodic frequency calculation,
          RTC_CALI_START_CYCLING: u1,

          /// [13:14] 0:rtc slow clock. 1:clk_8m, 2:xtal_32k.
          RTC_CALI_CLK_SEL: u2,

          /// [15:15] indicate one-shot frequency calculation is done.
          RTC_CALI_RDY: u1,

          /// [16:30] Configure the time to calculate RTC slow clock's frequency.
          RTC_CALI_MAX: u15,

          /// [31:31] Set this bit to start one-shot frequency calculation.
          RTC_CALI_START: u1,

        }), @ptrFromInt(0x60008068));

        /// RTC calibration configure1 register
        pub const RTCCALICFG1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] indicate periodic frequency calculation is done.
          RTC_CALI_CYCLING_DATA_VLD: u1,

          /// [1:6] 
          res0: u6,

          /// [7:31] When one-shot or periodic frequency calculation is done, read this value to calculate RTC slow clock's frequency.
          RTC_CALI_VALUE: u25,

        }), @ptrFromInt(0x6000806c));

        /// Interrupt enable bits
        pub const INT_ENA_TIMERS = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] The interrupt enable bit for the TIMG_T0_INT interrupt.
          T0_INT_ENA: u1,

          /// [1:1] The interrupt enable bit for the TIMG_WDT_INT interrupt.
          WDT_INT_ENA: u1,

          /// [2:31] 
          res0: u30,

        }), @ptrFromInt(0x60008070));

        /// Raw interrupt status
        pub const INT_RAW_TIMERS = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] The raw interrupt status bit for the TIMG_T0_INT interrupt.
          T0_INT_RAW: u1,

          /// [1:1] The raw interrupt status bit for the TIMG_WDT_INT interrupt.
          WDT_INT_RAW: u1,

          /// [2:31] 
          res0: u30,

        }), @ptrFromInt(0x60008074));

        /// Masked interrupt status
        pub const INT_ST_TIMERS = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] The masked interrupt status bit for the TIMG_T0_INT interrupt.
          T0_INT_ST: u1,

          /// [1:1] The masked interrupt status bit for the TIMG_WDT_INT interrupt.
          WDT_INT_ST: u1,

          /// [2:31] 
          res0: u30,

        }), @ptrFromInt(0x60008078));

        /// Interrupt clear bits
        pub const INT_CLR_TIMERS = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Set this bit to clear the TIMG_T0_INT interrupt.
          T0_INT_CLR: u1,

          /// [1:1] Set this bit to clear the TIMG_WDT_INT interrupt.
          WDT_INT_CLR: u1,

          /// [2:31] 
          res0: u30,

        }), @ptrFromInt(0x6000807c));

        /// Timer group calibration register
        pub const RTCCALICFG2 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] RTC calibration timeout indicator
          RTC_CALI_TIMEOUT: u1,

          /// [1:2] 
          res0: u2,

          /// [3:6] Cycles that release calibration timeout reset
          RTC_CALI_TIMEOUT_RST_CNT: u4,

          /// [7:31] Threshold value for the RTC calibration timer. If the calibration timer's value exceeds this threshold, a timeout is triggered.
          RTC_CALI_TIMEOUT_THRES: u25,

        }), @ptrFromInt(0x60008080));

        /// Timer version control register
        pub const NTIMERS_DATE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:27] Timer version control register
          NTIMGS_DATE: u28,

          /// [28:31] 
          res0: u4,

        }), @ptrFromInt(0x600080f8));

        /// Timer group clock gate register
        pub const REGCLK = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:27] 
          res0: u28,

          /// [28:28] enable timer's etm task and event
          ETM_EN: u1,

          /// [29:29] enable WDT's clock
          WDT_CLK_IS_ACTIVE: u1,

          /// [30:30] enable Timer 30's clock
          TIMER_CLK_IS_ACTIVE: u1,

          /// [31:31] Register clock gate signal. 1: Registers can be read and written to by software. 0: Registers can not be read or written to by software.
          CLK_EN: u1,

        }), @ptrFromInt(0x600080fc));

      };

      /// Timer Group 1
      pub const TIMG1 = struct {

      };

      /// TRACE Peripheral
      pub const TRACE = struct {

        /// mem start addr
        pub const MEM_START_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] The start address of trace memory
          MEM_STAET_ADDR: u32,

        }), @ptrFromInt(0x600c0000));

        /// mem end addr
        pub const MEM_END_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] The end address of trace memory
          MEM_END_ADDR: u32,

        }), @ptrFromInt(0x600c0004));

        /// mem current addr
        pub const MEM_CURRENT_ADDR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] current_mem_addr,indicate that next writing addr
          MEM_CURRENT_ADDR: u32,

        }), @ptrFromInt(0x600c0008));

        /// mem addr update
        pub const MEM_ADDR_UPDATE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] when set this reg, the current_mem_addr will update to start_addr
          MEM_CURRENT_ADDR_UPDATE: u1,

          /// [1:31] 
          res0: u31,

        }), @ptrFromInt(0x600c000c));

        /// fifo status register
        pub const FIFO_STATUS = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] 1 indicate that fifo is empty
          FIFO_EMPTY: u1,

          /// [1:1] mem_full interrupt status
          WORK_STATUS: u1,

          /// [2:31] 
          res0: u30,

        }), @ptrFromInt(0x600c0010));

        /// interrupt enable register
        pub const INTR_ENA = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Set 1 enable fifo_overflow interrupt
          FIFO_OVERFLOW_INTR_ENA: u1,

          /// [1:1] Set 1 enable mem_full interrupt
          MEM_FULL_INTR_ENA: u1,

          /// [2:31] 
          res0: u30,

        }), @ptrFromInt(0x600c0014));

        /// interrupt status register
        pub const INTR_RAW = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] fifo_overflow interrupt status
          FIFO_OVERFLOW_INTR_RAW: u1,

          /// [1:1] mem_full interrupt status
          MEM_FULL_INTR_RAW: u1,

          /// [2:31] 
          res0: u30,

        }), @ptrFromInt(0x600c0018));

        /// interrupt clear register
        pub const INTR_CLR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Set 1 clr fifo overflow interrupt
          FIFO_OVERFLOW_INTR_CLR: u1,

          /// [1:1] Set 1 clr mem full interrupt
          MEM_FULL_INTR_CLR: u1,

          /// [2:31] 
          res0: u30,

        }), @ptrFromInt(0x600c001c));

        /// trigger register
        pub const TRIGGER = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] [0] set 1 start trace.
          ON: u1,

          /// [1:1] set 1 stop trace.
          OFF: u1,

          /// [2:2] if this reg is 1, trace will loop wrtie trace_mem.If is 0, when mem_current_addr at mem_end_addr, it will stop at the mem_end_addr
          MEM_LOOP: u1,

          /// [3:3] enable encoder auto-restart, when lost package, the encoder will end, if enable auto-restart, when fifo empty, encoder will restart and send a sync package.
          RESTART_ENA: u1,

          /// [4:31] 
          res0: u28,

        }), @ptrFromInt(0x600c0020));

        /// resync configuration register
        pub const RESYNC_PROLONGED = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:23] count number, when count to this value, send a sync package
          RESYNC_PROLONGED: u24,

          /// [24:24] resyc mode sel: 0: default, cycle count 1: package num count
          RESYNC_MODE: u1,

          /// [25:31] 
          res0: u7,

        }), @ptrFromInt(0x600c0024));

        /// Clock gate control register
        pub const CLOCK_GATE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] The bit is used to enable clock gate when access all registers in this module.
          CLK_EN: u1,

          /// [1:31] 
          res0: u31,

        }), @ptrFromInt(0x600c0028));

        /// Version control register
        pub const DATE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:27] version control register. Note that this default value stored is the latest date when the hardware logic was updated.
          DATE: u28,

          /// [28:31] 
          res0: u4,

        }), @ptrFromInt(0x600c03fc));

      };

      /// Two-Wire Automotive Interface
      pub const TWAI0 = struct {

        /// TWAI mode register.
        pub const MODE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] 1: reset, detection of a set reset mode bit results in aborting the current transmission/reception of a message and entering the reset mode. 0: normal, on the '1-to-0' transition of the reset mode bit, the TWAI controller returns to the operating mode.
          RESET_MODE: u1,

          /// [1:1] 1: listen only, in this mode the TWAI controller would give no acknowledge to the TWAI-bus, even if a message is received successfully. The error counters are stopped at the current value. 0: normal.
          LISTEN_ONLY_MODE: u1,

          /// [2:2] 1: self test, in this mode a full node test is possible without any other active node on the bus using the self reception request command. The TWAI controller will perform a successful transmission, even if there is no acknowledge received. 0: normal, an acknowledge is required for successful transmission.
          SELF_TEST_MODE: u1,

          /// [3:3] 1:single, the single acceptance filter option is enabled (one filter with the length of 32 bit is active). 0:dual, the dual acceptance filter option is enabled (two filters, each with the length of 16 bit are active).
          RX_FILTER_MODE: u1,

          /// [4:31] 
          res0: u28,

        }), @ptrFromInt(0x6000b000));

        /// TWAI command register.
        pub const CMD = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] 1: present, a message shall be transmitted. 0: absent
          TX_REQ: u1,

          /// [1:1] 1: present, if not already in progress, a pending transmission request is cancelled. 0: absent
          ABORT_TX: u1,

          /// [2:2] 1: released, the receive buffer, representing the message memory space in the RXFIFO is released. 0: no action
          RELEASE_BUF: u1,

          /// [3:3] 1: clear, the data overrun status bit is cleared. 0: no action.
          CLEAR_DATA_OVERRUN: u1,

          /// [4:4] 1: present, a message shall be transmitted and received simultaneously. 0: absent.
          SELF_RX_REQUEST: u1,

          /// [5:31] 
          res0: u27,

        }), @ptrFromInt(0x6000b004));

        /// TWAI status register.
        pub const STATUS = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] 1: full, one or more complete messages are available in the RXFIFO. 0: empty, no message is available
          RX_BUF_ST: u1,

          /// [1:1] 1: overrun, a message was lost because there was not enough space for that message in the RXFIFO. 0: absent, no data overrun has occurred since the last clear data overrun command was given
          OVERRUN: u1,

          /// [2:2] 1: released, the CPU may write a message into the transmit buffer. 0: locked, the CPU cannot access the transmit buffer, a message is either waiting for transmission or is in the process of being transmitted
          TX_BUF_ST: u1,

          /// [3:3] 1: complete, last requested transmission has been successfully completed. 0: incomplete, previously requested transmission is not yet completed
          TRANSMISSION_COMPLETE: u1,

          /// [4:4] 1: receive, the TWAI controller is receiving a message. 0: idle
          RECEIVE: u1,

          /// [5:5] 1: transmit, the TWAI controller is transmitting a message. 0: idle
          TRANSMIT: u1,

          /// [6:6] 1: error, at least one of the error counters has reached or exceeded the CPU warning limit defined by the Error Warning Limit Register (EWLR). 0: ok, both error counters are below the warning limit
          ERR: u1,

          /// [7:7] 1: bus-off, the TWAI controller is not involved in bus activities. 0: bus-on, the TWAI controller is involved in bus activities
          BUS_OFF_ST: u1,

          /// [8:8] 1: current message is destroyed because of FIFO overflow.
          MISS_ST: u1,

          /// [9:31] 
          res0: u23,

        }), @ptrFromInt(0x6000b008));

        /// Interrupt signals' register.
        pub const INTERRUPT = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] 1: this bit is set while the receive FIFO is not empty and the RIE bit is set within the interrupt enable register. 0: reset
          RECEIVE_INT_ST: u1,

          /// [1:1] 1: this bit is set whenever the transmit buffer status changes from '0-to-1' (released) and the TIE bit is set within the interrupt enable register. 0: reset
          TRANSMIT_INT_ST: u1,

          /// [2:2] 1: this bit is set on every change (set and clear) of either the error status or bus status bits and the EIE bit is set within the interrupt enable register. 0: reset
          ERR_WARNING_INT_ST: u1,

          /// [3:3] 1: this bit is set on a '0-to-1' transition of the data overrun status bit and the DOIE bit is set within the interrupt enable register. 0: reset
          DATA_OVERRUN_INT_ST: u1,

          /// [4:4] 
          res0: u1,

          /// [5:5] 1: this bit is set whenever the TWAI controller has reached the error passive status (at least one error counter exceeds the protocol-defined level of 127) or if the TWAI controller is in the error passive status and enters the error active status again and the EPIE bit is set within the interrupt enable register. 0: reset
          ERR_PASSIVE_INT_ST: u1,

          /// [6:6] 1: this bit is set when the TWAI controller lost the arbitration and becomes a receiver and the ALIE bit is set within the interrupt enable register. 0: reset
          ARBITRATION_LOST_INT_ST: u1,

          /// [7:7] 1: this bit is set when the TWAI controller detects an error on the TWAI-bus and the BEIE bit is set within the interrupt enable register. 0: reset
          BUS_ERR_INT_ST: u1,

          /// [8:8] 1: this bit is set when the TWAI controller detects state of TWAI become IDLE and this interrupt enable bit is set within the interrupt enable register. 0: reset
          IDLE_INT_ST: u1,

          /// [9:31] 
          res1: u23,

        }), @ptrFromInt(0x6000b00c));

        /// Interrupt enable register.
        pub const INTERRUPT_ENABLE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] 1: enabled, when the receive buffer status is 'full' the TWAI controller requests the respective interrupt. 0: disable
          EXT_RECEIVE_INT_ENA: u1,

          /// [1:1] 1: enabled, when a message has been successfully transmitted or the transmit buffer is accessible again (e.g. after an abort transmission command), the TWAI controller requests the respective interrupt. 0: disable
          EXT_TRANSMIT_INT_ENA: u1,

          /// [2:2] 1: enabled, if the error or bus status change (see status register. Table 14), the TWAI controllerrequests the respective interrupt. 0: disable
          EXT_ERR_WARNING_INT_ENA: u1,

          /// [3:3] 1: enabled, if the data overrun status bit is set (see status register. Table 14), the TWAI controllerrequests the respective interrupt. 0: disable
          EXT_DATA_OVERRUN_INT_ENA: u1,

          /// [4:4] 
          res0: u1,

          /// [5:5] 1: enabled, if the error status of the TWAI controller changes from error active to error passive or vice versa, the respective interrupt is requested. 0: disable
          ERR_PASSIVE_INT_ENA: u1,

          /// [6:6] 1: enabled, if the TWAI controller has lost arbitration, the respective interrupt is requested. 0: disable
          ARBITRATION_LOST_INT_ENA: u1,

          /// [7:7] 1: enabled, if an bus error has been detected, the TWAI controller requests the respective interrupt. 0: disable
          BUS_ERR_INT_ENA: u1,

          /// [8:8] 1: enabled, if state of TWAI become IDLE, the TWAI controller requests the respective interrupt. 0: disable
          IDLE_INT_ENA: u1,

          /// [9:31] 
          res1: u23,

        }), @ptrFromInt(0x6000b010));

        /// Bit timing configuration register 0.
        pub const BUS_TIMING_0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:13] The period of the TWAI system clock is programmable and determines the individual bit timing. Software has R/W permission in reset mode and RO permission in operation mode.
          BAUD_PRESC: u14,

          /// [14:15] The synchronization jump width defines the maximum number of clock cycles a bit period may be shortened or lengthened. Software has R/W permission in reset mode and RO in operation mode.
          SYNC_JUMP_WIDTH: u2,

          /// [16:31] 
          res0: u16,

        }), @ptrFromInt(0x6000b018));

        /// Bit timing configuration register 1.
        pub const BUS_TIMING_1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:3] The number of clock cycles in TSEG1 per bit timing. Software has R/W permission in reset mode and RO in operation mode.
          TIME_SEG1: u4,

          /// [4:6] The number of clock cycles in TSEG2 per bit timing. Software has R/W permission in reset mode and RO in operation mode.
          TIME_SEG2: u3,

          /// [7:7] 1: triple, the bus is sampled three times. 0: single, the bus is sampled once. Software has R/W permission in reset mode and RO in operation mode.
          TIME_SAMP: u1,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x6000b01c));

        /// TWAI arbiter lost capture register.
        pub const ARB_LOST_CAP = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:4] This register contains information about the bit position of losing arbitration.
          ARBITRATION_LOST_CAPTURE: u5,

          /// [5:31] 
          res0: u27,

        }), @ptrFromInt(0x6000b02c));

        /// TWAI error info capture register.
        pub const ERR_CODE_CAP = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:4] This register contains information about the location of errors on the bus.
          ERR_CAPTURE_CODE_SEGMENT: u5,

          /// [5:5] 1: RX, error occurred during reception. 0: TX, error occurred during transmission.
          ERR_CAPTURE_CODE_DIRECTION: u1,

          /// [6:7] 00: bit error. 01: form error. 10:stuff error. 11:other type of error.
          ERR_CAPTURE_CODE_TYPE: u2,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x6000b030));

        /// TWAI error threshold configuration register.
        pub const ERR_WARNING_LIMIT = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] The threshold that trigger error warning interrupt when this interrupt is enabled. Software has R/W permission in reset mode and RO in operation mode.
          ERR_WARNING_LIMIT: u8,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x6000b034));

        /// Rx error counter register.
        pub const RX_ERR_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] The RX error counter register reflects the current value of the transmit error counter. Software has R/W permission in reset mode and RO in operation mode.
          RX_ERR_CNT: u8,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x6000b038));

        /// Tx error counter register.
        pub const TX_ERR_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] The TX error counter register reflects the current value of the transmit error counter. Software has R/W permission in reset mode and RO in operation mode.
          TX_ERR_CNT: u8,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x6000b03c));

        /// Data register 0.
        pub const DATA_0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] In reset mode, it is acceptance code register 0 with R/W Permission. In operation mode, when software initiate write operation, it is tx data register 0 and when software initiate read operation, it is rx data register 0.
          TX_BYTE_0: u8,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x6000b040));

        /// Data register 1.
        pub const DATA_1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] In reset mode, it is acceptance code register 1 with R/W Permission. In operation mode, when software initiate write operation, it is tx data register 1 and when software initiate read operation, it is rx data register 1.
          TX_BYTE_1: u8,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x6000b044));

        /// Data register 2.
        pub const DATA_2 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] In reset mode, it is acceptance code register 2 with R/W Permission. In operation mode, when software initiate write operation, it is tx data register 2 and when software initiate read operation, it is rx data register 2.
          TX_BYTE_2: u8,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x6000b048));

        /// Data register 3.
        pub const DATA_3 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] In reset mode, it is acceptance code register 3 with R/W Permission. In operation mode, when software initiate write operation, it is tx data register 3 and when software initiate read operation, it is rx data register 3.
          TX_BYTE_3: u8,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x6000b04c));

        /// Data register 4.
        pub const DATA_4 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] In reset mode, it is acceptance mask register 0 with R/W Permission. In operation mode, when software initiate write operation, it is tx data register 4 and when software initiate read operation, it is rx data register 4.
          TX_BYTE_4: u8,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x6000b050));

        /// Data register 5.
        pub const DATA_5 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] In reset mode, it is acceptance mask register 1 with R/W Permission. In operation mode, when software initiate write operation, it is tx data register 5 and when software initiate read operation, it is rx data register 5.
          TX_BYTE_5: u8,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x6000b054));

        /// Data register 6.
        pub const DATA_6 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] In reset mode, it is acceptance mask register 2 with R/W Permission. In operation mode, when software initiate write operation, it is tx data register 6 and when software initiate read operation, it is rx data register 6.
          TX_BYTE_6: u8,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x6000b058));

        /// Data register 7.
        pub const DATA_7 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] In reset mode, it is acceptance mask register 3 with R/W Permission. In operation mode, when software initiate write operation, it is tx data register 7 and when software initiate read operation, it is rx data register 7.
          TX_BYTE_7: u8,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x6000b05c));

        /// Data register 8.
        pub const DATA_8 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] In reset mode, reserved with RO. In operation mode, when software initiate write operation, it is tx data register 8 and when software initiate read operation, it is rx data register 8.
          TX_BYTE_8: u8,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x6000b060));

        /// Data register 9.
        pub const DATA_9 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] In reset mode, reserved with RO. In operation mode, when software initiate write operation, it is tx data register 9 and when software initiate read operation, it is rx data register 9.
          DATA_9: u8,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x6000b064));

        /// Data register 10.
        pub const DATA_10 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] In reset mode, reserved with RO. In operation mode, when software initiate write operation, it is tx data register 10 and when software initiate read operation, it is rx data register 10.
          TX_BYTE_10: u8,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x6000b068));

        /// Data register 11.
        pub const DATA_11 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] In reset mode, reserved with RO. In operation mode, when software initiate write operation, it is tx data register 11 and when software initiate read operation, it is rx data register 11.
          TX_BYTE_11: u8,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x6000b06c));

        /// Data register 12.
        pub const DATA_12 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] In reset mode, reserved with RO. In operation mode, when software initiate write operation, it is tx data register 12 and when software initiate read operation, it is rx data register 12.
          TX_BYTE_12: u8,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x6000b070));

        /// Received message counter register.
        pub const RX_MESSAGE_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:6] Reflects the number of messages available within the RXFIFO. The value is incremented with each receive event and decremented by the release receive buffer command.
          RX_MESSAGE_COUNTER: u7,

          /// [7:31] 
          res0: u25,

        }), @ptrFromInt(0x6000b074));

        /// Clock divider register.
        pub const CLOCK_DIVIDER = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] These bits are used to define the frequency at the external CLKOUT pin.
          CD: u8,

          /// [8:8] 1: Disable the external CLKOUT pin. 0: Enable the external CLKOUT pin. Software has R/W permission in reset mode and RO in operation mode.
          CLOCK_OFF: u1,

          /// [9:31] 
          res0: u23,

        }), @ptrFromInt(0x6000b07c));

        /// Software configure standby pin directly.
        pub const SW_STANDBY_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Enable standby pin.
          SW_STANDBY_EN: u1,

          /// [1:1] Clear standby pin.
          SW_STANDBY_CLR: u1,

          /// [2:31] 
          res0: u30,

        }), @ptrFromInt(0x6000b080));

        /// Hardware configure standby pin.
        pub const HW_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Enable function that hardware control standby pin.
          HW_STANDBY_EN: u1,

          /// [1:31] 
          res0: u31,

        }), @ptrFromInt(0x6000b084));

        /// Configure standby counter.
        pub const HW_STANDBY_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Configure the number of cycles before standby becomes high when TWAI_HW_STANDBY_EN is enabled.
          STANDBY_WAIT_CNT: u32,

        }), @ptrFromInt(0x6000b088));

        /// Configure idle interrupt counter.
        pub const IDLE_INTR_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Configure the number of cycles before triggering idle interrupt.
          IDLE_INTR_CNT: u32,

        }), @ptrFromInt(0x6000b08c));

        /// ECO configuration register.
        pub const ECO_CFG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Enable eco module.
          RDN_ENA: u1,

          /// [1:1] Output of eco module.
          RDN_RESULT: u1,

          /// [2:31] 
          res0: u30,

        }), @ptrFromInt(0x6000b090));

      };

      /// Two-Wire Automotive Interface
      pub const TWAI1 = struct {

      };

      /// UART (Universal Asynchronous Receiver-Transmitter) Controller 0
      pub const UART0 = struct {

        /// FIFO data register
        pub const FIFO = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] UART 0 accesses FIFO via this register.
          RXFIFO_RD_BYTE: u8,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x60000000));

        /// Raw interrupt status
        pub const INT_RAW = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] This interrupt raw bit turns to high level when receiver receives more data than what rxfifo_full_thrhd specifies.
          RXFIFO_FULL_INT_RAW: u1,

          /// [1:1] This interrupt raw bit turns to high level when the amount of data in Tx-FIFO is less than what txfifo_empty_thrhd specifies .
          TXFIFO_EMPTY_INT_RAW: u1,

          /// [2:2] This interrupt raw bit turns to high level when receiver detects a parity error in the data.
          PARITY_ERR_INT_RAW: u1,

          /// [3:3] This interrupt raw bit turns to high level when receiver detects a data frame error .
          FRM_ERR_INT_RAW: u1,

          /// [4:4] This interrupt raw bit turns to high level when receiver receives more data than the FIFO can store.
          RXFIFO_OVF_INT_RAW: u1,

          /// [5:5] This interrupt raw bit turns to high level when receiver detects the edge change of DSRn signal.
          DSR_CHG_INT_RAW: u1,

          /// [6:6] This interrupt raw bit turns to high level when receiver detects the edge change of CTSn signal.
          CTS_CHG_INT_RAW: u1,

          /// [7:7] This interrupt raw bit turns to high level when receiver detects a 0 after the stop bit.
          BRK_DET_INT_RAW: u1,

          /// [8:8] This interrupt raw bit turns to high level when receiver takes more time than rx_tout_thrhd to receive a byte.
          RXFIFO_TOUT_INT_RAW: u1,

          /// [9:9] This interrupt raw bit turns to high level when receiver recevies Xon char when uart_sw_flow_con_en is set to 1.
          SW_XON_INT_RAW: u1,

          /// [10:10] This interrupt raw bit turns to high level when receiver receives Xoff char when uart_sw_flow_con_en is set to 1.
          SW_XOFF_INT_RAW: u1,

          /// [11:11] This interrupt raw bit turns to high level when receiver detects a glitch in the middle of a start bit.
          GLITCH_DET_INT_RAW: u1,

          /// [12:12] This interrupt raw bit turns to high level when transmitter completessendingNULL characters after all data in Tx-FIFO are sent.
          TX_BRK_DONE_INT_RAW: u1,

          /// [13:13] This interrupt raw bit turns to high level when transmitter has kept the shortest duration after sending thelast data.
          TX_BRK_IDLE_DONE_INT_RAW: u1,

          /// [14:14] This interrupt raw bit turns to high level when transmitter has send out all data in FIFO.
          TX_DONE_INT_RAW: u1,

          /// [15:15] This interrupt raw bit turns to high level when receiver detects a parity error from the echo of transmitter in rs485 mode.
          RS485_PARITY_ERR_INT_RAW: u1,

          /// [16:16] This interrupt raw bit turns to high level when receiver detects a data frame error from the echo of transmitter in rs485 mode.
          RS485_FRM_ERR_INT_RAW: u1,

          /// [17:17] This interrupt raw bit turns to high level when detects a clash between transmitter and receiver in rs485 mode.
          RS485_CLASH_INT_RAW: u1,

          /// [18:18] This interrupt raw bit turns to high level when receiver detects the configured at_cmd char.
          AT_CMD_CHAR_DET_INT_RAW: u1,

          /// [19:19] This interrupt raw bit turns to high level when input rxd edge changes more times than what reg_active_threshold specifies in light sleeping mode.
          WAKEUP_INT_RAW: u1,

          /// [20:31] 
          res0: u12,

        }), @ptrFromInt(0x60000004));

        /// Masked interrupt status
        pub const INT_ST = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] This is the status bit for rxfifo_full_int_raw when rxfifo_full_int_ena is set to 1.
          RXFIFO_FULL_INT_ST: u1,

          /// [1:1] This is the status bit fortxfifo_empty_int_rawwhen txfifo_empty_int_ena is set to 1.
          TXFIFO_EMPTY_INT_ST: u1,

          /// [2:2] This is the status bit for parity_err_int_raw when parity_err_int_ena is set to 1.
          PARITY_ERR_INT_ST: u1,

          /// [3:3] This is the status bit for frm_err_int_raw when frm_err_int_ena is set to 1.
          FRM_ERR_INT_ST: u1,

          /// [4:4] This is the status bit for rxfifo_ovf_int_raw when rxfifo_ovf_int_ena is set to 1.
          RXFIFO_OVF_INT_ST: u1,

          /// [5:5] This is the status bit for dsr_chg_int_raw when dsr_chg_int_ena is set to 1.
          DSR_CHG_INT_ST: u1,

          /// [6:6] This is the status bit for cts_chg_int_raw when cts_chg_int_ena is set to 1.
          CTS_CHG_INT_ST: u1,

          /// [7:7] This is the status bit for brk_det_int_raw when brk_det_int_ena is set to 1.
          BRK_DET_INT_ST: u1,

          /// [8:8] This is the status bit for rxfifo_tout_int_raw when rxfifo_tout_int_ena is set to 1.
          RXFIFO_TOUT_INT_ST: u1,

          /// [9:9] This is the status bit for sw_xon_int_raw when sw_xon_int_ena is set to 1.
          SW_XON_INT_ST: u1,

          /// [10:10] This is the status bit for sw_xoff_int_raw when sw_xoff_int_ena is set to 1.
          SW_XOFF_INT_ST: u1,

          /// [11:11] This is the status bit for glitch_det_int_raw when glitch_det_int_ena is set to 1.
          GLITCH_DET_INT_ST: u1,

          /// [12:12] This is the status bit for tx_brk_done_int_raw when tx_brk_done_int_ena is set to 1.
          TX_BRK_DONE_INT_ST: u1,

          /// [13:13] This is the stauts bit for tx_brk_idle_done_int_raw when tx_brk_idle_done_int_ena is set to 1.
          TX_BRK_IDLE_DONE_INT_ST: u1,

          /// [14:14] This is the status bit for tx_done_int_raw when tx_done_int_ena is set to 1.
          TX_DONE_INT_ST: u1,

          /// [15:15] This is the status bit for rs485_parity_err_int_raw when rs485_parity_int_ena is set to 1.
          RS485_PARITY_ERR_INT_ST: u1,

          /// [16:16] This is the status bit for rs485_frm_err_int_raw when rs485_fm_err_int_ena is set to 1.
          RS485_FRM_ERR_INT_ST: u1,

          /// [17:17] This is the status bit for rs485_clash_int_raw when rs485_clash_int_ena is set to 1.
          RS485_CLASH_INT_ST: u1,

          /// [18:18] This is the status bit for at_cmd_det_int_raw when at_cmd_char_det_int_ena is set to 1.
          AT_CMD_CHAR_DET_INT_ST: u1,

          /// [19:19] This is the status bit for uart_wakeup_int_raw when uart_wakeup_int_ena is set to 1.
          WAKEUP_INT_ST: u1,

          /// [20:31] 
          res0: u12,

        }), @ptrFromInt(0x60000008));

        /// Interrupt enable bits
        pub const INT_ENA = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] This is the enable bit for rxfifo_full_int_st register.
          RXFIFO_FULL_INT_ENA: u1,

          /// [1:1] This is the enable bit for txfifo_empty_int_st register.
          TXFIFO_EMPTY_INT_ENA: u1,

          /// [2:2] This is the enable bit for parity_err_int_st register.
          PARITY_ERR_INT_ENA: u1,

          /// [3:3] This is the enable bit for frm_err_int_st register.
          FRM_ERR_INT_ENA: u1,

          /// [4:4] This is the enable bit for rxfifo_ovf_int_st register.
          RXFIFO_OVF_INT_ENA: u1,

          /// [5:5] This is the enable bit for dsr_chg_int_st register.
          DSR_CHG_INT_ENA: u1,

          /// [6:6] This is the enable bit for cts_chg_int_st register.
          CTS_CHG_INT_ENA: u1,

          /// [7:7] This is the enable bit for brk_det_int_st register.
          BRK_DET_INT_ENA: u1,

          /// [8:8] This is the enable bit for rxfifo_tout_int_st register.
          RXFIFO_TOUT_INT_ENA: u1,

          /// [9:9] This is the enable bit for sw_xon_int_st register.
          SW_XON_INT_ENA: u1,

          /// [10:10] This is the enable bit for sw_xoff_int_st register.
          SW_XOFF_INT_ENA: u1,

          /// [11:11] This is the enable bit for glitch_det_int_st register.
          GLITCH_DET_INT_ENA: u1,

          /// [12:12] This is the enable bit for tx_brk_done_int_st register.
          TX_BRK_DONE_INT_ENA: u1,

          /// [13:13] This is the enable bit for tx_brk_idle_done_int_st register.
          TX_BRK_IDLE_DONE_INT_ENA: u1,

          /// [14:14] This is the enable bit for tx_done_int_st register.
          TX_DONE_INT_ENA: u1,

          /// [15:15] This is the enable bit for rs485_parity_err_int_st register.
          RS485_PARITY_ERR_INT_ENA: u1,

          /// [16:16] This is the enable bit for rs485_parity_err_int_st register.
          RS485_FRM_ERR_INT_ENA: u1,

          /// [17:17] This is the enable bit for rs485_clash_int_st register.
          RS485_CLASH_INT_ENA: u1,

          /// [18:18] This is the enable bit for at_cmd_char_det_int_st register.
          AT_CMD_CHAR_DET_INT_ENA: u1,

          /// [19:19] This is the enable bit for uart_wakeup_int_st register.
          WAKEUP_INT_ENA: u1,

          /// [20:31] 
          res0: u12,

        }), @ptrFromInt(0x6000000c));

        /// Interrupt clear bits
        pub const INT_CLR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Set this bit to clear the rxfifo_full_int_raw interrupt.
          RXFIFO_FULL_INT_CLR: u1,

          /// [1:1] Set this bit to clear txfifo_empty_int_raw interrupt.
          TXFIFO_EMPTY_INT_CLR: u1,

          /// [2:2] Set this bit to clear parity_err_int_raw interrupt.
          PARITY_ERR_INT_CLR: u1,

          /// [3:3] Set this bit to clear frm_err_int_raw interrupt.
          FRM_ERR_INT_CLR: u1,

          /// [4:4] Set this bit to clear rxfifo_ovf_int_raw interrupt.
          RXFIFO_OVF_INT_CLR: u1,

          /// [5:5] Set this bit to clear the dsr_chg_int_raw interrupt.
          DSR_CHG_INT_CLR: u1,

          /// [6:6] Set this bit to clear the cts_chg_int_raw interrupt.
          CTS_CHG_INT_CLR: u1,

          /// [7:7] Set this bit to clear the brk_det_int_raw interrupt.
          BRK_DET_INT_CLR: u1,

          /// [8:8] Set this bit to clear the rxfifo_tout_int_raw interrupt.
          RXFIFO_TOUT_INT_CLR: u1,

          /// [9:9] Set this bit to clear the sw_xon_int_raw interrupt.
          SW_XON_INT_CLR: u1,

          /// [10:10] Set this bit to clear the sw_xoff_int_raw interrupt.
          SW_XOFF_INT_CLR: u1,

          /// [11:11] Set this bit to clear the glitch_det_int_raw interrupt.
          GLITCH_DET_INT_CLR: u1,

          /// [12:12] Set this bit to clear the tx_brk_done_int_raw interrupt..
          TX_BRK_DONE_INT_CLR: u1,

          /// [13:13] Set this bit to clear the tx_brk_idle_done_int_raw interrupt.
          TX_BRK_IDLE_DONE_INT_CLR: u1,

          /// [14:14] Set this bit to clear the tx_done_int_raw interrupt.
          TX_DONE_INT_CLR: u1,

          /// [15:15] Set this bit to clear the rs485_parity_err_int_raw interrupt.
          RS485_PARITY_ERR_INT_CLR: u1,

          /// [16:16] Set this bit to clear the rs485_frm_err_int_raw interrupt.
          RS485_FRM_ERR_INT_CLR: u1,

          /// [17:17] Set this bit to clear the rs485_clash_int_raw interrupt.
          RS485_CLASH_INT_CLR: u1,

          /// [18:18] Set this bit to clear the at_cmd_char_det_int_raw interrupt.
          AT_CMD_CHAR_DET_INT_CLR: u1,

          /// [19:19] Set this bit to clear the uart_wakeup_int_raw interrupt.
          WAKEUP_INT_CLR: u1,

          /// [20:31] 
          res0: u12,

        }), @ptrFromInt(0x60000010));

        /// Clock divider configuration
        pub const CLKDIV = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:11] The integral part of the frequency divider factor.
          CLKDIV: u12,

          /// [12:19] 
          res0: u8,

          /// [20:23] The decimal part of the frequency divider factor.
          FRAG: u4,

          /// [24:31] 
          res1: u8,

        }), @ptrFromInt(0x60000014));

        /// Rx Filter configuration
        pub const RX_FILT = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] when input pulse width is lower than this value the pulse is ignored.
          GLITCH_FILT: u8,

          /// [8:8] Set this bit to enable Rx signal filter.
          GLITCH_FILT_EN: u1,

          /// [9:31] 
          res0: u23,

        }), @ptrFromInt(0x60000018));

        /// UART status register
        pub const STATUS = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] Stores the byte number of valid data in Rx-FIFO.
          RXFIFO_CNT: u8,

          /// [8:12] 
          res0: u5,

          /// [13:13] The register represent the level value of the internal uart dsr signal.
          DSRN: u1,

          /// [14:14] This register represent the level value of the internal uart cts signal.
          CTSN: u1,

          /// [15:15] This register represent thelevel value of the internal uart rxd signal.
          RXD: u1,

          /// [16:23] Stores the byte number of data in Tx-FIFO.
          TXFIFO_CNT: u8,

          /// [24:28] 
          res1: u5,

          /// [29:29] This bit represents the level of the internal uart dtr signal.
          DTRN: u1,

          /// [30:30] This bit represents the level of the internal uart rts signal.
          RTSN: u1,

          /// [31:31] This bit represents thelevel of the internal uart txd signal.
          TXD: u1,

        }), @ptrFromInt(0x6000001c));

        /// a
        pub const CONF0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] This register is used to configure the parity check mode.
          PARITY: u1,

          /// [1:1] Set this bit to enable uart parity check.
          PARITY_EN: u1,

          /// [2:3] This register is used to set the length of data.
          BIT_NUM: u2,

          /// [4:5] This register is used to set the length ofstop bit.
          STOP_BIT_NUM: u2,

          /// [6:6] Set this bit to enbale transmitter tosend NULL when the process of sending data is done.
          TXD_BRK: u1,

          /// [7:7] Set this bit to enable IrDA loopback mode.
          IRDA_DPLX: u1,

          /// [8:8] This is the start enable bit for IrDA transmitter.
          IRDA_TX_EN: u1,

          /// [9:9] 1'h1: The IrDA transmitter's 11th bit is the same as 10th bit. 1'h0: Set IrDA transmitter's 11th bit to 0.
          IRDA_WCTL: u1,

          /// [10:10] Set this bit to invert the level ofIrDA transmitter.
          IRDA_TX_INV: u1,

          /// [11:11] Set this bit to invert the level of IrDA receiver.
          IRDA_RX_INV: u1,

          /// [12:12] Set this bit to enable uart loopback test mode.
          LOOPBACK: u1,

          /// [13:13] Set this bit to enable flow control function for transmitter.
          TX_FLOW_EN: u1,

          /// [14:14] Set this bit to enable IrDA protocol.
          IRDA_EN: u1,

          /// [15:15] Set this bit to inverse the level value of uart rxd signal.
          RXD_INV: u1,

          /// [16:16] Set this bit to inverse the level value of uart txd signal.
          TXD_INV: u1,

          /// [17:17] Disable UART Rx data overflow detect.
          DIS_RX_DAT_OVF: u1,

          /// [18:18] 1'h1: Receiver stops storing data into FIFO when data is wrong. 1'h0: Receiver stores the data even if thereceived data is wrong.
          ERR_WR_MASK: u1,

          /// [19:19] This is the enable bit for detecting baudrate.
          AUTOBAUD_EN: u1,

          /// [20:20] UART memory clock gate enable signal.
          MEM_CLK_EN: u1,

          /// [21:21] This register is used to configure the software rts signal which is used in software flow control.
          SW_RTS: u1,

          /// [22:22] Set this bit to reset the uart receive-FIFO.
          RXFIFO_RST: u1,

          /// [23:23] Set this bit to reset the uart transmit-FIFO.
          TXFIFO_RST: u1,

          /// [24:31] 
          res0: u8,

        }), @ptrFromInt(0x60000020));

        /// Configuration register 1
        pub const CONF1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] It will produce rxfifo_full_int interrupt when receiver receives more data than this register value.
          RXFIFO_FULL_THRHD: u8,

          /// [8:15] It will produce txfifo_empty_int interrupt when the data amount in Tx-FIFO is less than this register value.
          TXFIFO_EMPTY_THRHD: u8,

          /// [16:16] Set this bit to inverse the level value of uart cts signal.
          CTS_INV: u1,

          /// [17:17] Set this bit to inverse the level value of uart dsr signal.
          DSR_INV: u1,

          /// [18:18] Set this bit to inverse the level value of uart rts signal.
          RTS_INV: u1,

          /// [19:19] Set this bit to inverse the level value of uart dtr signal.
          DTR_INV: u1,

          /// [20:20] This register is used to configure the software dtr signal which is used in software flow control.
          SW_DTR: u1,

          /// [21:21] 1'h1: Force clock on for register. 1'h0: Support clock only when application writes registers.
          CLK_EN: u1,

          /// [22:31] 
          res0: u10,

        }), @ptrFromInt(0x60000024));

        /// Hardware flow-control configuration
        pub const HWFC_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] This register is used to configure the maximum amount of data that can be receivedwhen hardware flow control works.
          RX_FLOW_THRHD: u8,

          /// [8:8] This is the flow enable bit for UART receiver.
          RX_FLOW_EN: u1,

          /// [9:31] 
          res0: u23,

        }), @ptrFromInt(0x6000002c));

        /// UART sleep configure register 0
        pub const SLEEP_CONF0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] This register restores the specified wake up char1 to wake up
          WK_CHAR1: u8,

          /// [8:15] This register restores the specified wake up char2 to wake up
          WK_CHAR2: u8,

          /// [16:23] This register restores the specified wake up char3 to wake up
          WK_CHAR3: u8,

          /// [24:31] This register restores the specified wake up char4 to wake up
          WK_CHAR4: u8,

        }), @ptrFromInt(0x60000030));

        /// UART sleep configure register 1
        pub const SLEEP_CONF1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] This register restores the specified char0 to wake up
          WK_CHAR0: u8,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x60000034));

        /// UART sleep configure register 2
        pub const SLEEP_CONF2 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:9] The uart is activated from light sleeping mode when the input rxd edge changes more times than this register value.
          ACTIVE_THRESHOLD: u10,

          /// [10:17] In wake up mode 1 this field is used to set the received data number threshold to wake up chip.
          RX_WAKE_UP_THRHD: u8,

          /// [18:20] This register is used to select number of wake up char.
          WK_CHAR_NUM: u3,

          /// [21:25] This register is used to maskwake up char.
          WK_CHAR_MASK: u5,

          /// [26:27] This register is used to select wake up mode. 0: RXD toggling to wake up. 1: received data number larger than
          WK_MODE_SEL: u2,

          /// [28:31] 
          res0: u4,

        }), @ptrFromInt(0x60000038));

        /// Software flow-control character configuration
        pub const SWFC_CONF0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] This register stores the Xon flow control char.
          XON_CHAR: u8,

          /// [8:15] This register stores the Xoff flow control char.
          XOFF_CHAR: u8,

          /// [16:16] In software flow control mode, UART Tx is disabled once UART Rx receives XOFF. In this status, UART Tx can not transmit XOFF even the received data number is larger than UART_XOFF_THRESHOLD. Set this bit to enable UART Tx can transmit XON/XOFF when UART Tx is disabled.
          XON_XOFF_STILL_SEND: u1,

          /// [17:17] Set this bit to enable software flow control. It is used with register sw_xon or sw_xoff.
          SW_FLOW_CON_EN: u1,

          /// [18:18] Set this bit to remove flow control char from the received data.
          XONOFF_DEL: u1,

          /// [19:19] Set this bit to enable the transmitter to go on sending data.
          FORCE_XON: u1,

          /// [20:20] Set this bit to stop thetransmitter from sending data.
          FORCE_XOFF: u1,

          /// [21:21] Set this bit to send Xon char. It is cleared by hardware automatically.
          SEND_XON: u1,

          /// [22:22] Set this bit to send Xoff char. It is cleared by hardware automatically.
          SEND_XOFF: u1,

          /// [23:31] 
          res0: u9,

        }), @ptrFromInt(0x6000003c));

        /// Software flow-control character configuration
        pub const SWFC_CONF1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] When the data amount in Rx-FIFO is less than this register value with uart_sw_flow_con_en set to 1it will send a Xon char.
          XON_THRESHOLD: u8,

          /// [8:15] When the data amount in Rx-FIFO is more than this register value with uart_sw_flow_con_en set to 1it will send a Xoff char.
          XOFF_THRESHOLD: u8,

          /// [16:31] 
          res0: u16,

        }), @ptrFromInt(0x60000040));

        /// Tx Break character configuration
        pub const TXBRK_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] This register is used to configure the number of 0 to be sent after the process of sending data is done. It is active when txd_brk is set to 1.
          TX_BRK_NUM: u8,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x60000044));

        /// Frame-end idle configuration
        pub const IDLE_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:9] It will produce frame end signal when receiver takes more time to receive one byte data than this register value.
          RX_IDLE_THRHD: u10,

          /// [10:19] This register is used to configure the duration time between transfers.
          TX_IDLE_NUM: u10,

          /// [20:31] 
          res0: u12,

        }), @ptrFromInt(0x60000048));

        /// RS485 mode configuration
        pub const RS485_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Set this bit to choose the rs485 mode.
          RS485_EN: u1,

          /// [1:1] Set this bit to delay the stop bit by 1 bit.
          DL0_EN: u1,

          /// [2:2] Set this bit to delay the stop bit by 1 bit.
          DL1_EN: u1,

          /// [3:3] Set this bit to enable receiver could receive data when the transmitter is transmitting data in rs485 mode.
          RS485TX_RX_EN: u1,

          /// [4:4] 1'h1: enable rs485 transmitter to send data when rs485 receiver line is busy.
          RS485RXBY_TX_EN: u1,

          /// [5:5] This register is used to delay the receiver's internal data signal.
          RS485_RX_DLY_NUM: u1,

          /// [6:9] This register is used to delay the transmitter's internal data signal.
          RS485_TX_DLY_NUM: u4,

          /// [10:31] 
          res0: u22,

        }), @ptrFromInt(0x6000004c));

        /// Pre-sequence timing configuration
        pub const AT_CMD_PRECNT = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:15] This register is used to configure the idle duration time before the first at_cmd is received by receiver.
          PRE_IDLE_NUM: u16,

          /// [16:31] 
          res0: u16,

        }), @ptrFromInt(0x60000050));

        /// Post-sequence timing configuration
        pub const AT_CMD_POSTCNT = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:15] This register is used to configure the duration time between the last at_cmd and the next data.
          POST_IDLE_NUM: u16,

          /// [16:31] 
          res0: u16,

        }), @ptrFromInt(0x60000054));

        /// Timeout configuration
        pub const AT_CMD_GAPTOUT = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:15] This register is used to configure the duration time between the at_cmd chars.
          RX_GAP_TOUT: u16,

          /// [16:31] 
          res0: u16,

        }), @ptrFromInt(0x60000058));

        /// AT escape sequence detection configuration
        pub const AT_CMD_CHAR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] This register is used to configure the content of at_cmd char.
          AT_CMD_CHAR: u8,

          /// [8:15] This register is used to configure the num of continuous at_cmd chars received by receiver.
          CHAR_NUM: u8,

          /// [16:31] 
          res0: u16,

        }), @ptrFromInt(0x6000005c));

        /// UART memory power configuration
        pub const MEM_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:24] 
          res0: u25,

          /// [25:25] Set this bit to force power down UART memory.
          MEM_FORCE_PD: u1,

          /// [26:26] Set this bit to force power up UART memory.
          MEM_FORCE_PU: u1,

          /// [27:31] 
          res1: u5,

        }), @ptrFromInt(0x60000060));

        /// UART threshold and allocation configuration
        pub const TOUT_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] This is the enble bit for uart receiver's timeout function.
          RX_TOUT_EN: u1,

          /// [1:1] Set this bit to stop accumulating idle_cnt when hardware flow control works.
          RX_TOUT_FLOW_DIS: u1,

          /// [2:11] This register is used to configure the threshold time that receiver takes to receive one byte. The rxfifo_tout_int interrupt will be trigger when the receiver takes more time to receive one byte with rx_tout_en set to 1.
          RX_TOUT_THRHD: u10,

          /// [12:31] 
          res0: u20,

        }), @ptrFromInt(0x60000064));

        /// Tx-SRAM write and read offset address.
        pub const MEM_TX_STATUS = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] This register stores the offset write address in Tx-SRAM.
          TX_SRAM_WADDR: u8,

          /// [8:8] 
          res0: u1,

          /// [9:16] This register stores the offset read address in Tx-SRAM.
          TX_SRAM_RADDR: u8,

          /// [17:31] 
          res1: u15,

        }), @ptrFromInt(0x60000068));

        /// Rx-SRAM write and read offset address.
        pub const MEM_RX_STATUS = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] This register stores the offset read address in RX-SRAM.
          RX_SRAM_RADDR: u8,

          /// [8:8] 
          res0: u1,

          /// [9:16] This register stores the offset write address in Rx-SRAM.
          RX_SRAM_WADDR: u8,

          /// [17:31] 
          res1: u15,

        }), @ptrFromInt(0x6000006c));

        /// UART transmit and receive status.
        pub const FSM_STATUS = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:3] This is the status register of receiver.
          ST_URX_OUT: u4,

          /// [4:7] This is the status register of transmitter.
          ST_UTX_OUT: u4,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x60000070));

        /// Autobaud high pulse register
        pub const POSPULSE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:11] This register stores the minimal input clock count between two positive edges. It is used in boudrate-detect process.
          POSEDGE_MIN_CNT: u12,

          /// [12:31] 
          res0: u20,

        }), @ptrFromInt(0x60000074));

        /// Autobaud low pulse register
        pub const NEGPULSE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:11] This register stores the minimal input clock count between two negative edges. It is used in boudrate-detect process.
          NEGEDGE_MIN_CNT: u12,

          /// [12:31] 
          res0: u20,

        }), @ptrFromInt(0x60000078));

        /// Autobaud minimum low pulse duration register
        pub const LOWPULSE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:11] This register stores the value of the minimum duration time of the low level pulse. It is used in baud rate-detect process.
          MIN_CNT: u12,

          /// [12:31] 
          res0: u20,

        }), @ptrFromInt(0x6000007c));

        /// Autobaud minimum high pulse duration register
        pub const HIGHPULSE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:11] This register storesthe value of the maxinum duration time for the high level pulse. It is used in baud rate-detect process.
          MIN_CNT: u12,

          /// [12:31] 
          res0: u20,

        }), @ptrFromInt(0x60000080));

        /// Autobaud edge change count register
        pub const RXD_CNT = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:9] This register stores the count of rxd edge change. It is used in baud rate-detect process.
          RXD_EDGE_CNT: u10,

          /// [10:31] 
          res0: u22,

        }), @ptrFromInt(0x60000084));

        /// UART core clock configuration
        pub const CLK_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:5] Thedenominator of the frequency divider factor.
          SCLK_DIV_B: u6,

          /// [6:11] The numerator of the frequency divider factor.
          SCLK_DIV_A: u6,

          /// [12:19] The integral part of the frequency divider factor.
          SCLK_DIV_NUM: u8,

          /// [20:21] UART clock source select. 1: 80Mhz.2: 8Mhz.3: XTAL.
          SCLK_SEL: u2,

          /// [22:22] Set this bit to enable UART Tx/Rx clock.
          SCLK_EN: u1,

          /// [23:23] Write 1 then write 0 to this bit to reset UART Tx/Rx.
          RST_CORE: u1,

          /// [24:24] Set this bit to enable UART Tx clock.
          TX_SCLK_EN: u1,

          /// [25:25] Set this bit to enable UART Rx clock.
          RX_SCLK_EN: u1,

          /// [26:26] Write 1 then write 0 to this bit to reset UART Tx.
          TX_RST_CORE: u1,

          /// [27:27] Write 1 then write 0 to this bit to reset UART Rx.
          RX_RST_CORE: u1,

          /// [28:31] 
          res0: u4,

        }), @ptrFromInt(0x60000088));

        /// UART Version register
        pub const DATE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] This is the version register.
          DATE: u32,

        }), @ptrFromInt(0x6000008c));

        /// UART AFIFO Status
        pub const AFIFO_STATUS = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Full signal of APB TX AFIFO.
          TX_AFIFO_FULL: u1,

          /// [1:1] Empty signal of APB TX AFIFO.
          TX_AFIFO_EMPTY: u1,

          /// [2:2] Full signal of APB RX AFIFO.
          RX_AFIFO_FULL: u1,

          /// [3:3] Empty signal of APB RX AFIFO.
          RX_AFIFO_EMPTY: u1,

          /// [4:31] 
          res0: u28,

        }), @ptrFromInt(0x60000090));

        /// UART Registers Configuration Update register
        pub const REG_UPDATE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Software write 1 would synchronize registers into UART Core clock domain and would be cleared by hardware after synchronization is done.
          REG_UPDATE: u1,

          /// [1:31] 
          res0: u31,

        }), @ptrFromInt(0x60000098));

        /// UART ID register
        pub const ID = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] This register is used to configure the uart_id.
          ID: u32,

        }), @ptrFromInt(0x6000009c));

      };

      /// UART (Universal Asynchronous Receiver-Transmitter) Controller 1
      pub const UART1 = struct {

      };

      /// Universal Host Controller Interface 0
      pub const UHCI0 = struct {

        /// UHCI Configuration Register0
        pub const CONF0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Write 1 then write 0 to this bit to reset decode state machine.
          TX_RST: u1,

          /// [1:1] Write 1 then write 0 to this bit to reset encode state machine.
          RX_RST: u1,

          /// [2:2] Set this bit to link up HCI and UART0.
          UART0_CE: u1,

          /// [3:3] Set this bit to link up HCI and UART1.
          UART1_CE: u1,

          /// [4:4] 
          res0: u1,

          /// [5:5] Set this bit to separate the data frame using a special char.
          SEPER_EN: u1,

          /// [6:6] Set this bit to encode the data packet with a formatting header.
          HEAD_EN: u1,

          /// [7:7] Set this bit to enable UHCI to receive the 16 bit CRC.
          CRC_REC_EN: u1,

          /// [8:8] If this bit is set to 1 UHCI will end the payload receiving process when UART has been in idle state.
          UART_IDLE_EOF_EN: u1,

          /// [9:9] If this bit is set to 1 UHCI decoder receiving payload data is end when the receiving byte count has reached the specified value. The value is payload length indicated by UHCI packet header when UHCI_HEAD_EN is 1 or the value is configuration value when UHCI_HEAD_EN is 0. If this bit is set to 0 UHCI decoder receiving payload data is end when 0xc0 is received.
          LEN_EOF_EN: u1,

          /// [10:10] Set this bit to enable data integrity checking by appending a 16 bit CCITT-CRC to end of the payload.
          ENCODE_CRC_EN: u1,

          /// [11:11] 1'b1: Force clock on for register. 1'b0: Support clock only when application writes registers.
          CLK_EN: u1,

          /// [12:12] If this bit is set to 1 UHCI will end payload receive process when NULL frame is received by UART.
          UART_RX_BRK_EOF_EN: u1,

          /// [13:31] 
          res1: u19,

        }), @ptrFromInt(0x60005000));

        /// UHCI Interrupt Raw Register
        pub const INT_RAW = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Indicates the raw interrupt of UHCI_RX_START_INT. Interrupt will be triggered when delimiter is sent successfully.
          RX_START_INT_RAW: u1,

          /// [1:1] Indicates the raw interrupt of UHCI_TX_START_INT. Interrupt will be triggered when DMA detects delimiter.
          TX_START_INT_RAW: u1,

          /// [2:2] Indicates the raw interrupt of UHCI_RX_HUNG_INT. Interrupt will be triggered when the required time of DMA receiving dataexceeds the configuration value.
          RX_HUNG_INT_RAW: u1,

          /// [3:3] Indicates the raw interrupt of UHCI_TX_HUNG_INT. Interrupt will be triggered when the required time of DMA reading RAM dataexceeds the configuration value.
          TX_HUNG_INT_RAW: u1,

          /// [4:4] Indicates the raw interrupt of UHCI_SEND_S_REG_Q_INT. Interrupt will be triggered when UHCI sends short packet successfully with single_send mode.
          SEND_S_REG_Q_INT_RAW: u1,

          /// [5:5] Indicates the raw interrupt of UHCI_SEND_A_REG_Q_INT. Interrupt will be triggered when UHCI sends short packet successfully with always_send mode.
          SEND_A_REG_Q_INT_RAW: u1,

          /// [6:6] Indicates the raw interrupt of UHCI_OUT_EOF_INT. Interrupt will be triggered when there are errors in EOF.
          OUT_EOF_INT_RAW: u1,

          /// [7:7] Indicates the raw interrupt of UHCI_APP_CTRL0_INT. Interrupt will be triggered when UHCI_APP_CTRL0_IN_SET is set to 1.
          APP_CTRL0_INT_RAW: u1,

          /// [8:8] Indicates the raw interrupt of UHCI_APP_CTRL1_INT. Interrupt will be triggered when UHCI_APP_CTRL1_IN_SET is set to 1.
          APP_CTRL1_INT_RAW: u1,

          /// [9:31] 
          res0: u23,

        }), @ptrFromInt(0x60005004));

        /// UHCI Interrupt Status Register
        pub const INT_ST = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Indicates the interrupt status of UHCI_RX_START_INT.
          RX_START_INT_ST: u1,

          /// [1:1] Indicates the interrupt status of UHCI_TX_START_INT.
          TX_START_INT_ST: u1,

          /// [2:2] Indicates the interrupt status of UHCI_RX_HUNG_INT.
          RX_HUNG_INT_ST: u1,

          /// [3:3] Indicates the interrupt status of UHCI_TX_HUNG_INT.
          TX_HUNG_INT_ST: u1,

          /// [4:4] Indicates the interrupt status of UHCI_SEND_S_REG_Q_INT.
          SEND_S_REG_Q_INT_ST: u1,

          /// [5:5] Indicates the interrupt status of UHCI_SEND_A_REG_Q_INT.
          SEND_A_REG_Q_INT_ST: u1,

          /// [6:6] Indicates the interrupt status of UHCI_OUT_EOF_INT.
          OUTLINK_EOF_ERR_INT_ST: u1,

          /// [7:7] Indicates the interrupt status of UHCI_APP_CTRL0_INT.
          APP_CTRL0_INT_ST: u1,

          /// [8:8] Indicates the interrupt status of UHCI_APP_CTRL1_INT.
          APP_CTRL1_INT_ST: u1,

          /// [9:31] 
          res0: u23,

        }), @ptrFromInt(0x60005008));

        /// UHCI Interrupt Enable Register
        pub const INT_ENA = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Set this bit to enable the interrupt of UHCI_RX_START_INT.
          RX_START_INT_ENA: u1,

          /// [1:1] Set this bit to enable the interrupt of UHCI_TX_START_INT.
          TX_START_INT_ENA: u1,

          /// [2:2] Set this bit to enable the interrupt of UHCI_RX_HUNG_INT.
          RX_HUNG_INT_ENA: u1,

          /// [3:3] Set this bit to enable the interrupt of UHCI_TX_HUNG_INT.
          TX_HUNG_INT_ENA: u1,

          /// [4:4] Set this bit to enable the interrupt of UHCI_SEND_S_REG_Q_INT.
          SEND_S_REG_Q_INT_ENA: u1,

          /// [5:5] Set this bit to enable the interrupt of UHCI_SEND_A_REG_Q_INT.
          SEND_A_REG_Q_INT_ENA: u1,

          /// [6:6] Set this bit to enable the interrupt of UHCI_OUT_EOF_INT.
          OUTLINK_EOF_ERR_INT_ENA: u1,

          /// [7:7] Set this bit to enable the interrupt of UHCI_APP_CTRL0_INT.
          APP_CTRL0_INT_ENA: u1,

          /// [8:8] Set this bit to enable the interrupt of UHCI_APP_CTRL1_INT.
          APP_CTRL1_INT_ENA: u1,

          /// [9:31] 
          res0: u23,

        }), @ptrFromInt(0x6000500c));

        /// UHCI Interrupt Clear Register
        pub const INT_CLR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Set this bit to clear the raw interrupt of UHCI_RX_START_INT.
          RX_START_INT_CLR: u1,

          /// [1:1] Set this bit to clear the raw interrupt of UHCI_TX_START_INT.
          TX_START_INT_CLR: u1,

          /// [2:2] Set this bit to clear the raw interrupt of UHCI_RX_HUNG_INT.
          RX_HUNG_INT_CLR: u1,

          /// [3:3] Set this bit to clear the raw interrupt of UHCI_TX_HUNG_INT.
          TX_HUNG_INT_CLR: u1,

          /// [4:4] Set this bit to clear the raw interrupt of UHCI_SEND_S_REG_Q_INT.
          SEND_S_REG_Q_INT_CLR: u1,

          /// [5:5] Set this bit to clear the raw interrupt of UHCI_SEND_A_REG_Q_INT.
          SEND_A_REG_Q_INT_CLR: u1,

          /// [6:6] Set this bit to clear the raw interrupt of UHCI_OUT_EOF_INT.
          OUTLINK_EOF_ERR_INT_CLR: u1,

          /// [7:7] Set this bit to clear the raw interrupt of UHCI_APP_CTRL0_INT.
          APP_CTRL0_INT_CLR: u1,

          /// [8:8] Set this bit to clear the raw interrupt of UHCI_APP_CTRL1_INT.
          APP_CTRL1_INT_CLR: u1,

          /// [9:31] 
          res0: u23,

        }), @ptrFromInt(0x60005010));

        /// UHCI Configuration Register1
        pub const CONF1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Set this bit to enable head checksum check when receiving.
          CHECK_SUM_EN: u1,

          /// [1:1] Set this bit toenable sequence number check when receiving.
          CHECK_SEQ_EN: u1,

          /// [2:2] Set this bit to support CRC calculation, and data integrity check bit should 1.
          CRC_DISABLE: u1,

          /// [3:3] Set this bit to save data packet head when UHCI receive data.
          SAVE_HEAD: u1,

          /// [4:4] Set this bit to encode data packet with checksum.
          TX_CHECK_SUM_RE: u1,

          /// [5:5] Set this bit to encode data packet with ACK when reliable data packet is ready.
          TX_ACK_NUM_RE: u1,

          /// [6:6] 
          res0: u1,

          /// [7:7] Set this bit to enable UHCI encoder transfer to ST_SW_WAIT status.
          WAIT_SW_START: u1,

          /// [8:8] Set this bit to transmit data packet if UCHI_ENCODE_STATE is ST_SW_WAIT.
          SW_START: u1,

          /// [9:31] 
          res1: u23,

        }), @ptrFromInt(0x60005014));

        /// UHCI Receive Status Register
        pub const STATE0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:2] Indicates the error types when DMA receives the error frame. 3'b001: UHCI packet checksum error. 3'b010: UHCI packet sequence number error. 3'b011: UHCI packet CRC bit error. 3'b100: find 0xC0, but received packet is uncompleted. 3'b101: 0xC0 is not found, but received packet is completed. 3'b110: CRC check error.
          RX_ERR_CAUSE: u3,

          /// [3:5] Indicates UHCI decoder status.
          DECODE_STATE: u3,

          /// [6:31] 
          res0: u26,

        }), @ptrFromInt(0x60005018));

        /// UHCI Transmit Status Register
        pub const STATE1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:2] Indicates UHCI encoder status.
          ENCODE_STATE: u3,

          /// [3:31] 
          res0: u29,

        }), @ptrFromInt(0x6000501c));

        /// UHCI Escapes Configuration Register0
        pub const ESCAPE_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Set this bit to enable resolve char 0xC0 when DMA receiving data.
          TX_C0_ESC_EN: u1,

          /// [1:1] Set this bit to enable resolve char 0xDB when DMA receiving data.
          TX_DB_ESC_EN: u1,

          /// [2:2] Set this bit to enable resolve flow control char 0x11 when DMA receiving data.
          TX_11_ESC_EN: u1,

          /// [3:3] Set this bit to enable resolve flow control char 0x13 when DMA receiving data.
          TX_13_ESC_EN: u1,

          /// [4:4] Set this bit to enable replacing 0xC0 with special char when DMA receiving data.
          RX_C0_ESC_EN: u1,

          /// [5:5] Set this bit to enable replacing 0xDB with special char when DMA receiving data.
          RX_DB_ESC_EN: u1,

          /// [6:6] Set this bit to enable replacing 0x11 with special char when DMA receiving data.
          RX_11_ESC_EN: u1,

          /// [7:7] Set this bit to enable replacing 0x13 with special char when DMA receiving data.
          RX_13_ESC_EN: u1,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x60005020));

        /// UHCI Hung Configuration Register0
        pub const HUNG_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] Stores the timeout value. DMA generates UHCI_TX_HUNG_INT for timeout when receiving data.
          TXFIFO_TIMEOUT: u8,

          /// [8:10] Configures the maximum counter value.
          TXFIFO_TIMEOUT_SHIFT: u3,

          /// [11:11] Set this bit to enable TX FIFO timeout when receiving.
          TXFIFO_TIMEOUT_ENA: u1,

          /// [12:19] Stores the timeout value. DMA generates UHCI_TX_HUNG_INT for timeout when reading RAM data.
          RXFIFO_TIMEOUT: u8,

          /// [20:22] Configures the maximum counter value.
          RXFIFO_TIMEOUT_SHIFT: u3,

          /// [23:23] Set this bit to enable TX FIFO timeout when DMA sending data.
          RXFIFO_TIMEOUT_ENA: u1,

          /// [24:31] 
          res0: u8,

        }), @ptrFromInt(0x60005024));

        /// UHCI Ack Value Configuration Register0
        pub const ACK_NUM = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:2] Indicates the ACK number during software flow control.
          ACK_NUM: u3,

          /// [3:3] Set this bit to load the ACK value of UHCI_ACK_NUM.
          LOAD: u1,

          /// [4:31] 
          res0: u28,

        }), @ptrFromInt(0x60005028));

        /// UHCI Head Register
        pub const RX_HEAD = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Stores the head of received packet.
          RX_HEAD: u32,

        }), @ptrFromInt(0x6000502c));

        /// UCHI Quick send Register
        pub const QUICK_SENT = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:2] Configures single_send mode.
          SINGLE_SEND_NUM: u3,

          /// [3:3] Set this bit to enable sending short packet with single_send mode.
          SINGLE_SEND_EN: u1,

          /// [4:6] Configures always_send mode.
          ALWAYS_SEND_NUM: u3,

          /// [7:7] Set this bit to enable sending short packet with always_send mode.
          ALWAYS_SEND_EN: u1,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x60005030));

        /// UHCI Q0_WORD0 Quick Send Register
        pub const REG_Q0_WORD0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Serves as quick sending register in specified mode in UHCI_ALWAYS_SEND_NUM or UHCI_SINGLE_SEND_NUM.
          SEND_Q0_WORD0: u32,

        }), @ptrFromInt(0x60005034));

        /// UHCI Q0_WORD1 Quick Send Register
        pub const REG_Q0_WORD1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Serves as quick sending register in specified mode in UHCI_ALWAYS_SEND_NUM or UHCI_SINGLE_SEND_NUM.
          SEND_Q0_WORD1: u32,

        }), @ptrFromInt(0x60005038));

        /// UHCI Q1_WORD0 Quick Send Register
        pub const REG_Q1_WORD0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Serves as quick sending register in specified mode in UHCI_ALWAYS_SEND_NUM or UHCI_SINGLE_SEND_NUM.
          SEND_Q1_WORD0: u32,

        }), @ptrFromInt(0x6000503c));

        /// UHCI Q1_WORD1 Quick Send Register
        pub const REG_Q1_WORD1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Serves as quick sending register in specified mode in UHCI_ALWAYS_SEND_NUM or UHCI_SINGLE_SEND_NUM.
          SEND_Q1_WORD1: u32,

        }), @ptrFromInt(0x60005040));

        /// UHCI Q2_WORD0 Quick Send Register
        pub const REG_Q2_WORD0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Serves as quick sending register in specified mode in UHCI_ALWAYS_SEND_NUM or UHCI_SINGLE_SEND_NUM.
          SEND_Q2_WORD0: u32,

        }), @ptrFromInt(0x60005044));

        /// UHCI Q2_WORD1 Quick Send Register
        pub const REG_Q2_WORD1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Serves as quick sending register in specified mode in UHCI_ALWAYS_SEND_NUM or UHCI_SINGLE_SEND_NUM.
          SEND_Q2_WORD1: u32,

        }), @ptrFromInt(0x60005048));

        /// UHCI Q3_WORD0 Quick Send Register
        pub const REG_Q3_WORD0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Serves as quick sending register in specified mode in UHCI_ALWAYS_SEND_NUM or UHCI_SINGLE_SEND_NUM.
          SEND_Q3_WORD0: u32,

        }), @ptrFromInt(0x6000504c));

        /// UHCI Q3_WORD1 Quick Send Register
        pub const REG_Q3_WORD1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Serves as quick sending register in specified mode in UHCI_ALWAYS_SEND_NUM or UHCI_SINGLE_SEND_NUM.
          SEND_Q3_WORD1: u32,

        }), @ptrFromInt(0x60005050));

        /// UHCI Q4_WORD0 Quick Send Register
        pub const REG_Q4_WORD0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Serves as quick sending register in specified mode in UHCI_ALWAYS_SEND_NUM or UHCI_SINGLE_SEND_NUM.
          SEND_Q4_WORD0: u32,

        }), @ptrFromInt(0x60005054));

        /// UHCI Q4_WORD1 Quick Send Register
        pub const REG_Q4_WORD1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Serves as quick sending register in specified mode in UHCI_ALWAYS_SEND_NUM or UHCI_SINGLE_SEND_NUM.
          SEND_Q4_WORD1: u32,

        }), @ptrFromInt(0x60005058));

        /// UHCI Q5_WORD0 Quick Send Register
        pub const REG_Q5_WORD0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Serves as quick sending register in specified mode in UHCI_ALWAYS_SEND_NUM or UHCI_SINGLE_SEND_NUM.
          SEND_Q5_WORD0: u32,

        }), @ptrFromInt(0x6000505c));

        /// UHCI Q5_WORD1 Quick Send Register
        pub const REG_Q5_WORD1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Serves as quick sending register in specified mode in UHCI_ALWAYS_SEND_NUM or UHCI_SINGLE_SEND_NUM.
          SEND_Q5_WORD1: u32,

        }), @ptrFromInt(0x60005060));

        /// UHCI Q6_WORD0 Quick Send Register
        pub const REG_Q6_WORD0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Serves as quick sending register in specified mode in UHCI_ALWAYS_SEND_NUM or UHCI_SINGLE_SEND_NUM.
          SEND_Q6_WORD0: u32,

        }), @ptrFromInt(0x60005064));

        /// UHCI Q6_WORD1 Quick Send Register
        pub const REG_Q6_WORD1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Serves as quick sending register in specified mode in UHCI_ALWAYS_SEND_NUM or UHCI_SINGLE_SEND_NUM.
          SEND_Q6_WORD1: u32,

        }), @ptrFromInt(0x60005068));

        /// UHCI Escapes Sequence Configuration Register0
        pub const ESC_CONF0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] Configures the delimiter for encoding, default value is 0xC0.
          SEPER_CHAR: u8,

          /// [8:15] Configures the first char of SLIP escape character, default value is 0xDB.
          SEPER_ESC_CHAR0: u8,

          /// [16:23] Configures the second char of SLIP escape character, default value is 0xDC.
          SEPER_ESC_CHAR1: u8,

          /// [24:31] 
          res0: u8,

        }), @ptrFromInt(0x6000506c));

        /// UHCI Escapes Sequence Configuration Register1
        pub const ESC_CONF1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] Configures the char needing encoding, which is 0xDB as flow control char by default.
          ESC_SEQ0: u8,

          /// [8:15] Configures the first char of SLIP escape character, default value is 0xDB.
          ESC_SEQ0_CHAR0: u8,

          /// [16:23] Configures the second char of SLIP escape character, default value is 0xDD.
          ESC_SEQ0_CHAR1: u8,

          /// [24:31] 
          res0: u8,

        }), @ptrFromInt(0x60005070));

        /// UHCI Escapes Sequence Configuration Register2
        pub const ESC_CONF2 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] Configures the char needing encoding, which is 0x11 as flow control char by default.
          ESC_SEQ1: u8,

          /// [8:15] Configures the first char of SLIP escape character, default value is 0xDB.
          ESC_SEQ1_CHAR0: u8,

          /// [16:23] Configures the second char of SLIP escape character, default value is 0xDE.
          ESC_SEQ1_CHAR1: u8,

          /// [24:31] 
          res0: u8,

        }), @ptrFromInt(0x60005074));

        /// UHCI Escapes Sequence Configuration Register3
        pub const ESC_CONF3 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] Configures the char needing encoding, which is 0x13 as flow control char by default.
          ESC_SEQ2: u8,

          /// [8:15] Configures the first char of SLIP escape character, default value is 0xDB.
          ESC_SEQ2_CHAR0: u8,

          /// [16:23] Configures the second char of SLIP escape character, default value is 0xDF.
          ESC_SEQ2_CHAR1: u8,

          /// [24:31] 
          res0: u8,

        }), @ptrFromInt(0x60005078));

        /// UCHI Packet Length Configuration Register
        pub const PKT_THRES = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:12] Configures the data packet's maximum length when UHCI_HEAD_EN is 0.
          PKT_THRS: u13,

          /// [13:31] 
          res0: u19,

        }), @ptrFromInt(0x6000507c));

        /// UHCI Version Register
        pub const DATE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] Configures version.
          DATE: u32,

        }), @ptrFromInt(0x60005080));

      };

      /// Full-speed USB Serial/JTAG Controller
      pub const USB_DEVICE = struct {

        /// FIFO access for the CDC-ACM data IN and OUT endpoints.
        pub const EP1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] Write and read byte data to/from UART Tx/Rx FIFO through this field. When USB_DEVICE_SERIAL_IN_EMPTY_INT is set, then user can write data (up to 64 bytes) into UART Tx FIFO. When USB_DEVICE_SERIAL_OUT_RECV_PKT_INT is set, user can check USB_DEVICE_OUT_EP1_WR_ADDR USB_DEVICE_OUT_EP0_RD_ADDR to know how many data is received, then read data from UART Rx FIFO.
          RDWR_BYTE: u8,

          /// [8:31] 
          res0: u24,

        }), @ptrFromInt(0x6000f000));

        /// Configuration and control registers for the CDC-ACM FIFOs.
        pub const EP1_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Set this bit to indicate writing byte data to UART Tx FIFO is done.
          WR_DONE: u1,

          /// [1:1] 1'b1: Indicate UART Tx FIFO is not full and can write data into in. After writing USB_DEVICE_WR_DONE, this bit would be 0 until data in UART Tx FIFO is read by USB Host.
          SERIAL_IN_EP_DATA_FREE: u1,

          /// [2:2] 1'b1: Indicate there is data in UART Rx FIFO.
          SERIAL_OUT_EP_DATA_AVAIL: u1,

          /// [3:31] 
          res0: u29,

        }), @ptrFromInt(0x6000f004));

        /// Interrupt raw status register.
        pub const INT_RAW = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] The raw interrupt bit turns to high level when flush cmd is received for IN endpoint 2 of JTAG.
          JTAG_IN_FLUSH_INT_RAW: u1,

          /// [1:1] The raw interrupt bit turns to high level when SOF frame is received.
          SOF_INT_RAW: u1,

          /// [2:2] The raw interrupt bit turns to high level when Serial Port OUT Endpoint received one packet.
          SERIAL_OUT_RECV_PKT_INT_RAW: u1,

          /// [3:3] The raw interrupt bit turns to high level when Serial Port IN Endpoint is empty.
          SERIAL_IN_EMPTY_INT_RAW: u1,

          /// [4:4] The raw interrupt bit turns to high level when pid error is detected.
          PID_ERR_INT_RAW: u1,

          /// [5:5] The raw interrupt bit turns to high level when CRC5 error is detected.
          CRC5_ERR_INT_RAW: u1,

          /// [6:6] The raw interrupt bit turns to high level when CRC16 error is detected.
          CRC16_ERR_INT_RAW: u1,

          /// [7:7] The raw interrupt bit turns to high level when stuff error is detected.
          STUFF_ERR_INT_RAW: u1,

          /// [8:8] The raw interrupt bit turns to high level when IN token for IN endpoint 1 is received.
          IN_TOKEN_REC_IN_EP1_INT_RAW: u1,

          /// [9:9] The raw interrupt bit turns to high level when usb bus reset is detected.
          USB_BUS_RESET_INT_RAW: u1,

          /// [10:10] The raw interrupt bit turns to high level when OUT endpoint 1 received packet with zero palyload.
          OUT_EP1_ZERO_PAYLOAD_INT_RAW: u1,

          /// [11:11] The raw interrupt bit turns to high level when OUT endpoint 2 received packet with zero palyload.
          OUT_EP2_ZERO_PAYLOAD_INT_RAW: u1,

          /// [12:12] The raw interrupt bit turns to high level when level of RTS from usb serial channel is changed.
          RTS_CHG_INT_RAW: u1,

          /// [13:13] The raw interrupt bit turns to high level when level of DTR from usb serial channel is changed.
          DTR_CHG_INT_RAW: u1,

          /// [14:14] The raw interrupt bit turns to high level when level of GET LINE CODING request is received.
          GET_LINE_CODE_INT_RAW: u1,

          /// [15:15] The raw interrupt bit turns to high level when level of SET LINE CODING request is received.
          SET_LINE_CODE_INT_RAW: u1,

          /// [16:31] 
          res0: u16,

        }), @ptrFromInt(0x6000f008));

        /// Interrupt status register.
        pub const INT_ST = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] The raw interrupt status bit for the USB_DEVICE_JTAG_IN_FLUSH_INT interrupt.
          JTAG_IN_FLUSH_INT_ST: u1,

          /// [1:1] The raw interrupt status bit for the USB_DEVICE_SOF_INT interrupt.
          SOF_INT_ST: u1,

          /// [2:2] The raw interrupt status bit for the USB_DEVICE_SERIAL_OUT_RECV_PKT_INT interrupt.
          SERIAL_OUT_RECV_PKT_INT_ST: u1,

          /// [3:3] The raw interrupt status bit for the USB_DEVICE_SERIAL_IN_EMPTY_INT interrupt.
          SERIAL_IN_EMPTY_INT_ST: u1,

          /// [4:4] The raw interrupt status bit for the USB_DEVICE_PID_ERR_INT interrupt.
          PID_ERR_INT_ST: u1,

          /// [5:5] The raw interrupt status bit for the USB_DEVICE_CRC5_ERR_INT interrupt.
          CRC5_ERR_INT_ST: u1,

          /// [6:6] The raw interrupt status bit for the USB_DEVICE_CRC16_ERR_INT interrupt.
          CRC16_ERR_INT_ST: u1,

          /// [7:7] The raw interrupt status bit for the USB_DEVICE_STUFF_ERR_INT interrupt.
          STUFF_ERR_INT_ST: u1,

          /// [8:8] The raw interrupt status bit for the USB_DEVICE_IN_TOKEN_REC_IN_EP1_INT interrupt.
          IN_TOKEN_REC_IN_EP1_INT_ST: u1,

          /// [9:9] The raw interrupt status bit for the USB_DEVICE_USB_BUS_RESET_INT interrupt.
          USB_BUS_RESET_INT_ST: u1,

          /// [10:10] The raw interrupt status bit for the USB_DEVICE_OUT_EP1_ZERO_PAYLOAD_INT interrupt.
          OUT_EP1_ZERO_PAYLOAD_INT_ST: u1,

          /// [11:11] The raw interrupt status bit for the USB_DEVICE_OUT_EP2_ZERO_PAYLOAD_INT interrupt.
          OUT_EP2_ZERO_PAYLOAD_INT_ST: u1,

          /// [12:12] The raw interrupt status bit for the USB_DEVICE_RTS_CHG_INT interrupt.
          RTS_CHG_INT_ST: u1,

          /// [13:13] The raw interrupt status bit for the USB_DEVICE_DTR_CHG_INT interrupt.
          DTR_CHG_INT_ST: u1,

          /// [14:14] The raw interrupt status bit for the USB_DEVICE_GET_LINE_CODE_INT interrupt.
          GET_LINE_CODE_INT_ST: u1,

          /// [15:15] The raw interrupt status bit for the USB_DEVICE_SET_LINE_CODE_INT interrupt.
          SET_LINE_CODE_INT_ST: u1,

          /// [16:31] 
          res0: u16,

        }), @ptrFromInt(0x6000f00c));

        /// Interrupt enable status register.
        pub const INT_ENA = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] The interrupt enable bit for the USB_DEVICE_JTAG_IN_FLUSH_INT interrupt.
          JTAG_IN_FLUSH_INT_ENA: u1,

          /// [1:1] The interrupt enable bit for the USB_DEVICE_SOF_INT interrupt.
          SOF_INT_ENA: u1,

          /// [2:2] The interrupt enable bit for the USB_DEVICE_SERIAL_OUT_RECV_PKT_INT interrupt.
          SERIAL_OUT_RECV_PKT_INT_ENA: u1,

          /// [3:3] The interrupt enable bit for the USB_DEVICE_SERIAL_IN_EMPTY_INT interrupt.
          SERIAL_IN_EMPTY_INT_ENA: u1,

          /// [4:4] The interrupt enable bit for the USB_DEVICE_PID_ERR_INT interrupt.
          PID_ERR_INT_ENA: u1,

          /// [5:5] The interrupt enable bit for the USB_DEVICE_CRC5_ERR_INT interrupt.
          CRC5_ERR_INT_ENA: u1,

          /// [6:6] The interrupt enable bit for the USB_DEVICE_CRC16_ERR_INT interrupt.
          CRC16_ERR_INT_ENA: u1,

          /// [7:7] The interrupt enable bit for the USB_DEVICE_STUFF_ERR_INT interrupt.
          STUFF_ERR_INT_ENA: u1,

          /// [8:8] The interrupt enable bit for the USB_DEVICE_IN_TOKEN_REC_IN_EP1_INT interrupt.
          IN_TOKEN_REC_IN_EP1_INT_ENA: u1,

          /// [9:9] The interrupt enable bit for the USB_DEVICE_USB_BUS_RESET_INT interrupt.
          USB_BUS_RESET_INT_ENA: u1,

          /// [10:10] The interrupt enable bit for the USB_DEVICE_OUT_EP1_ZERO_PAYLOAD_INT interrupt.
          OUT_EP1_ZERO_PAYLOAD_INT_ENA: u1,

          /// [11:11] The interrupt enable bit for the USB_DEVICE_OUT_EP2_ZERO_PAYLOAD_INT interrupt.
          OUT_EP2_ZERO_PAYLOAD_INT_ENA: u1,

          /// [12:12] The interrupt enable bit for the USB_DEVICE_RTS_CHG_INT interrupt.
          RTS_CHG_INT_ENA: u1,

          /// [13:13] The interrupt enable bit for the USB_DEVICE_DTR_CHG_INT interrupt.
          DTR_CHG_INT_ENA: u1,

          /// [14:14] The interrupt enable bit for the USB_DEVICE_GET_LINE_CODE_INT interrupt.
          GET_LINE_CODE_INT_ENA: u1,

          /// [15:15] The interrupt enable bit for the USB_DEVICE_SET_LINE_CODE_INT interrupt.
          SET_LINE_CODE_INT_ENA: u1,

          /// [16:31] 
          res0: u16,

        }), @ptrFromInt(0x6000f010));

        /// Interrupt clear status register.
        pub const INT_CLR = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Set this bit to clear the USB_DEVICE_JTAG_IN_FLUSH_INT interrupt.
          JTAG_IN_FLUSH_INT_CLR: u1,

          /// [1:1] Set this bit to clear the USB_DEVICE_JTAG_SOF_INT interrupt.
          SOF_INT_CLR: u1,

          /// [2:2] Set this bit to clear the USB_DEVICE_SERIAL_OUT_RECV_PKT_INT interrupt.
          SERIAL_OUT_RECV_PKT_INT_CLR: u1,

          /// [3:3] Set this bit to clear the USB_DEVICE_SERIAL_IN_EMPTY_INT interrupt.
          SERIAL_IN_EMPTY_INT_CLR: u1,

          /// [4:4] Set this bit to clear the USB_DEVICE_PID_ERR_INT interrupt.
          PID_ERR_INT_CLR: u1,

          /// [5:5] Set this bit to clear the USB_DEVICE_CRC5_ERR_INT interrupt.
          CRC5_ERR_INT_CLR: u1,

          /// [6:6] Set this bit to clear the USB_DEVICE_CRC16_ERR_INT interrupt.
          CRC16_ERR_INT_CLR: u1,

          /// [7:7] Set this bit to clear the USB_DEVICE_STUFF_ERR_INT interrupt.
          STUFF_ERR_INT_CLR: u1,

          /// [8:8] Set this bit to clear the USB_DEVICE_IN_TOKEN_IN_EP1_INT interrupt.
          IN_TOKEN_REC_IN_EP1_INT_CLR: u1,

          /// [9:9] Set this bit to clear the USB_DEVICE_USB_BUS_RESET_INT interrupt.
          USB_BUS_RESET_INT_CLR: u1,

          /// [10:10] Set this bit to clear the USB_DEVICE_OUT_EP1_ZERO_PAYLOAD_INT interrupt.
          OUT_EP1_ZERO_PAYLOAD_INT_CLR: u1,

          /// [11:11] Set this bit to clear the USB_DEVICE_OUT_EP2_ZERO_PAYLOAD_INT interrupt.
          OUT_EP2_ZERO_PAYLOAD_INT_CLR: u1,

          /// [12:12] Set this bit to clear the USB_DEVICE_RTS_CHG_INT interrupt.
          RTS_CHG_INT_CLR: u1,

          /// [13:13] Set this bit to clear the USB_DEVICE_DTR_CHG_INT interrupt.
          DTR_CHG_INT_CLR: u1,

          /// [14:14] Set this bit to clear the USB_DEVICE_GET_LINE_CODE_INT interrupt.
          GET_LINE_CODE_INT_CLR: u1,

          /// [15:15] Set this bit to clear the USB_DEVICE_SET_LINE_CODE_INT interrupt.
          SET_LINE_CODE_INT_CLR: u1,

          /// [16:31] 
          res0: u16,

        }), @ptrFromInt(0x6000f014));

        /// PHY hardware configuration.
        pub const CONF0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Select internal/external PHY
          PHY_SEL: u1,

          /// [1:1] Enable software control USB D+ D- exchange
          EXCHG_PINS_OVERRIDE: u1,

          /// [2:2] USB D+ D- exchange
          EXCHG_PINS: u1,

          /// [3:4] Control single-end input high threshold,1.76V to 2V, step 80mV
          VREFH: u2,

          /// [5:6] Control single-end input low threshold,0.8V to 1.04V, step 80mV
          VREFL: u2,

          /// [7:7] Enable software control inputthreshold
          VREF_OVERRIDE: u1,

          /// [8:8] Enable software control USB D+ D- pullup pulldown
          PAD_PULL_OVERRIDE: u1,

          /// [9:9] Control USB D+ pull up.
          DP_PULLUP: u1,

          /// [10:10] Control USB D+ pull down.
          DP_PULLDOWN: u1,

          /// [11:11] Control USB D- pull up.
          DM_PULLUP: u1,

          /// [12:12] Control USB D- pull down.
          DM_PULLDOWN: u1,

          /// [13:13] Control pull up value.
          PULLUP_VALUE: u1,

          /// [14:14] Enable USB pad function.
          USB_PAD_ENABLE: u1,

          /// [15:15] Set this bit usb_jtag, the connection between usb_jtag and internal JTAG is disconnected, and MTMS, MTDI, MTCK are output through GPIO Matrix, MTDO is input through GPIO Matrix.
          USB_JTAG_BRIDGE_EN: u1,

          /// [16:31] 
          res0: u16,

        }), @ptrFromInt(0x6000f018));

        /// Registers used for debugging the PHY.
        pub const TEST = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Enable test of the USB pad
          TEST_ENABLE: u1,

          /// [1:1] USB pad oen in test
          TEST_USB_OE: u1,

          /// [2:2] USB D+ tx value in test
          TEST_TX_DP: u1,

          /// [3:3] USB D- tx value in test
          TEST_TX_DM: u1,

          /// [4:4] USB RCV value in test
          TEST_RX_RCV: u1,

          /// [5:5] USB D+ rx value in test
          TEST_RX_DP: u1,

          /// [6:6] USB D- rx value in test
          TEST_RX_DM: u1,

          /// [7:31] 
          res0: u25,

        }), @ptrFromInt(0x6000f01c));

        /// JTAG FIFO status and control registers.
        pub const JFIFO_ST = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:1] JTAT in fifo counter.
          IN_FIFO_CNT: u2,

          /// [2:2] 1: JTAG in fifo is empty.
          IN_FIFO_EMPTY: u1,

          /// [3:3] 1: JTAG in fifo is full.
          IN_FIFO_FULL: u1,

          /// [4:5] JTAT out fifo counter.
          OUT_FIFO_CNT: u2,

          /// [6:6] 1: JTAG out fifo is empty.
          OUT_FIFO_EMPTY: u1,

          /// [7:7] 1: JTAG out fifo is full.
          OUT_FIFO_FULL: u1,

          /// [8:8] Write 1 to reset JTAG in fifo.
          IN_FIFO_RESET: u1,

          /// [9:9] Write 1 to reset JTAG out fifo.
          OUT_FIFO_RESET: u1,

          /// [10:31] 
          res0: u22,

        }), @ptrFromInt(0x6000f020));

        /// Last received SOF frame index register.
        pub const FRAM_NUM = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:10] Frame index of received SOF frame.
          SOF_FRAME_INDEX: u11,

          /// [11:31] 
          res0: u21,

        }), @ptrFromInt(0x6000f024));

        /// Control IN endpoint status information.
        pub const IN_EP0_ST = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:1] State of IN Endpoint 0.
          IN_EP0_STATE: u2,

          /// [2:8] Write data address of IN endpoint 0.
          IN_EP0_WR_ADDR: u7,

          /// [9:15] Read data address of IN endpoint 0.
          IN_EP0_RD_ADDR: u7,

          /// [16:31] 
          res0: u16,

        }), @ptrFromInt(0x6000f028));

        /// CDC-ACM IN endpoint status information.
        pub const IN_EP1_ST = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:1] State of IN Endpoint 1.
          IN_EP1_STATE: u2,

          /// [2:8] Write data address of IN endpoint 1.
          IN_EP1_WR_ADDR: u7,

          /// [9:15] Read data address of IN endpoint 1.
          IN_EP1_RD_ADDR: u7,

          /// [16:31] 
          res0: u16,

        }), @ptrFromInt(0x6000f02c));

        /// CDC-ACM interrupt IN endpoint status information.
        pub const IN_EP2_ST = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:1] State of IN Endpoint 2.
          IN_EP2_STATE: u2,

          /// [2:8] Write data address of IN endpoint 2.
          IN_EP2_WR_ADDR: u7,

          /// [9:15] Read data address of IN endpoint 2.
          IN_EP2_RD_ADDR: u7,

          /// [16:31] 
          res0: u16,

        }), @ptrFromInt(0x6000f030));

        /// JTAG IN endpoint status information.
        pub const IN_EP3_ST = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:1] State of IN Endpoint 3.
          IN_EP3_STATE: u2,

          /// [2:8] Write data address of IN endpoint 3.
          IN_EP3_WR_ADDR: u7,

          /// [9:15] Read data address of IN endpoint 3.
          IN_EP3_RD_ADDR: u7,

          /// [16:31] 
          res0: u16,

        }), @ptrFromInt(0x6000f034));

        /// Control OUT endpoint status information.
        pub const OUT_EP0_ST = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:1] State of OUT Endpoint 0.
          OUT_EP0_STATE: u2,

          /// [2:8] Write data address of OUT endpoint 0. When USB_DEVICE_SERIAL_OUT_RECV_PKT_INT is detected, there are USB_DEVICE_OUT_EP0_WR_ADDR-2 bytes data in OUT EP0.
          OUT_EP0_WR_ADDR: u7,

          /// [9:15] Read data address of OUT endpoint 0.
          OUT_EP0_RD_ADDR: u7,

          /// [16:31] 
          res0: u16,

        }), @ptrFromInt(0x6000f038));

        /// CDC-ACM OUT endpoint status information.
        pub const OUT_EP1_ST = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:1] State of OUT Endpoint 1.
          OUT_EP1_STATE: u2,

          /// [2:8] Write data address of OUT endpoint 1. When USB_DEVICE_SERIAL_OUT_RECV_PKT_INT is detected, there are USB_DEVICE_OUT_EP1_WR_ADDR-2 bytes data in OUT EP1.
          OUT_EP1_WR_ADDR: u7,

          /// [9:15] Read data address of OUT endpoint 1.
          OUT_EP1_RD_ADDR: u7,

          /// [16:22] Data count in OUT endpoint 1 when one packet is received.
          OUT_EP1_REC_DATA_CNT: u7,

          /// [23:31] 
          res0: u9,

        }), @ptrFromInt(0x6000f03c));

        /// JTAG OUT endpoint status information.
        pub const OUT_EP2_ST = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:1] State of OUT Endpoint 2.
          OUT_EP2_STATE: u2,

          /// [2:8] Write data address of OUT endpoint 2. When USB_DEVICE_SERIAL_OUT_RECV_PKT_INT is detected, there are USB_DEVICE_OUT_EP2_WR_ADDR-2 bytes data in OUT EP2.
          OUT_EP2_WR_ADDR: u7,

          /// [9:15] Read data address of OUT endpoint 2.
          OUT_EP2_RD_ADDR: u7,

          /// [16:31] 
          res0: u16,

        }), @ptrFromInt(0x6000f040));

        /// Clock enable control
        pub const MISC_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] 1'h1: Force clock on for register. 1'h0: Support clock only when application writes registers.
          CLK_EN: u1,

          /// [1:31] 
          res0: u31,

        }), @ptrFromInt(0x6000f044));

        /// Memory power control
        pub const MEM_CONF = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] 1: power down usb memory.
          USB_MEM_PD: u1,

          /// [1:1] 1: Force clock on for usb memory.
          USB_MEM_CLK_EN: u1,

          /// [2:31] 
          res0: u30,

        }), @ptrFromInt(0x6000f048));

        /// CDC-ACM chip reset control.
        pub const CHIP_RST = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] 1: Chip reset is detected from usb serial channel. Software write 1 to clear it.
          RTS: u1,

          /// [1:1] 1: Chip reset is detected from usb jtag channel. Software write 1 to clear it.
          DTR: u1,

          /// [2:2] Set this bit to disable chip reset from usb serial channel to reset chip.
          USB_UART_CHIP_RST_DIS: u1,

          /// [3:31] 
          res0: u29,

        }), @ptrFromInt(0x6000f04c));

        /// W0 of SET_LINE_CODING command.
        pub const SET_LINE_CODE_W0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] The value of dwDTERate set by host through SET_LINE_CODING command.
          DW_DTE_RATE: u32,

        }), @ptrFromInt(0x6000f050));

        /// W1 of SET_LINE_CODING command.
        pub const SET_LINE_CODE_W1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] The value of bCharFormat set by host through SET_LINE_CODING command.
          BCHAR_FORMAT: u8,

          /// [8:15] The value of bParityTpye set by host through SET_LINE_CODING command.
          BPARITY_TYPE: u8,

          /// [16:23] The value of bDataBits set by host through SET_LINE_CODING command.
          BDATA_BITS: u8,

          /// [24:31] 
          res0: u8,

        }), @ptrFromInt(0x6000f054));

        /// W0 of GET_LINE_CODING command.
        pub const GET_LINE_CODE_W0 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] The value of dwDTERate set by software which is requested by GET_LINE_CODING command.
          GET_DW_DTE_RATE: u32,

        }), @ptrFromInt(0x6000f058));

        /// W1 of GET_LINE_CODING command.
        pub const GET_LINE_CODE_W1 = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:7] The value of bCharFormat set by software which is requested by GET_LINE_CODING command.
          GET_BDATA_BITS: u8,

          /// [8:15] The value of bParityTpye set by software which is requested by GET_LINE_CODING command.
          GET_BPARITY_TYPE: u8,

          /// [16:23] The value of bDataBits set by software which is requested by GET_LINE_CODING command.
          GET_BCHAR_FORMAT: u8,

          /// [24:31] 
          res0: u8,

        }), @ptrFromInt(0x6000f05c));

        /// Configuration registers' value update
        pub const CONFIG_UPDATE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Write 1 to this register would update the value of configure registers from APB clock domain to 48MHz clock domain.
          CONFIG_UPDATE: u1,

          /// [1:31] 
          res0: u31,

        }), @ptrFromInt(0x6000f060));

        /// Serial AFIFO configure register
        pub const SER_AFIFO_CONFIG = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] Write 1 to reset CDC_ACM IN async FIFO write clock domain.
          SERIAL_IN_AFIFO_RESET_WR: u1,

          /// [1:1] Write 1 to reset CDC_ACM IN async FIFO read clock domain.
          SERIAL_IN_AFIFO_RESET_RD: u1,

          /// [2:2] Write 1 to reset CDC_ACM OUT async FIFO write clock domain.
          SERIAL_OUT_AFIFO_RESET_WR: u1,

          /// [3:3] Write 1 to reset CDC_ACM OUT async FIFO read clock domain.
          SERIAL_OUT_AFIFO_RESET_RD: u1,

          /// [4:4] CDC_ACM OUTOUT async FIFO empty signal in read clock domain.
          SERIAL_OUT_AFIFO_REMPTY: u1,

          /// [5:5] CDC_ACM OUT IN async FIFO empty signal in write clock domain.
          SERIAL_IN_AFIFO_WFULL: u1,

          /// [6:31] 
          res0: u26,

        }), @ptrFromInt(0x6000f064));

        /// USB Bus reset status register
        pub const BUS_RESET_ST = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:0] USB bus reset status. 0: USB-Serial-JTAG is in usb bus reset status. 1: USB bus reset is released.
          USB_BUS_RESET_ST: u1,

          /// [1:31] 
          res0: u31,

        }), @ptrFromInt(0x6000f068));

        /// Date register
        pub const DATE = @as(*volatile mmio.Mmio(packed struct(u32) {

          /// [0:31] register version.
          DATE: u32,

        }), @ptrFromInt(0x6000f080));

      };

    };
  };
};